<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>叹为观止</title>
  <subtitle>追求卓越，成功自然来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.vichamp.com/"/>
  <updated>2017-03-28T14:47:54.045Z</updated>
  <id>http://blog.vichamp.com/</id>
  
  <author>
    <name>John Doe</name>
    <email>victorwoo@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PowerShell 技能连载 - 调用一个脚本块</title>
    <link href="http://blog.vichamp.com/2017/03/22/invoking-a-script-block/"/>
    <id>http://blog.vichamp.com/2017/03/22/invoking-a-script-block/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:54.045Z</updated>
    
    <content type="html"><![CDATA[<p>可以通过调用操作符，例如 “<code>&amp;</code>“、”<code>.</code>“ 或调用 <code>Invoke()</code> 方法调用在一个脚本块中的代码。</p>
<p>一个区别是当有多于一个结果时的输出：调用操作符返回一个扁平的对象数组，而 <code>Invoke()</code> 返回一个集合：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$code</span> = &#123; <span class="built_in">Get-Process</span> &#125;</div><div class="line"></div><div class="line"><span class="variable">$result1</span> = &amp; <span class="variable">$code</span></div><div class="line"><span class="variable">$result2</span> = <span class="variable">$code</span>.Invoke()</div><div class="line"></div><div class="line"><span class="variable">$result1</span>.GetType().FullName</div><div class="line"><span class="variable">$result2</span>.GetType().FullName</div></pre></td></tr></table></figure>
<p>通过 <code>Invoke()</code> 方法返回的集合拥有额外的方法，例如 <code>RemoveAt()</code> 和 <code>Insert()</code>，它们能够帮您修改结果数据，能高效地插入或删除元素。</p>
<p>您可以手动将一个 cmdlet 的返回值手动转为一个 ArrayList：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$arrayList</span> = [Collections.ArrayList]@(<span class="built_in">Get-Process</span>)</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/invoking-a-script-block" target="_blank" rel="external">Invoking a Script Block</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Invoking a Script Block
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 不带动词运行 Cmdlet</title>
    <link href="http://blog.vichamp.com/2017/03/21/running-cmdlets-without-verb/"/>
    <id>http://blog.vichamp.com/2017/03/21/running-cmdlets-without-verb/</id>
    <published>2017-03-20T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:54.045Z</updated>
    
    <content type="html"><![CDATA[<p>这是从 PowerShell 1.0 开始就具有的一个特性：调用动词为 “get” 的 cmdlet 可以省略动词。所以调用 “<code>Get-Service</code>“ 时您可以仅执行 “<code>Service</code>“；调用 “<code>Get-Date</code>“ 时可以仅执行 “<code>Date</code>“。</p>
<p>以下不是别名，甚至 PowerShell 引擎并不知道为什么它能工作。请试试这些代码：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PS&gt; Date</div><div class="line">PS&gt; <span class="built_in">Get-Command</span> Date</div></pre></td></tr></table></figure>
<p>使用这个快捷方式的前提是没有冲突的命令或语法元素。这也是为什么您可以运行 “<code>Get-Process</code>“，但不能运行 “<code>Process</code>“ 的原因：”<code>Process</code>“ 是 PowerShell 语言中的一个保留关键字。</p>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/running-cmdlets-without-verb" target="_blank" rel="external">Running Cmdlets without Verb</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Running Cmdlets without Verb
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 限制文本的长度（第二部分）</title>
    <link href="http://blog.vichamp.com/2017/03/20/texts-with-maximum-length-part-2/"/>
    <id>http://blog.vichamp.com/2017/03/20/texts-with-maximum-length-part-2/</id>
    <published>2017-03-19T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:54.029Z</updated>
    
    <content type="html"><![CDATA[<p>以下是确保一段文本不超过指定长度的另一种策略。和前一个技能不同的是，当文本长度小于最大长度时，这段代码不会补齐空格：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$text</span> = <span class="string">'this'</span></div><div class="line"><span class="variable">$MaxLength</span> = <span class="number">10</span></div><div class="line"><span class="variable">$CutOff</span> = [Math]::Min(<span class="variable">$MaxLength</span>, <span class="variable">$text</span>.Length)</div><div class="line"><span class="variable">$text</span>.Substring(<span class="number">0</span>,<span class="variable">$CutOff</span>)</div></pre></td></tr></table></figure>
<p>关键点在 <code>Min()</code> 函数，它决定了两个值中小的哪个。</p>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/texts-with-maximum-length-part-2" target="_blank" rel="external">Texts with Maximum Length (Part 2)</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Texts with Maximum Length (Part 2)
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 限制文本的长度（第一部分）</title>
    <link href="http://blog.vichamp.com/2017/03/17/texts-with-maximum-length-part-1/"/>
    <id>http://blog.vichamp.com/2017/03/17/texts-with-maximum-length-part-1/</id>
    <published>2017-03-16T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:54.027Z</updated>
    
    <content type="html"><![CDATA[<p>如果您想将一个文本的长度限制在某一个长度，以下是一个简单的方法：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$text</span> = <span class="string">'this is a long text'</span></div><div class="line"><span class="variable">$MaxLength</span> = <span class="number">10</span></div><div class="line"></div><div class="line"><span class="variable">$text</span>.PadRight(<span class="variable">$MaxLength</span>).Substring(<span class="number">0</span>,<span class="variable">$MaxLength</span>)</div></pre></td></tr></table></figure>
<p>这段代码首先对文本填充，以防它比最大长度还短，然后使用 <code>Substring()</code> 裁剪掉多余的文本。</p>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/texts-with-maximum-length-part-1" target="_blank" rel="external">Texts with Maximum Length (Part 1)</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Texts with Maximum Length (Part 1)
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 查找所有含桌面的配置文件</title>
    <link href="http://blog.vichamp.com/2017/03/16/finding-all-profiles-with-desktop/"/>
    <id>http://blog.vichamp.com/2017/03/16/finding-all-profiles-with-desktop/</id>
    <published>2017-03-15T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:54.007Z</updated>
    
    <content type="html"><![CDATA[<p>这一行代码能够列出所有本地用户配置文件中的桌面——请确保以管理员身份运行这行代码才能查看其他人的配置文件：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Resolve-Path</span> -Path C:\users\*\Desktop -ErrorAction SilentlyContinue</div></pre></td></tr></table></figure>
<p>如果您只想获得配置文件中包含 “Desktop” 文件夹的用户名，请用以下代码：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Resolve-Path</span> -Path C:\users\*\Desktop -ErrorAction SilentlyContinue |</div><div class="line">    <span class="built_in">ForEach-Object</span> &#123; </div><div class="line">        <span class="variable">$_</span>.Path.Split(<span class="string">'\'</span>)[-<span class="number">2</span>]</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码获取路径并用反斜杠将它们分割，创建一个路径元素的数组。下标 -2 是指倒数第二个元素，即用户名。</p>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/finding-all-profiles-with-desktop" target="_blank" rel="external">Finding All Profiles with Desktop</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Finding All Profiles with Desktop
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - Where-Object 和 .Where()</title>
    <link href="http://blog.vichamp.com/2017/03/15/where-object-and-where/"/>
    <id>http://blog.vichamp.com/2017/03/15/where-object-and-where/</id>
    <published>2017-03-14T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.991Z</updated>
    
    <content type="html"><![CDATA[<p>从 PowerShell 4 开始，当您不想使用管道的时候，可以使用 <code>Where()</code> 和 <code>ForEach()</code> 方法来代替 <code>Where-Object</code> 和 <code>ForEach-Object</code>。</p>
<p>所以如果您已经将所有数据加载到一个变量中，那么非流式操作会更高效：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$Services</span> = <span class="built_in">Get-Service</span></div><div class="line"></div><div class="line"><span class="comment"># streaming</span></div><div class="line"><span class="variable">$Services</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.Status <span class="nomarkup">-eq</span> <span class="string">'Running'</span> &#125;</div><div class="line"><span class="comment"># non-streaming</span></div><div class="line"><span class="variable">$Services</span>.Where&#123; <span class="variable">$_</span>.Status <span class="nomarkup">-eq</span> <span class="string">'Running'</span> &#125;</div></pre></td></tr></table></figure>
<p>要节约资源，最有效地方法仍然是使用流式管道，而不是用变量：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Get-Service</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.Status <span class="nomarkup">-eq</span> <span class="string">'Running'</span> &#125;</div></pre></td></tr></table></figure>
<p>请注意 <code>Where-Object</code> 和 <code>.Where()</code> 使用不同的数组类型，所以它们的输出技术上是不同的：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; (<span class="number">1</span>..<span class="number">19</span> |  <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span> <span class="nomarkup">-gt</span> <span class="number">10</span> &#125;).GetType().FullName</div><div class="line">System.Object[]</div><div class="line"></div><div class="line">PS C:\&gt;  ((<span class="number">1</span>..<span class="number">19</span>).Where&#123; <span class="variable">$_</span> <span class="nomarkup">-gt</span> <span class="number">10</span> &#125;).GetType().FullName</div><div class="line">System.Collections.ObjectModel.Collection`1[[System.Management.Automation.PSObject, System.Management.Automation, Version=<span class="number">3.0</span>.<span class="number">0.0</span>, Culture=neutral,  PublicKeyToken=<span class="number">31</span>bf3856ad364e35]]</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/where-object-and-where" target="_blank" rel="external">Where-Object and .Where()</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Where-Object and .Where()
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 快速创建对象数组</title>
    <link href="http://blog.vichamp.com/2017/03/14/creating-object-arrays-on-the-fly/"/>
    <id>http://blog.vichamp.com/2017/03/14/creating-object-arrays-on-the-fly/</id>
    <published>2017-03-13T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.991Z</updated>
    
    <content type="html"><![CDATA[<p>以下是一个用内置的 CSV 处理器生成对象数组的代码实例：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$csv</span> = <span class="string">@'</span></div><div class="line">PC,Date</div><div class="line">PC82012,2017-02-28</div><div class="line">PC82038,2017-02-28</div><div class="line">PC83073,2017-02-28</div><div class="line">PC84004,2017-02-28</div><div class="line">PC84009,2017-02-28</div><div class="line">PC84015,2017-02-28</div><div class="line">PC90435,2017-02-28</div><div class="line">'@</div><div class="line"></div><div class="line"><span class="variable">$data</span> = <span class="variable">$csv</span> | <span class="built_in">ConvertFrom-Csv</span></div><div class="line"></div><div class="line"><span class="variable">$data</span></div><div class="line"><span class="variable">$data</span> | <span class="built_in">Out-GridView</span></div></pre></td></tr></table></figure>
<p>如果一个脚本需要一个静态的服务器、连接数据或其他信息的列表，这种方式会很有用。</p>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/creating-object-arrays-on-the-fly" target="_blank" rel="external">Creating Object Arrays on the Fly</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Creating Object Arrays on the Fly
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - Exploring Type Accelerators</title>
    <link href="http://blog.vichamp.com/2017/03/13/exploring-type-accelerators/"/>
    <id>http://blog.vichamp.com/2017/03/13/exploring-type-accelerators/</id>
    <published>2017-03-12T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.991Z</updated>
    
    <content type="html"><![CDATA[<p>PowerShell uses a number of so-called type accelerators that help with long .NET type names. Instead of using “System.DirectoryServices.DirectoryEntry”, for example, you can simply type “ADSI”.</p>
<p>When you query the property FullName of a type, you always get back the underlying full .NET type name:</p>
<pre><code>PS C:\&gt; [ADSI].FullName
System.DirectoryServices.DirectoryEntry

PS C:\&gt;
</code></pre><p>And this line dumps all the built-in .NET type accelerators in PowerShell:</p>
<pre><code>[PSObject].Assembly.GetType(&quot;System.Management.Automation.TypeAccelerators&quot;)::get |
  Out-GridView
</code></pre><p>Aside from the explicit type accelerators, there is another rule built into PowerShell: when a type resides in the namespace “System”, then you can always omit this namespace. This is why all of these are the same:</p>
<pre><code>PS C:\&gt; [int].FullName
System.Int32

PS C:\&gt; [System.Int32].FullName
System.Int32

PS C:\&gt; [Int32].FullName
System.Int32
</code></pre><a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/exploring-type-accelerators" target="_blank" rel="external">Exploring Type Accelerators</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Exploring Type Accelerators
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 危险的临时文件！</title>
    <link href="http://blog.vichamp.com/2017/03/10/dangerous-temp-files/"/>
    <id>http://blog.vichamp.com/2017/03/10/dangerous-temp-files/</id>
    <published>2017-03-09T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.975Z</updated>
    
    <content type="html"><![CDATA[<p>内部的系统功能往往十分有用，但请确保真正了解它们的功能。</p>
<p>一个特别常见的系统方法叫做 <code>GetTempFileName()</code> ，能够创建临时文件名。而当您进一步观察的时候，您会发现它不仅创建临时文件名，而且还创建了临时文件：</p>
<pre><code>$file = [System.IO.Path]::GetTempFileName()
Test-Path -Path $file
</code></pre><p>所以如果在脚本中只是使用这个方法来创建临时文件名的话，会留下一大堆孤立的文件。</p>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/dangerous-temp-files" target="_blank" rel="external">Dangerous Temp Files!</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Dangerous Temp Files!
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 探索对象</title>
    <link href="http://blog.vichamp.com/2017/03/09/explore-objects/"/>
    <id>http://blog.vichamp.com/2017/03/09/explore-objects/</id>
    <published>2017-03-08T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.975Z</updated>
    
    <content type="html"><![CDATA[<p>在 PowerShell 中，一切都是用对象描述。以下是一个检查任意对象并将它的成员以文本的方式复制到剪贴板的单行代码：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">"Hello"</span> | </div><div class="line">  <span class="built_in">Get-Member</span> |</div><div class="line">  <span class="built_in">Format-Table</span> -AutoSize -Wrap |</div><div class="line">  <span class="built_in">Out-String</span> -Width <span class="number">150</span> |</div><div class="line">  clip.exe</div></pre></td></tr></table></figure>
<p>只需要将 “Hello” 替换成任何变量或命令，然后看看复制了什么到剪贴板中。您可以将信息粘贴到文本编辑器或文字处理器中，并将它打印出来或转成 PDF 备用。</p>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/explore-objects" target="_blank" rel="external">Explore Objects</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Explore Objects
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 管理比特标志位（第四部分）</title>
    <link href="http://blog.vichamp.com/2017/03/08/managing-bit-flags-part-4/"/>
    <id>http://blog.vichamp.com/2017/03/08/managing-bit-flags-part-4/</id>
    <published>2017-03-07T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.960Z</updated>
    
    <content type="html"><![CDATA[<p>在 PowerShell 5 中，对枚举的新支持特性使得处理比特位比您在前面的 PowerShell 技能中看到的简单得多。现在设置或清除比特位不再需要冗长的逻辑操作符。</p>
<p>我们先定义一个枚举类型，这样更好管理十进制数：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#requires -Version 5</span></div><div class="line"></div><div class="line">[Flags()]</div><div class="line">enum GardenPartyItems</div><div class="line">&#123;</div><div class="line">    Chair = <span class="number">0</span></div><div class="line">    Table = <span class="number">1</span></div><div class="line">    Barbecue = <span class="number">2</span></div><div class="line">    Fridge = <span class="number">4</span></div><div class="line">    Candle = <span class="number">8</span></div><div class="line">    Knife = <span class="number">16</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="variable">$decimal</span> = <span class="number">11</span></div><div class="line">[GardenPartyItems]<span class="variable">$flags</span> = <span class="variable">$decimal</span></div><div class="line"><span class="variable">$flags</span></div></pre></td></tr></table></figure>
<p>现在，十进制数的比特位可以很容易地转化为 GardenPartyItem 的列表：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt;  [GardenPartyItems]<span class="number">11</span></div><div class="line">Table, Barbecue, Candle</div><div class="line"></div><div class="line">PS C:\&gt;</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：将十进制数转换为枚举型时，请确保枚举型中定义了所有的比特。如果十进制数太大，包含枚举型之外的比特时，转换会失败。</p>
<p>要增加一个新的标志位，请试试以下的代码：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">Table, Barbecue, Candle</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span> += [GardenPartyItems]::Knife</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">Table, Barbecue, Candle, Knife</div><div class="line"></div><div class="line">PS C:\&gt;</div></pre></td></tr></table></figure>
<p>要移除一个标志位，请试试以下代码：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">Table, Barbecue, Candle, Knife</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span> -= [GardenPartyItems]::Candle</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">Table, Barbecue, Knife</div><div class="line"></div><div class="line">PS C:\&gt;</div></pre></td></tr></table></figure>
<p>然而，实际上并没有看起来这么简单。当移除一个已有的标志位，没有问题。但移除一个没有置位的标志位，会把比特值搞乱：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">Table, Barbecue, Candle</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span> -= [GardenPartyItems]::Candle</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">Table, Barbecue</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span> -= [GardenPartyItems]::Candle</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">-<span class="number">5</span></div><div class="line"></div><div class="line">PS C:\&gt;</div></pre></td></tr></table></figure>
<p>所以 PowerShell 在自动处理二进制算法方面明显还不够智能。要安全地使用该功能，您还是要用二进制操作符。要移除标志位，请使用 <code>-band</code> 和 <code>-bnot</code>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">Table, Barbecue, Candle</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span> = <span class="variable">$flags</span> -band -bnot [GardenPartyItems]::Candle</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">Table, Barbecue</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span> = <span class="variable">$flags</span> -band -bnot [GardenPartyItems]::Candle</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">Table, Barbecue</div><div class="line"></div><div class="line">PS C:\&gt;</div></pre></td></tr></table></figure>
<p>要设置标志位，请使用 <code>-bor</code>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">Table, Barbecue, Candle</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span> = <span class="variable">$flags</span> -bor [GardenPartyItems]::Knife</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">Table, Barbecue, Candle, Knife</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span> = <span class="variable">$flags</span> -bor [GardenPartyItems]::Knife</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">Table, Barbecue, Candle, Knife</div><div class="line"></div><div class="line">PS C:\&gt;</div></pre></td></tr></table></figure>
<p>在所有这些操作中，实际上是在操作一个十进制数：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; [Int]<span class="variable">$flags</span></div><div class="line"><span class="number">19</span></div></pre></td></tr></table></figure>
<p>相当棒，对吧？</p>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/managing-bit-flags-part-4" target="_blank" rel="external">Managing Bit Flags (Part 4)</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Managing Bit Flags (Part 4)
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 管理比特标志位（第三部分）</title>
    <link href="http://blog.vichamp.com/2017/03/07/managing-bit-flags-part-3/"/>
    <id>http://blog.vichamp.com/2017/03/07/managing-bit-flags-part-3/</id>
    <published>2017-03-06T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.960Z</updated>
    
    <content type="html"><![CDATA[<p>对十进制数设置比特标志位不是很难，但是不够直观。以下是一个快速的新方法，演示如何设置或取消一个数字中特定的比特：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$decimal</span> = <span class="number">6254</span></div><div class="line">[Convert]::ToString(<span class="variable">$decimal</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment"># set bit 4</span></div><div class="line"><span class="variable">$bit</span> = <span class="number">4</span></div><div class="line"><span class="variable">$decimal</span> = <span class="variable">$decimal</span> -bor [Math]::Pow(<span class="number">2</span>, <span class="variable">$bit</span>)</div><div class="line">[Convert]::ToString(<span class="variable">$decimal</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment"># set bit 0</span></div><div class="line"><span class="variable">$bit</span> = <span class="number">0</span></div><div class="line"><span class="variable">$decimal</span> = <span class="variable">$decimal</span> -bor [Math]::Pow(<span class="number">2</span>, <span class="variable">$bit</span>)</div><div class="line">[Convert]::ToString(<span class="variable">$decimal</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment"># clear bit 1</span></div><div class="line"><span class="variable">$bit</span> = <span class="number">1</span></div><div class="line"><span class="variable">$decimal</span> = <span class="variable">$decimal</span> -band -bnot [Math]::Pow(<span class="number">2</span>, <span class="variable">$bit</span>)</div><div class="line">[Convert]::ToString(<span class="variable">$decimal</span>, <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果演示了代码做了什么。<code>ToString()</code> 从右到左显示比特，所以第 0 比特是在最右边。在第二行和第三行，设置了两个独立的比特位，而并不影响其它位。在最后一行中，清除了一个比特位。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1100001101110</span></div><div class="line"><span class="number">1100001111110</span></div><div class="line"><span class="number">1100001111111</span></div><div class="line"><span class="number">1100001111101</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/managing-bit-flags-part-3" target="_blank" rel="external">Managing Bit Flags (Part 3)</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Managing Bit Flags (Part 3)
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 管理比特标志位（第二部分）</title>
    <link href="http://blog.vichamp.com/2017/03/06/managing-bit-flags-part-2/"/>
    <id>http://blog.vichamp.com/2017/03/06/managing-bit-flags-part-2/</id>
    <published>2017-03-05T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.944Z</updated>
    
    <content type="html"><![CDATA[<p>在前一个技能中我们演示了如何使用 PowerShell 5 新的枚举特性来解析bite标志位，甚至可以独立地检测每个标志位。</p>
<p>如果您无法使用 PowerShell 5，在早期的 PowerShell 版本中，仍然可以使用这个技术只需要通过 C# 代码来定义枚举即可：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># this is the decimal we want to decipher</span></div><div class="line"><span class="variable">$rawflags</span> = <span class="number">56823</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># define an enum with the friendly names for the flags</span></div><div class="line"><span class="comment"># don't forget [Flags]</span></div><div class="line"><span class="comment"># IMPORTANT: you cannot change your type inside a PowerShell session!</span></div><div class="line"><span class="comment"># if you made changes to the enum, close PowerShell and open a new</span></div><div class="line"><span class="comment"># PowerShell!</span></div><div class="line"><span class="variable">$enum</span> = <span class="string">'</span></div><div class="line">using System;</div><div class="line">[Flags]</div><div class="line">public enum BitFlags</div><div class="line">&#123;</div><div class="line">    None    = 0,</div><div class="line">    Option1 = 1,</div><div class="line">    Option2 = 2,</div><div class="line">    Option3 = 4,</div><div class="line">    Option4 = 8,</div><div class="line">    Option5 = 16,</div><div class="line">    Option6 = 32,</div><div class="line">    Option7 = 64,</div><div class="line">    Option8 = 128,</div><div class="line">    Option9 = 256,</div><div class="line">    Option10= 512,</div><div class="line">    Option11= 1024,</div><div class="line">    Option12= 2048,</div><div class="line">    Option13= 4096,</div><div class="line">    Option14= 8192,</div><div class="line">    Option15= 16384,</div><div class="line">    Option16= 32768,</div><div class="line">    Option17= 65536</div><div class="line">&#125;</div><div class="line">'</div><div class="line"><span class="built_in">Add-Type</span> -TypeDefinition <span class="variable">$enum</span></div><div class="line"></div><div class="line"><span class="comment"># convert the decimal to the new enum</span></div><div class="line">[BitFlags]<span class="variable">$flags</span> = <span class="variable">$rawflags</span></div><div class="line"><span class="variable">$flags</span></div><div class="line"></div><div class="line"><span class="comment"># test individual flags</span></div><div class="line"><span class="variable">$flags</span>.HasFlag([BitFlags]::Option1)</div><div class="line"><span class="variable">$flags</span>.HasFlag([BitFlags]::Option2)</div></pre></td></tr></table></figure>
<p>如您所见，从十进制数转换到新的枚举类型使用正常而且非常简单：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; [BitFlags]<span class="number">6625</span></div><div class="line">Option1, Option6, Option7, Option8, Option9, Option12, Option13</div><div class="line"></div><div class="line">PS C:\&gt;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/managing-bit-flags-part-2" target="_blank" rel="external">Managing Bit Flags (Part 2)</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Managing Bit Flags (Part 2)
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 管理比特标志位（第一部分）</title>
    <link href="http://blog.vichamp.com/2017/03/03/managing-bit-flags-part-1/"/>
    <id>http://blog.vichamp.com/2017/03/03/managing-bit-flags-part-1/</id>
    <published>2017-03-02T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.944Z</updated>
    
    <content type="html"><![CDATA[<p>有时候您会需要处理比特标志位值。一个数字中的每个比特代表一个特定的设置，并且您的代码可能需要决定一个标志位是否置位，而不能影响别的比特。</p>
<p>这常常需要一系列位操作。然而在 PowerShell 5 中，有一个简单得多的办法——标志位枚举。</p>
<p>假设有一个值 56823，并且希望知道哪个比特是置位的。您需要将该数字转换成可视化的比特：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; [Convert]::ToString(<span class="number">56823</span>, <span class="number">2</span>)</div><div class="line"><span class="number">1101110111110111</span></div></pre></td></tr></table></figure>
<p>如果您了解每个比特的意义，那么一个更强大的方法是定义一个枚举：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#requires -Version 5</span></div><div class="line"></div><div class="line">[flags()]</div><div class="line">enum CustomBitFlags</div><div class="line">&#123;</div><div class="line">    None    = <span class="number">0</span></div><div class="line">    Option1 = <span class="number">1</span></div><div class="line">    Option2 = <span class="number">2</span></div><div class="line">    Option3 = <span class="number">4</span></div><div class="line">    Option4 = <span class="number">8</span></div><div class="line">    Option5 = <span class="number">16</span></div><div class="line">    Option6 = <span class="number">32</span></div><div class="line">    Option7 = <span class="number">64</span></div><div class="line">    Option8 = <span class="number">128</span></div><div class="line">    Option9 = <span class="number">256</span></div><div class="line">    Option10= <span class="number">512</span></div><div class="line">    Option11= <span class="number">1024</span></div><div class="line">    Option12= <span class="number">2048</span></div><div class="line">    Option13= <span class="number">4096</span></div><div class="line">    Option14= <span class="number">8192</span></div><div class="line">    Option15= <span class="number">16384</span></div><div class="line">    Option16= <span class="number">32768</span></div><div class="line">    Option17= <span class="number">65536</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对每个比特提供一个友好的名字，并且记得添加属性 <code>[Flags]</code>（这将允许设置多个值）。</p>
<p>现在要解析这个十进制值非常简单——只需要将它转换成新定义的枚举类型：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$rawflags</span> = <span class="number">56823</span></div><div class="line">[CustomBitFlags]<span class="variable">$flags</span> = <span class="variable">$rawflags</span></div></pre></td></tr></table></figure>
<p>这时得到的结果：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; <span class="variable">$flags</span></div><div class="line">Option1, Option2, Option3, Option5, Option6, Option7, Option8, Option9, Option11, Option12, Option13, Option15, Option16</div></pre></td></tr></table></figure>
<p>如果您只希望检测某个标志位是否置位，请使用 <code>HasFlag()</code> 方法：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; <span class="variable">$flags</span>.HasFlag([CustomBitFlags]::Option1)</div><div class="line"></div><div class="line">True</div><div class="line"></div><div class="line">PS C:\&gt; <span class="variable">$flags</span>.HasFlag([CustomBitFlags]::Option4)</div><div class="line"></div><div class="line">False</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/managing-bit-flags-part-1" target="_blank" rel="external">Managing Bit Flags (Part 1)</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Managing Bit Flags (Part 1)
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 使用泛型</title>
    <link href="http://blog.vichamp.com/2017/03/02/working-with-generics/"/>
    <id>http://blog.vichamp.com/2017/03/02/working-with-generics/</id>
    <published>2017-03-01T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.929Z</updated>
    
    <content type="html"><![CDATA[<p>泛型可以作为实际类型的占位符，您可能会好奇为什么它会有意思。</p>
<p>有许多不同的数据类型没有 NULL 值。例如 Integer 和 Boolean 型，没有办法指出一个值是非法的还是未设置。您可以通过将一个 0（或者 -1）指定为某个 integer 变量的 “undefined” 值。但如果所有的数字都是合法的值呢？对于 Boolean，情况也是一样：虽然您可以定义 <code>$false</code> 值为 “undefined” 值，但许多情况下的确需要三种值：<code>$true</code>、<code>$flase</code> 和 <code>undefined</code>。</p>
<p>泛型是解决的办法，您可以使用 <code>Nullable</code> 类型根据任何合法的类型来创建自己的可空值类型。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[Nullable[int]]<span class="variable">$number</span> =  <span class="literal">$null</span></div><div class="line">[Nullable[bool]]<span class="variable">$flag</span> =  <span class="literal">$null</span></div><div class="line"></div><div class="line"><span class="variable">$number</span></div><div class="line"><span class="variable">$flag</span></div></pre></td></tr></table></figure>
<p>用常规数据类型来做数据转换：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; [int]<span class="literal">$null</span></div><div class="line"><span class="number">0</span></div><div class="line"></div><div class="line">PS C:\&gt; [bool]<span class="literal">$null</span></div><div class="line">False</div><div class="line"></div><div class="line">PS C:\&gt;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/working-with-generics" target="_blank" rel="external">Working With Generics</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Working With Generics
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - Power Shell 5 的类继承（第二部分）</title>
    <link href="http://blog.vichamp.com/2017/03/01/inheriting-classes-in-powershell-5-part-2/"/>
    <id>http://blog.vichamp.com/2017/03/01/inheriting-classes-in-powershell-5-part-2/</id>
    <published>2017-02-28T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.929Z</updated>
    
    <content type="html"><![CDATA[<p>以下是在 PowerShell 5 中使用新的类特性的另一个用例。在前一个例子中，我们演示了如何从 <code>System.Diagnostics.Process</code> 派生一个新类，从而获得代表进程的功能更强大的对象。</p>
<p>以下是一个从 <code>WebClient</code> 派生的类，<code>WebClient</code> 主要是用来连接网站。当您使用标准的 <code>WebClient</code> 对象是，它拒绝连接到证书错误的 HTTPS 网站。这是一件好事，但是有时候您仍需要连接这类网站。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#requires -Version 5</span></div><div class="line"></div><div class="line">class MyWebClient : System.Net.WebClient</div><div class="line">&#123;</div><div class="line">  MyWebClient() : base()</div><div class="line">  &#123;</div><div class="line">    <span class="comment"># with SSL certificate errors, connect anyway</span></div><div class="line">    [System.Net.ServicePointManager]::ServerCertificateValidationCallback = &#123; <span class="literal">$true</span> &#125;</div><div class="line">    <span class="variable">$proxy</span> = [System.Net.WebRequest]::GetSystemWebProxy()</div><div class="line">    <span class="variable">$proxy</span>.Credentials = [System.Net.CredentialCache]::DefaultCredentials</div><div class="line">    <span class="variable">$this</span>.Proxy = <span class="variable">$proxy</span></div><div class="line">    <span class="variable">$this</span>.UseDefaultCredentials = <span class="literal">$true</span></div><div class="line">    <span class="variable">$this</span>.Proxy.Credentials = <span class="variable">$this</span>.Credentials</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="variable">$client</span> = [mywebclient]::new()</div><div class="line"><span class="variable">$client</span>.DownloadString(<span class="string">'http://www.psconf.eu'</span>)</div></pre></td></tr></table></figure>
<p>这样，”<code>“MyWebClient”</code>“ 类继承于 <code>WebClient()</code> 并改变了 <code>ServerCertificateValidationCallBack</code> 的行为。它只是返回 <code>$true</code>，所以所有的连接都是成功的，而且证书检验变得无关紧要。</p>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/inheriting-classes-in-powershell-5-part-2" target="_blank" rel="external">Inheriting Classes in PowerShell 5 (part 2)</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Inheriting Classes in PowerShell 5 (part 2)
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - Power Shell 5 的类继承（第一部分）</title>
    <link href="http://blog.vichamp.com/2017/02/28/inheriting-classes-in-powershell-5-part-1/"/>
    <id>http://blog.vichamp.com/2017/02/28/inheriting-classes-in-powershell-5-part-1/</id>
    <published>2017-02-27T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.924Z</updated>
    
    <content type="html"><![CDATA[<p>PowerShell 5 内置了类的支持。您可以使用这个新特性来增强已有的 .NET 类的功能。以下是一个例子：创建一个包含新功能的增强的进程类。</p>
<p>进程通常是由 <code>System.Diagnostics.Process</code> 对象代表。它们只有有限的功能，并且假设没有能直接使用的以友好方式关闭一个应用程序的方法。您可以杀除进程（会丢失未保存的数据），或关闭它（用户可以取消关闭）。</p>
<p>以下是一个新的 继承于 <code>System.Diagnostics.Process</code> 的名为 <code>AppInstance</code> 的类。所以它拥有 <code>Process</code> 类中所有已有的功能，您可以增加额外的属性和方法：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#requires -Version 5</span></div><div class="line">class AppInstance : System.Diagnostics.Process</div><div class="line">&#123;</div><div class="line">  <span class="comment"># Constructor, being called when you instantiate a new object of</span></div><div class="line">  <span class="comment"># this class</span></div><div class="line">  AppInstance([string]<span class="variable">$Name</span>) : base()</div><div class="line">  &#123;</div><div class="line">    <span class="comment"># launch the process, get a regular process object, and then</span></div><div class="line">    <span class="comment"># enhance it with additional functionality</span></div><div class="line">    <span class="variable">$this</span>.StartInfo.FileName = <span class="variable">$Name</span></div><div class="line">    <span class="variable">$this</span>.Start()</div><div class="line">    <span class="variable">$this</span>.WaitForInputIdle()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment"># for example, rename an existing method</span></div><div class="line">  [void]Stop()</div><div class="line">  &#123;</div><div class="line">    <span class="variable">$this</span>.Kill()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment"># or invent new functionality</span></div><div class="line">  <span class="comment"># Close() closes the window gracefully. Unlike Kill(),</span></div><div class="line">  <span class="comment"># the user gets the chance to save unsaved work for</span></div><div class="line">  <span class="comment"># a specified number of seconds before the process</span></div><div class="line">  <span class="comment"># is killed</span></div><div class="line">  [void]Close([Int]<span class="variable">$Timeout</span> = <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="comment"># send close message</span></div><div class="line">    <span class="variable">$this</span>.CloseMainWindow()</div><div class="line">    <span class="comment"># wait for success</span></div><div class="line">    <span class="keyword">if</span> (<span class="variable">$Timeout</span> <span class="nomarkup">-gt</span> <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="literal">$null</span> = <span class="variable">$this</span>.WaitForExit(<span class="variable">$Timeout</span> * <span class="number">1000</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment"># if process still runs (user aborted request), kill forcefully</span></div><div class="line">    <span class="keyword">if</span> (<span class="variable">$this</span>.HasExited <span class="nomarkup">-eq</span> <span class="literal">$false</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="variable">$this</span>.Stop()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment"># example of how to change a property like process priority</span></div><div class="line">  [void]SetPriority([System.Diagnostics.ProcessPriorityClass] <span class="variable">$Priority</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="variable">$this</span>.PriorityClass = <span class="variable">$Priority</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  [System.Diagnostics.ProcessPriorityClass]GetPriority()</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="variable">$this</span>.HasExited <span class="nomarkup">-eq</span> <span class="literal">$false</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> <span class="variable">$this</span>.PriorityClass</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">Throw</span> <span class="string">"Process PID $(<span class="variable">$this</span>.Id) does not run anymore."</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment"># add static methods, for example a way to list all processes</span></div><div class="line">  <span class="comment"># variant A: no arguments</span></div><div class="line">  static [System.Diagnostics.Process[]] GetAllProcesses()</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> [AppInstance]::GetAllProcesses(<span class="literal">$false</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="comment"># variant B: submit $false to see only processes that have a window</span></div><div class="line">  static [System.Diagnostics.Process[]] GetAllProcesses([bool]<span class="variable">$All</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="variable">$All</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Get-Process</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Get-Process</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.MainWindowHandle <span class="nomarkup">-ne</span> <span class="number">0</span> &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># you can always run static methods</span></div><div class="line">[AppInstance]::GetAllProcesses(<span class="literal">$true</span>) | <span class="built_in">Out-GridView</span> -Title <span class="string">'All Processes'</span></div><div class="line">[AppInstance]::GetAllProcesses(<span class="literal">$false</span>) | <span class="built_in">Out-GridView</span> -Title <span class="string">'Processes with Window'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># this is how you instantiate a new process and get back</span></div><div class="line"><span class="comment"># a new enhanced process object</span></div><div class="line"><span class="comment"># classic way:</span></div><div class="line"><span class="comment"># $notepad = New-Object -TypeName AppInstance('notepad')</span></div><div class="line"><span class="comment"># new (and faster) way in PowerShell 5 to instantiate new objects:</span></div><div class="line"><span class="variable">$notepad</span> = [AppInstance]::new(<span class="string">'notepad'</span>)</div><div class="line"></div><div class="line"><span class="comment"># set a different process priority</span></div><div class="line"><span class="variable">$notepad</span>.SetPriority(<span class="string">'BelowNormal'</span>)</div><div class="line"></div><div class="line"><span class="comment"># add some text to the editor to see the close message</span></div><div class="line"><span class="built_in">Start-Sleep</span> -Seconds <span class="number">5</span></div><div class="line"></div><div class="line"><span class="comment"># close the application and offer to save changes for a maximum</span></div><div class="line"><span class="comment"># of 10 seconds</span></div><div class="line"><span class="variable">$notepad</span>.Close(<span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>如您在这个例子中所见，当您从这个类创建一个新实例时，它启动了一个新的进程，而且这些进程照常暴露出相同的属性和方法。而且，有一些新的例如 <code>SetPriority()</code> 和 <code>Close()</code> 的新方法。</p>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/inheriting-classes-in-powershell-5-part-1" target="_blank" rel="external">Inheriting Classes in PowerShell 5 (part 1)</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Inheriting Classes in PowerShell 5 (part 1)
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 显示或隐藏窗口</title>
    <link href="http://blog.vichamp.com/2017/02/27/show-or-hide-windows/"/>
    <id>http://blog.vichamp.com/2017/02/27/show-or-hide-windows/</id>
    <published>2017-02-26T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.914Z</updated>
    
    <content type="html"><![CDATA[<p>PowerShell 可以调用 Windows 内部的 API，在这个例子中，我们想向您展示如何改变一个应用程序窗口的显示状态。比如可以最大化、最小化、隐藏或显示窗口。</p>
<p>这个例子使用 PowerShell 5 最新的枚举特性对 <code>showstate</code> 数值赋予有意义的名字。在 PowerShell 的更早版本中，只需要移除枚举部分，并在代码中直接使用合适的 <code>showstate</code> 数字即可。</p>
<p>这里的学习要点是如何使用 <code>Add-Type</code> 来包装一个 C# 形式的 API 方法并在 PowerShell 代码中返回一个暴露这个方法的 type：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#requires -Version 5</span></div><div class="line"><span class="comment"># this enum works in PowerShell 5 only</span></div><div class="line"><span class="comment"># in earlier versions, simply remove the enum,</span></div><div class="line"><span class="comment"># and use the numbers for the desired window state</span></div><div class="line"><span class="comment"># directly</span></div><div class="line"></div><div class="line">Enum ShowStates</div><div class="line">&#123;</div><div class="line">  Hide = <span class="number">0</span></div><div class="line">  Normal = <span class="number">1</span></div><div class="line">  Minimized = <span class="number">2</span></div><div class="line">  Maximized = <span class="number">3</span></div><div class="line">  ShowNoActivateRecentPosition = <span class="number">4</span></div><div class="line">  Show = <span class="number">5</span></div><div class="line">  MinimizeActivateNext = <span class="number">6</span></div><div class="line">  MinimizeNoActivate = <span class="number">7</span></div><div class="line">  ShowNoActivate = <span class="number">8</span></div><div class="line">  Restore = <span class="number">9</span></div><div class="line">  ShowDefault = <span class="number">10</span></div><div class="line">  ForceMinimize = <span class="number">11</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># the C#-style signature of an API function (see also www.pinvoke.net)</span></div><div class="line"><span class="variable">$code</span> = <span class="string">'[DllImport("user32.dll")] public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);'</span></div><div class="line"></div><div class="line"><span class="comment"># add signature as new type to PowerShell (for this session)</span></div><div class="line"><span class="variable">$type</span> = <span class="built_in">Add-Type</span> -MemberDefinition <span class="variable">$code</span> -Name myAPI -PassThru</div><div class="line"></div><div class="line"><span class="comment"># access a process</span></div><div class="line"><span class="comment"># (in this example, we are accessing the current PowerShell host</span></div><div class="line"><span class="comment">#  with its process ID being present in $pid, but you can use</span></div><div class="line"><span class="comment">#  any process ID instead)</span></div><div class="line"><span class="variable">$process</span> = <span class="built_in">Get-Process</span> -Id <span class="variable">$PID</span></div><div class="line"></div><div class="line"><span class="comment"># get the process window handle</span></div><div class="line"><span class="variable">$hwnd</span> = <span class="variable">$process</span>.MainWindowHandle</div><div class="line"></div><div class="line"><span class="comment"># apply a new window size to the handle, i.e. hide the window completely</span></div><div class="line"><span class="variable">$type::ShowWindowAsync</span>(<span class="variable">$hwnd</span>, [ShowStates]::Hide)</div><div class="line"></div><div class="line"><span class="built_in">Start-Sleep</span> -Seconds <span class="number">2</span></div><div class="line"><span class="comment"># restore the window handle again</span></div><div class="line"><span class="variable">$type::ShowWindowAsync</span>(<span class="variable">$hwnd</span>, [ShowStates]::Show)</div></pre></td></tr></table></figure>
<p>请注意这个例子将 PowerShell 窗口临时隐藏 2 秒钟。您可以对任何运行中的应用程序窗口做相同的事情。只需要用 <code>Get-Process</code> 来查找目标进程，并使用它的 “<code>MainWindowHandle</code>“ 属性来发送 showstate 改变请求。</p>
<p>一些应用程序有多个窗口。在这种情况下，您只能针对主窗口操作，否则需要先靠其它 API 来获取子窗口的句柄集合。</p>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/show-or-hide-windows" target="_blank" rel="external">Show or Hide Windows</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Show or Hide Windows
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - 用 Pester Tests 做测试</title>
    <link href="http://blog.vichamp.com/2017/02/24/using-pester-tests-to-test-anything/"/>
    <id>http://blog.vichamp.com/2017/02/24/using-pester-tests-to-test-anything/</id>
    <published>2017-02-23T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.897Z</updated>
    
    <content type="html"><![CDATA[<p>Pester 是一个随 Windows 10 和 Windows Server 2016 发布的开源模块，可以通过 <a href="http://www.powershellgallery.com" target="_blank" rel="external">PowerShell Gallery</a> 免费下载（需要事先安装最新版本的 PowerShellGet）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; Install-Module -Name Pester -Force -SkipPublisherCheck</div></pre></td></tr></table></figure>
<p>Pester 是一个主要用来测试 PowerShell 代码的测试框架。您不仅可以用它来测试代码，而且可以用它来测试任何东西。以下是一个测试 PowerShell 版本号和一些设置的小例子：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Describe <span class="string">'PowerShell Basic Check'</span> &#123;</div><div class="line"></div><div class="line">  Context <span class="string">'PS Versioning'</span>   &#123;</div><div class="line">    It <span class="string">'is current version'</span> &#123;</div><div class="line">      <span class="variable">$host</span>.Version.Major <span class="nomarkup">-ge</span> <span class="number">5</span> -and <span class="variable">$host</span>.Version.Minor <span class="nomarkup">-ge</span> <span class="number">1</span> | Should Be <span class="literal">$true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  Context <span class="string">'PS Settings'</span>   &#123;</div><div class="line">    It <span class="string">'can execute scripts'</span> &#123;</div><div class="line">      (<span class="built_in">Get-ExecutionPolicy</span>) | Should Not Be <span class="string">'Restricted'</span></div><div class="line">    &#125;</div><div class="line">    It <span class="string">'does not use AllSigned'</span> &#123;</div><div class="line">      (<span class="built_in">Get-ExecutionPolicy</span>) | Should Not Be <span class="string">'AllSigned'</span></div><div class="line">    &#125;</div><div class="line">    It <span class="string">'does not have GPO restrictions'</span> &#123;</div><div class="line">      (<span class="built_in">Get-ExecutionPolicy</span> -Scope MachinePolicy) | Should Be <span class="string">'Undefined'</span></div><div class="line">      (<span class="built_in">Get-ExecutionPolicy</span> -Scope UserPolicy) | Should Be <span class="string">'Undefined'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当您运行它时（当然，前提是已经安装了 Pester 模块），这是得到的输出结果：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Describing PowerShell Basic Check</div><div class="line"></div><div class="line">  Context PS Versioning</div><div class="line">    [+] is current version <span class="number">76</span>ms</div><div class="line"></div><div class="line">  Context PS Settings</div><div class="line">    [+] can execute scripts <span class="number">47</span>ms</div><div class="line">    [+] does not use AllSigned <span class="number">18</span>ms</div><div class="line">    [+] does not have GPO restrictions <span class="number">21</span>ms</div><div class="line"></div><div class="line">PS&gt;</div></pre></td></tr></table></figure>
<p>当然，这只是一个例子。您可以把它做详细并且将测试扩展到更多的其它设置或依赖条件。</p>
<a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/using-pester-tests-to-test-anything" target="_blank" rel="external">Using Pester Tests to Test Anything</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Using Pester Tests to Test Anything
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 技能连载 - Reading Environment Variables Freshly</title>
    <link href="http://blog.vichamp.com/2017/02/23/reading-environment-variables-freshly/"/>
    <id>http://blog.vichamp.com/2017/02/23/reading-environment-variables-freshly/</id>
    <published>2017-02-22T16:00:00.000Z</published>
    <updated>2017-03-28T14:47:53.882Z</updated>
    
    <content type="html"><![CDATA[<p>When you read environment variables in PowerShell, you probably make use of the “env:” drive. This line retrieves the environment variable %USERNAME%, for example, telling you the name of the user executing the script:</p>
<pre><code>PS C:\&gt; $env:USERNAME
tobwe

PS C:\&gt;
</code></pre><p>The “env:” drive always accesses the process set of environment variables. This makes sense in most cases as many of the environment variables (like “UserName”) are defined in this set. Basically, the process set of environment variables is a “snapshot” of all environment variables at the time of when an application starts, plus a number of additional pieces of information (like “UserName”).</p>
<p>To read environment variables freshly and explicitly from the system or user set, use code like this:</p>
<pre><code>$name = &apos;temp&apos;
$scope = [EnvironmentVariableTarget]::Machine

$content = [Environment]::GetEnvironmentVariable($name, $scope)
&quot;Content: $content&quot;
</code></pre><p>You could use this technique, for example, to communicate between two processes. To play with this, open two PowerShell consoles. Now, in the first console, enter this:</p>
<pre><code>[Environment]::SetEnvironmentVariable(&quot;PS_Info&quot;, &quot;Hello&quot;, &quot;user&quot;)
</code></pre><p>In the second PowerShell console, enter this line to receive the information:</p>
<pre><code>[Environment]::GetEnvironmentVariable(&quot;PS_Info&quot;, &quot;user&quot;) 
</code></pre><p>To clean up the environment variable, enter this line in either console:</p>
<pre><code>[Environment]::SetEnvironmentVariable(&quot;PS_Info&quot;, &quot;&quot;, &quot;user&quot;)
</code></pre><a id="more"></a>
<p>本文国际来源：<a href="http://community.idera.com/powershell/powertips/b/tips/posts/reading-environment-variables-freshly" target="_blank" rel="external">Reading Environment Variables Freshly</a></p>]]></content>
    
    <summary type="html">
    
      PowerTip of the Day - Reading Environment Variables Freshly
    
    </summary>
    
      <category term="powershell" scheme="http://blog.vichamp.com/categories/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/categories/powershell/tip/"/>
    
    
      <category term="powershell" scheme="http://blog.vichamp.com/tags/powershell/"/>
    
      <category term="tip" scheme="http://blog.vichamp.com/tags/tip/"/>
    
      <category term="powertip" scheme="http://blog.vichamp.com/tags/powertip/"/>
    
      <category term="series" scheme="http://blog.vichamp.com/tags/series/"/>
    
      <category term="translation" scheme="http://blog.vichamp.com/tags/translation/"/>
    
  </entry>
  
</feed>
