{"meta":{"title":"叹为观止","subtitle":"追求卓越，成功自然来","description":"PowerShell, 中文博客, 互联网, 效率党, 同步控, 工程师, 脚本爱好者, 崇尚优雅的程序设计","author":"John Doe","url":"http://blog.vichamp.com"},"pages":[{"title":"","date":"2016-09-13T07:04:32.713Z","updated":"2016-09-13T07:04:32.713Z","comments":true,"path":"404.html","permalink":"http://blog.vichamp.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2014-07-14T06:56:08.000Z","updated":"2016-09-13T07:04:36.698Z","comments":true,"path":"about/index.html","permalink":"http://blog.vichamp.com/about/index.html","excerpt":"","text":"追求卓越，成功自然来victorwoo@gmail.com"}],"posts":[{"title":"PowerShell 技能连载 - 限制文本的长度（第一部分）","slug":"texts-with-maximum-length-part-1","date":"2017-03-16T08:00:00.000Z","updated":"2017-03-17T15:26:27.740Z","comments":true,"path":"2017/03/16/texts-with-maximum-length-part-1/","link":"","permalink":"http://blog.vichamp.com/2017/03/16/texts-with-maximum-length-part-1/","excerpt":"如果您想将一个文本的长度限制在某一个长度，以下是一个简单的方法： 1234$text = 'this is a long text'$MaxLength = 10$text.PadRight($MaxLength).Substring(0,$MaxLength) 这段代码首先对文本填充，以防它比最大长度还短，然后使用 Substring() 裁剪掉多余的文本。","text":"如果您想将一个文本的长度限制在某一个长度，以下是一个简单的方法： 1234$text = 'this is a long text'$MaxLength = 10$text.PadRight($MaxLength).Substring(0,$MaxLength) 这段代码首先对文本填充，以防它比最大长度还短，然后使用 Substring() 裁剪掉多余的文本。 本文国际来源：Texts with Maximum Length (Part 1)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找所有含桌面的配置文件","slug":"finding-all-profiles-with-desktop","date":"2017-03-15T08:00:00.000Z","updated":"2017-03-17T15:26:27.732Z","comments":true,"path":"2017/03/15/finding-all-profiles-with-desktop/","link":"","permalink":"http://blog.vichamp.com/2017/03/15/finding-all-profiles-with-desktop/","excerpt":"这一行代码能够列出所有本地用户配置文件中的桌面——请确保以管理员身份运行这行代码才能查看其他人的配置文件： 1Resolve-Path -Path C:\\users\\*\\Desktop -ErrorAction SilentlyContinue 如果您只想获得配置文件中包含 “Desktop” 文件夹的用户名，请用以下代码： 1234Resolve-Path -Path C:\\users\\*\\Desktop -ErrorAction SilentlyContinue | ForEach-Object &#123; $_.Path.Split('\\')[-2] &#125; 这段代码获取路径并用反斜杠将它们分割，创建一个路径元素的数组。下标 -2 是指倒数第二个元素，即用户名。","text":"这一行代码能够列出所有本地用户配置文件中的桌面——请确保以管理员身份运行这行代码才能查看其他人的配置文件： 1Resolve-Path -Path C:\\users\\*\\Desktop -ErrorAction SilentlyContinue 如果您只想获得配置文件中包含 “Desktop” 文件夹的用户名，请用以下代码： 1234Resolve-Path -Path C:\\users\\*\\Desktop -ErrorAction SilentlyContinue | ForEach-Object &#123; $_.Path.Split('\\')[-2] &#125; 这段代码获取路径并用反斜杠将它们分割，创建一个路径元素的数组。下标 -2 是指倒数第二个元素，即用户名。 本文国际来源：Finding All Profiles with Desktop","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Where-Object 和 .Where()","slug":"where-object-and-where","date":"2017-03-14T08:00:00.000Z","updated":"2017-03-17T15:26:27.721Z","comments":true,"path":"2017/03/14/where-object-and-where/","link":"","permalink":"http://blog.vichamp.com/2017/03/14/where-object-and-where/","excerpt":"从 PowerShell 4 开始，当您不想使用管道的时候，可以使用 Where() 和 ForEach() 方法来代替 Where-Object 和 ForEach-Object。 所以如果您已经将所有数据加载到一个变量中，那么非流式操作会更高效： 123456$Services = Get-Service# streaming$Services | Where-Object &#123; $_.Status -eq 'Running' &#125;# non-streaming$Services.Where&#123; $_.Status -eq 'Running' &#125; 要节约资源，最有效地方法仍然是使用流式管道，而不是用变量： 1Get-Service | Where-Object &#123; $_.Status -eq 'Running' &#125; 请注意 Where-Object 和 .Where() 使用不同的数组类型，所以它们的输出技术上是不同的： 12345PS C:\\&gt; (1..19 | Where-Object &#123; $_ -gt 10 &#125;).GetType().FullNameSystem.Object[]PS C:\\&gt; ((1..19).Where&#123; $_ -gt 10 &#125;).GetType().FullNameSystem.Collections.ObjectModel.Collection`1[[System.Management.Automation.PSObject, System.Management.Automation, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]]","text":"从 PowerShell 4 开始，当您不想使用管道的时候，可以使用 Where() 和 ForEach() 方法来代替 Where-Object 和 ForEach-Object。 所以如果您已经将所有数据加载到一个变量中，那么非流式操作会更高效： 123456$Services = Get-Service# streaming$Services | Where-Object &#123; $_.Status -eq 'Running' &#125;# non-streaming$Services.Where&#123; $_.Status -eq 'Running' &#125; 要节约资源，最有效地方法仍然是使用流式管道，而不是用变量： 1Get-Service | Where-Object &#123; $_.Status -eq 'Running' &#125; 请注意 Where-Object 和 .Where() 使用不同的数组类型，所以它们的输出技术上是不同的： 12345PS C:\\&gt; (1..19 | Where-Object &#123; $_ -gt 10 &#125;).GetType().FullNameSystem.Object[]PS C:\\&gt; ((1..19).Where&#123; $_ -gt 10 &#125;).GetType().FullNameSystem.Collections.ObjectModel.Collection`1[[System.Management.Automation.PSObject, System.Management.Automation, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] 本文国际来源：Where-Object and .Where()","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 快速创建对象数组","slug":"creating-object-arrays-on-the-fly","date":"2017-03-13T08:00:00.000Z","updated":"2017-03-17T15:26:27.714Z","comments":true,"path":"2017/03/13/creating-object-arrays-on-the-fly/","link":"","permalink":"http://blog.vichamp.com/2017/03/13/creating-object-arrays-on-the-fly/","excerpt":"以下是一个用内置的 CSV 处理器生成对象数组的代码实例： 123456789101112131415$csv = @'PC,DatePC82012,2017-02-28PC82038,2017-02-28PC83073,2017-02-28PC84004,2017-02-28PC84009,2017-02-28PC84015,2017-02-28PC90435,2017-02-28'@$data = $csv | ConvertFrom-Csv$data$data | Out-GridView 如果一个脚本需要一个静态的服务器、连接数据或其他信息的列表，这种方式会很有用。","text":"以下是一个用内置的 CSV 处理器生成对象数组的代码实例： 123456789101112131415$csv = @'PC,DatePC82012,2017-02-28PC82038,2017-02-28PC83073,2017-02-28PC84004,2017-02-28PC84009,2017-02-28PC84015,2017-02-28PC90435,2017-02-28'@$data = $csv | ConvertFrom-Csv$data$data | Out-GridView 如果一个脚本需要一个静态的服务器、连接数据或其他信息的列表，这种方式会很有用。 本文国际来源：Creating Object Arrays on the Fly","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Exploring Type Accelerators","slug":"exploring-type-accelerators","date":"2017-03-12T08:00:00.000Z","updated":"2017-03-17T15:26:27.706Z","comments":true,"path":"2017/03/12/exploring-type-accelerators/","link":"","permalink":"http://blog.vichamp.com/2017/03/12/exploring-type-accelerators/","excerpt":"PowerShell uses a number of so-called type accelerators that help with long .NET type names. Instead of using “System.DirectoryServices.DirectoryEntry”, for example, you can simply type “ADSI”. When you query the property FullName of a type, you always get back the underlying full .NET type name: PS C:\\&gt; [ADSI].FullName System.DirectoryServices.DirectoryEntry PS C:\\&gt; And this line dumps all the built-in .NET type accelerators in PowerShell: [PSObject].Assembly.GetType(&quot;System.Management.Automation.TypeAccelerators&quot;)::get | Out-GridView Aside from the explicit type accelerators, there is another rule built into PowerShell: when a type resides in the namespace “System”, then you can always omit this namespace. This is why all of these are the same: PS C:\\&gt; [int].FullName System.Int32 PS C:\\&gt; [System.Int32].FullName System.Int32 PS C:\\&gt; [Int32].FullName System.Int32","text":"PowerShell uses a number of so-called type accelerators that help with long .NET type names. Instead of using “System.DirectoryServices.DirectoryEntry”, for example, you can simply type “ADSI”. When you query the property FullName of a type, you always get back the underlying full .NET type name: PS C:\\&gt; [ADSI].FullName System.DirectoryServices.DirectoryEntry PS C:\\&gt; And this line dumps all the built-in .NET type accelerators in PowerShell: [PSObject].Assembly.GetType(&quot;System.Management.Automation.TypeAccelerators&quot;)::get | Out-GridView Aside from the explicit type accelerators, there is another rule built into PowerShell: when a type resides in the namespace “System”, then you can always omit this namespace. This is why all of these are the same: PS C:\\&gt; [int].FullName System.Int32 PS C:\\&gt; [System.Int32].FullName System.Int32 PS C:\\&gt; [Int32].FullName System.Int32 本文国际来源：Exploring Type Accelerators","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 危险的临时文件！","slug":"dangerous-temp-files","date":"2017-03-09T08:00:00.000Z","updated":"2017-03-17T15:26:27.698Z","comments":true,"path":"2017/03/09/dangerous-temp-files/","link":"","permalink":"http://blog.vichamp.com/2017/03/09/dangerous-temp-files/","excerpt":"内部的系统功能往往十分有用，但请确保真正了解它们的功能。 一个特别常见的系统方法叫做 GetTempFileName() ，能够创建临时文件名。而当您进一步观察的时候，您会发现它不仅创建临时文件名，而且还创建了临时文件： $file = [System.IO.Path]::GetTempFileName() Test-Path -Path $file 所以如果在脚本中只是使用这个方法来创建临时文件名的话，会留下一大堆孤立的文件。","text":"内部的系统功能往往十分有用，但请确保真正了解它们的功能。 一个特别常见的系统方法叫做 GetTempFileName() ，能够创建临时文件名。而当您进一步观察的时候，您会发现它不仅创建临时文件名，而且还创建了临时文件： $file = [System.IO.Path]::GetTempFileName() Test-Path -Path $file 所以如果在脚本中只是使用这个方法来创建临时文件名的话，会留下一大堆孤立的文件。 本文国际来源：Dangerous Temp Files!","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 探索对象","slug":"explore-objects","date":"2017-03-08T08:00:00.000Z","updated":"2017-03-17T15:26:27.691Z","comments":true,"path":"2017/03/08/explore-objects/","link":"","permalink":"http://blog.vichamp.com/2017/03/08/explore-objects/","excerpt":"在 PowerShell 中，一切都是用对象描述。以下是一个检查任意对象并将它的成员以文本的方式复制到剪贴板的单行代码： 12345\"Hello\" | Get-Member | Format-Table -AutoSize -Wrap | Out-String -Width 150 | clip.exe 只需要将 “Hello” 替换成任何变量或命令，然后看看复制了什么到剪贴板中。您可以将信息粘贴到文本编辑器或文字处理器中，并将它打印出来或转成 PDF 备用。","text":"在 PowerShell 中，一切都是用对象描述。以下是一个检查任意对象并将它的成员以文本的方式复制到剪贴板的单行代码： 12345\"Hello\" | Get-Member | Format-Table -AutoSize -Wrap | Out-String -Width 150 | clip.exe 只需要将 “Hello” 替换成任何变量或命令，然后看看复制了什么到剪贴板中。您可以将信息粘贴到文本编辑器或文字处理器中，并将它打印出来或转成 PDF 备用。 本文国际来源：Explore Objects","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理比特标志位（第四部分）","slug":"managing-bit-flags-part-4","date":"2017-03-07T08:00:00.000Z","updated":"2017-03-17T15:26:27.685Z","comments":true,"path":"2017/03/07/managing-bit-flags-part-4/","link":"","permalink":"http://blog.vichamp.com/2017/03/07/managing-bit-flags-part-4/","excerpt":"在 PowerShell 5 中，对枚举的新支持特性使得处理比特位比您在前面的 PowerShell 技能中看到的简单得多。现在设置或清除比特位不再需要冗长的逻辑操作符。 我们先定义一个枚举类型，这样更好管理十进制数： 12345678910111213141516#requires -Version 5[Flags()]enum GardenPartyItems&#123; Chair = 0 Table = 1 Barbecue = 2 Fridge = 4 Candle = 8 Knife = 16&#125;$decimal = 11[GardenPartyItems]$flags = $decimal$flags 现在，十进制数的比特位可以很容易地转化为 GardenPartyItem 的列表： 1234PS C:\\&gt; [GardenPartyItems]11Table, Barbecue, CandlePS C:\\&gt; 注意：将十进制数转换为枚举型时，请确保枚举型中定义了所有的比特。如果十进制数太大，包含枚举型之外的比特时，转换会失败。 要增加一个新的标志位，请试试以下的代码： 123456789PS C:\\&gt; $flagsTable, Barbecue, CandlePS C:\\&gt; $flags += [GardenPartyItems]::KnifePS C:\\&gt; $flagsTable, Barbecue, Candle, KnifePS C:\\&gt; 要移除一个标志位，请试试以下代码： 123456789PS C:\\&gt; $flagsTable, Barbecue, Candle, KnifePS C:\\&gt; $flags -= [GardenPartyItems]::CandlePS C:\\&gt; $flagsTable, Barbecue, KnifePS C:\\&gt; 然而，实际上并没有看起来这么简单。当移除一个已有的标志位，没有问题。但移除一个没有置位的标志位，会把比特值搞乱： 1234567891011121314PS C:\\&gt; $flagsTable, Barbecue, CandlePS C:\\&gt; $flags -= [GardenPartyItems]::CandlePS C:\\&gt; $flagsTable, BarbecuePS C:\\&gt; $flags -= [GardenPartyItems]::CandlePS C:\\&gt; $flags-5PS C:\\&gt; 所以 PowerShell 在自动处理二进制算法方面明显还不够智能。要安全地使用该功能，您还是要用二进制操作符。要移除标志位，请使用 -band 和 -bnot： 1234567891011121314PS C:\\&gt; $flagsTable, Barbecue, CandlePS C:\\&gt; $flags = $flags -band -bnot [GardenPartyItems]::CandlePS C:\\&gt; $flagsTable, BarbecuePS C:\\&gt; $flags = $flags -band -bnot [GardenPartyItems]::CandlePS C:\\&gt; $flagsTable, BarbecuePS C:\\&gt; 要设置标志位，请使用 -bor： 1234567891011121314PS C:\\&gt; $flagsTable, Barbecue, CandlePS C:\\&gt; $flags = $flags -bor [GardenPartyItems]::KnifePS C:\\&gt; $flagsTable, Barbecue, Candle, KnifePS C:\\&gt; $flags = $flags -bor [GardenPartyItems]::KnifePS C:\\&gt; $flagsTable, Barbecue, Candle, KnifePS C:\\&gt; 在所有这些操作中，实际上是在操作一个十进制数： 12PS C:\\&gt; [Int]$flags19 相当棒，对吧？","text":"在 PowerShell 5 中，对枚举的新支持特性使得处理比特位比您在前面的 PowerShell 技能中看到的简单得多。现在设置或清除比特位不再需要冗长的逻辑操作符。 我们先定义一个枚举类型，这样更好管理十进制数： 12345678910111213141516#requires -Version 5[Flags()]enum GardenPartyItems&#123; Chair = 0 Table = 1 Barbecue = 2 Fridge = 4 Candle = 8 Knife = 16&#125;$decimal = 11[GardenPartyItems]$flags = $decimal$flags 现在，十进制数的比特位可以很容易地转化为 GardenPartyItem 的列表： 1234PS C:\\&gt; [GardenPartyItems]11Table, Barbecue, CandlePS C:\\&gt; 注意：将十进制数转换为枚举型时，请确保枚举型中定义了所有的比特。如果十进制数太大，包含枚举型之外的比特时，转换会失败。 要增加一个新的标志位，请试试以下的代码： 123456789PS C:\\&gt; $flagsTable, Barbecue, CandlePS C:\\&gt; $flags += [GardenPartyItems]::KnifePS C:\\&gt; $flagsTable, Barbecue, Candle, KnifePS C:\\&gt; 要移除一个标志位，请试试以下代码： 123456789PS C:\\&gt; $flagsTable, Barbecue, Candle, KnifePS C:\\&gt; $flags -= [GardenPartyItems]::CandlePS C:\\&gt; $flagsTable, Barbecue, KnifePS C:\\&gt; 然而，实际上并没有看起来这么简单。当移除一个已有的标志位，没有问题。但移除一个没有置位的标志位，会把比特值搞乱： 1234567891011121314PS C:\\&gt; $flagsTable, Barbecue, CandlePS C:\\&gt; $flags -= [GardenPartyItems]::CandlePS C:\\&gt; $flagsTable, BarbecuePS C:\\&gt; $flags -= [GardenPartyItems]::CandlePS C:\\&gt; $flags-5PS C:\\&gt; 所以 PowerShell 在自动处理二进制算法方面明显还不够智能。要安全地使用该功能，您还是要用二进制操作符。要移除标志位，请使用 -band 和 -bnot： 1234567891011121314PS C:\\&gt; $flagsTable, Barbecue, CandlePS C:\\&gt; $flags = $flags -band -bnot [GardenPartyItems]::CandlePS C:\\&gt; $flagsTable, BarbecuePS C:\\&gt; $flags = $flags -band -bnot [GardenPartyItems]::CandlePS C:\\&gt; $flagsTable, BarbecuePS C:\\&gt; 要设置标志位，请使用 -bor： 1234567891011121314PS C:\\&gt; $flagsTable, Barbecue, CandlePS C:\\&gt; $flags = $flags -bor [GardenPartyItems]::KnifePS C:\\&gt; $flagsTable, Barbecue, Candle, KnifePS C:\\&gt; $flags = $flags -bor [GardenPartyItems]::KnifePS C:\\&gt; $flagsTable, Barbecue, Candle, KnifePS C:\\&gt; 在所有这些操作中，实际上是在操作一个十进制数： 12PS C:\\&gt; [Int]$flags19 相当棒，对吧？ 本文国际来源：Managing Bit Flags (Part 4)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理比特标志位（第三部分）","slug":"managing-bit-flags-part-3","date":"2017-03-06T08:00:00.000Z","updated":"2017-03-17T15:26:27.682Z","comments":true,"path":"2017/03/06/managing-bit-flags-part-3/","link":"","permalink":"http://blog.vichamp.com/2017/03/06/managing-bit-flags-part-3/","excerpt":"对十进制数设置比特标志位不是很难，但是不够直观。以下是一个快速的新方法，演示如何设置或取消一个数字中特定的比特： 1234567891011121314151617$decimal = 6254[Convert]::ToString($decimal, 2)# set bit 4$bit = 4$decimal = $decimal -bor [Math]::Pow(2, $bit)[Convert]::ToString($decimal, 2)# set bit 0$bit = 0$decimal = $decimal -bor [Math]::Pow(2, $bit)[Convert]::ToString($decimal, 2)# clear bit 1$bit = 1$decimal = $decimal -band -bnot [Math]::Pow(2, $bit)[Convert]::ToString($decimal, 2) 结果演示了代码做了什么。ToString() 从右到左显示比特，所以第 0 比特是在最右边。在第二行和第三行，设置了两个独立的比特位，而并不影响其它位。在最后一行中，清除了一个比特位。 12341100001101110110000111111011000011111111100001111101","text":"对十进制数设置比特标志位不是很难，但是不够直观。以下是一个快速的新方法，演示如何设置或取消一个数字中特定的比特： 1234567891011121314151617$decimal = 6254[Convert]::ToString($decimal, 2)# set bit 4$bit = 4$decimal = $decimal -bor [Math]::Pow(2, $bit)[Convert]::ToString($decimal, 2)# set bit 0$bit = 0$decimal = $decimal -bor [Math]::Pow(2, $bit)[Convert]::ToString($decimal, 2)# clear bit 1$bit = 1$decimal = $decimal -band -bnot [Math]::Pow(2, $bit)[Convert]::ToString($decimal, 2) 结果演示了代码做了什么。ToString() 从右到左显示比特，所以第 0 比特是在最右边。在第二行和第三行，设置了两个独立的比特位，而并不影响其它位。在最后一行中，清除了一个比特位。 12341100001101110110000111111011000011111111100001111101 本文国际来源：Managing Bit Flags (Part 3)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理比特标志位（第二部分）","slug":"managing-bit-flags-part-2","date":"2017-03-05T08:00:00.000Z","updated":"2017-03-17T15:26:27.676Z","comments":true,"path":"2017/03/05/managing-bit-flags-part-2/","link":"","permalink":"http://blog.vichamp.com/2017/03/05/managing-bit-flags-part-2/","excerpt":"在前一个技能中我们演示了如何使用 PowerShell 5 新的枚举特性来解析bite标志位，甚至可以独立地检测每个标志位。 如果您无法使用 PowerShell 5，在早期的 PowerShell 版本中，仍然可以使用这个技术只需要通过 C# 代码来定义枚举即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243# this is the decimal we want to decipher$rawflags = 56823# define an enum with the friendly names for the flags# don't forget [Flags]# IMPORTANT: you cannot change your type inside a PowerShell session!# if you made changes to the enum, close PowerShell and open a new# PowerShell!$enum = 'using System;[Flags]public enum BitFlags&#123; None = 0, Option1 = 1, Option2 = 2, Option3 = 4, Option4 = 8, Option5 = 16, Option6 = 32, Option7 = 64, Option8 = 128, Option9 = 256, Option10= 512, Option11= 1024, Option12= 2048, Option13= 4096, Option14= 8192, Option15= 16384, Option16= 32768, Option17= 65536&#125;'Add-Type -TypeDefinition $enum# convert the decimal to the new enum[BitFlags]$flags = $rawflags$flags# test individual flags$flags.HasFlag([BitFlags]::Option1)$flags.HasFlag([BitFlags]::Option2) 如您所见，从十进制数转换到新的枚举类型使用正常而且非常简单： 1234PS C:\\&gt; [BitFlags]6625Option1, Option6, Option7, Option8, Option9, Option12, Option13PS C:\\&gt;","text":"在前一个技能中我们演示了如何使用 PowerShell 5 新的枚举特性来解析bite标志位，甚至可以独立地检测每个标志位。 如果您无法使用 PowerShell 5，在早期的 PowerShell 版本中，仍然可以使用这个技术只需要通过 C# 代码来定义枚举即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243# this is the decimal we want to decipher$rawflags = 56823# define an enum with the friendly names for the flags# don't forget [Flags]# IMPORTANT: you cannot change your type inside a PowerShell session!# if you made changes to the enum, close PowerShell and open a new# PowerShell!$enum = 'using System;[Flags]public enum BitFlags&#123; None = 0, Option1 = 1, Option2 = 2, Option3 = 4, Option4 = 8, Option5 = 16, Option6 = 32, Option7 = 64, Option8 = 128, Option9 = 256, Option10= 512, Option11= 1024, Option12= 2048, Option13= 4096, Option14= 8192, Option15= 16384, Option16= 32768, Option17= 65536&#125;'Add-Type -TypeDefinition $enum# convert the decimal to the new enum[BitFlags]$flags = $rawflags$flags# test individual flags$flags.HasFlag([BitFlags]::Option1)$flags.HasFlag([BitFlags]::Option2) 如您所见，从十进制数转换到新的枚举类型使用正常而且非常简单： 1234PS C:\\&gt; [BitFlags]6625Option1, Option6, Option7, Option8, Option9, Option12, Option13PS C:\\&gt; 本文国际来源：Managing Bit Flags (Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理比特标志位（第一部分）","slug":"managing-bit-flags-part-1","date":"2017-03-02T08:00:00.000Z","updated":"2017-03-17T15:26:27.667Z","comments":true,"path":"2017/03/02/managing-bit-flags-part-1/","link":"","permalink":"http://blog.vichamp.com/2017/03/02/managing-bit-flags-part-1/","excerpt":"有时候您会需要处理比特标志位值。一个数字中的每个比特代表一个特定的设置，并且您的代码可能需要决定一个标志位是否置位，而不能影响别的比特。 这常常需要一系列位操作。然而在 PowerShell 5 中，有一个简单得多的办法——标志位枚举。 假设有一个值 56823，并且希望知道哪个比特是置位的。您需要将该数字转换成可视化的比特： 12PS C:\\&gt; [Convert]::ToString(56823, 2)1101110111110111 如果您了解每个比特的意义，那么一个更强大的方法是定义一个枚举： 123456789101112131415161718192021222324#requires -Version 5[flags()]enum CustomBitFlags&#123; None = 0 Option1 = 1 Option2 = 2 Option3 = 4 Option4 = 8 Option5 = 16 Option6 = 32 Option7 = 64 Option8 = 128 Option9 = 256 Option10= 512 Option11= 1024 Option12= 2048 Option13= 4096 Option14= 8192 Option15= 16384 Option16= 32768 Option17= 65536&#125; 对每个比特提供一个友好的名字，并且记得添加属性 [Flags]（这将允许设置多个值）。 现在要解析这个十进制值非常简单——只需要将它转换成新定义的枚举类型： 12$rawflags = 56823[CustomBitFlags]$flags = $rawflags 这时得到的结果： 12PS C:\\&gt; $flagsOption1, Option2, Option3, Option5, Option6, Option7, Option8, Option9, Option11, Option12, Option13, Option15, Option16 如果您只希望检测某个标志位是否置位，请使用 HasFlag() 方法： 1234567PS C:\\&gt; $flags.HasFlag([CustomBitFlags]::Option1)TruePS C:\\&gt; $flags.HasFlag([CustomBitFlags]::Option4)False","text":"有时候您会需要处理比特标志位值。一个数字中的每个比特代表一个特定的设置，并且您的代码可能需要决定一个标志位是否置位，而不能影响别的比特。 这常常需要一系列位操作。然而在 PowerShell 5 中，有一个简单得多的办法——标志位枚举。 假设有一个值 56823，并且希望知道哪个比特是置位的。您需要将该数字转换成可视化的比特： 12PS C:\\&gt; [Convert]::ToString(56823, 2)1101110111110111 如果您了解每个比特的意义，那么一个更强大的方法是定义一个枚举： 123456789101112131415161718192021222324#requires -Version 5[flags()]enum CustomBitFlags&#123; None = 0 Option1 = 1 Option2 = 2 Option3 = 4 Option4 = 8 Option5 = 16 Option6 = 32 Option7 = 64 Option8 = 128 Option9 = 256 Option10= 512 Option11= 1024 Option12= 2048 Option13= 4096 Option14= 8192 Option15= 16384 Option16= 32768 Option17= 65536&#125; 对每个比特提供一个友好的名字，并且记得添加属性 [Flags]（这将允许设置多个值）。 现在要解析这个十进制值非常简单——只需要将它转换成新定义的枚举类型： 12$rawflags = 56823[CustomBitFlags]$flags = $rawflags 这时得到的结果： 12PS C:\\&gt; $flagsOption1, Option2, Option3, Option5, Option6, Option7, Option8, Option9, Option11, Option12, Option13, Option15, Option16 如果您只希望检测某个标志位是否置位，请使用 HasFlag() 方法： 1234567PS C:\\&gt; $flags.HasFlag([CustomBitFlags]::Option1)TruePS C:\\&gt; $flags.HasFlag([CustomBitFlags]::Option4)False 本文国际来源：Managing Bit Flags (Part 1)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用泛型","slug":"working-with-generics","date":"2017-03-01T08:00:00.000Z","updated":"2017-03-17T15:26:27.659Z","comments":true,"path":"2017/03/01/working-with-generics/","link":"","permalink":"http://blog.vichamp.com/2017/03/01/working-with-generics/","excerpt":"泛型可以作为实际类型的占位符，您可能会好奇为什么它会有意思。 有许多不同的数据类型没有 NULL 值。例如 Integer 和 Boolean 型，没有办法指出一个值是非法的还是未设置。您可以通过将一个 0（或者 -1）指定为某个 integer 变量的 “undefined” 值。但如果所有的数字都是合法的值呢？对于 Boolean，情况也是一样：虽然您可以定义 $false 值为 “undefined” 值，但许多情况下的确需要三种值：$true、$flase 和 undefined。 泛型是解决的办法，您可以使用 Nullable 类型根据任何合法的类型来创建自己的可空值类型。 12345[Nullable[int]]$number = $null[Nullable[bool]]$flag = $null$number$flag 用常规数据类型来做数据转换： 1234567PS C:\\&gt; [int]$null0PS C:\\&gt; [bool]$nullFalsePS C:\\&gt;","text":"泛型可以作为实际类型的占位符，您可能会好奇为什么它会有意思。 有许多不同的数据类型没有 NULL 值。例如 Integer 和 Boolean 型，没有办法指出一个值是非法的还是未设置。您可以通过将一个 0（或者 -1）指定为某个 integer 变量的 “undefined” 值。但如果所有的数字都是合法的值呢？对于 Boolean，情况也是一样：虽然您可以定义 $false 值为 “undefined” 值，但许多情况下的确需要三种值：$true、$flase 和 undefined。 泛型是解决的办法，您可以使用 Nullable 类型根据任何合法的类型来创建自己的可空值类型。 12345[Nullable[int]]$number = $null[Nullable[bool]]$flag = $null$number$flag 用常规数据类型来做数据转换： 1234567PS C:\\&gt; [int]$null0PS C:\\&gt; [bool]$nullFalsePS C:\\&gt; 本文国际来源：Working With Generics","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Power Shell 5 的类继承（第二部分）","slug":"inheriting-classes-in-powershell-5-part-2","date":"2017-02-28T08:00:00.000Z","updated":"2017-03-17T15:26:27.656Z","comments":true,"path":"2017/02/28/inheriting-classes-in-powershell-5-part-2/","link":"","permalink":"http://blog.vichamp.com/2017/02/28/inheriting-classes-in-powershell-5-part-2/","excerpt":"以下是在 PowerShell 5 中使用新的类特性的另一个用例。在前一个例子中，我们演示了如何从 System.Diagnostics.Process 派生一个新类，从而获得代表进程的功能更强大的对象。 以下是一个从 WebClient 派生的类，WebClient 主要是用来连接网站。当您使用标准的 WebClient 对象是，它拒绝连接到证书错误的 HTTPS 网站。这是一件好事，但是有时候您仍需要连接这类网站。 123456789101112131415161718#requires -Version 5class MyWebClient : System.Net.WebClient&#123; MyWebClient() : base() &#123; # with SSL certificate errors, connect anyway [System.Net.ServicePointManager]::ServerCertificateValidationCallback = &#123; $true &#125; $proxy = [System.Net.WebRequest]::GetSystemWebProxy() $proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials $this.Proxy = $proxy $this.UseDefaultCredentials = $true $this.Proxy.Credentials = $this.Credentials &#125;&#125;$client = [mywebclient]::new()$client.DownloadString('http://www.psconf.eu') 这样，”“MyWebClient”“ 类继承于 WebClient() 并改变了 ServerCertificateValidationCallBack 的行为。它只是返回 $true，所以所有的连接都是成功的，而且证书检验变得无关紧要。","text":"以下是在 PowerShell 5 中使用新的类特性的另一个用例。在前一个例子中，我们演示了如何从 System.Diagnostics.Process 派生一个新类，从而获得代表进程的功能更强大的对象。 以下是一个从 WebClient 派生的类，WebClient 主要是用来连接网站。当您使用标准的 WebClient 对象是，它拒绝连接到证书错误的 HTTPS 网站。这是一件好事，但是有时候您仍需要连接这类网站。 123456789101112131415161718#requires -Version 5class MyWebClient : System.Net.WebClient&#123; MyWebClient() : base() &#123; # with SSL certificate errors, connect anyway [System.Net.ServicePointManager]::ServerCertificateValidationCallback = &#123; $true &#125; $proxy = [System.Net.WebRequest]::GetSystemWebProxy() $proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials $this.Proxy = $proxy $this.UseDefaultCredentials = $true $this.Proxy.Credentials = $this.Credentials &#125;&#125;$client = [mywebclient]::new()$client.DownloadString('http://www.psconf.eu') 这样，”“MyWebClient”“ 类继承于 WebClient() 并改变了 ServerCertificateValidationCallBack 的行为。它只是返回 $true，所以所有的连接都是成功的，而且证书检验变得无关紧要。 本文国际来源：Inheriting Classes in PowerShell 5 (part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Power Shell 5 的类继承（第一部分）","slug":"inheriting-classes-in-powershell-5-part-1","date":"2017-02-27T08:00:00.000Z","updated":"2017-03-17T15:26:27.653Z","comments":true,"path":"2017/02/27/inheriting-classes-in-powershell-5-part-1/","link":"","permalink":"http://blog.vichamp.com/2017/02/27/inheriting-classes-in-powershell-5-part-1/","excerpt":"PowerShell 5 内置了类的支持。您可以使用这个新特性来增强已有的 .NET 类的功能。以下是一个例子：创建一个包含新功能的增强的进程类。 进程通常是由 System.Diagnostics.Process 对象代表。它们只有有限的功能，并且假设没有能直接使用的以友好方式关闭一个应用程序的方法。您可以杀除进程（会丢失未保存的数据），或关闭它（用户可以取消关闭）。 以下是一个新的 继承于 System.Diagnostics.Process 的名为 AppInstance 的类。所以它拥有 Process 类中所有已有的功能，您可以增加额外的属性和方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#requires -Version 5class AppInstance : System.Diagnostics.Process&#123; # Constructor, being called when you instantiate a new object of # this class AppInstance([string]$Name) : base() &#123; # launch the process, get a regular process object, and then # enhance it with additional functionality $this.StartInfo.FileName = $Name $this.Start() $this.WaitForInputIdle() &#125; # for example, rename an existing method [void]Stop() &#123; $this.Kill() &#125; # or invent new functionality # Close() closes the window gracefully. Unlike Kill(), # the user gets the chance to save unsaved work for # a specified number of seconds before the process # is killed [void]Close([Int]$Timeout = 0) &#123; # send close message $this.CloseMainWindow() # wait for success if ($Timeout -gt 0) &#123; $null = $this.WaitForExit($Timeout * 1000) &#125; # if process still runs (user aborted request), kill forcefully if ($this.HasExited -eq $false) &#123; $this.Stop() &#125; &#125; # example of how to change a property like process priority [void]SetPriority([System.Diagnostics.ProcessPriorityClass] $Priority) &#123; $this.PriorityClass = $Priority &#125; [System.Diagnostics.ProcessPriorityClass]GetPriority() &#123; if ($this.HasExited -eq $false) &#123; return $this.PriorityClass &#125; else &#123; Throw \"Process PID $($this.Id) does not run anymore.\" &#125; &#125; # add static methods, for example a way to list all processes # variant A: no arguments static [System.Diagnostics.Process[]] GetAllProcesses() &#123; return [AppInstance]::GetAllProcesses($false) &#125; # variant B: submit $false to see only processes that have a window static [System.Diagnostics.Process[]] GetAllProcesses([bool]$All) &#123; if ($All) &#123; return Get-Process &#125; else &#123; return Get-Process | Where-Object &#123; $_.MainWindowHandle -ne 0 &#125; &#125; &#125;&#125;# you can always run static methods[AppInstance]::GetAllProcesses($true) | Out-GridView -Title 'All Processes'[AppInstance]::GetAllProcesses($false) | Out-GridView -Title 'Processes with Window'# this is how you instantiate a new process and get back# a new enhanced process object# classic way:# $notepad = New-Object -TypeName AppInstance('notepad')# new (and faster) way in PowerShell 5 to instantiate new objects:$notepad = [AppInstance]::new('notepad')# set a different process priority$notepad.SetPriority('BelowNormal')# add some text to the editor to see the close messageStart-Sleep -Seconds 5# close the application and offer to save changes for a maximum# of 10 seconds$notepad.Close(10) 如您在这个例子中所见，当您从这个类创建一个新实例时，它启动了一个新的进程，而且这些进程照常暴露出相同的属性和方法。而且，有一些新的例如 SetPriority() 和 Close() 的新方法。","text":"PowerShell 5 内置了类的支持。您可以使用这个新特性来增强已有的 .NET 类的功能。以下是一个例子：创建一个包含新功能的增强的进程类。 进程通常是由 System.Diagnostics.Process 对象代表。它们只有有限的功能，并且假设没有能直接使用的以友好方式关闭一个应用程序的方法。您可以杀除进程（会丢失未保存的数据），或关闭它（用户可以取消关闭）。 以下是一个新的 继承于 System.Diagnostics.Process 的名为 AppInstance 的类。所以它拥有 Process 类中所有已有的功能，您可以增加额外的属性和方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#requires -Version 5class AppInstance : System.Diagnostics.Process&#123; # Constructor, being called when you instantiate a new object of # this class AppInstance([string]$Name) : base() &#123; # launch the process, get a regular process object, and then # enhance it with additional functionality $this.StartInfo.FileName = $Name $this.Start() $this.WaitForInputIdle() &#125; # for example, rename an existing method [void]Stop() &#123; $this.Kill() &#125; # or invent new functionality # Close() closes the window gracefully. Unlike Kill(), # the user gets the chance to save unsaved work for # a specified number of seconds before the process # is killed [void]Close([Int]$Timeout = 0) &#123; # send close message $this.CloseMainWindow() # wait for success if ($Timeout -gt 0) &#123; $null = $this.WaitForExit($Timeout * 1000) &#125; # if process still runs (user aborted request), kill forcefully if ($this.HasExited -eq $false) &#123; $this.Stop() &#125; &#125; # example of how to change a property like process priority [void]SetPriority([System.Diagnostics.ProcessPriorityClass] $Priority) &#123; $this.PriorityClass = $Priority &#125; [System.Diagnostics.ProcessPriorityClass]GetPriority() &#123; if ($this.HasExited -eq $false) &#123; return $this.PriorityClass &#125; else &#123; Throw \"Process PID $($this.Id) does not run anymore.\" &#125; &#125; # add static methods, for example a way to list all processes # variant A: no arguments static [System.Diagnostics.Process[]] GetAllProcesses() &#123; return [AppInstance]::GetAllProcesses($false) &#125; # variant B: submit $false to see only processes that have a window static [System.Diagnostics.Process[]] GetAllProcesses([bool]$All) &#123; if ($All) &#123; return Get-Process &#125; else &#123; return Get-Process | Where-Object &#123; $_.MainWindowHandle -ne 0 &#125; &#125; &#125;&#125;# you can always run static methods[AppInstance]::GetAllProcesses($true) | Out-GridView -Title 'All Processes'[AppInstance]::GetAllProcesses($false) | Out-GridView -Title 'Processes with Window'# this is how you instantiate a new process and get back# a new enhanced process object# classic way:# $notepad = New-Object -TypeName AppInstance('notepad')# new (and faster) way in PowerShell 5 to instantiate new objects:$notepad = [AppInstance]::new('notepad')# set a different process priority$notepad.SetPriority('BelowNormal')# add some text to the editor to see the close messageStart-Sleep -Seconds 5# close the application and offer to save changes for a maximum# of 10 seconds$notepad.Close(10) 如您在这个例子中所见，当您从这个类创建一个新实例时，它启动了一个新的进程，而且这些进程照常暴露出相同的属性和方法。而且，有一些新的例如 SetPriority() 和 Close() 的新方法。 本文国际来源：Inheriting Classes in PowerShell 5 (part 1)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 显示或隐藏窗口","slug":"show-or-hide-windows","date":"2017-02-26T08:00:00.000Z","updated":"2017-03-17T15:26:27.651Z","comments":true,"path":"2017/02/26/show-or-hide-windows/","link":"","permalink":"http://blog.vichamp.com/2017/02/26/show-or-hide-windows/","excerpt":"PowerShell 可以调用 Windows 内部的 API，在这个例子中，我们想向您展示如何改变一个应用程序窗口的显示状态。比如可以最大化、最小化、隐藏或显示窗口。 这个例子使用 PowerShell 5 最新的枚举特性对 showstate 数值赋予有意义的名字。在 PowerShell 的更早版本中，只需要移除枚举部分，并在代码中直接使用合适的 showstate 数字即可。 这里的学习要点是如何使用 Add-Type 来包装一个 C# 形式的 API 方法并在 PowerShell 代码中返回一个暴露这个方法的 type： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#requires -Version 5# this enum works in PowerShell 5 only# in earlier versions, simply remove the enum,# and use the numbers for the desired window state# directlyEnum ShowStates&#123; Hide = 0 Normal = 1 Minimized = 2 Maximized = 3 ShowNoActivateRecentPosition = 4 Show = 5 MinimizeActivateNext = 6 MinimizeNoActivate = 7 ShowNoActivate = 8 Restore = 9 ShowDefault = 10 ForceMinimize = 11&#125;# the C#-style signature of an API function (see also www.pinvoke.net)$code = '[DllImport(\"user32.dll\")] public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);'# add signature as new type to PowerShell (for this session)$type = Add-Type -MemberDefinition $code -Name myAPI -PassThru# access a process# (in this example, we are accessing the current PowerShell host# with its process ID being present in $pid, but you can use# any process ID instead)$process = Get-Process -Id $PID# get the process window handle$hwnd = $process.MainWindowHandle# apply a new window size to the handle, i.e. hide the window completely$type::ShowWindowAsync($hwnd, [ShowStates]::Hide)Start-Sleep -Seconds 2# restore the window handle again$type::ShowWindowAsync($hwnd, [ShowStates]::Show) 请注意这个例子将 PowerShell 窗口临时隐藏 2 秒钟。您可以对任何运行中的应用程序窗口做相同的事情。只需要用 Get-Process 来查找目标进程，并使用它的 “MainWindowHandle“ 属性来发送 showstate 改变请求。 一些应用程序有多个窗口。在这种情况下，您只能针对主窗口操作，否则需要先靠其它 API 来获取子窗口的句柄集合。","text":"PowerShell 可以调用 Windows 内部的 API，在这个例子中，我们想向您展示如何改变一个应用程序窗口的显示状态。比如可以最大化、最小化、隐藏或显示窗口。 这个例子使用 PowerShell 5 最新的枚举特性对 showstate 数值赋予有意义的名字。在 PowerShell 的更早版本中，只需要移除枚举部分，并在代码中直接使用合适的 showstate 数字即可。 这里的学习要点是如何使用 Add-Type 来包装一个 C# 形式的 API 方法并在 PowerShell 代码中返回一个暴露这个方法的 type： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#requires -Version 5# this enum works in PowerShell 5 only# in earlier versions, simply remove the enum,# and use the numbers for the desired window state# directlyEnum ShowStates&#123; Hide = 0 Normal = 1 Minimized = 2 Maximized = 3 ShowNoActivateRecentPosition = 4 Show = 5 MinimizeActivateNext = 6 MinimizeNoActivate = 7 ShowNoActivate = 8 Restore = 9 ShowDefault = 10 ForceMinimize = 11&#125;# the C#-style signature of an API function (see also www.pinvoke.net)$code = '[DllImport(\"user32.dll\")] public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);'# add signature as new type to PowerShell (for this session)$type = Add-Type -MemberDefinition $code -Name myAPI -PassThru# access a process# (in this example, we are accessing the current PowerShell host# with its process ID being present in $pid, but you can use# any process ID instead)$process = Get-Process -Id $PID# get the process window handle$hwnd = $process.MainWindowHandle# apply a new window size to the handle, i.e. hide the window completely$type::ShowWindowAsync($hwnd, [ShowStates]::Hide)Start-Sleep -Seconds 2# restore the window handle again$type::ShowWindowAsync($hwnd, [ShowStates]::Show) 请注意这个例子将 PowerShell 窗口临时隐藏 2 秒钟。您可以对任何运行中的应用程序窗口做相同的事情。只需要用 Get-Process 来查找目标进程，并使用它的 “MainWindowHandle“ 属性来发送 showstate 改变请求。 一些应用程序有多个窗口。在这种情况下，您只能针对主窗口操作，否则需要先靠其它 API 来获取子窗口的句柄集合。 本文国际来源：Show or Hide Windows","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 Pester Tests 做测试","slug":"using-pester-tests-to-test-anything","date":"2017-02-23T08:00:00.000Z","updated":"2017-03-17T15:26:27.648Z","comments":true,"path":"2017/02/23/using-pester-tests-to-test-anything/","link":"","permalink":"http://blog.vichamp.com/2017/02/23/using-pester-tests-to-test-anything/","excerpt":"Pester 是一个随 Windows 10 和 Windows Server 2016 发布的开源模块，可以通过 PowerShell Gallery 免费下载（需要事先安装最新版本的 PowerShellGet）： 1PS C:\\&gt; Install-Module -Name Pester -Force -SkipPublisherCheck Pester 是一个主要用来测试 PowerShell 代码的测试框架。您不仅可以用它来测试代码，而且可以用它来测试任何东西。以下是一个测试 PowerShell 版本号和一些设置的小例子： 1234567891011121314151617181920Describe 'PowerShell Basic Check' &#123; Context 'PS Versioning' &#123; It 'is current version' &#123; $host.Version.Major -ge 5 -and $host.Version.Minor -ge 1 | Should Be $true &#125; &#125; Context 'PS Settings' &#123; It 'can execute scripts' &#123; (Get-ExecutionPolicy) | Should Not Be 'Restricted' &#125; It 'does not use AllSigned' &#123; (Get-ExecutionPolicy) | Should Not Be 'AllSigned' &#125; It 'does not have GPO restrictions' &#123; (Get-ExecutionPolicy -Scope MachinePolicy) | Should Be 'Undefined' (Get-ExecutionPolicy -Scope UserPolicy) | Should Be 'Undefined' &#125; &#125;&#125; 当您运行它时（当然，前提是已经安装了 Pester 模块），这是得到的输出结果： 1234567891011Describing PowerShell Basic Check Context PS Versioning [+] is current version 76ms Context PS Settings [+] can execute scripts 47ms [+] does not use AllSigned 18ms [+] does not have GPO restrictions 21msPS&gt; 当然，这只是一个例子。您可以把它做详细并且将测试扩展到更多的其它设置或依赖条件。","text":"Pester 是一个随 Windows 10 和 Windows Server 2016 发布的开源模块，可以通过 PowerShell Gallery 免费下载（需要事先安装最新版本的 PowerShellGet）： 1PS C:\\&gt; Install-Module -Name Pester -Force -SkipPublisherCheck Pester 是一个主要用来测试 PowerShell 代码的测试框架。您不仅可以用它来测试代码，而且可以用它来测试任何东西。以下是一个测试 PowerShell 版本号和一些设置的小例子： 1234567891011121314151617181920Describe 'PowerShell Basic Check' &#123; Context 'PS Versioning' &#123; It 'is current version' &#123; $host.Version.Major -ge 5 -and $host.Version.Minor -ge 1 | Should Be $true &#125; &#125; Context 'PS Settings' &#123; It 'can execute scripts' &#123; (Get-ExecutionPolicy) | Should Not Be 'Restricted' &#125; It 'does not use AllSigned' &#123; (Get-ExecutionPolicy) | Should Not Be 'AllSigned' &#125; It 'does not have GPO restrictions' &#123; (Get-ExecutionPolicy -Scope MachinePolicy) | Should Be 'Undefined' (Get-ExecutionPolicy -Scope UserPolicy) | Should Be 'Undefined' &#125; &#125;&#125; 当您运行它时（当然，前提是已经安装了 Pester 模块），这是得到的输出结果： 1234567891011Describing PowerShell Basic Check Context PS Versioning [+] is current version 76ms Context PS Settings [+] can execute scripts 47ms [+] does not use AllSigned 18ms [+] does not have GPO restrictions 21msPS&gt; 当然，这只是一个例子。您可以把它做详细并且将测试扩展到更多的其它设置或依赖条件。 本文国际来源：Using Pester Tests to Test Anything","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Reading Environment Variables Freshly","slug":"reading-environment-variables-freshly","date":"2017-02-22T08:00:00.000Z","updated":"2017-03-17T15:26:27.637Z","comments":true,"path":"2017/02/22/reading-environment-variables-freshly/","link":"","permalink":"http://blog.vichamp.com/2017/02/22/reading-environment-variables-freshly/","excerpt":"When you read environment variables in PowerShell, you probably make use of the “env:” drive. This line retrieves the environment variable %USERNAME%, for example, telling you the name of the user executing the script: PS C:\\&gt; $env:USERNAME tobwe PS C:\\&gt; The “env:” drive always accesses the process set of environment variables. This makes sense in most cases as many of the environment variables (like “UserName”) are defined in this set. Basically, the process set of environment variables is a “snapshot” of all environment variables at the time of when an application starts, plus a number of additional pieces of information (like “UserName”). To read environment variables freshly and explicitly from the system or user set, use code like this: $name = &apos;temp&apos; $scope = [EnvironmentVariableTarget]::Machine $content = [Environment]::GetEnvironmentVariable($name, $scope) &quot;Content: $content&quot; You could use this technique, for example, to communicate between two processes. To play with this, open two PowerShell consoles. Now, in the first console, enter this: [Environment]::SetEnvironmentVariable(&quot;PS_Info&quot;, &quot;Hello&quot;, &quot;user&quot;) In the second PowerShell console, enter this line to receive the information: [Environment]::GetEnvironmentVariable(&quot;PS_Info&quot;, &quot;user&quot;) To clean up the environment variable, enter this line in either console: [Environment]::SetEnvironmentVariable(&quot;PS_Info&quot;, &quot;&quot;, &quot;user&quot;)","text":"When you read environment variables in PowerShell, you probably make use of the “env:” drive. This line retrieves the environment variable %USERNAME%, for example, telling you the name of the user executing the script: PS C:\\&gt; $env:USERNAME tobwe PS C:\\&gt; The “env:” drive always accesses the process set of environment variables. This makes sense in most cases as many of the environment variables (like “UserName”) are defined in this set. Basically, the process set of environment variables is a “snapshot” of all environment variables at the time of when an application starts, plus a number of additional pieces of information (like “UserName”). To read environment variables freshly and explicitly from the system or user set, use code like this: $name = &apos;temp&apos; $scope = [EnvironmentVariableTarget]::Machine $content = [Environment]::GetEnvironmentVariable($name, $scope) &quot;Content: $content&quot; You could use this technique, for example, to communicate between two processes. To play with this, open two PowerShell consoles. Now, in the first console, enter this: [Environment]::SetEnvironmentVariable(&quot;PS_Info&quot;, &quot;Hello&quot;, &quot;user&quot;) In the second PowerShell console, enter this line to receive the information: [Environment]::GetEnvironmentVariable(&quot;PS_Info&quot;, &quot;user&quot;) To clean up the environment variable, enter this line in either console: [Environment]::SetEnvironmentVariable(&quot;PS_Info&quot;, &quot;&quot;, &quot;user&quot;) 本文国际来源：Reading Environment Variables Freshly","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 设置环境变量","slug":"setting-environment-variables","date":"2017-02-21T08:00:00.000Z","updated":"2017-03-17T15:26:27.635Z","comments":true,"path":"2017/02/21/setting-environment-variables/","link":"","permalink":"http://blog.vichamp.com/2017/02/21/setting-environment-variables/","excerpt":"当通过 PowerShell 的 “env:“ 驱动器来设置环境变量，您只需要操作其中的数据即可。它会应用到当前的 PowerShell 实例，和所有由它启动的应用程序。不过改变并不会保存。 要设置环境变量并使之持久化，请用这段代码代替： 12345$name = 'Test'$value = 'hello'$scope = [EnvironmentVariableTarget]::User[Environment]::SetEnvironmentVariable($name, $value, $scope) 这个例子设置了一个名为 “test”，值为 “hello” 的用户级别新环境变量。请注意这个改变只会影响设置这个变量之后启动的应用程序。 要彻底删除一个环境变量，请将 $value 设置成一个空字符串。","text":"当通过 PowerShell 的 “env:“ 驱动器来设置环境变量，您只需要操作其中的数据即可。它会应用到当前的 PowerShell 实例，和所有由它启动的应用程序。不过改变并不会保存。 要设置环境变量并使之持久化，请用这段代码代替： 12345$name = 'Test'$value = 'hello'$scope = [EnvironmentVariableTarget]::User[Environment]::SetEnvironmentVariable($name, $value, $scope) 这个例子设置了一个名为 “test”，值为 “hello” 的用户级别新环境变量。请注意这个改变只会影响设置这个变量之后启动的应用程序。 要彻底删除一个环境变量，请将 $value 设置成一个空字符串。 本文国际来源：Setting Environment Variables","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检测宿主","slug":"checking-host","date":"2017-02-20T08:00:00.000Z","updated":"2017-03-17T15:26:27.628Z","comments":true,"path":"2017/02/20/checking-host/","link":"","permalink":"http://blog.vichamp.com/2017/02/20/checking-host/","excerpt":"在过去，Microsoft 发布了两个 PowerShell 宿主 (host)：一个时基本的 PowerShell 控制台，以及更复杂的 PowerShell ISE。一些用户使用类似以下的代码来分辨脚本时运行在控制台中还是运行在 PowerShell ISE 中： 123$inISE = $psISE -ne $null\"Running in ISE: $inISE\" 然而，现在有越来越多的宿主。Visual Studio 可以作为 PowerShell 的宿主，Visual Studio Code 也可以。而且还有许多商业编辑器。所以您需要确定一个脚本是否在一个特定的环境中运行，请使用宿主标识符来代替： 1234$name = $host.Name$inISE = $name -eq 'Windows PowerShell ISE Host'\"Running in ISE: $inISE\" Each host emits its own host name, so this approach can be adjusted to any host. When you run a script inside Visual Studio Code, for example, the host name is “Visual Studio Code Host”.每个宿主会提供它的宿主名称，所以这种方法可以适用于任何宿主。例如当您在 Visual Studio Code 中运行一个脚本，宿主名会变为 “Visual Studio Code Host”。","text":"在过去，Microsoft 发布了两个 PowerShell 宿主 (host)：一个时基本的 PowerShell 控制台，以及更复杂的 PowerShell ISE。一些用户使用类似以下的代码来分辨脚本时运行在控制台中还是运行在 PowerShell ISE 中： 123$inISE = $psISE -ne $null\"Running in ISE: $inISE\" 然而，现在有越来越多的宿主。Visual Studio 可以作为 PowerShell 的宿主，Visual Studio Code 也可以。而且还有许多商业编辑器。所以您需要确定一个脚本是否在一个特定的环境中运行，请使用宿主标识符来代替： 1234$name = $host.Name$inISE = $name -eq 'Windows PowerShell ISE Host'\"Running in ISE: $inISE\" Each host emits its own host name, so this approach can be adjusted to any host. When you run a script inside Visual Studio Code, for example, the host name is “Visual Studio Code Host”.每个宿主会提供它的宿主名称，所以这种方法可以适用于任何宿主。例如当您在 Visual Studio Code 中运行一个脚本，宿主名会变为 “Visual Studio Code Host”。 本文国际来源：Checking Host","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 接触 PowerShell 6.0","slug":"playing-with-powershell-6-0","date":"2017-02-19T08:00:00.000Z","updated":"2017-03-17T15:26:27.619Z","comments":true,"path":"2017/02/19/playing-with-powershell-6-0/","link":"","permalink":"http://blog.vichamp.com/2017/02/19/playing-with-powershell-6-0/","excerpt":"PowerShell 现在是开源的，而且 PowerShell 下一个主要的 release 是在开放的环境中开发。如果您希望看一眼预览版，只需要打开源项目的发布发布页面，并且下载合适的 release： https://github.com/PowerShell/PowerShell/releases 而且现在 PowerShell 6.0 是跨平台的。您可以同时找到适合 Linux 或 OS X 和 Windows 操作系统的版本。 当您下载某个了 Windows 平台的 ZIP 格式的 release，请先对文件解锁（右键单击文件，选择“属性”，然后解锁）。下一步，解压压缩包。在压缩包里，找到 powershell.exe，可以双击它启动一个新的 PowerShell 6.0 控制台。它是一个完全独立发行的 PowerShell，可以和现有的 PowerShell 版本同时运行。 12345678910111213141516171819PowerShellCopyright (C) 2016 Microsoft Corporation. All rights reserved.PS C:\\Users\\tobwe\\Downloads\\PowerShell_6.0.0-alpha.15-win10-win2k16-x64&gt; $PSVersionTableName Value---- -----PSVersion 6.0.0-alphaCLRVersionWSManStackVersion 3.0SerializationVersion 1.1.0.1PSCompatibleVersions &#123;1.0, 2.0, 3.0, 4.0...&#125;PSRemotingProtocolVersion 2.3GitCommitId v6.0.0-alpha.15BuildVersion 3.0.0.0PSEdition CorePS C:\\Users\\tobwe\\Downloads\\PowerShell_6.0.0-alpha.15-win10-win2k16-x64&gt; 如果您是一个开发者，请查看 GitHub 工程：您可以查看所有源代码，甚至可以加入这个版本的开发者社区。","text":"PowerShell 现在是开源的，而且 PowerShell 下一个主要的 release 是在开放的环境中开发。如果您希望看一眼预览版，只需要打开源项目的发布发布页面，并且下载合适的 release： https://github.com/PowerShell/PowerShell/releases 而且现在 PowerShell 6.0 是跨平台的。您可以同时找到适合 Linux 或 OS X 和 Windows 操作系统的版本。 当您下载某个了 Windows 平台的 ZIP 格式的 release，请先对文件解锁（右键单击文件，选择“属性”，然后解锁）。下一步，解压压缩包。在压缩包里，找到 powershell.exe，可以双击它启动一个新的 PowerShell 6.0 控制台。它是一个完全独立发行的 PowerShell，可以和现有的 PowerShell 版本同时运行。 12345678910111213141516171819PowerShellCopyright (C) 2016 Microsoft Corporation. All rights reserved.PS C:\\Users\\tobwe\\Downloads\\PowerShell_6.0.0-alpha.15-win10-win2k16-x64&gt; $PSVersionTableName Value---- -----PSVersion 6.0.0-alphaCLRVersionWSManStackVersion 3.0SerializationVersion 1.1.0.1PSCompatibleVersions &#123;1.0, 2.0, 3.0, 4.0...&#125;PSRemotingProtocolVersion 2.3GitCommitId v6.0.0-alpha.15BuildVersion 3.0.0.0PSEdition CorePS C:\\Users\\tobwe\\Downloads\\PowerShell_6.0.0-alpha.15-win10-win2k16-x64&gt; 如果您是一个开发者，请查看 GitHub 工程：您可以查看所有源代码，甚至可以加入这个版本的开发者社区。 本文国际来源：Playing with PowerShell 6.0","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 -用 JSON 缓存凭据","slug":"caching-credentials-using-json","date":"2017-02-16T08:00:00.000Z","updated":"2017-03-17T15:26:27.616Z","comments":true,"path":"2017/02/16/caching-credentials-using-json/","link":"","permalink":"http://blog.vichamp.com/2017/02/16/caching-credentials-using-json/","excerpt":"当您需要将登录凭据缓存到一个文件，通常的做法是用管道将凭据传给 Export-Clixml 命令，这将会产生一个很长的 XML 文件。使用 Import-Clixml 命令，缓存的凭据可以随时导回脚本中。PowerShell 自动使用用户和机器身份来加密密码（它只能被同一个人在同一台机器上读取）。 可以用 JSON 格式来做同样的事情，并且不会产生更多凌乱的文件。只有对密码加密的部分需要人工完成。 这个例子提示输入登录凭据，然后将它们保存到桌面的 “mycred.json” 文件中，然后在记事本中打开它们，这样您可以查看它的内容并确认密码是加密的： 1234567891011121314151617181920212223$path = \"$home\\Desktop\\mycred.json\"$cred = Get-Credential$cred | Select Username,@&#123;n=\"Password\"; e=&#123;$_.password | ConvertFrom-SecureString&#125;&#125; | ConvertTo-Json | Set-Content -Path $path -Encoding UTF8notepad.exe $pathTo later reuse the file and import the credential, use this:$path = \"$home\\Desktop\\mycred.json\"$o = Get-Content -Path $path -Encoding UTF8 -Raw | ConvertFrom-Json$cred = New-Object -TypeName PSCredential $o.UserName, ($o.Password | ConvertTo-SecureString)# if you entered a valid user credentials, this line# will start Notepad using the credentials retrieved from# the JSON file to prove that the credentials are# working.Start-Process notepad -Credential $cred 回头要使用该文件并导入凭据，请使用这段代码： 1234567891011$path = \"$home\\Desktop\\mycred.json\"$o = Get-Content -Path $path -Encoding UTF8 -Raw | ConvertFrom-Json$cred = New-Object -TypeName PSCredential $o.UserName, ($o.Password | ConvertTo-SecureString)# if you entered a valid user credentials, this line# will start Notepad using the credentials retrieved from# the JSON file to prove that the credentials are# working.Start-Process notepad -Credential $cred 请注意这个例子将使用存储在 JSON 文件中的凭据来启动记事本的实例。如果您在第一个示例脚本中键入了非法的登录信息，以上操作显然会失败。 也请注意密码事是以加密的方式存储的。加密是以您的账户和机器作为密钥。所以保存的密码是经过安全加密的，但是这里展示的技术只适合同一个人（在同一台机器上）希望下次再使用保存的凭据。一个使用场景是保存再您自己机器上常用的脚本凭据。","text":"当您需要将登录凭据缓存到一个文件，通常的做法是用管道将凭据传给 Export-Clixml 命令，这将会产生一个很长的 XML 文件。使用 Import-Clixml 命令，缓存的凭据可以随时导回脚本中。PowerShell 自动使用用户和机器身份来加密密码（它只能被同一个人在同一台机器上读取）。 可以用 JSON 格式来做同样的事情，并且不会产生更多凌乱的文件。只有对密码加密的部分需要人工完成。 这个例子提示输入登录凭据，然后将它们保存到桌面的 “mycred.json” 文件中，然后在记事本中打开它们，这样您可以查看它的内容并确认密码是加密的： 1234567891011121314151617181920212223$path = \"$home\\Desktop\\mycred.json\"$cred = Get-Credential$cred | Select Username,@&#123;n=\"Password\"; e=&#123;$_.password | ConvertFrom-SecureString&#125;&#125; | ConvertTo-Json | Set-Content -Path $path -Encoding UTF8notepad.exe $pathTo later reuse the file and import the credential, use this:$path = \"$home\\Desktop\\mycred.json\"$o = Get-Content -Path $path -Encoding UTF8 -Raw | ConvertFrom-Json$cred = New-Object -TypeName PSCredential $o.UserName, ($o.Password | ConvertTo-SecureString)# if you entered a valid user credentials, this line# will start Notepad using the credentials retrieved from# the JSON file to prove that the credentials are# working.Start-Process notepad -Credential $cred 回头要使用该文件并导入凭据，请使用这段代码： 1234567891011$path = \"$home\\Desktop\\mycred.json\"$o = Get-Content -Path $path -Encoding UTF8 -Raw | ConvertFrom-Json$cred = New-Object -TypeName PSCredential $o.UserName, ($o.Password | ConvertTo-SecureString)# if you entered a valid user credentials, this line# will start Notepad using the credentials retrieved from# the JSON file to prove that the credentials are# working.Start-Process notepad -Credential $cred 请注意这个例子将使用存储在 JSON 文件中的凭据来启动记事本的实例。如果您在第一个示例脚本中键入了非法的登录信息，以上操作显然会失败。 也请注意密码事是以加密的方式存储的。加密是以您的账户和机器作为密钥。所以保存的密码是经过安全加密的，但是这里展示的技术只适合同一个人（在同一台机器上）希望下次再使用保存的凭据。一个使用场景是保存再您自己机器上常用的脚本凭据。 本文国际来源：Caching Credentials Using JSON","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 免费的 PowerShell 起步指南","slug":"free-guides-to-start-with-powershell","date":"2017-02-15T08:00:00.000Z","updated":"2017-03-17T15:26:27.610Z","comments":true,"path":"2017/02/15/free-guides-to-start-with-powershell/","link":"","permalink":"http://blog.vichamp.com/2017/02/15/free-guides-to-start-with-powershell/","excerpt":"如果有还不会 PowerShell 的同事，并且您希望帮助他们起步，一下是三个免费的学习资源： https://go.veeam.com/powershell-study-guide https://www.manning.com/books/exploring-powershell-automation http://community.idera.com/powershell/powertips/b/ebookv2#pi619PostSortOrder=Ascending","text":"如果有还不会 PowerShell 的同事，并且您希望帮助他们起步，一下是三个免费的学习资源： https://go.veeam.com/powershell-study-guide https://www.manning.com/books/exploring-powershell-automation http://community.idera.com/powershell/powertips/b/ebookv2#pi619PostSortOrder=Ascending 本文国际来源：Free Guides to Start With PowerShell","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检测有问题的 Execution Policy 设置","slug":"identifying-problematic-execution-policy-settings","date":"2017-02-14T08:00:00.000Z","updated":"2017-03-17T15:26:27.607Z","comments":true,"path":"2017/02/14/identifying-problematic-execution-policy-settings/","link":"","permalink":"http://blog.vichamp.com/2017/02/14/identifying-problematic-execution-policy-settings/","excerpt":"PowerShell 用执行策略 (execution policy) 来决定是否执行某个脚本。实际上定义执行策略可以定义 5 种作用域。要查看这所有五种情况，请使用这个命令： 123456789PS C:\\&gt; Get-ExecutionPolicy -List Scope ExecutionPolicy ----- ---------------MachinePolicy UndefinedUserPolicy Undefined Process UndefinedCurrentUser RemoteSignedLocalMachine Undefined 要确定生效的设置，PowerShell 会从上到下遍历这些作用域，然后取第一个非 “Undefined“ 设置。如果所有作用域都设置成 “Undefined“，那么 PowerShell 将使用 “Restricted“ 设置，并且阻止脚本执行。这是缺省的行为。 请永远保持 “MachinePolicy“ 和 “UserPolicy“ 作用域设置成 “Undefined“。这些作用域智能由组策略集中设置。如果它们设置成任何非 “Undefined“ 的值，用户则无法改变生效的设置。 有些公司使用这种方式来限制脚本的执行，它们用 execution policy 作为安全的屏障——而它并不是。”LocalMachine“ 作用域种的 Execution policy 永远应该是缺省值，而不应该强迫一个用户的设置。 如果 “MachinePolicy“ 或 “UserPolicy“ 有设置值，在 PowerShell 5 以及以下版本也有个 bug，可能会导致启动一个 PowerShell 脚本时延迟近 30 秒。这个延迟可能是内部导致的：PowerShell 使用 WMI 确定当前运行的进程，来决定一个 PowerShell 脚本是否作为一个组策略执行，而这种实现方式可能会造成过多的延迟。 所以如果您看见 “MachinePolicy“ 或 “UserPolicy“ 作用域中的设置不是 “Undefined“，您应该和 Active Directory 团队商量并和他们解释执行策略的目的：这是一个偏好设置，而不是一个限制设置。应该使用其它技术，例如 ““Software Restriction Policy” 来安全地限制脚本的使用。","text":"PowerShell 用执行策略 (execution policy) 来决定是否执行某个脚本。实际上定义执行策略可以定义 5 种作用域。要查看这所有五种情况，请使用这个命令： 123456789PS C:\\&gt; Get-ExecutionPolicy -List Scope ExecutionPolicy ----- ---------------MachinePolicy UndefinedUserPolicy Undefined Process UndefinedCurrentUser RemoteSignedLocalMachine Undefined 要确定生效的设置，PowerShell 会从上到下遍历这些作用域，然后取第一个非 “Undefined“ 设置。如果所有作用域都设置成 “Undefined“，那么 PowerShell 将使用 “Restricted“ 设置，并且阻止脚本执行。这是缺省的行为。 请永远保持 “MachinePolicy“ 和 “UserPolicy“ 作用域设置成 “Undefined“。这些作用域智能由组策略集中设置。如果它们设置成任何非 “Undefined“ 的值，用户则无法改变生效的设置。 有些公司使用这种方式来限制脚本的执行，它们用 execution policy 作为安全的屏障——而它并不是。”LocalMachine“ 作用域种的 Execution policy 永远应该是缺省值，而不应该强迫一个用户的设置。 如果 “MachinePolicy“ 或 “UserPolicy“ 有设置值，在 PowerShell 5 以及以下版本也有个 bug，可能会导致启动一个 PowerShell 脚本时延迟近 30 秒。这个延迟可能是内部导致的：PowerShell 使用 WMI 确定当前运行的进程，来决定一个 PowerShell 脚本是否作为一个组策略执行，而这种实现方式可能会造成过多的延迟。 所以如果您看见 “MachinePolicy“ 或 “UserPolicy“ 作用域中的设置不是 “Undefined“，您应该和 Active Directory 团队商量并和他们解释执行策略的目的：这是一个偏好设置，而不是一个限制设置。应该使用其它技术，例如 ““Software Restriction Policy” 来安全地限制脚本的使用。 本文国际来源：Identifying Problematic Execution Policy Settings","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检查 Execution Policy","slug":"checking-execution-policy","date":"2017-02-13T08:00:00.000Z","updated":"2017-03-17T15:26:27.604Z","comments":true,"path":"2017/02/13/checking-execution-policy/","link":"","permalink":"http://blog.vichamp.com/2017/02/13/checking-execution-policy/","excerpt":"execution policy 决定了 PowerShell 能执行哪类脚本。您需要将 execution policy 设置成 Undefined、Restricted，或 Default 之外的值，来允许脚本执行。 对于没有经验的用户，推荐使用 “RemoteSigned“。它可以运行本地脚本，也可以运行位于您信任的网络域的文件服务器上的脚本。它不会运行从 internet 上下载的脚本，或从其它非信任的源获取的脚本，除非这些脚本包含合法的数字签名。 以下是查看和设置当前 execution policy 的方法。 123456789PS C:\\&gt; Get-ExecutionPolicyRestrictedPS C:\\&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned -ForcePS C:\\&gt; Get-ExecutionPolicyRemoteSignedPS C:\\&gt; 当您使用 “CurrentUser“ 作用域，那么不需要管理员权限来更改这个设置。这是您个人的安全带，而不是公司级别的安全边界。这个设置将会保持住直到您改变它。 如果您需要确保确保可以无人值守地运行任何地方的脚本，您可能需要使用 “Bypass“ 设置，而不是 “RemoteSigned“。”Bypass“ 允许运行任意位置的脚本，而且不像 ““Unrestricted”“ 那样会弹出确认对话框。","text":"execution policy 决定了 PowerShell 能执行哪类脚本。您需要将 execution policy 设置成 Undefined、Restricted，或 Default 之外的值，来允许脚本执行。 对于没有经验的用户，推荐使用 “RemoteSigned“。它可以运行本地脚本，也可以运行位于您信任的网络域的文件服务器上的脚本。它不会运行从 internet 上下载的脚本，或从其它非信任的源获取的脚本，除非这些脚本包含合法的数字签名。 以下是查看和设置当前 execution policy 的方法。 123456789PS C:\\&gt; Get-ExecutionPolicyRestrictedPS C:\\&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned -ForcePS C:\\&gt; Get-ExecutionPolicyRemoteSignedPS C:\\&gt; 当您使用 “CurrentUser“ 作用域，那么不需要管理员权限来更改这个设置。这是您个人的安全带，而不是公司级别的安全边界。这个设置将会保持住直到您改变它。 如果您需要确保确保可以无人值守地运行任何地方的脚本，您可能需要使用 “Bypass“ 设置，而不是 “RemoteSigned“。”Bypass“ 允许运行任意位置的脚本，而且不像 ““Unrestricted”“ 那样会弹出确认对话框。 本文国际来源：Checking Execution Policy","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用类（静态成员 - 第六部分）","slug":"classes-static-members-part-6","date":"2017-02-12T08:00:00.000Z","updated":"2017-03-17T15:26:27.601Z","comments":true,"path":"2017/02/12/classes-static-members-part-6/","link":"","permalink":"http://blog.vichamp.com/2017/02/12/classes-static-members-part-6/","excerpt":"Class 可以定义所谓的“静态”成员。静态成员（属性和方法）可以通过类本身调用，而不需要对象实例。 看看这个例子： 1234567891011121314151617181920#requires -Version 5.0class TextToSpeech&#123; # store the initialized synthesizer here hidden static $synthesizer # static constructor, gets called whenever the type is initialized static TextToSpeech() &#123; Add-Type -AssemblyName System.Speech [TextToSpeech]::Synthesizer = New-Object System.Speech.Synthesis.SpeechSynthesizer &#125; # convert text to speech static Speak([string]$text) &#123; [TextToSpeech]::Synthesizer.Speak($text) &#125;&#125; “TextToSpeech“ 类包装了文本转语音的一切需要。它使用了静态的构造函数（当定义类型的时候执行）和一个静态方法，所以不需要实例化一个对象。立刻就可以使用 “Speak“ 方法： 123# since this class uses static constructors and methods, there is no need# to instantiate an object[TextToSpeech]::Speak('Hello World!') 如果您不用“静态”成员来做相同的事情，这个类会长得十分相似。您只需要移除所有 “static“ 关键字，并且通过 $this 代替类型名来存取类的属性： 1234567891011121314151617181920#requires -Version 5.0class TextToSpeech&#123; # store the initialized synthesizer here hidden $synthesizer # static constructor, gets called whenever the type is initialized TextToSpeech() &#123; Add-Type -AssemblyName System.Speech $this.Synthesizer = New-Object System.Speech.Synthesis.SpeechSynthesizer &#125; # convert text to speech Speak([string]$text) &#123; $this.Synthesizer.Speak($text) &#125;&#125; 最显著的区别可能是在用户端：用户现在需要先实例化一个对象： 12$speaker = [TextToSpeech]::new()$speaker.Speak('Hello World!') 所以使用规则提炼如下： 使用静态成员来实现只需要存在一次的功能（所以文本到语音转换器是一个静态类的好例子） 使用动态成员来实现需要在多于一个实例中同时存在（这样用户可以根据需要实例化任意多个独立的对象）的功能。","text":"Class 可以定义所谓的“静态”成员。静态成员（属性和方法）可以通过类本身调用，而不需要对象实例。 看看这个例子： 1234567891011121314151617181920#requires -Version 5.0class TextToSpeech&#123; # store the initialized synthesizer here hidden static $synthesizer # static constructor, gets called whenever the type is initialized static TextToSpeech() &#123; Add-Type -AssemblyName System.Speech [TextToSpeech]::Synthesizer = New-Object System.Speech.Synthesis.SpeechSynthesizer &#125; # convert text to speech static Speak([string]$text) &#123; [TextToSpeech]::Synthesizer.Speak($text) &#125;&#125; “TextToSpeech“ 类包装了文本转语音的一切需要。它使用了静态的构造函数（当定义类型的时候执行）和一个静态方法，所以不需要实例化一个对象。立刻就可以使用 “Speak“ 方法： 123# since this class uses static constructors and methods, there is no need# to instantiate an object[TextToSpeech]::Speak('Hello World!') 如果您不用“静态”成员来做相同的事情，这个类会长得十分相似。您只需要移除所有 “static“ 关键字，并且通过 $this 代替类型名来存取类的属性： 1234567891011121314151617181920#requires -Version 5.0class TextToSpeech&#123; # store the initialized synthesizer here hidden $synthesizer # static constructor, gets called whenever the type is initialized TextToSpeech() &#123; Add-Type -AssemblyName System.Speech $this.Synthesizer = New-Object System.Speech.Synthesis.SpeechSynthesizer &#125; # convert text to speech Speak([string]$text) &#123; $this.Synthesizer.Speak($text) &#125;&#125; 最显著的区别可能是在用户端：用户现在需要先实例化一个对象： 12$speaker = [TextToSpeech]::new()$speaker.Speak('Hello World!') 所以使用规则提炼如下： 使用静态成员来实现只需要存在一次的功能（所以文本到语音转换器是一个静态类的好例子） 使用动态成员来实现需要在多于一个实例中同时存在（这样用户可以根据需要实例化任意多个独立的对象）的功能。 本文国际来源：Classes (Static Members - Part 6)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用类（构造函数 - 第五部分）","slug":"using-classes-constructors-part-5","date":"2017-02-09T08:00:00.000Z","updated":"2017-03-17T15:26:27.594Z","comments":true,"path":"2017/02/09/using-classes-constructors-part-5/","link":"","permalink":"http://blog.vichamp.com/2017/02/09/using-classes-constructors-part-5/","excerpt":"Class 也可以称为构造函数。构造函数是创建一个新对象的方法。构造函数只是和类名相同的方法。通过构造函数，可以更简单地创建事先为属性赋过值的对象。以下是一个例子：“Person”类定义了一个 person。 以下是一个构造函数，输入姓和名，以及生日。当一个对象实例化的时候，构造函数会被调用，并且事先填充好对象的属性： 1234567891011121314151617181920#requires -Version 5.0class Person&#123; [string]$FirstName [string]$LastName [int][ValidateRange(0,100)]$Age [DateTime]$Birthday # constructor Person([string]$FirstName, [string]$LastName, [DateTime]$Birthday) &#123; # set object properties $this.FirstName = $FirstName $this.LastName = $LastName $this.Birthday = $Birthday # calculate person age $ticks = ((Get-Date) - $Birthday).Ticks $this.Age = (New-Object DateTime -ArgumentList $ticks).Year-1 &#125;&#125; 有了这个类之后，您可以很方便地创建 person 对象的列表： 123[Person]::new('Tobias','Weltner','2000-02-03')[Person]::new('Frank','Peterson','1976-04-12')[Person]::new('Helen','Stewards','1987-11-19') 结果类似如下： 12345FirstName LastName Age Birthday--------- -------- --- --------Tobias Weltner 16 2/3/2000 12:00:00 AMFrank Peterson 40 4/12/1976 12:00:00 AMHelen Stewards 29 11/19/1987 12:00:00 AM","text":"Class 也可以称为构造函数。构造函数是创建一个新对象的方法。构造函数只是和类名相同的方法。通过构造函数，可以更简单地创建事先为属性赋过值的对象。以下是一个例子：“Person”类定义了一个 person。 以下是一个构造函数，输入姓和名，以及生日。当一个对象实例化的时候，构造函数会被调用，并且事先填充好对象的属性： 1234567891011121314151617181920#requires -Version 5.0class Person&#123; [string]$FirstName [string]$LastName [int][ValidateRange(0,100)]$Age [DateTime]$Birthday # constructor Person([string]$FirstName, [string]$LastName, [DateTime]$Birthday) &#123; # set object properties $this.FirstName = $FirstName $this.LastName = $LastName $this.Birthday = $Birthday # calculate person age $ticks = ((Get-Date) - $Birthday).Ticks $this.Age = (New-Object DateTime -ArgumentList $ticks).Year-1 &#125;&#125; 有了这个类之后，您可以很方便地创建 person 对象的列表： 123[Person]::new('Tobias','Weltner','2000-02-03')[Person]::new('Frank','Peterson','1976-04-12')[Person]::new('Helen','Stewards','1987-11-19') 结果类似如下： 12345FirstName LastName Age Birthday--------- -------- --- --------Tobias Weltner 16 2/3/2000 12:00:00 AMFrank Peterson 40 4/12/1976 12:00:00 AMHelen Stewards 29 11/19/1987 12:00:00 AM 本文国际来源：Using Classes (Constructors - Part 5)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用类（重载 - 第四部分）","slug":"using-classes-overloading-part-4","date":"2017-02-08T08:00:00.000Z","updated":"2017-03-17T15:26:27.584Z","comments":true,"path":"2017/02/08/using-classes-overloading-part-4/","link":"","permalink":"http://blog.vichamp.com/2017/02/08/using-classes-overloading-part-4/","excerpt":"类中的方法可以重载：您可以定义多个同名的方法，但是参数类型不同。它用起来和 cmdlet 中的参数集类似。请看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#requires -Version 5.0class StopWatch&#123; # property is marked \"hidden\" because it is used internally only # it is not shown by IntelliSense hidden [DateTime]$LastDate = (Get-Date) # when no parameter is specified, do not emit verbose info [int] TimeElapsed() &#123; return $this.TimeElapsedInternal($false) &#125; # user can decide whether to emit verbose info or not [int] TimeElapsed([bool]$Verbose) &#123; return $this.TimeElapsedInternal($Verbose) &#125; # this method is called by all public methods hidden [int] TimeElapsedInternal([bool]$Verbose) &#123; # get current date $now = Get-Date # and subtract last date, report back milliseconds $milliseconds = ($now - $this.LastDate).TotalMilliseconds # use $this to access internal properties and methods # update the last date so that it now is the current date $this.LastDate = $now # output verbose information if requested if ($Verbose) &#123; $VerbosePreference = 'Continue' Write-Verbose \"Last step took $milliseconds ms.\" &#125; # use \"return\" to define the return value return $milliseconds &#125; Reset() &#123; $this.LastDate = Get-Date &#125;&#125;# create instance$stopWatch = [StopWatch]::new()# do not output verbose info$stopWatch.TimeElapsed()Start-Sleep -Seconds 2# output verbose info$stopWatch.TimeElapsed($true)$a = Get-Service# output verbose info$stopWatch.TimeElapsed($true) 结果类似如下： 123450VERBOSE: Last step took 2018.1879 ms.2018VERBOSE: Last step took 68.8883 ms.69","text":"类中的方法可以重载：您可以定义多个同名的方法，但是参数类型不同。它用起来和 cmdlet 中的参数集类似。请看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#requires -Version 5.0class StopWatch&#123; # property is marked \"hidden\" because it is used internally only # it is not shown by IntelliSense hidden [DateTime]$LastDate = (Get-Date) # when no parameter is specified, do not emit verbose info [int] TimeElapsed() &#123; return $this.TimeElapsedInternal($false) &#125; # user can decide whether to emit verbose info or not [int] TimeElapsed([bool]$Verbose) &#123; return $this.TimeElapsedInternal($Verbose) &#125; # this method is called by all public methods hidden [int] TimeElapsedInternal([bool]$Verbose) &#123; # get current date $now = Get-Date # and subtract last date, report back milliseconds $milliseconds = ($now - $this.LastDate).TotalMilliseconds # use $this to access internal properties and methods # update the last date so that it now is the current date $this.LastDate = $now # output verbose information if requested if ($Verbose) &#123; $VerbosePreference = 'Continue' Write-Verbose \"Last step took $milliseconds ms.\" &#125; # use \"return\" to define the return value return $milliseconds &#125; Reset() &#123; $this.LastDate = Get-Date &#125;&#125;# create instance$stopWatch = [StopWatch]::new()# do not output verbose info$stopWatch.TimeElapsed()Start-Sleep -Seconds 2# output verbose info$stopWatch.TimeElapsed($true)$a = Get-Service# output verbose info$stopWatch.TimeElapsed($true) 结果类似如下： 123450VERBOSE: Last step took 2018.1879 ms.2018VERBOSE: Last step took 68.8883 ms.69 本文国际来源：Using Classes (Overloading - Part 4)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用类（增加方法 - 第三部分）","slug":"using-classes-adding-methods-part-3","date":"2017-02-07T08:00:00.000Z","updated":"2017-03-17T15:26:27.581Z","comments":true,"path":"2017/02/07/using-classes-adding-methods-part-3/","link":"","permalink":"http://blog.vichamp.com/2017/02/07/using-classes-adding-methods-part-3/","excerpt":"相对于 [PSCustomObject]，使用 class 的最大好处之一是它也可以定义方法（命令）。以下例子实现了秒表功能。秒表可以用来计算代码执行了多少时间： 12345678910111213141516171819202122232425#requires -Version 5.0class StopWatch&#123; # property is marked \"hidden\" because it is used internally only # it is not shown by IntelliSense hidden [DateTime]$LastDate = (Get-Date) [int] TimeElapsed() &#123; # get current date $now = Get-Date # and subtract last date, report back milliseconds $milliseconds = ($now - $this.LastDate).TotalMilliseconds # use $this to access internal properties and methods # update the last date so that it now is the current date $this.LastDate = $now # use \"return\" to define the return value return $milliseconds &#125; Reset() &#123; $this.LastDate = Get-Date &#125;&#125; 以下是秒表的使用方法： 12345678910# create instance$stopWatch = [StopWatch]::new()$stopWatch.TimeElapsed()Start-Sleep -Seconds 2$stopWatch.TimeElapsed()$a = Get-Service$stopWatch.TimeElapsed() 结果类似如下： 1230201869 当您在一个函数中定义方法时，要遵守一系列规则： 如果一个方法有返回值，那么必须指定返回值的数据类型 方法的返回值必须用关键字“return”来指定 方法中不能使用未赋值的变量，也不能从父作用域中读取变量 要引用这个类中的属性或方法，请在前面加上“$this.”","text":"相对于 [PSCustomObject]，使用 class 的最大好处之一是它也可以定义方法（命令）。以下例子实现了秒表功能。秒表可以用来计算代码执行了多少时间： 12345678910111213141516171819202122232425#requires -Version 5.0class StopWatch&#123; # property is marked \"hidden\" because it is used internally only # it is not shown by IntelliSense hidden [DateTime]$LastDate = (Get-Date) [int] TimeElapsed() &#123; # get current date $now = Get-Date # and subtract last date, report back milliseconds $milliseconds = ($now - $this.LastDate).TotalMilliseconds # use $this to access internal properties and methods # update the last date so that it now is the current date $this.LastDate = $now # use \"return\" to define the return value return $milliseconds &#125; Reset() &#123; $this.LastDate = Get-Date &#125;&#125; 以下是秒表的使用方法： 12345678910# create instance$stopWatch = [StopWatch]::new()$stopWatch.TimeElapsed()Start-Sleep -Seconds 2$stopWatch.TimeElapsed()$a = Get-Service$stopWatch.TimeElapsed() 结果类似如下： 1230201869 当您在一个函数中定义方法时，要遵守一系列规则： 如果一个方法有返回值，那么必须指定返回值的数据类型 方法的返回值必须用关键字“return”来指定 方法中不能使用未赋值的变量，也不能从父作用域中读取变量 要引用这个类中的属性或方法，请在前面加上“$this.” 本文国际来源：Using Classes (Adding Methods - Part 3)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用类（初始化属性 - 第二部分）","slug":"using-classes-initializing-properties-part-2","date":"2017-02-06T08:00:00.000Z","updated":"2017-03-17T15:26:27.573Z","comments":true,"path":"2017/02/06/using-classes-initializing-properties-part-2/","link":"","permalink":"http://blog.vichamp.com/2017/02/06/using-classes-initializing-properties-part-2/","excerpt":"可以为类的属性手动指定一个数据类型和缺省值。当您从一个类实例化一个对象时，属性已经填充好并且只接受指定的数据类型： 1234567891011121314151617181920212223#requires -Version 5.0class Info&#123; # strongly typed properties with default values [String] $Name = $env:USERNAME [String] $Computer = $env:COMPUTERNAME [DateTime] $Date = (Get-Date)&#125;# create instance$infoObj = [Info]::new()# view default (initial) values$infoObj# change value$infoObj.Name = 'test'$infoObj","text":"可以为类的属性手动指定一个数据类型和缺省值。当您从一个类实例化一个对象时，属性已经填充好并且只接受指定的数据类型： 1234567891011121314151617181920212223#requires -Version 5.0class Info&#123; # strongly typed properties with default values [String] $Name = $env:USERNAME [String] $Computer = $env:COMPUTERNAME [DateTime] $Date = (Get-Date)&#125;# create instance$infoObj = [Info]::new()# view default (initial) values$infoObj# change value$infoObj.Name = 'test'$infoObj 本文国际来源：Using Classes (Initializing Properties - Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用类（创建对象 - 第一部分）","slug":"using-classes-creating-objects-part-1","date":"2017-02-05T08:00:00.000Z","updated":"2017-03-17T15:26:27.566Z","comments":true,"path":"2017/02/05/using-classes-creating-objects-part-1/","link":"","permalink":"http://blog.vichamp.com/2017/02/05/using-classes-creating-objects-part-1/","excerpt":"从 PowerShell 5.0 开始，引入了一个新的关键字 “class”。它能够创建新的类。您可以使用类作为新对象的模板。一下代码定义了一个名为 “Info” 的新类的模板，这个类有一系列属性： 1234567891011121314151617181920212223#requires -Version 5.0class Info &#123; $Name $Computer $Date &#125;# generic syntax to create a new object instance$infoObj = New-Object -TypeName Info# alternate syntax PS5 or better (shorter and faster)$infoObj = [Info]::new()$infoObj$infoObj.Name = $env:COMPUTERNAME$infoObj.Computer = $env:COMPUTERNAME$infoObj.Date = Get-Date$infoObj$infoObj.GetType().Name 您可以使用 New-Object 来创建这个类的任意多个新实例。每个实例代表有三个属性的 “Info” 类型的一个新对象。 12345Name Computer Date ---- -------- ---- DESKTOP-7AAMJLF DESKTOP-7AAMJLF 1/2/2017 2:00:02 PMInfo 这是一个非常简单（但很有用）的例子，演示了如何使用类来生产对象。如果您只希望在新对象中存储一些零碎信息，您也可以使用 PowerShell 3.0 引入的 [PSCustomObject] 语法： 123456789#requires -Version 3.0$infoObj = [PSCustomObject]@&#123; Name = $env:COMPUTERNAME Computer = $env:COMPUTERNAME Date = Get-Date&#125;$infoObj$infoObj.GetType().Name 这种做法没有使用一个蓝本（类），而是根据哈希表创建独立的新对象： 1234Name Computer Date ---- -------- ---- DESKTOP-7AAMJLF DESKTOP-7AAMJLF 1/2/2017 2:02:39 PMPSCustomObject 所以新创建的对象类型永远是 “PSCustomObject“；而在前一个例子中，对象的类型是通过类名定义的。","text":"从 PowerShell 5.0 开始，引入了一个新的关键字 “class”。它能够创建新的类。您可以使用类作为新对象的模板。一下代码定义了一个名为 “Info” 的新类的模板，这个类有一系列属性： 1234567891011121314151617181920212223#requires -Version 5.0class Info &#123; $Name $Computer $Date &#125;# generic syntax to create a new object instance$infoObj = New-Object -TypeName Info# alternate syntax PS5 or better (shorter and faster)$infoObj = [Info]::new()$infoObj$infoObj.Name = $env:COMPUTERNAME$infoObj.Computer = $env:COMPUTERNAME$infoObj.Date = Get-Date$infoObj$infoObj.GetType().Name 您可以使用 New-Object 来创建这个类的任意多个新实例。每个实例代表有三个属性的 “Info” 类型的一个新对象。 12345Name Computer Date ---- -------- ---- DESKTOP-7AAMJLF DESKTOP-7AAMJLF 1/2/2017 2:00:02 PMInfo 这是一个非常简单（但很有用）的例子，演示了如何使用类来生产对象。如果您只希望在新对象中存储一些零碎信息，您也可以使用 PowerShell 3.0 引入的 [PSCustomObject] 语法： 123456789#requires -Version 3.0$infoObj = [PSCustomObject]@&#123; Name = $env:COMPUTERNAME Computer = $env:COMPUTERNAME Date = Get-Date&#125;$infoObj$infoObj.GetType().Name 这种做法没有使用一个蓝本（类），而是根据哈希表创建独立的新对象： 1234Name Computer Date ---- -------- ---- DESKTOP-7AAMJLF DESKTOP-7AAMJLF 1/2/2017 2:02:39 PMPSCustomObject 所以新创建的对象类型永远是 “PSCustomObject“；而在前一个例子中，对象的类型是通过类名定义的。 本文国际来源：Using Classes (Creating Objects - Part 1)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用命名空间","slug":"using-using-namespace","date":"2017-02-02T08:00:00.000Z","updated":"2017-03-17T15:26:27.563Z","comments":true,"path":"2017/02/02/using-using-namespace/","link":"","permalink":"http://blog.vichamp.com/2017/02/02/using-using-namespace/","excerpt":"使用 .NET 的类型名称很麻烦，因为这些名字很长。以下是一个例子： 12345#requires -Version 2.0Add-Type -AssemblyName System.Speech$speak = New-Object -TypeName System.Speech.Synthesis.SpeechSynthesizer$speak.Speak('Hello I am PowerShell!') 在 PowerShell 5.0 以上版本，您可以定义希望使用的 .NET 命名空间。这些 “using namespace“ 语句必须放在脚本的开头。此时代码的可读性变得更好，并且 using 语句明确了该脚本使用了哪些 .NET 命名空间： 12345678#requires -Version 5.0using namespace System.Speech.SynthesisAdd-Type -AssemblyName System.Speech$speak = New-Object -TypeName SpeechSynthesizer$speak.Speak('Hello I am PowerShell!') 以下是另一个例子：System.IO.Path .NET 命名空间包含一系列有用的路径工具方法。以下是一些例子： 12[System.IO.Path]::ChangeExtension('test.txt', 'bat')[System.IO.Path]::GetExtension('test.txt') 现在可以不必重复地使用 [System.IO.Path] 来访问这些方法。添加一句 “using namespace System.IO“ 语句之后就可以直接访问 [Path] 类型： 123456#requires -Version 5.0using namespace System.IO[Path]::ChangeExtension('test.txt', 'bat')[Path]::GetExtension('test.txt')","text":"使用 .NET 的类型名称很麻烦，因为这些名字很长。以下是一个例子： 12345#requires -Version 2.0Add-Type -AssemblyName System.Speech$speak = New-Object -TypeName System.Speech.Synthesis.SpeechSynthesizer$speak.Speak('Hello I am PowerShell!') 在 PowerShell 5.0 以上版本，您可以定义希望使用的 .NET 命名空间。这些 “using namespace“ 语句必须放在脚本的开头。此时代码的可读性变得更好，并且 using 语句明确了该脚本使用了哪些 .NET 命名空间： 12345678#requires -Version 5.0using namespace System.Speech.SynthesisAdd-Type -AssemblyName System.Speech$speak = New-Object -TypeName SpeechSynthesizer$speak.Speak('Hello I am PowerShell!') 以下是另一个例子：System.IO.Path .NET 命名空间包含一系列有用的路径工具方法。以下是一些例子： 12[System.IO.Path]::ChangeExtension('test.txt', 'bat')[System.IO.Path]::GetExtension('test.txt') 现在可以不必重复地使用 [System.IO.Path] 来访问这些方法。添加一句 “using namespace System.IO“ 语句之后就可以直接访问 [Path] 类型： 123456#requires -Version 5.0using namespace System.IO[Path]::ChangeExtension('test.txt', 'bat')[Path]::GetExtension('test.txt') 本文国际来源：Using “Using Namespace”","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 确定个人年龄","slug":"determining-person-age","date":"2017-02-01T08:00:00.000Z","updated":"2017-03-17T15:26:27.556Z","comments":true,"path":"2017/02/01/determining-person-age/","link":"","permalink":"http://blog.vichamp.com/2017/02/01/determining-person-age/","excerpt":"您是如何基于生日确定一个人的年龄？您可以将 Get-Date 命令返回的当前时间减去生日事件，但是结果并不包含年数： 1234567#requires -Version 1.0$birthday = Get-Date -Date '1978-12-09'$today = Get-Date$timedifference = $today - $birthday$timedifference 以下是结果： 1234567891011Days : 13905Hours : 16Minutes : 34Seconds : 58Milliseconds : 575Ticks : 12014516985758198TotalDays : 13905.6909557387TotalHours : 333736.582937728TotalMinutes : 20024194.9762637TotalSeconds : 1201451698.57582TotalMilliseconds : 1201451698575.82 要计算年数，请取 “ticks” 的数值（衡量时间最小单位），并且转换为 datetime 类型，然后取年数并减一： 12345678#requires -Version 1.0$birthdayString = '1978-12-09'$birthday = Get-Date -Date $birthdayString$today = Get-Date$timedifference = $today - $birthday$ticks = $timedifference.Ticks$age = (New-Object DateTime -ArgumentList $ticks).Year -1\"Born on $birthdayString = $age Years old (at time of printing)\" 这是计算结果的样子： 1Born on 1978-12-09 = 38 Years old (at time of printing)","text":"您是如何基于生日确定一个人的年龄？您可以将 Get-Date 命令返回的当前时间减去生日事件，但是结果并不包含年数： 1234567#requires -Version 1.0$birthday = Get-Date -Date '1978-12-09'$today = Get-Date$timedifference = $today - $birthday$timedifference 以下是结果： 1234567891011Days : 13905Hours : 16Minutes : 34Seconds : 58Milliseconds : 575Ticks : 12014516985758198TotalDays : 13905.6909557387TotalHours : 333736.582937728TotalMinutes : 20024194.9762637TotalSeconds : 1201451698.57582TotalMilliseconds : 1201451698575.82 要计算年数，请取 “ticks” 的数值（衡量时间最小单位），并且转换为 datetime 类型，然后取年数并减一： 12345678#requires -Version 1.0$birthdayString = '1978-12-09'$birthday = Get-Date -Date $birthdayString$today = Get-Date$timedifference = $today - $birthday$ticks = $timedifference.Ticks$age = (New-Object DateTime -ArgumentList $ticks).Year -1\"Born on $birthdayString = $age Years old (at time of printing)\" 这是计算结果的样子： 1Born on 1978-12-09 = 38 Years old (at time of printing) 本文国际来源：Determining Person Age","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 加速 New-Object Synthesizer","slug":"speeding-up-new-object-synthesizer","date":"2017-01-31T08:00:00.000Z","updated":"2017-03-17T15:26:27.547Z","comments":true,"path":"2017/01/31/speeding-up-new-object-synthesizer/","link":"","permalink":"http://blog.vichamp.com/2017/01/31/speeding-up-new-object-synthesizer/","excerpt":"New-Object 创建新的对象实例，在之前的“语音之周”中，您已经见到了如何创建一个语音合成器对象，并且将文本转换为语音： 123Add-Type -AssemblyName System.Speech$speak = New-Object -TypeName System.Speech.Synthesis.SpeechSynthesizer$speak.Speak('Hello I am PowerShell!') 创建对象的方法是类似的，所以如果换成一个不同的类，例如 System.Net.NetworkInformation.Ping，就可以 ping 某个 IP 地址或主机名： 12345$ping = New-Object -TypeName System.Net.NetworkInformation.Ping$timeout = 1000$result = $ping.Send('powershellmagazine.com', $timeout)$result 在 PowerShell 5.0 或以上版本，有另一种方法来代替 New-Object，而且用起来更快：使用任意类型暴露的 New() 静态方法。您可以像这样重写以上的例子： 123Add-Type -AssemblyName System.Speech$speak = [System.Speech.Synthesis.SpeechSynthesizer]::New()$speak.Speak('Hello I am PowerShell!') 类似地： 12345$ping = [System.Net.NetworkInformation.Ping]::New()$timeout = 1000$result = $ping.Send('powershellmagazine.com', $timeout)$result 或者，可以精简： 1[System.Net.NetworkInformation.Ping]::New().Send('powershellmagazine.com', 1000) 请注意：一旦您使用 New() 来代替 New-Object，您的代码需要 PowerShell 5.0 以上版本。","text":"New-Object 创建新的对象实例，在之前的“语音之周”中，您已经见到了如何创建一个语音合成器对象，并且将文本转换为语音： 123Add-Type -AssemblyName System.Speech$speak = New-Object -TypeName System.Speech.Synthesis.SpeechSynthesizer$speak.Speak('Hello I am PowerShell!') 创建对象的方法是类似的，所以如果换成一个不同的类，例如 System.Net.NetworkInformation.Ping，就可以 ping 某个 IP 地址或主机名： 12345$ping = New-Object -TypeName System.Net.NetworkInformation.Ping$timeout = 1000$result = $ping.Send('powershellmagazine.com', $timeout)$result 在 PowerShell 5.0 或以上版本，有另一种方法来代替 New-Object，而且用起来更快：使用任意类型暴露的 New() 静态方法。您可以像这样重写以上的例子： 123Add-Type -AssemblyName System.Speech$speak = [System.Speech.Synthesis.SpeechSynthesizer]::New()$speak.Speak('Hello I am PowerShell!') 类似地： 12345$ping = [System.Net.NetworkInformation.Ping]::New()$timeout = 1000$result = $ping.Send('powershellmagazine.com', $timeout)$result 或者，可以精简： 1[System.Net.NetworkInformation.Ping]::New().Send('powershellmagazine.com', 1000) 请注意：一旦您使用 New() 来代替 New-Object，您的代码需要 PowerShell 5.0 以上版本。 本文国际来源：Speeding Up New-Object Synthesizer","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 语音之周：使用语音合成器高级选项","slug":"speech-week-using-advanced-speech-synthesizer-options-synthesizer","date":"2017-01-30T08:00:00.000Z","updated":"2017-03-17T15:26:27.545Z","comments":true,"path":"2017/01/30/speech-week-using-advanced-speech-synthesizer-options-synthesizer/","link":"","permalink":"http://blog.vichamp.com/2017/01/30/speech-week-using-advanced-speech-synthesizer-options-synthesizer/","excerpt":".NET 语音引擎不止可以接受文本输入。如果您使用 SpeakSsm()，您可以使用 XML 来切换语言、速度，以及其它文本到语音转换的参数。 以下例子需要同时安装了英语和德语的语音。如果您没有安装德语语音，请使当地修改脚本中的语言 ID。以下是查找系统中可用的语言 ID 的方法： 12345678PS C:\\&gt; Add-Type -AssemblyName System.Speech PS C:\\&gt; $speak.GetInstalledVoices() | Select-Object -ExpandProperty VoiceInfo | Select-Object -ExpandProperty Culture | Sort-Object -UniqueLCID Name DisplayName ---- ---- ----------- 1031 de-DE German (Germany) 1033 en-US English (United States) 以下是完整的例子： 12345678910111213141516171819202122232425#requires -Version 2.0Add-Type -AssemblyName System.Speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$ssml = '&lt;speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\" xml:lang=\"en-US\"&gt; &lt;voice xml:lang=\"en-US\"&gt; &lt;prosody rate=\"1\"&gt; &lt;p&gt;I can speak English!&lt;/p&gt; &lt;/prosody&gt; &lt;/voice&gt; &lt;voice xml:lang=\"de-DE\"&gt; &lt;prosody rate=\"1\"&gt; &lt;p&gt;und ich kann auch deutsch sprechen!&lt;/p&gt; &lt;/prosody&gt; &lt;/voice&gt; &lt;voice xml:lang=\"en-US\"&gt; &lt;prosody rate=\"0\"&gt; &lt;p&gt;...and sometimes I get really tired.&lt;/p&gt; &lt;/prosody&gt; &lt;/voice&gt;&lt;/speak&gt;'$speak.SpeakSsml($ssml)","text":".NET 语音引擎不止可以接受文本输入。如果您使用 SpeakSsm()，您可以使用 XML 来切换语言、速度，以及其它文本到语音转换的参数。 以下例子需要同时安装了英语和德语的语音。如果您没有安装德语语音，请使当地修改脚本中的语言 ID。以下是查找系统中可用的语言 ID 的方法： 12345678PS C:\\&gt; Add-Type -AssemblyName System.Speech PS C:\\&gt; $speak.GetInstalledVoices() | Select-Object -ExpandProperty VoiceInfo | Select-Object -ExpandProperty Culture | Sort-Object -UniqueLCID Name DisplayName ---- ---- ----------- 1031 de-DE German (Germany) 1033 en-US English (United States) 以下是完整的例子： 12345678910111213141516171819202122232425#requires -Version 2.0Add-Type -AssemblyName System.Speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$ssml = '&lt;speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\" xml:lang=\"en-US\"&gt; &lt;voice xml:lang=\"en-US\"&gt; &lt;prosody rate=\"1\"&gt; &lt;p&gt;I can speak English!&lt;/p&gt; &lt;/prosody&gt; &lt;/voice&gt; &lt;voice xml:lang=\"de-DE\"&gt; &lt;prosody rate=\"1\"&gt; &lt;p&gt;und ich kann auch deutsch sprechen!&lt;/p&gt; &lt;/prosody&gt; &lt;/voice&gt; &lt;voice xml:lang=\"en-US\"&gt; &lt;prosody rate=\"0\"&gt; &lt;p&gt;...and sometimes I get really tired.&lt;/p&gt; &lt;/prosody&gt; &lt;/voice&gt;&lt;/speak&gt;'$speak.SpeakSsml($ssml) 本文国际来源：Speech-Week: Using Advanced Speech Synthesizer Options Synthesizer","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 语音之周：记录语音到文件合成器","slug":"speech-week-recording-voice-to-file-synthesizer","date":"2017-01-29T08:00:00.000Z","updated":"2017-03-17T15:26:27.541Z","comments":true,"path":"2017/01/29/speech-week-recording-voice-to-file-synthesizer/","link":"","permalink":"http://blog.vichamp.com/2017/01/29/speech-week-recording-voice-to-file-synthesizer/","excerpt":"内置的 Microsoft 文本到语音引擎可以将音频文件保存到文件。通过这种方式，您可以自动生成 WAV 文件。以下是一个例子：它在您的桌面上创建一个新的 “clickme.wav” 文件，当您打开这个文件时，将会听到语音文本： 12345678910#requires -Version 2.0$Path = \"$home\\Desktop\\clickme.wav\"Add-Type -AssemblyName System.Speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$speak.SetOutputToWaveFile($Path)$speak.Speak('Hello I am PowerShell!')$speak.SetOutputToDefaultAudioDevice()Invoke-Item -Path $Path","text":"内置的 Microsoft 文本到语音引擎可以将音频文件保存到文件。通过这种方式，您可以自动生成 WAV 文件。以下是一个例子：它在您的桌面上创建一个新的 “clickme.wav” 文件，当您打开这个文件时，将会听到语音文本： 12345678910#requires -Version 2.0$Path = \"$home\\Desktop\\clickme.wav\"Add-Type -AssemblyName System.Speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$speak.SetOutputToWaveFile($Path)$speak.Speak('Hello I am PowerShell!')$speak.SetOutputToDefaultAudioDevice()Invoke-Item -Path $Path 本文国际来源：Speech-Week: Recording Voice to File Synthesizer","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 语音之周：更改讲述人的语音","slug":"speech-week-using-different-voices-with-speech-synthesizer","date":"2017-01-26T08:00:00.000Z","updated":"2017-03-17T15:26:27.536Z","comments":true,"path":"2017/01/26/speech-week-using-different-voices-with-speech-synthesizer/","link":"","permalink":"http://blog.vichamp.com/2017/01/26/speech-week-using-different-voices-with-speech-synthesizer/","excerpt":"在前一个技能中我们演示了如何使用语音转换器来念出文本。以下是查找您系统中安装的语言的方法： 123456#requires -Version 2.0Add-Type -AssemblyName System.Speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$speak.GetInstalledVoices() | Select-Object -ExpandProperty VoiceInfo | Select-Object -Property Culture, Name, Gender, Age 结果类似如下： 12345Culture Name Gender Age------- ---- ------ ---en-US Microsoft Zira Desktop Female Adulten-US Microsoft David Desktop Male Adultde-DE Microsoft Hedda Desktop Female Adult 用这行代码可以返回缺省的语音： 1$speak.Voice 假设您的系统安装了多个语音，以下是选择一个不同语音的方法。只需要传入您想使用的语音名字。这个例子在德文 Windows 10 系统上使用德语语音引擎： 12345#requires -Version 2.0Add-Type -AssemblyName System.speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$speak.SelectVoice('Microsoft Hedda Desktop')$speak.Speak('Jetzt spreche ich deutsch.')","text":"在前一个技能中我们演示了如何使用语音转换器来念出文本。以下是查找您系统中安装的语言的方法： 123456#requires -Version 2.0Add-Type -AssemblyName System.Speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$speak.GetInstalledVoices() | Select-Object -ExpandProperty VoiceInfo | Select-Object -Property Culture, Name, Gender, Age 结果类似如下： 12345Culture Name Gender Age------- ---- ------ ---en-US Microsoft Zira Desktop Female Adulten-US Microsoft David Desktop Male Adultde-DE Microsoft Hedda Desktop Female Adult 用这行代码可以返回缺省的语音： 1$speak.Voice 假设您的系统安装了多个语音，以下是选择一个不同语音的方法。只需要传入您想使用的语音名字。这个例子在德文 Windows 10 系统上使用德语语音引擎： 12345#requires -Version 2.0Add-Type -AssemblyName System.speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$speak.SelectVoice('Microsoft Hedda Desktop')$speak.Speak('Jetzt spreche ich deutsch.') 本文国际来源：Speech-Week: Using Different Voices with Speech Synthesizer","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 语音之周：使用语音讲述人","slug":"speech-week-using-a-speech-synthesizer","date":"2017-01-25T08:00:00.000Z","updated":"2017-03-17T15:26:27.534Z","comments":true,"path":"2017/01/25/speech-week-using-a-speech-synthesizer/","link":"","permalink":"http://blog.vichamp.com/2017/01/25/speech-week-using-a-speech-synthesizer/","excerpt":"当您将 “System.Speech“ 程序集添加到 PowerShell 中后，就可以使用新增的 “SpeechSynthesizer“ 类将文字转成语音： 123Add-Type -AssemblyName System.Speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$speak.Speak('Hello I am PowerShell!') 请注意语音讲述人用的是您系统的缺省语音。您的讲述人缺省情况下可能说的不是英文。我们将在接下来的技能当中介绍如何使用不同的语音。","text":"当您将 “System.Speech“ 程序集添加到 PowerShell 中后，就可以使用新增的 “SpeechSynthesizer“ 类将文字转成语音： 123Add-Type -AssemblyName System.Speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$speak.Speak('Hello I am PowerShell!') 请注意语音讲述人用的是您系统的缺省语音。您的讲述人缺省情况下可能说的不是英文。我们将在接下来的技能当中介绍如何使用不同的语音。 本文国际来源：Speech-Week: Using a Speech Synthesizer","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 增加和删除反斜杠","slug":"adding-and-removing-backslashes","date":"2017-01-24T08:00:00.000Z","updated":"2017-03-17T15:26:27.530Z","comments":true,"path":"2017/01/24/adding-and-removing-backslashes/","link":"","permalink":"http://blog.vichamp.com/2017/01/24/adding-and-removing-backslashes/","excerpt":"我们处理路径时，常常需要使路径“标准化”。例如确保所有的路径都以反斜杠结尾。一种尝试如下： 123456$path = 'c:\\temp'if ($path -notmatch '\\\\$') &#123; $path += '\\' &#125;$path 这段代码用正则表达式来查找一段文本尾部的反斜杠。如果不存在，则添加一个反斜杠。 如果您想删除路径尾部的反斜杠，您可以直接使用 -replace 运算符： 12$path = 'c:\\temp\\' -replace '\\\\$'$path","text":"我们处理路径时，常常需要使路径“标准化”。例如确保所有的路径都以反斜杠结尾。一种尝试如下： 123456$path = 'c:\\temp'if ($path -notmatch '\\\\$') &#123; $path += '\\' &#125;$path 这段代码用正则表达式来查找一段文本尾部的反斜杠。如果不存在，则添加一个反斜杠。 如果您想删除路径尾部的反斜杠，您可以直接使用 -replace 运算符： 12$path = 'c:\\temp\\' -replace '\\\\$'$path 本文国际来源：Adding and Removing Backslashes","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检查整数的位数","slug":"checking-number-of-digits-in-integer","date":"2017-01-23T08:00:00.000Z","updated":"2017-03-17T15:26:27.524Z","comments":true,"path":"2017/01/23/checking-number-of-digits-in-integer/","link":"","permalink":"http://blog.vichamp.com/2017/01/23/checking-number-of-digits-in-integer/","excerpt":"有些时候您可能会需要检查一个整数的位数，例如验证用户的输入。以下是一个非常简单的使用正则表达式的方法： 123456789101112131415# check the number of digits in an integer$integer = 5721567# is it between 4 and 6 digits?$is4to6 = $integer -match '^\\d&#123;4,6&#125;$'# is it exactly 7 digits?$is7 = $integer -match '^\\d&#123;7&#125;$'# is it at least 4 digits?$isatleast4 = $integer -match '^\\d&#123;4,&#125;$'\"4-6 digits? $is4to6\"\"exactly 7 digits? $is7\"\"at least 4 digits? $isatleast4\" 这个例子演示了如何检查是否是恰好的位数，或者位数处于某个范围。请注意 “^” 代表表达式的起始，”$” 代表表达式的结尾。”\\d” 表示一位数字，大括号确定位数。","text":"有些时候您可能会需要检查一个整数的位数，例如验证用户的输入。以下是一个非常简单的使用正则表达式的方法： 123456789101112131415# check the number of digits in an integer$integer = 5721567# is it between 4 and 6 digits?$is4to6 = $integer -match '^\\d&#123;4,6&#125;$'# is it exactly 7 digits?$is7 = $integer -match '^\\d&#123;7&#125;$'# is it at least 4 digits?$isatleast4 = $integer -match '^\\d&#123;4,&#125;$'\"4-6 digits? $is4to6\"\"exactly 7 digits? $is7\"\"at least 4 digits? $isatleast4\" 这个例子演示了如何检查是否是恰好的位数，或者位数处于某个范围。请注意 “^” 代表表达式的起始，”$” 代表表达式的结尾。”\\d” 表示一位数字，大括号确定位数。 本文国际来源：Checking Number of Digits in Integer","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在资源管理器中打开 PowerShell","slug":"opening-powershell-inside-explorer","date":"2017-01-22T08:00:00.000Z","updated":"2017-03-17T15:26:27.520Z","comments":true,"path":"2017/01/22/opening-powershell-inside-explorer/","link":"","permalink":"http://blog.vichamp.com/2017/01/22/opening-powershell-inside-explorer/","excerpt":"一个在文件资源管理器中快速启动 PowerShell 的办法是导航到您数据的文件夹，然后点击导航条。这时导航面包屑控件变成了文件夹路径。将它改为 “powershell”，并按下回车键。 这时会打开 PowerShell，并且当前文件夹会设置为您导航到的文件夹。 不过，当前路径下有一个名为 “powershell” 的子文件夹时，这个技巧会失效。在这个例子中，文件资源管理器只会导航到该目录中。","text":"一个在文件资源管理器中快速启动 PowerShell 的办法是导航到您数据的文件夹，然后点击导航条。这时导航面包屑控件变成了文件夹路径。将它改为 “powershell”，并按下回车键。 这时会打开 PowerShell，并且当前文件夹会设置为您导航到的文件夹。 不过，当前路径下有一个名为 “powershell” 的子文件夹时，这个技巧会失效。在这个例子中，文件资源管理器只会导航到该目录中。 本文国际来源：Opening PowerShell Inside Explorer","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 隐藏进度条","slug":"hiding-progress-bars","date":"2017-01-19T08:00:00.000Z","updated":"2017-03-17T15:26:27.514Z","comments":true,"path":"2017/01/19/hiding-progress-bars/","link":"","permalink":"http://blog.vichamp.com/2017/01/19/hiding-progress-bars/","excerpt":"有些 cmdlet 和脚本使用进度条来指示进度。如您在前一个技能中所学的，进度条可能会导致延迟，所以如果您如果不想指示进度，您可能会希望隐藏进度条。以下是实现方法： 以下代码从互联网下载一张图片。Invoke-WebRequest 处理耗时的操作并且在下载时显示一个进度条： 12345678#requires -Version 3.0$path = \"$home\\Pictures\\psconf15.jpg\"$url = 'http://www.powertheshell.com/wp-content/uploads/groupWPK2015.jpg'Invoke-WebRequest -Uri $url -OutFile $path Invoke-Item -Path $path 如果您不想显示进度条，请使用 $ProgressPreference 变量，临时隐藏进度条。请注意代码是如何用大括号包裹起来，并且用 ”&amp;“ 号执行的。通过这种方法，当代码执行完毕后，所有在大括号中改变的变量都会被忽略，所以您不需要将 $ProgressPreference 变量重置为原来的值。 1234567891011#requires -Version 3.0&amp; &#123; $ProgressPreference = 'SilentlyContinue' $path = \"$home\\Pictures\\psconf15.jpg\" $url = 'http://www.powertheshell.com/wp-content/uploads/groupWPK2015.jpg' Invoke-WebRequest -Uri $url -OutFile $path &#125;Invoke-Item -Path $path","text":"有些 cmdlet 和脚本使用进度条来指示进度。如您在前一个技能中所学的，进度条可能会导致延迟，所以如果您如果不想指示进度，您可能会希望隐藏进度条。以下是实现方法： 以下代码从互联网下载一张图片。Invoke-WebRequest 处理耗时的操作并且在下载时显示一个进度条： 12345678#requires -Version 3.0$path = \"$home\\Pictures\\psconf15.jpg\"$url = 'http://www.powertheshell.com/wp-content/uploads/groupWPK2015.jpg'Invoke-WebRequest -Uri $url -OutFile $path Invoke-Item -Path $path 如果您不想显示进度条，请使用 $ProgressPreference 变量，临时隐藏进度条。请注意代码是如何用大括号包裹起来，并且用 ”&amp;“ 号执行的。通过这种方法，当代码执行完毕后，所有在大括号中改变的变量都会被忽略，所以您不需要将 $ProgressPreference 变量重置为原来的值。 1234567891011#requires -Version 3.0&amp; &#123; $ProgressPreference = 'SilentlyContinue' $path = \"$home\\Pictures\\psconf15.jpg\" $url = 'http://www.powertheshell.com/wp-content/uploads/groupWPK2015.jpg' Invoke-WebRequest -Uri $url -OutFile $path &#125;Invoke-Item -Path $path 本文国际来源：Hiding Progress Bars","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 明智地使用进度条","slug":"using-a-progress-bar-wisely","date":"2017-01-18T08:00:00.000Z","updated":"2017-03-17T15:26:27.504Z","comments":true,"path":"2017/01/18/using-a-progress-bar-wisely/","link":"","permalink":"http://blog.vichamp.com/2017/01/18/using-a-progress-bar-wisely/","excerpt":"PowerShell 支持使用进度条。这是一个很简单的例子： 12341..100 | ForEach-Object &#123; Write-Progress -Activity 'Counting' -Status \"Processing $_\" -PercentComplete $_ Start-Sleep -Milliseconds 100&#125; 如果您没有过度使用 Write-Progress，那么使用进度条是很有价值的。特别在一个长时间的循环中，在循环的每一圈中调用一次 Write-Progress 并没有意义。如果那么做，脚本会变得非常慢。 假设您的循环运行 10000 次。显示一个进度条会显著地拖慢脚本： 12345678910111213$min = 1$max = 10000$start = Get-Date$min..$max | ForEach-Object &#123; $percent = $_ * 100 / $max Write-Progress -Activity 'Counting' -Status \"Processing $_\" -PercentComplete $percent&#125;$end = Get-Date($end-$start).TotalMilliseconds 延迟的时间和 Write-Progress 的调用次数直接相关，所以如果您将 $max 的值改为 100000，该脚本会运行 10 倍的时间，只因为 Write-Progress 调用的次数达到 10 倍。 所以您需要使用一种智能的机制来限制 Write-Progress 的次数。以下例子每增加 0.1% 时跟新一次进度条： 1234567891011121314151617181920$min = 1$max = 10000$start = Get-Date# update progress bar every 0.1 %$interval = $max / 1000$min..$max | ForEach-Object &#123; $percent = $_ * 100 / $max if ($_ % $interval -eq 0) &#123; Write-Progress -Activity 'Counting' -Status \"Processing $_\" -PercentComplete $percent &#125;&#125;$end = Get-Date($end-$start).TotalMilliseconds 当您增加 $max 的数值，您会注意到脚本并不会增加多少时间，因为调用 Write-Progress 的次数仍然没变。","text":"PowerShell 支持使用进度条。这是一个很简单的例子： 12341..100 | ForEach-Object &#123; Write-Progress -Activity 'Counting' -Status \"Processing $_\" -PercentComplete $_ Start-Sleep -Milliseconds 100&#125; 如果您没有过度使用 Write-Progress，那么使用进度条是很有价值的。特别在一个长时间的循环中，在循环的每一圈中调用一次 Write-Progress 并没有意义。如果那么做，脚本会变得非常慢。 假设您的循环运行 10000 次。显示一个进度条会显著地拖慢脚本： 12345678910111213$min = 1$max = 10000$start = Get-Date$min..$max | ForEach-Object &#123; $percent = $_ * 100 / $max Write-Progress -Activity 'Counting' -Status \"Processing $_\" -PercentComplete $percent&#125;$end = Get-Date($end-$start).TotalMilliseconds 延迟的时间和 Write-Progress 的调用次数直接相关，所以如果您将 $max 的值改为 100000，该脚本会运行 10 倍的时间，只因为 Write-Progress 调用的次数达到 10 倍。 所以您需要使用一种智能的机制来限制 Write-Progress 的次数。以下例子每增加 0.1% 时跟新一次进度条： 1234567891011121314151617181920$min = 1$max = 10000$start = Get-Date# update progress bar every 0.1 %$interval = $max / 1000$min..$max | ForEach-Object &#123; $percent = $_ * 100 / $max if ($_ % $interval -eq 0) &#123; Write-Progress -Activity 'Counting' -Status \"Processing $_\" -PercentComplete $percent &#125;&#125;$end = Get-Date($end-$start).TotalMilliseconds 当您增加 $max 的数值，您会注意到脚本并不会增加多少时间，因为调用 Write-Progress 的次数仍然没变。 本文国际来源：Using a Progress Bar Wisely","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 批量重命名照片","slug":"bulk-renaming-photos","date":"2017-01-17T08:00:00.000Z","updated":"2017-03-17T15:26:27.494Z","comments":true,"path":"2017/01/17/bulk-renaming-photos/","link":"","permalink":"http://blog.vichamp.com/2017/01/17/bulk-renaming-photos/","excerpt":"以下是一个快速批量重命名文件的方法，可以用于照片或其它文件。请看： 123456#requires -Version 1.0$Path = \"$home\\Pictures\"$Filter = '*.jpg'Get-ChildItem -Path $Path -Filter $Filter | Rename-Item -NewName &#123;$_.name -replace 'DSC','TEST'&#125; 只需要调整路径和过滤器，使之指向所需的文件即可。在这个例子中，照片文件夹中的所有 *.jpg 文件中，关键字 “DSC” 将被替换成 “TEST”。请在使用前将脚本的参数改为您想要的。 要递归地重命名文件，请向 Get-ChildItem 命令添加 -Recurse 参数。但是，请小心。这一小段代码可能会导致一不小心对无数文件重命名。","text":"以下是一个快速批量重命名文件的方法，可以用于照片或其它文件。请看： 123456#requires -Version 1.0$Path = \"$home\\Pictures\"$Filter = '*.jpg'Get-ChildItem -Path $Path -Filter $Filter | Rename-Item -NewName &#123;$_.name -replace 'DSC','TEST'&#125; 只需要调整路径和过滤器，使之指向所需的文件即可。在这个例子中，照片文件夹中的所有 *.jpg 文件中，关键字 “DSC” 将被替换成 “TEST”。请在使用前将脚本的参数改为您想要的。 要递归地重命名文件，请向 Get-ChildItem 命令添加 -Recurse 参数。但是，请小心。这一小段代码可能会导致一不小心对无数文件重命名。 本文国际来源：Bulk Renaming Photos","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 定位锁定的 AD 账户","slug":"identifying-locked-ad-accounts","date":"2017-01-16T08:00:00.000Z","updated":"2017-03-17T15:26:27.491Z","comments":true,"path":"2017/01/16/identifying-locked-ad-accounts/","link":"","permalink":"http://blog.vichamp.com/2017/01/16/identifying-locked-ad-accounts/","excerpt":"在搜索指定的 AD 账户时，您可能曾经用过 Get-ADUser 命令，并且用 filter 参数来过滤结果。不过这样的过滤器可能会变得非常复杂。 这就是为什么针对最常见的 AD 搜索有一个快捷方式。只需要用 Search-ADAccount 命令即可： 123456#requires -Modules ActiveDirectorySearch-ADAccount -AccountDisabled Search-ADAccount -AccountExpiredSearch-ADAccount -AccountInactive Search-ADAccount 暴露一系列参数来搜索最常见的条件。","text":"在搜索指定的 AD 账户时，您可能曾经用过 Get-ADUser 命令，并且用 filter 参数来过滤结果。不过这样的过滤器可能会变得非常复杂。 这就是为什么针对最常见的 AD 搜索有一个快捷方式。只需要用 Search-ADAccount 命令即可： 123456#requires -Modules ActiveDirectorySearch-ADAccount -AccountDisabled Search-ADAccount -AccountExpiredSearch-ADAccount -AccountInactive Search-ADAccount 暴露一系列参数来搜索最常见的条件。 本文国际来源：Identifying Locked AD Accounts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 探索本地账户管理 cmdlet","slug":"exploring-local-account-management-cmdlets","date":"2017-01-15T08:00:00.000Z","updated":"2017-03-17T15:26:27.485Z","comments":true,"path":"2017/01/15/exploring-local-account-management-cmdlets/","link":"","permalink":"http://blog.vichamp.com/2017/01/15/exploring-local-account-management-cmdlets/","excerpt":"PowerShell 5.1（随着 Windows 10 和 Server 2016 发布）现在原生支持管理本地账户。在前一个技能中您学习了如何使用 Get-LocalUser 命令。 要探索本地账户管理的其它 cmdlet，以下是如何识别暴露 Get-LocalUser 命令的模块的方法，然后列出该模块的其它 cmdlet： 12345678#requires -Modules Microsoft.PowerShell.LocalAccounts# find module that defines this cmdlet$module = Get-Command -Name Get-LocalUser | Select-Object -ExpandProperty Source# list all cmdlets defined by this moduleGet-Command -Module $module 最终，列出所有新的管理 cmdlet： 1234567891011121314151617CommandType Name Version Source ----------- ---- ------- ------ Cmdlet Add-LocalGroupMember 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Disable-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Enable-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Get-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Get-LocalGroupMember 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Get-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet New-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet New-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Remove-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Remove-LocalGroupMember 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Remove-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Rename-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Rename-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Set-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Set-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccounts","text":"PowerShell 5.1（随着 Windows 10 和 Server 2016 发布）现在原生支持管理本地账户。在前一个技能中您学习了如何使用 Get-LocalUser 命令。 要探索本地账户管理的其它 cmdlet，以下是如何识别暴露 Get-LocalUser 命令的模块的方法，然后列出该模块的其它 cmdlet： 12345678#requires -Modules Microsoft.PowerShell.LocalAccounts# find module that defines this cmdlet$module = Get-Command -Name Get-LocalUser | Select-Object -ExpandProperty Source# list all cmdlets defined by this moduleGet-Command -Module $module 最终，列出所有新的管理 cmdlet： 1234567891011121314151617CommandType Name Version Source ----------- ---- ------- ------ Cmdlet Add-LocalGroupMember 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Disable-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Enable-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Get-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Get-LocalGroupMember 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Get-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet New-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet New-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Remove-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Remove-LocalGroupMember 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Remove-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Rename-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Rename-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Set-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Set-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccounts 本文国际来源：Exploring Local Account Management Cmdlets","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理本地用户","slug":"managing-local-users","date":"2017-01-12T08:00:00.000Z","updated":"2017-03-17T15:26:27.478Z","comments":true,"path":"2017/01/12/managing-local-users/","link":"","permalink":"http://blog.vichamp.com/2017/01/12/managing-local-users/","excerpt":"PowerShell 5.1 终于发布了管理本地用户账户的 cmdlet。要获取本地用户账户的列表，请使用 Get-LocalUser 并将结果通过管道传给 Select-Object 命令来查看所有属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748PS C:\\&gt; Get-LocalUser | Select-Object -Property *AccountExpires : Description : Predefined Account to manage computer or domainEnabled : FalseFullName : PasswordChangeableDate : PasswordExpires : UserMayChangePassword : TruePasswordRequired : TruePasswordLastSet : 7/10/2015 2:22:01 PMLastLogon : 12/8/2015 5:44:47 AMName : AdministratorSID : S-1-5-21-2012478179-265285931-690539891-500PrincipalSource : LocalObjectClass : UserAccountExpires : Description : User Account managed by systemEnabled : FalseFullName : PasswordChangeableDate : PasswordExpires : UserMayChangePassword : TruePasswordRequired : FalsePasswordLastSet : LastLogon : Name : DefaultAccountSID : S-1-5-21-2012478179-265285931-690539891-503PrincipalSource : LocalObjectClass : UserAccountExpires : Description : Predefined Account for Guest accessEnabled : FalseFullName : PasswordChangeableDate : PasswordExpires : UserMayChangePassword : FalsePasswordRequired : FalsePasswordLastSet : LastLogon : Name : GuestSID : S-1-5-21-2012478179-265285931-690539891-501PrincipalSource : LocalObjectClass : User...","text":"PowerShell 5.1 终于发布了管理本地用户账户的 cmdlet。要获取本地用户账户的列表，请使用 Get-LocalUser 并将结果通过管道传给 Select-Object 命令来查看所有属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748PS C:\\&gt; Get-LocalUser | Select-Object -Property *AccountExpires : Description : Predefined Account to manage computer or domainEnabled : FalseFullName : PasswordChangeableDate : PasswordExpires : UserMayChangePassword : TruePasswordRequired : TruePasswordLastSet : 7/10/2015 2:22:01 PMLastLogon : 12/8/2015 5:44:47 AMName : AdministratorSID : S-1-5-21-2012478179-265285931-690539891-500PrincipalSource : LocalObjectClass : UserAccountExpires : Description : User Account managed by systemEnabled : FalseFullName : PasswordChangeableDate : PasswordExpires : UserMayChangePassword : TruePasswordRequired : FalsePasswordLastSet : LastLogon : Name : DefaultAccountSID : S-1-5-21-2012478179-265285931-690539891-503PrincipalSource : LocalObjectClass : UserAccountExpires : Description : Predefined Account for Guest accessEnabled : FalseFullName : PasswordChangeableDate : PasswordExpires : UserMayChangePassword : FalsePasswordRequired : FalsePasswordLastSet : LastLogon : Name : GuestSID : S-1-5-21-2012478179-265285931-690539891-501PrincipalSource : LocalObjectClass : User... 本文国际来源：Managing Local Users","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取 AD 用户属性","slug":"getting-ad-user-attributes","date":"2017-01-11T08:00:00.000Z","updated":"2017-03-17T15:26:27.475Z","comments":true,"path":"2017/01/11/getting-ad-user-attributes/","link":"","permalink":"http://blog.vichamp.com/2017/01/11/getting-ad-user-attributes/","excerpt":"缺省情况下，Get-ADUser（由 ActiveDirectory 模块提供，该模块是免费的 Microsoft RSAT 工具的一部分）只获取一小部分缺省属性。要获取更多信息，请使用 -Properties 参数，并且指定您需要获取的属性。 要获取所有 AD 用户的列表，以及他们的备注和描述字段，请使用这段代码： #requires -Modules ActiveDirectory Get-ADUser -Filter * -Properties Description, Info 如果你不知道所有可用属性的名字，请使用“*”代替，来获取所有可用的属性。","text":"缺省情况下，Get-ADUser（由 ActiveDirectory 模块提供，该模块是免费的 Microsoft RSAT 工具的一部分）只获取一小部分缺省属性。要获取更多信息，请使用 -Properties 参数，并且指定您需要获取的属性。 要获取所有 AD 用户的列表，以及他们的备注和描述字段，请使用这段代码： #requires -Modules ActiveDirectory Get-ADUser -Filter * -Properties Description, Info 如果你不知道所有可用属性的名字，请使用“*”代替，来获取所有可用的属性。 本文国际来源：Getting AD User Attributes","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 小心 Get-Credential 和 SecureString","slug":"careful-with-get-credential-and-securestrings","date":"2017-01-10T08:00:00.000Z","updated":"2017-03-17T15:26:27.466Z","comments":true,"path":"2017/01/10/careful-with-get-credential-and-securestrings/","link":"","permalink":"http://blog.vichamp.com/2017/01/10/careful-with-get-credential-and-securestrings/","excerpt":"有些时候，脚本以交互的方式询问凭据或密码。请时刻注意脚本的作者可以获取所有输入信息的明文。仅当您信任脚本和作者的时候才可以输入敏感信息。 请注意：这并不是一个 PowerShell 问题，这是所有软件的共同问题。 让我们看看一个脚本如何利用输入的密码。如果一个脚本需要完整的凭据，它可以检查凭据对象并解出密码明文： 1234$credential = Get-Credential$password = $credential.GetNetworkCredential().Password\"The password entered was: $password\" 类似地，当提示您输入密码作为安全字符串时，脚本的作者也能获取到输入的明文： 1234567$password = Read-Host -AsSecureString -Prompt 'Enter Password'# this is how the owner of a secure string can get back the plain text:$BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($password)$plaintext = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)\"The password entered was $plaintext\"","text":"有些时候，脚本以交互的方式询问凭据或密码。请时刻注意脚本的作者可以获取所有输入信息的明文。仅当您信任脚本和作者的时候才可以输入敏感信息。 请注意：这并不是一个 PowerShell 问题，这是所有软件的共同问题。 让我们看看一个脚本如何利用输入的密码。如果一个脚本需要完整的凭据，它可以检查凭据对象并解出密码明文： 1234$credential = Get-Credential$password = $credential.GetNetworkCredential().Password\"The password entered was: $password\" 类似地，当提示您输入密码作为安全字符串时，脚本的作者也能获取到输入的明文： 1234567$password = Read-Host -AsSecureString -Prompt 'Enter Password'# this is how the owner of a secure string can get back the plain text:$BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($password)$plaintext = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)\"The password entered was $plaintext\" 本文国际来源：Careful with Get-Credential and SecureStrings","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理凭据（第五部分）","slug":"managing-credentials-part-5","date":"2017-01-09T08:00:00.000Z","updated":"2017-03-17T15:26:27.461Z","comments":true,"path":"2017/01/09/managing-credentials-part-5/","link":"","permalink":"http://blog.vichamp.com/2017/01/09/managing-credentials-part-5/","excerpt":"当 PowerShell 自动加密一个安全字符串时，它使用您的身份作为密钥。只有您可以解密该安全字符串。而如果您想用一个共享的密码来加密一段安全字符串，会怎么样呢？ 以下是一个经典的做法，用密码来加密： 123456789# $secretKey MUST be of length 8 or 16# anyone who knows the secret can decrypt the password $secretKey = 'mysecretmysecret'$password = 'myPassword'$SecureString = ConvertTo-SecureString -String $password -AsPlainText -Force$RandomSecureString = ConvertTo-SecureString -String $secretKey -AsPlainText -Force$encryptedPassword = ConvertFrom-SecureString -SecureString $SecureString -SecureKey $RandomSecureString$encryptedPassword 该密钥 ($secretKey) 必须是 8 或 16 个字符的文本。任何知道密钥的人都可以解密（这就是为何 secretKey 不应该是脚本的一部分，而下面的脚本下方加入了硬编码的密钥是为了延时解密的过程。最好以交互的方式输入密钥）： 123456789# this is the key to your secret$secretKey = 'mysecretmysecret'# this is the encrypted secret as produced by the former code$encryptedPassword = '76492d1116743f0423413b16050a5345MgB8AEMARQAxAFgAdwBmAHcARQBvAGUAKwBOAGoAYgBzAE4AUgBnAHoARABSAHcAPQA9AHwANQA3ADYAMABjAGYAYQAwAGMANgBkADQAYQBiADYAOAAyAGYAZAA5AGYAMwA5AGYAYQBjADcANQA5ADIAYwAzADkAMAA2ADQANwA1ADcAMQA3ADMAMwBmAGMAMwBlADIAZQBjADcANgAzAGQAYQA1AGIAZABjADYAMgA2AGQANAA='$RandomSecureString = ConvertTo-SecureString -String $secretKey -AsPlainText -Force$securestring = $encryptedPassword | ConvertTo-SecureString -SecureKey $RandomSecureString# Result is a secure string$SecureString 结果是一个安全字符串，您可以用它来构建一个完整的凭据： 12$credential = New-Object -TypeName PSCredential('yourcompany\\youruser', $SecureString)$credential 您也可以再次检查密码明文： PS C:\\Users\\tobwe&gt; $credential.GetNetworkCredential().Password myPassword 请注意安全字符串的所有者（创建它的人）总是可以取回明文形式的密码。这并不是一个安全问题。创建安全字符串的人在过去的时刻已经知道了密码。安全字符串保护第三方的敏感数据，并将它以其他用户无法接触到的形式保存到内存中。 密钥和对称加密算法的问题是您需要分发密钥，而密钥需要被保护，它既可以用来加密也可以用来解密。 在 PowerShell 5 中有一个简单得多的方法：Protect-CMSMessage 和 Unprotect-CMSMessage，它们使用数字证书和非对称加密。通过这种方法，加密安全信息的一方无需知道解密的密钥，反之亦然。加密的一方只需要制定谁（哪个证书）可用来解密保密信息。","text":"当 PowerShell 自动加密一个安全字符串时，它使用您的身份作为密钥。只有您可以解密该安全字符串。而如果您想用一个共享的密码来加密一段安全字符串，会怎么样呢？ 以下是一个经典的做法，用密码来加密： 123456789# $secretKey MUST be of length 8 or 16# anyone who knows the secret can decrypt the password $secretKey = 'mysecretmysecret'$password = 'myPassword'$SecureString = ConvertTo-SecureString -String $password -AsPlainText -Force$RandomSecureString = ConvertTo-SecureString -String $secretKey -AsPlainText -Force$encryptedPassword = ConvertFrom-SecureString -SecureString $SecureString -SecureKey $RandomSecureString$encryptedPassword 该密钥 ($secretKey) 必须是 8 或 16 个字符的文本。任何知道密钥的人都可以解密（这就是为何 secretKey 不应该是脚本的一部分，而下面的脚本下方加入了硬编码的密钥是为了延时解密的过程。最好以交互的方式输入密钥）： 123456789# this is the key to your secret$secretKey = 'mysecretmysecret'# this is the encrypted secret as produced by the former code$encryptedPassword = '76492d1116743f0423413b16050a5345MgB8AEMARQAxAFgAdwBmAHcARQBvAGUAKwBOAGoAYgBzAE4AUgBnAHoARABSAHcAPQA9AHwANQA3ADYAMABjAGYAYQAwAGMANgBkADQAYQBiADYAOAAyAGYAZAA5AGYAMwA5AGYAYQBjADcANQA5ADIAYwAzADkAMAA2ADQANwA1ADcAMQA3ADMAMwBmAGMAMwBlADIAZQBjADcANgAzAGQAYQA1AGIAZABjADYAMgA2AGQANAA='$RandomSecureString = ConvertTo-SecureString -String $secretKey -AsPlainText -Force$securestring = $encryptedPassword | ConvertTo-SecureString -SecureKey $RandomSecureString# Result is a secure string$SecureString 结果是一个安全字符串，您可以用它来构建一个完整的凭据： 12$credential = New-Object -TypeName PSCredential('yourcompany\\youruser', $SecureString)$credential 您也可以再次检查密码明文： PS C:\\Users\\tobwe&gt; $credential.GetNetworkCredential().Password myPassword 请注意安全字符串的所有者（创建它的人）总是可以取回明文形式的密码。这并不是一个安全问题。创建安全字符串的人在过去的时刻已经知道了密码。安全字符串保护第三方的敏感数据，并将它以其他用户无法接触到的形式保存到内存中。 密钥和对称加密算法的问题是您需要分发密钥，而密钥需要被保护，它既可以用来加密也可以用来解密。 在 PowerShell 5 中有一个简单得多的方法：Protect-CMSMessage 和 Unprotect-CMSMessage，它们使用数字证书和非对称加密。通过这种方法，加密安全信息的一方无需知道解密的密钥，反之亦然。加密的一方只需要制定谁（哪个证书）可用来解密保密信息。 本文国际来源：Managing Credentials (Part 5)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理凭据（第四部分）","slug":"managing-credentials-part-4","date":"2017-01-08T08:00:00.000Z","updated":"2017-03-17T15:26:27.449Z","comments":true,"path":"2017/01/08/managing-credentials-part-4/","link":"","permalink":"http://blog.vichamp.com/2017/01/08/managing-credentials-part-4/","excerpt":"在前一个脚本中我们演示了如何以加密的方式将一个凭据保存到磁盘上。一个类似的方法只将密码保存到加密的文件中。这段代码将创建一个加密的密码文件： 123# read in the password, and save it encrypted$text = Read-Host -AsSecureString -Prompt 'Enter Password'$text | Export-Clixml -Path \"$home\\desktop\\mypassword.xml\" 它只能由保存的人读取，而且必须在同一台机子上操作。第二个脚本可以用该密码登录其它系统而无需用户交互： 123456# read in the secret and encrypted password from file$password = Import-Clixml -Path \"$home\\desktop\\mypassword.xml\"# add the username and create a credential object$username = 'yourCompany\\yourUserName'$credential = New-Object -TypeName PSCredential($username, $password) 凭据对象可以用在所有支持 -Credential 参数的 cmdlet 中。 123# use the credential with any cmdlet that exposes the –Credential parameter# to log in to remote systemsGet-WmiObject -Class Win32_LogicalDisk -ComputerName SomeServer -Credential $credential","text":"在前一个脚本中我们演示了如何以加密的方式将一个凭据保存到磁盘上。一个类似的方法只将密码保存到加密的文件中。这段代码将创建一个加密的密码文件： 123# read in the password, and save it encrypted$text = Read-Host -AsSecureString -Prompt 'Enter Password'$text | Export-Clixml -Path \"$home\\desktop\\mypassword.xml\" 它只能由保存的人读取，而且必须在同一台机子上操作。第二个脚本可以用该密码登录其它系统而无需用户交互： 123456# read in the secret and encrypted password from file$password = Import-Clixml -Path \"$home\\desktop\\mypassword.xml\"# add the username and create a credential object$username = 'yourCompany\\yourUserName'$credential = New-Object -TypeName PSCredential($username, $password) 凭据对象可以用在所有支持 -Credential 参数的 cmdlet 中。 123# use the credential with any cmdlet that exposes the –Credential parameter# to log in to remote systemsGet-WmiObject -Class Win32_LogicalDisk -ComputerName SomeServer -Credential $credential 本文国际来源：Managing Credentials (Part 4)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理凭据（第三部分）","slug":"managing-credentials-part-3","date":"2017-01-05T08:00:00.000Z","updated":"2017-03-17T15:26:27.445Z","comments":true,"path":"2017/01/05/managing-credentials-part-3/","link":"","permalink":"http://blog.vichamp.com/2017/01/05/managing-credentials-part-3/","excerpt":"对于无人值守的脚本，以硬编码的方式将密码保存在脚本中是不安全且不推荐的。 有一种替代方法是，您可以一次性提示输入密码，然后创建一个凭据对象，然后在您的脚本中需要的地方使用它。这段代码提示输入一个密码，然后创建一个凭据对象： 123$password = Read-Host -AsSecureString -Prompt 'Enter Password'$username = 'myCompany\\myUserName'$credential = New-Object -TypeName PSCredential($username, $password) 平局对象可以用在任何接受 -Credential 参数的 cmdlet 中。 123# use the credential with any cmdlet that exposes the –Credential parameter# to log in to remote systemsGet-WmiObject -Class Win32_LogicalDisk -ComputerName SomeServer -Credential $credential","text":"对于无人值守的脚本，以硬编码的方式将密码保存在脚本中是不安全且不推荐的。 有一种替代方法是，您可以一次性提示输入密码，然后创建一个凭据对象，然后在您的脚本中需要的地方使用它。这段代码提示输入一个密码，然后创建一个凭据对象： 123$password = Read-Host -AsSecureString -Prompt 'Enter Password'$username = 'myCompany\\myUserName'$credential = New-Object -TypeName PSCredential($username, $password) 平局对象可以用在任何接受 -Credential 参数的 cmdlet 中。 123# use the credential with any cmdlet that exposes the –Credential parameter# to log in to remote systemsGet-WmiObject -Class Win32_LogicalDisk -ComputerName SomeServer -Credential $credential 本文国际来源：Managing Credentials (Part 3)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理凭据（第二部分）","slug":"managing-credentials-part-2","date":"2017-01-04T08:00:00.000Z","updated":"2017-03-17T15:26:27.440Z","comments":true,"path":"2017/01/04/managing-credentials-part-2/","link":"","permalink":"http://blog.vichamp.com/2017/01/04/managing-credentials-part-2/","excerpt":"对于无人值守运行的脚本，您可以从代码创建登录凭据。这需要将密码以明文的方式存在脚本中（这显然是不安全的，除非您用加密文件系统（EFS）加密您的脚本，或是用其它办法来保护内容）： 1234567$password = 'topsecret!' | ConvertTo-SecureString -AsPlainText -Force$username = 'myCompany\\myUserName'$credential = New-Object -TypeName PSCredential($username, $password) # use the credential with any cmdlet that exposes the –Credential parameter# to log in to remote systemsGet-WmiObject -Class Win32_LogicalDisk -ComputerName SomeServer -Credential $credential","text":"对于无人值守运行的脚本，您可以从代码创建登录凭据。这需要将密码以明文的方式存在脚本中（这显然是不安全的，除非您用加密文件系统（EFS）加密您的脚本，或是用其它办法来保护内容）： 1234567$password = 'topsecret!' | ConvertTo-SecureString -AsPlainText -Force$username = 'myCompany\\myUserName'$credential = New-Object -TypeName PSCredential($username, $password) # use the credential with any cmdlet that exposes the –Credential parameter# to log in to remote systemsGet-WmiObject -Class Win32_LogicalDisk -ComputerName SomeServer -Credential $credential 本文国际来源：Managing Credentials (Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理凭据（第一部分）","slug":"managing-credentials-part-1","date":"2017-01-03T08:00:00.000Z","updated":"2017-03-17T15:26:27.431Z","comments":true,"path":"2017/01/03/managing-credentials-part-1/","link":"","permalink":"http://blog.vichamp.com/2017/01/03/managing-credentials-part-1/","excerpt":"假设您每天都要运行一个需要凭据的脚本。一个使用强壮凭据的安全方法是将它们保存到一个加密的文件中。这段代码提示输入凭据，然后将它们保存到您桌面上的 XML 文件中： 12$credential = Get-Credential -UserName train\\user02 -Message 'Please provide credentials' $credential | Export-Clixml -Path \"$home\\desktop\\myCredentials.xml\" 密码是以您的身份加密的，所以只有您（并且只能在保存凭据的机器上）能存取该凭据。 以下是读取保存的凭据的代码： 12345$credential = Import-Clixml -Path \"$home\\desktop\\myCredentials.xml\"# use the credential with any cmdlet that exposes the –Credential parameter# to log in to remote systemsGet-WmiObject -Class Win32_LogicalDisk -ComputerName SomeServer -Credential $credential","text":"假设您每天都要运行一个需要凭据的脚本。一个使用强壮凭据的安全方法是将它们保存到一个加密的文件中。这段代码提示输入凭据，然后将它们保存到您桌面上的 XML 文件中： 12$credential = Get-Credential -UserName train\\user02 -Message 'Please provide credentials' $credential | Export-Clixml -Path \"$home\\desktop\\myCredentials.xml\" 密码是以您的身份加密的，所以只有您（并且只能在保存凭据的机器上）能存取该凭据。 以下是读取保存的凭据的代码： 12345$credential = Import-Clixml -Path \"$home\\desktop\\myCredentials.xml\"# use the credential with any cmdlet that exposes the –Credential parameter# to log in to remote systemsGet-WmiObject -Class Win32_LogicalDisk -ComputerName SomeServer -Credential $credential 本文国际来源：Managing Credentials (Part 1)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 解析纯文本（第三部分）","slug":"parsing-raw-text-part-3","date":"2017-01-02T08:00:00.000Z","updated":"2017-03-17T15:26:27.427Z","comments":true,"path":"2017/01/02/parsing-raw-text-part-3/","link":"","permalink":"http://blog.vichamp.com/2017/01/02/parsing-raw-text-part-3/","excerpt":"在前一个技能中我们演示了如何用 Select-String 在纯文本中查找指定的词。费了一些功夫通过指定的 pattern 来提取实际的值： 1234PS C:\\&gt; $data = ipconfig | select-string 'IPv4' PS C:\\&gt; [regex]::Matches($data,\"\\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b\") | Select-Object -ExpandProperty Value192.168.2.112 不过这些功夫并不是必要的，因为 Select-String 已经在使用正则表达式来做匹配，然后返回匹配的对象。 1234567891011121314151617181920212223242526272829303132PS C:\\&gt; ipconfig | Select-String '\\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b' | Select-Object -Property * IgnoreCase : True LineNumber : 16 Line : IPv4 Address. . . . . . . . . . . : 192.168.2.112 Filename : InputStream Path : InputStream Pattern : \\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b Context : Matches : &#123;192.168.2.112&#125; IgnoreCase : True LineNumber : 17 Line : Subnet Mask . . . . . . . . . . . : 255.255.255.0 Filename : InputStream Path : InputStream Pattern : \\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b Context : Matches : &#123;255.255.255.0&#125; IgnoreCase : True LineNumber : 19 Line : 192.168.2.1 Filename : InputStream Path : InputStream Pattern : \\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b Context : Matches : &#123;192.168.2.1&#125; 所以您可以简单地使用 Where-Object 和类似 -like 的操作符来预过滤，识别出只包含感兴趣内容的行（例如只包含 “IPV4” 的行），然后将一个正则表达式 pattern 传给 Select-String，并计算最终结果： 1234567891011PS C:\\&gt; ipconfig | # do raw prefiltering and get only lines containing this word Where-Object &#123; $_ -like '*IPv4*' &#125; | # do RegEx filtering using a pattern for IPv4 addresses Select-String '\\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b' | # get the matching values Select-Object -ExpandProperty Matches | # get the value for each match Select-Object -ExpandProperty Value192.168.2.112","text":"在前一个技能中我们演示了如何用 Select-String 在纯文本中查找指定的词。费了一些功夫通过指定的 pattern 来提取实际的值： 1234PS C:\\&gt; $data = ipconfig | select-string 'IPv4' PS C:\\&gt; [regex]::Matches($data,\"\\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b\") | Select-Object -ExpandProperty Value192.168.2.112 不过这些功夫并不是必要的，因为 Select-String 已经在使用正则表达式来做匹配，然后返回匹配的对象。 1234567891011121314151617181920212223242526272829303132PS C:\\&gt; ipconfig | Select-String '\\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b' | Select-Object -Property * IgnoreCase : True LineNumber : 16 Line : IPv4 Address. . . . . . . . . . . : 192.168.2.112 Filename : InputStream Path : InputStream Pattern : \\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b Context : Matches : &#123;192.168.2.112&#125; IgnoreCase : True LineNumber : 17 Line : Subnet Mask . . . . . . . . . . . : 255.255.255.0 Filename : InputStream Path : InputStream Pattern : \\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b Context : Matches : &#123;255.255.255.0&#125; IgnoreCase : True LineNumber : 19 Line : 192.168.2.1 Filename : InputStream Path : InputStream Pattern : \\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b Context : Matches : &#123;192.168.2.1&#125; 所以您可以简单地使用 Where-Object 和类似 -like 的操作符来预过滤，识别出只包含感兴趣内容的行（例如只包含 “IPV4” 的行），然后将一个正则表达式 pattern 传给 Select-String，并计算最终结果： 1234567891011PS C:\\&gt; ipconfig | # do raw prefiltering and get only lines containing this word Where-Object &#123; $_ -like '*IPv4*' &#125; | # do RegEx filtering using a pattern for IPv4 addresses Select-String '\\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b' | # get the matching values Select-Object -ExpandProperty Matches | # get the value for each match Select-Object -ExpandProperty Value192.168.2.112 本文国际来源：Parsing Raw Text (Part 3)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 解析纯文本（第二部分）","slug":"parsing-raw-text-part-2","date":"2017-01-01T08:00:00.000Z","updated":"2017-03-17T15:26:27.417Z","comments":true,"path":"2017/01/01/parsing-raw-text-part-2/","link":"","permalink":"http://blog.vichamp.com/2017/01/01/parsing-raw-text-part-2/","excerpt":"在前一个技能中我们解释了如何使用 Select-String 和正则表达式从纯文本结果中提取有用的信息： 1234PS C:\\&gt; $data = ipconfig | select-string 'IPv4' PS C:\\&gt; [regex]::Matches($data,\"\\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b\") | Select-Object -ExpandProperty Value192.168.2.112 PowerShell 支持 -match 参数，它也能够处理正则表达式。不过它在一行里只能找到一个匹配项。在多数场景中这也不是大问题，因为一行中通常只包含了一个匹配项。您所做的只需要在管道中使用 -match，则原始的数据会逐行地输入： 123456789PS C:\\&gt; ipconfig | # do raw filtering to only get lines with this word Where-Object &#123; $_ -like '*IPv4*' &#125; | # do RegEx filtering to identify the value matching the pattern Where-Object &#123; $_ -match '\\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b' &#125; | # return the results from -match which show in $matches Foreach-Object &#123; $matches[0] &#125;192.168.2.112","text":"在前一个技能中我们解释了如何使用 Select-String 和正则表达式从纯文本结果中提取有用的信息： 1234PS C:\\&gt; $data = ipconfig | select-string 'IPv4' PS C:\\&gt; [regex]::Matches($data,\"\\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b\") | Select-Object -ExpandProperty Value192.168.2.112 PowerShell 支持 -match 参数，它也能够处理正则表达式。不过它在一行里只能找到一个匹配项。在多数场景中这也不是大问题，因为一行中通常只包含了一个匹配项。您所做的只需要在管道中使用 -match，则原始的数据会逐行地输入： 123456789PS C:\\&gt; ipconfig | # do raw filtering to only get lines with this word Where-Object &#123; $_ -like '*IPv4*' &#125; | # do RegEx filtering to identify the value matching the pattern Where-Object &#123; $_ -match '\\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b' &#125; | # return the results from -match which show in $matches Foreach-Object &#123; $matches[0] &#125;192.168.2.112 本文国际来源：Parsing Raw Text (Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 解析纯文本（第一部分）","slug":"parsing-raw-text-part-1","date":"2016-12-29T08:00:00.000Z","updated":"2017-03-17T15:26:27.410Z","comments":true,"path":"2016/12/29/parsing-raw-text-part-1/","link":"","permalink":"http://blog.vichamp.com/2016/12/29/parsing-raw-text-part-1/","excerpt":"有些时候，您可能希望从纯文本结果中提取一些有用的信息。一个简单的办法是使用 Select-String 命令。这个例子只提取包含“IPv4”的文本行： 123PS C:\\&gt; ipconfig | Select-String 'IPv4' IPv4 Address. . . . . . . . . . . : 192.168.2.112 如果您只对实际的 IP 地址感兴趣，您可以改进这个结果，用正则表达式来提取您感兴趣的部分： 1234PS C:\\&gt; $data = ipconfig | select-string 'IPv4' PS C:\\&gt; [regex]::Matches($data,\"\\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b\") | Select-Object -ExpandProperty Value192.168.2.112 [Regex]::Matches() 输入原始数据和正则表达式 pattern，后者描述了您感兴趣的部分。符合该 pattern 的内容可以在“Value”属性中找到。","text":"有些时候，您可能希望从纯文本结果中提取一些有用的信息。一个简单的办法是使用 Select-String 命令。这个例子只提取包含“IPv4”的文本行： 123PS C:\\&gt; ipconfig | Select-String 'IPv4' IPv4 Address. . . . . . . . . . . : 192.168.2.112 如果您只对实际的 IP 地址感兴趣，您可以改进这个结果，用正则表达式来提取您感兴趣的部分： 1234PS C:\\&gt; $data = ipconfig | select-string 'IPv4' PS C:\\&gt; [regex]::Matches($data,\"\\b(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;\\b\") | Select-Object -ExpandProperty Value192.168.2.112 [Regex]::Matches() 输入原始数据和正则表达式 pattern，后者描述了您感兴趣的部分。符合该 pattern 的内容可以在“Value”属性中找到。 本文国际来源：Parsing Raw Text (Part 1)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 调整简单界面","slug":"adjusting-simple-uis","date":"2016-12-28T08:00:00.000Z","updated":"2017-03-17T15:26:27.403Z","comments":true,"path":"2016/12/28/adjusting-simple-uis/","link":"","permalink":"http://blog.vichamp.com/2016/12/28/adjusting-simple-uis/","excerpt":"在前一个技能中您学到了如何使用 Show-Command 为基于文本的命令创建简单的 UI： 12345678#requires -Version 3.0function Send-MailMessageUI&#123; Show-Command -Name Send-MailMessage&#125;Send-MailMessageUI 如果您想调整 UI 中显示的参数的个数，只需要编写您自己的函数即可。 在下面的例子中，Send-MailMessage 被包裹在一个自定义的函数中，并只暴露其中的某些属性，然后在内部初始化其它的属性（例如 SMTP 服务器和凭据）。 以下是一个非常简单的 email 发送函数，只显示发送 email 的文本框： 1234567891011121314151617181920212223242526272829303132333435363738394041#requires -Version 3.0function Send-MailMessageCustomized&#123; param ( [Parameter(Mandatory)] [string] $From, [Parameter(Mandatory)] [string] $To, [Parameter(Mandatory)] [string] $Subject, [Parameter(Mandatory)] [string] $building, [switch] $BodyAsHTML ) $username = 'mymailusername' $password = 'mymailpassword' # Dangerous, never hardcode! Consider using Get-Credential instead. $myServer = 'mail.mymailserver.mycompany.com' $passwordSecure = $password | ConvertTo-SecureString -AsPlainText -Force $myCred = New-Object -TypeName PSCredential($username, $passwordSecure) Send-MailMessage -From $From -To $To -Subject $Subject -building $building -BodyAsHtml:$BodyAsHTML -SmtpServer $myServer -Encoding UTF8 -Credential $myCred&#125;function Send-MailMessageUI&#123; Show-Command -Name Send-MailMessageCustomized&#125;Send-MailMessageUI","text":"在前一个技能中您学到了如何使用 Show-Command 为基于文本的命令创建简单的 UI： 12345678#requires -Version 3.0function Send-MailMessageUI&#123; Show-Command -Name Send-MailMessage&#125;Send-MailMessageUI 如果您想调整 UI 中显示的参数的个数，只需要编写您自己的函数即可。 在下面的例子中，Send-MailMessage 被包裹在一个自定义的函数中，并只暴露其中的某些属性，然后在内部初始化其它的属性（例如 SMTP 服务器和凭据）。 以下是一个非常简单的 email 发送函数，只显示发送 email 的文本框： 1234567891011121314151617181920212223242526272829303132333435363738394041#requires -Version 3.0function Send-MailMessageCustomized&#123; param ( [Parameter(Mandatory)] [string] $From, [Parameter(Mandatory)] [string] $To, [Parameter(Mandatory)] [string] $Subject, [Parameter(Mandatory)] [string] $building, [switch] $BodyAsHTML ) $username = 'mymailusername' $password = 'mymailpassword' # Dangerous, never hardcode! Consider using Get-Credential instead. $myServer = 'mail.mymailserver.mycompany.com' $passwordSecure = $password | ConvertTo-SecureString -AsPlainText -Force $myCred = New-Object -TypeName PSCredential($username, $passwordSecure) Send-MailMessage -From $From -To $To -Subject $Subject -building $building -BodyAsHtml:$BodyAsHTML -SmtpServer $myServer -Encoding UTF8 -Credential $myCred&#125;function Send-MailMessageUI&#123; Show-Command -Name Send-MailMessageCustomized&#125;Send-MailMessageUI 本文国际来源：Adjusting Simple UIs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建简单的 UI","slug":"creating-simple-uis","date":"2016-12-27T08:00:00.000Z","updated":"2017-03-17T15:26:27.396Z","comments":true,"path":"2016/12/27/creating-simple-uis/","link":"","permalink":"http://blog.vichamp.com/2016/12/27/creating-simple-uis/","excerpt":"函数和 cmdlet 参数是 PowerShell 提供的基础功能，这些文本界面可以轻松地转换成图形界面。 如果您想发送一条消息，您可以使用 Send-MailMessage 并通过文本参数的方式提交细节信息。或者，您可以创建一个图形界面，并将它命名为 Send-MailMessageUI： 12345678#requires -Version 3.0 function Send-MailMessageUI &#123; Show-Command -Name Send-MailMessage &#125; ​ Send-MailMessageUI 现在，您可以运行 Send-MailMessageUI，所有参数都将变成文本框和复选框。甚至不会脚本开发的人现在也能填写这个表单，然后点击“运行”来执行命令。","text":"函数和 cmdlet 参数是 PowerShell 提供的基础功能，这些文本界面可以轻松地转换成图形界面。 如果您想发送一条消息，您可以使用 Send-MailMessage 并通过文本参数的方式提交细节信息。或者，您可以创建一个图形界面，并将它命名为 Send-MailMessageUI： 12345678#requires -Version 3.0 function Send-MailMessageUI &#123; Show-Command -Name Send-MailMessage &#125; ​ Send-MailMessageUI 现在，您可以运行 Send-MailMessageUI，所有参数都将变成文本框和复选框。甚至不会脚本开发的人现在也能填写这个表单，然后点击“运行”来执行命令。 本文国际来源：Creating Simple UIs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 扩展 Robocopy","slug":"extending-robocopy","date":"2016-12-26T08:00:00.000Z","updated":"2017-03-17T15:26:27.388Z","comments":true,"path":"2016/12/26/extending-robocopy/","link":"","permalink":"http://blog.vichamp.com/2016/12/26/extending-robocopy/","excerpt":"PowerShell 可以向原有的命令（例如 robocopy）添加值。请看以下的函数——它用 robocopy 来拷贝文件，并且当拷贝完成时，增加了“扁平拷贝”选项来打开目标文件夹： 12345678910111213141516171819202122232425262728293031323334353637383940414243#requires -Version 3.0function Copy-FileWithRobocopy&#123; param ( [Parameter(Mandatory)] [string]$Source, [Parameter(Mandatory)] [string]$Destination, [string]$Filter = '*', [int]$RetryCount = 0, [string]$ExcludeDirectory = '', [switch]$Open, [switch]$FlatCopy, [switch]$NoRecurse ) $Recurse = '/S' if ($NoRecurse) &#123; $Recurse = '' &#125; robocopy.exe $Source $Destination $Filter /R:$RetryCount $Recurse /XD $ExcludeDirectory if ($FlatCopy) &#123; Get-ChildItem -Path $Destination -Recurse -Filter $Filter | Move-Item -Destination $Destination -Force Get-ChildItem -Path $Destination -Directory | Remove-Item -Recurse -Force &#125; if ($Open) &#123; explorer $Destination &#125;&#125; 这将会把 Windows 文件夹下所有子文件夹中的 log 文件拷贝到名为 c:\\\\logs 的新文件夹，并且执行扁平化拷贝： 1PS&gt; Copy-FileWithRobocopy -Source $env:windir -Destination c:\\logs -Filter *.log -FlatCopy -Open 当您在生产系统使用这段代码之前，请观察 -FlatCopy 是如何工作的：它只是在目标文件夹中查找匹配指定的过滤器，然后将它们移到根目录，最后删除所有文件夹。 所以重复的文件将会被覆盖，而且如果目标文件夹的子文件夹中有其他数据，也会被删除。这是一个很简单的操作，适用于许多情况，但也有很多改进空间。","text":"PowerShell 可以向原有的命令（例如 robocopy）添加值。请看以下的函数——它用 robocopy 来拷贝文件，并且当拷贝完成时，增加了“扁平拷贝”选项来打开目标文件夹： 12345678910111213141516171819202122232425262728293031323334353637383940414243#requires -Version 3.0function Copy-FileWithRobocopy&#123; param ( [Parameter(Mandatory)] [string]$Source, [Parameter(Mandatory)] [string]$Destination, [string]$Filter = '*', [int]$RetryCount = 0, [string]$ExcludeDirectory = '', [switch]$Open, [switch]$FlatCopy, [switch]$NoRecurse ) $Recurse = '/S' if ($NoRecurse) &#123; $Recurse = '' &#125; robocopy.exe $Source $Destination $Filter /R:$RetryCount $Recurse /XD $ExcludeDirectory if ($FlatCopy) &#123; Get-ChildItem -Path $Destination -Recurse -Filter $Filter | Move-Item -Destination $Destination -Force Get-ChildItem -Path $Destination -Directory | Remove-Item -Recurse -Force &#125; if ($Open) &#123; explorer $Destination &#125;&#125; 这将会把 Windows 文件夹下所有子文件夹中的 log 文件拷贝到名为 c:\\\\logs 的新文件夹，并且执行扁平化拷贝： 1PS&gt; Copy-FileWithRobocopy -Source $env:windir -Destination c:\\logs -Filter *.log -FlatCopy -Open 当您在生产系统使用这段代码之前，请观察 -FlatCopy 是如何工作的：它只是在目标文件夹中查找匹配指定的过滤器，然后将它们移到根目录，最后删除所有文件夹。 所以重复的文件将会被覆盖，而且如果目标文件夹的子文件夹中有其他数据，也会被删除。这是一个很简单的操作，适用于许多情况，但也有很多改进空间。 本文国际来源：Extending Robocopy","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 复制着色过的代码","slug":"copy-color-coded-code","date":"2016-12-25T08:00:00.000Z","updated":"2017-03-17T15:26:27.381Z","comments":true,"path":"2016/12/25/copy-color-coded-code/","link":"","permalink":"http://blog.vichamp.com/2016/12/25/copy-color-coded-code/","excerpt":"当您在 PowerShell ISE 中选中一段代码并复制到剪贴板时，它是以 RTF 格式复制的并且保留了所有颜色代码和字体信息。您可以将它粘贴到支持 RTF 的应用程序，例如 Word 中，就可以看到格式化并着色好的 PowerShell 代码。 要调节字体大小，您不能用 PowerShell ISE 右下角的滑块。这个滑块只是改变 PowerShell ISE 中的字体大小，并不会影响复制的代码字体大小。 正确的方法是，在 PowerShell ISE 中，选择工具/选项，然后在选项对话框中调节字体大小。","text":"当您在 PowerShell ISE 中选中一段代码并复制到剪贴板时，它是以 RTF 格式复制的并且保留了所有颜色代码和字体信息。您可以将它粘贴到支持 RTF 的应用程序，例如 Word 中，就可以看到格式化并着色好的 PowerShell 代码。 要调节字体大小，您不能用 PowerShell ISE 右下角的滑块。这个滑块只是改变 PowerShell ISE 中的字体大小，并不会影响复制的代码字体大小。 正确的方法是，在 PowerShell ISE 中，选择工具/选项，然后在选项对话框中调节字体大小。 本文国际来源：Copy Color-Coded Code","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 PowerShell 中创建 WinForms GUI 界面","slug":"creating-winforms-guis-in-powershell","date":"2016-12-22T08:00:00.000Z","updated":"2017-03-17T15:26:27.378Z","comments":true,"path":"2016/12/22/creating-winforms-guis-in-powershell/","link":"","permalink":"http://blog.vichamp.com/2016/12/22/creating-winforms-guis-in-powershell/","excerpt":"虽然建议使用更现代的 WPF 技术来创建 PowerShell 用户界面，但您在某些时候仍然会希望使用更早的 WinForms 技术。特别是要在没有安装 .NET framework 3.51 及以上版本的机器上运行时。WinForms 用户界面需要很多代码，而且不是那么直观。 所以这里提供一个免费的 PowerShell 在线图形设计器，可以快速地创建代码： http://www.poshgui.com/","text":"虽然建议使用更现代的 WPF 技术来创建 PowerShell 用户界面，但您在某些时候仍然会希望使用更早的 WinForms 技术。特别是要在没有安装 .NET framework 3.51 及以上版本的机器上运行时。WinForms 用户界面需要很多代码，而且不是那么直观。 所以这里提供一个免费的 PowerShell 在线图形设计器，可以快速地创建代码： http://www.poshgui.com/ 本文国际来源：Creating WinForms GUIs in PowerShell","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用“Exit”和 Linux 通信","slug":"using-exit-to-communicate-with-linux","date":"2016-12-21T08:00:00.000Z","updated":"2017-03-17T15:26:27.374Z","comments":true,"path":"2016/12/21/using-exit-to-communicate-with-linux/","link":"","permalink":"http://blog.vichamp.com/2016/12/21/using-exit-to-communicate-with-linux/","excerpt":"当一个 PowerShell 脚本结束时，您可以使用“Exit”命令来返回一个数值。这在 Windows 世界中是一个很好的实践。它能够设置“Error Level”值，并能够被调用者（例如一个批处理文件或是定时任务管理器）读取到。 1exit 99 既然 PowerShell 在 Linux 上也可以运行，它也可以用来报告调用 Linux 进程的状态值。","text":"当一个 PowerShell 脚本结束时，您可以使用“Exit”命令来返回一个数值。这在 Windows 世界中是一个很好的实践。它能够设置“Error Level”值，并能够被调用者（例如一个批处理文件或是定时任务管理器）读取到。 1exit 99 既然 PowerShell 在 Linux 上也可以运行，它也可以用来报告调用 Linux 进程的状态值。 本文国际来源：Using “Exit” to Communicate with Linux","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 捕获 Linux 输出","slug":"capturing-linux-output","date":"2016-12-20T08:00:00.000Z","updated":"2017-03-17T15:26:27.370Z","comments":true,"path":"2016/12/20/capturing-linux-output/","link":"","permalink":"http://blog.vichamp.com/2016/12/20/capturing-linux-output/","excerpt":"如果您在 Linux 上运行 PowerShell，您可以混合使用 Linux 命令和 PowerShell 命令。要将 Linux 命令的输出赋值给 PowerShell 变量，请像这样写： 1$content = (ls) 请注意“ls”在 Windows 系统上是一个别名，但在 Linux 系统上指向的是原始的 ls 命令。","text":"如果您在 Linux 上运行 PowerShell，您可以混合使用 Linux 命令和 PowerShell 命令。要将 Linux 命令的输出赋值给 PowerShell 变量，请像这样写： 1$content = (ls) 请注意“ls”在 Windows 系统上是一个别名，但在 Linux 系统上指向的是原始的 ls 命令。 本文国际来源：Capturing Linux Output","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"Drone Resources","slug":"Drone-Resources","date":"2016-12-19T13:00:01.000Z","updated":"2017-03-17T15:26:27.354Z","comments":true,"path":"2016/12/19/Drone-Resources/","link":"","permalink":"http://blog.vichamp.com/2016/12/19/Drone-Resources/","excerpt":"","text":"DJI 大疆 DJI Developer DJI PC Simulator Installer &amp; User Manual 【新手必看】DJI 官方教程、网友经验分享合集（更新于11.22) 3rd Party 第三方 Altizure 用无人机创建三维世界 玩出新高度，Altizure 手把手教你航拍三维建模-Altizure-大不六文章网(wtoutiao.com) Aerial Photography 航拍 电影，纪录片，真人秀，分别该如何航拍？ - 乔岩的回答 - 知乎","categories":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/categories/geek/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"drone","slug":"drone","permalink":"http://blog.vichamp.com/tags/drone/"}],"keywords":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/categories/geek/"}]},{"title":"PowerShell 技能连载 - 检测文件或文件夹","slug":"test-for-file-or-folder","date":"2016-12-19T08:00:00.000Z","updated":"2017-03-17T15:26:27.367Z","comments":true,"path":"2016/12/19/test-for-file-or-folder/","link":"","permalink":"http://blog.vichamp.com/2016/12/19/test-for-file-or-folder/","excerpt":"Test-Path 可以检测一个文件或文件夹是否存在。如果您添加了 -PathType 来指定叶子节点（文件），或 -Container（文件夹），结果会更具体： 123456$path = 'c:\\windows'Test-Path -Path $pathTest-Path -Path $path -PathType LeafTest-Path -Path $path -PathType Container`","text":"Test-Path 可以检测一个文件或文件夹是否存在。如果您添加了 -PathType 来指定叶子节点（文件），或 -Container（文件夹），结果会更具体： 123456$path = 'c:\\windows'Test-Path -Path $pathTest-Path -Path $path -PathType LeafTest-Path -Path $path -PathType Container` 本文国际来源：Test for File or Folder","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 系统内存、单位和四舍五入","slug":"system-memory-units-and-rounding","date":"2016-12-18T08:00:00.000Z","updated":"2017-03-17T15:26:27.360Z","comments":true,"path":"2016/12/18/system-memory-units-and-rounding/","link":"","permalink":"http://blog.vichamp.com/2016/12/18/system-memory-units-and-rounding/","excerpt":"有些时候，您可能会需要不同的度量单位。例如整个系统的内存是以字节计算的。以下是一些将字节转换为 GB 并且仍然保证可读性的例子： 123456789101112131415$memory = Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty TotalPhysicalMemory$memoryGB = $memory/1GB# raw result in bytes$memoryGB# rounding[Int]$memoryGB[Math]::Round($memoryGB)[Math]::Round($memoryGB, 1)# string formatting'&#123;0:n1&#125; GB' -f $memoryGB 结果看起来类似如下： 15.8744087219238 16 16 15.9 15.9 GB","text":"有些时候，您可能会需要不同的度量单位。例如整个系统的内存是以字节计算的。以下是一些将字节转换为 GB 并且仍然保证可读性的例子： 123456789101112131415$memory = Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty TotalPhysicalMemory$memoryGB = $memory/1GB# raw result in bytes$memoryGB# rounding[Int]$memoryGB[Math]::Round($memoryGB)[Math]::Round($memoryGB, 1)# string formatting'&#123;0:n1&#125; GB' -f $memoryGB 结果看起来类似如下： 15.8744087219238 16 16 15.9 15.9 GB 本文国际来源：System Memory, Units, and Rounding","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建 Time Span","slug":"creating-time-spans1","date":"2016-12-15T08:00:00.000Z","updated":"2017-03-17T15:26:27.348Z","comments":true,"path":"2016/12/15/creating-time-spans1/","link":"","permalink":"http://blog.vichamp.com/2016/12/15/creating-time-spans1/","excerpt":"您可以用 New-TimeSpan 来定义时间的“量”，然后对某个日期增加或减少这个量。以下是一个例子： 12345$1Day = New-TimeSpan -Days 1$today = Get-Date$yesterday = $today - $1Day$yesterday 更简单的办法是使用 DateTime 对象的内置方法： 1234$today = Get-Date$yesterday = $today.AddDays(-1)$yesterday 您也可以使用 TimeSpan .NET 类来创建 time span 对象： 1234567891011121314PS C:\\&gt; [Timespan]::FromDays(1)​ Days : 1Hours : 0Minutes : 0Seconds : 0Milliseconds : 0Ticks : 864000000000TotalDays : 1TotalHours : 24TotalMinutes : 1440TotalSeconds : 86400TotalMilliseconds : 86400000","text":"您可以用 New-TimeSpan 来定义时间的“量”，然后对某个日期增加或减少这个量。以下是一个例子： 12345$1Day = New-TimeSpan -Days 1$today = Get-Date$yesterday = $today - $1Day$yesterday 更简单的办法是使用 DateTime 对象的内置方法： 1234$today = Get-Date$yesterday = $today.AddDays(-1)$yesterday 您也可以使用 TimeSpan .NET 类来创建 time span 对象： 1234567891011121314PS C:\\&gt; [Timespan]::FromDays(1)​ Days : 1Hours : 0Minutes : 0Seconds : 0Milliseconds : 0Ticks : 864000000000TotalDays : 1TotalHours : 24TotalMinutes : 1440TotalSeconds : 86400TotalMilliseconds : 86400000 本文国际来源：Creating Time Spans","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"图片网站集合","slug":"picture-site-collection","date":"2016-12-15T07:54:53.000Z","updated":"2017-03-17T15:26:27.338Z","comments":true,"path":"2016/12/15/picture-site-collection/","link":"","permalink":"http://blog.vichamp.com/2016/12/15/picture-site-collection/","excerpt":"","text":"综合 Google 图片 百度图片 必应图像 专业 花瓣 Pinterest Shutterstock 含优秀图标 图标 图标搜索引擎 - findicons Iconfinder IcoMoon App","categories":[{"name":"design","slug":"design","permalink":"http://blog.vichamp.com/categories/design/"}],"tags":[{"name":"picture","slug":"picture","permalink":"http://blog.vichamp.com/tags/picture/"},{"name":"icon","slug":"icon","permalink":"http://blog.vichamp.com/tags/icon/"},{"name":"gallery","slug":"gallery","permalink":"http://blog.vichamp.com/tags/gallery/"}],"keywords":[{"name":"design","slug":"design","permalink":"http://blog.vichamp.com/categories/design/"}]},{"title":"PowerShell 技能连载 - 等待进程退出","slug":"waiting-for-processes-to-exit","date":"2016-12-14T08:00:00.000Z","updated":"2017-03-17T15:26:27.342Z","comments":true,"path":"2016/12/14/waiting-for-processes-to-exit/","link":"","permalink":"http://blog.vichamp.com/2016/12/14/waiting-for-processes-to-exit/","excerpt":"有时候，一个 PowerShell 脚本需要等待外部进程结束。以下是一些用户的做法： 12345$processNameToWaitForExit = 'notepad'do&#123; Start-Sleep -Seconds 1&#125; while (Get-Process -Name $processNameToWaitForExit -ErrorAction SilentlyContinue) 这种做法不太理想，因为它至少等待了一秒钟，即便进程已经不在运行了。以下是一个更好的方法： 12$processNameToWaitForExit = 'notepad'Wait-Process -Name $processNameToWaitForExit -ErrorAction SilentlyContinue 不仅代码更短，Wait-Process 也支持超时时间。如果等待的时间过长，您可以通过超时时间来结束等待。","text":"有时候，一个 PowerShell 脚本需要等待外部进程结束。以下是一些用户的做法： 12345$processNameToWaitForExit = 'notepad'do&#123; Start-Sleep -Seconds 1&#125; while (Get-Process -Name $processNameToWaitForExit -ErrorAction SilentlyContinue) 这种做法不太理想，因为它至少等待了一秒钟，即便进程已经不在运行了。以下是一个更好的方法： 12$processNameToWaitForExit = 'notepad'Wait-Process -Name $processNameToWaitForExit -ErrorAction SilentlyContinue 不仅代码更短，Wait-Process 也支持超时时间。如果等待的时间过长，您可以通过超时时间来结束等待。 本文国际来源：Waiting for Processes to Exit","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 对启用 PIN 的用户使用 PowerShell Remoting","slug":"using-powershell-remoting-with-pin-enabled-accounts","date":"2016-12-13T08:00:00.000Z","updated":"2017-03-17T15:26:27.329Z","comments":true,"path":"2016/12/13/using-powershell-remoting-with-pin-enabled-accounts/","link":"","permalink":"http://blog.vichamp.com/2016/12/13/using-powershell-remoting-with-pin-enabled-accounts/","excerpt":"如果您设置了 PIN 用来登录您的电脑，对您自己的机器使用 PowerShell remoting 可能会失败，提示如下奇怪的错误信息： 12345678910111213141516PS C:\\&gt; Invoke-Command &#123; \"Hello\" &#125; -ComputerName $env:computername [DESKTOP-7AAMJLF] Connecting to remote server DESKTOP-7AAMJLF failed with the following error message : WinRM cannot process the request. The following error with errorcode 0x8009030e occurred while using Negotiate authentication: A specified logon session does not exist. It may already have been terminated. Possible causes are: -The user name or password specified are invalid. -Kerberos is used when no authentication method and no user name are specified. -Kerberos accepts domain user names, but not local user names. -The Service Principal Name (SPN) for the remote computer name and port does not exist. -The client and remote computers are in different domains and there is no trust between the two domains. After checking for the above issues, try the following: -Check the Event Viewer for events related to authentication. -Change the authentication method; add the destination computer to the WinRM TrustedHosts configuration setting or use HTTPS transport. Note that computers in the TrustedHosts list might not be authenticated. -For more information about WinRM configuration, run the following command: winrm help config. For more information, see the about_Remote_Troubleshooting Help topic. + CategoryInfo : OpenError: (DESKTOP-7AAMJLF:String) [], PSRemotingTransportException + FullyQualifiedErrorId : 1312,PSSessionStateBroken 要解决这个问题，您可以有两个选择： 设置一个使用密码的用户账户（需要本地管理员权限）。然后，运行 Invoke-Command 的时候使用 -Credential 参数，然后指定账户和密码。 如果您的电脑没有加入域，那么您需要启用 Negotiate 认证来进行 PowerShell remoting 操作。，并且使用机器的 IP 地址而不是计算机名。","text":"如果您设置了 PIN 用来登录您的电脑，对您自己的机器使用 PowerShell remoting 可能会失败，提示如下奇怪的错误信息： 12345678910111213141516PS C:\\&gt; Invoke-Command &#123; \"Hello\" &#125; -ComputerName $env:computername [DESKTOP-7AAMJLF] Connecting to remote server DESKTOP-7AAMJLF failed with the following error message : WinRM cannot process the request. The following error with errorcode 0x8009030e occurred while using Negotiate authentication: A specified logon session does not exist. It may already have been terminated. Possible causes are: -The user name or password specified are invalid. -Kerberos is used when no authentication method and no user name are specified. -Kerberos accepts domain user names, but not local user names. -The Service Principal Name (SPN) for the remote computer name and port does not exist. -The client and remote computers are in different domains and there is no trust between the two domains. After checking for the above issues, try the following: -Check the Event Viewer for events related to authentication. -Change the authentication method; add the destination computer to the WinRM TrustedHosts configuration setting or use HTTPS transport. Note that computers in the TrustedHosts list might not be authenticated. -For more information about WinRM configuration, run the following command: winrm help config. For more information, see the about_Remote_Troubleshooting Help topic. + CategoryInfo : OpenError: (DESKTOP-7AAMJLF:String) [], PSRemotingTransportException + FullyQualifiedErrorId : 1312,PSSessionStateBroken 要解决这个问题，您可以有两个选择： 设置一个使用密码的用户账户（需要本地管理员权限）。然后，运行 Invoke-Command 的时候使用 -Credential 参数，然后指定账户和密码。 如果您的电脑没有加入域，那么您需要启用 Negotiate 认证来进行 PowerShell remoting 操作。，并且使用机器的 IP 地址而不是计算机名。 本文国际来源：Using PowerShell Remoting with PIN-enabled Accounts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 按属性值分割结果","slug":"separating-results-by-property-value","date":"2016-12-12T08:00:00.000Z","updated":"2017-03-17T15:26:27.327Z","comments":true,"path":"2016/12/12/separating-results-by-property-value/","link":"","permalink":"http://blog.vichamp.com/2016/12/12/separating-results-by-property-value/","excerpt":"如果您使用 PowerShell 远程操作来接收远程机器的信息，您可以指定多个计算机名（扇出）。PowerShell 会自动逐台访问所有的机器，这样可以节省很多时间（当然，这些操作的前提是设置并启用了 PowerShell，这里不再赘述）。 返回的结果顺序是随机的，因为所有被访问的机器都会在它们准备好数据的时候返回各自的信息。 要将结果数据按每台机器分割，请使用 Group-Object 命令： 123456789101112131415161718$pc1 = $env:computername$pc2 = '192.168.2.112'$code = &#123; Get-Service | Where-Object Status -eq Running&#125;# get all results$result = Invoke-Command -ScriptBlock $code -ComputerName $pc1, $pc2 # separate per computer$groups = $result | Group-Object -Property PSComputerName -AsHashTable $groups# access per computer results separately$groups.$pc1$groups.$pc2 当您指定了 -AsHashTable 参数时，Groutp-Object 创建了一个以计算机名为键的哈希表。通过这种方法，您可以并发执行操作以节约时间，并仍然按每台机器来区分数据。","text":"如果您使用 PowerShell 远程操作来接收远程机器的信息，您可以指定多个计算机名（扇出）。PowerShell 会自动逐台访问所有的机器，这样可以节省很多时间（当然，这些操作的前提是设置并启用了 PowerShell，这里不再赘述）。 返回的结果顺序是随机的，因为所有被访问的机器都会在它们准备好数据的时候返回各自的信息。 要将结果数据按每台机器分割，请使用 Group-Object 命令： 123456789101112131415161718$pc1 = $env:computername$pc2 = '192.168.2.112'$code = &#123; Get-Service | Where-Object Status -eq Running&#125;# get all results$result = Invoke-Command -ScriptBlock $code -ComputerName $pc1, $pc2 # separate per computer$groups = $result | Group-Object -Property PSComputerName -AsHashTable $groups# access per computer results separately$groups.$pc1$groups.$pc2 当您指定了 -AsHashTable 参数时，Groutp-Object 创建了一个以计算机名为键的哈希表。通过这种方法，您可以并发执行操作以节约时间，并仍然按每台机器来区分数据。 本文国际来源：Separating Results by Property Value","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 分析结果出现次数（不浪费内存）","slug":"analyzing-result-frequencies-without-wasting-memory","date":"2016-12-11T08:00:00.000Z","updated":"2017-03-17T15:26:27.318Z","comments":true,"path":"2016/12/11/analyzing-result-frequencies-without-wasting-memory/","link":"","permalink":"http://blog.vichamp.com/2016/12/11/analyzing-result-frequencies-without-wasting-memory/","excerpt":"用 Group-Object 可以基于共享的属性值对对象分组，但请不要忘记使用 -NoElement 参数来忽略实际的对象而只返回出现次数。 这行简单的代码告诉您指定文件夹中有哪些文件类型： 1Get-ChildItem -Path c:\\Windows -File | Group-Object -Property Extension -NoElement 结果看起来如下： 12345678Count Name ----- ---- 11 .exe 1 .dat 9 .log 4 .xml 1 .txt ... 指定了 -NoElement 之后，您可以节约相当客观的内存，因为原对象不再包括在结果中。","text":"用 Group-Object 可以基于共享的属性值对对象分组，但请不要忘记使用 -NoElement 参数来忽略实际的对象而只返回出现次数。 这行简单的代码告诉您指定文件夹中有哪些文件类型： 1Get-ChildItem -Path c:\\Windows -File | Group-Object -Property Extension -NoElement 结果看起来如下： 12345678Count Name ----- ---- 11 .exe 1 .dat 9 .log 4 .xml 1 .txt ... 指定了 -NoElement 之后，您可以节约相当客观的内存，因为原对象不再包括在结果中。 本文国际来源：Analyzing Result Frequencies (without Wasting Memory)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找不合规的命令动词","slug":"finding-unapproved-verbs","date":"2016-12-08T08:00:00.000Z","updated":"2017-03-17T15:26:27.316Z","comments":true,"path":"2016/12/08/finding-unapproved-verbs/","link":"","permalink":"http://blog.vichamp.com/2016/12/08/finding-unapproved-verbs/","excerpt":"Cmdlet 和函数只能用认可的动词以便于用户查找命令，并且保持一致性。 以下是一个快速的审计代码，能够显示不符合这个规定的所有命令： 1234$approved = Get-Verb | Select-Object -ExpandProperty VerbGet-Command -CommandType Cmdlet, Function | Where-Object &#123; $approved -notcontains $_.Verb &#125; 这里返回的是所有不符合规定或根本没有命令动词的 cmdlet 和函数。","text":"Cmdlet 和函数只能用认可的动词以便于用户查找命令，并且保持一致性。 以下是一个快速的审计代码，能够显示不符合这个规定的所有命令： 1234$approved = Get-Verb | Select-Object -ExpandProperty VerbGet-Command -CommandType Cmdlet, Function | Where-Object &#123; $approved -notcontains $_.Verb &#125; 这里返回的是所有不符合规定或根本没有命令动词的 cmdlet 和函数。 本文国际来源：Finding Unapproved Verbs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 最常用的动词","slug":"most-popular-verbs","date":"2016-12-07T08:00:00.000Z","updated":"2017-03-17T15:26:27.309Z","comments":true,"path":"2016/12/07/most-popular-verbs/","link":"","permalink":"http://blog.vichamp.com/2016/12/07/most-popular-verbs/","excerpt":"让我们来看看您的 PowerShell 中哪个命令动词是最常用的： 123Get-Command -CommandType cmdlet, function | Group-Object -Property Verb | Sort-Object -Property Count -Descending 这是我们系统的输出结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798Count Name Group ----- ---- ----- 456 Get &#123;Get-AppBackgroundTask, Get-AppvVirtualProcess... 210 Set &#123;Set-AssignedAccess, Set-AutologgerConfig, Set... 120 Remove &#123;Remove-AutologgerConfig, Remove-BCDataCacheEx... 102 New &#123;New-AutologgerConfig, New-DAEntryPointTableIt... 72 Enable &#123;Enable-BCDistributed, Enable-BCDowngrading, E... 70 &#123;A:, ABC, AfterAll, AfterAll...&#125; 67 Add &#123;Add-BCDataCacheExtension, Add-BitLockerKeyPro... 65 Disable &#123;Disable-BC, Disable-BCDowngrading, Disable-BC... 28 Start &#123;Start-Animation, Start-AppBackgroundTask, Sta... 26 Update &#123;Update-Disk, Update-DscConfiguration, Update-... 24 Clear &#123;Clear-AssignedAccess, Clear-BCCache, Clear-Bi... 22 Export &#123;Export-Application, Export-BCCachePackage, Ex... 22 Invoke &#123;Invoke-AsWorkflow, Invoke-Background, Invoke-... 20 Import &#123;Import-BCCachePackage, Import-BCSecretKey, Im... 19 Stop &#123;Stop-DscConfiguration, Stop-Dtc, Stop-DtcTran... 19 Rename &#123;Rename-DAEntryPointTableItem, Rename-MaskingS... 19 Test &#123;Test-Ancestor, Test-Descendent, Test-Dtc, Tes... 16 Register &#123;Register-ClusteredScheduledTask, Register-Dns... 15 ConvertTo &#123;ConvertTo-DataTemplate, ConvertTo-GridLength,... 14 Write &#123;Write-DtcTransactionsTraceSession, Write-Prin... 14 Show &#123;Show-Clock, Show-Details, Show-NetFirewallRul... 14 Reset &#123;Reset-BC, Reset-DAClientExperienceConfigurati... 13 Unregister &#123;Unregister-AppBackgroundTask, Unregister-Clus... 11 Out &#123;Out-GridViewVertical, Out-Notepad, Out-Voice,... 11 Copy &#123;Copy-DependencyProperty, Copy-NetFirewallRule... 9 Send &#123;Send-EtwTraceSession, Send-PSCONFConfirmation... 9 Find &#123;Find-Command, Find-DscResource, Find-Module, ... 9 ConvertFrom &#123;ConvertFrom-SddlString, ConvertFrom-TypeToScr... 7 Save &#123;Save-Module, Save-NetGPO, Save-NetworkSwitchC... 7 Repair &#123;Repair-FileIntegrity, Repair-VirtualDisk, Rep... 7 Debug &#123;Debug-FileShare, Debug-MMAppPrelaunch, Debug-... 7 Format &#123;Format-Hex, Format-Volume, Format-Custom, For... 6 Suspend &#123;Suspend-BitLocker, Suspend-PrintJob, Suspend-... 6 Install &#123;Install-Dtc, Install-ISEPreviewShortcut, Inst... 6 Publish &#123;Publish-BCFileContent, Publish-BCWebContent, ... 6 Resume &#123;Resume-BitLocker, Resume-PrintJob, Resume-Bit... 6 Move &#123;Move-Control, Move-SmbWitnessClient, Move-App... 5 Restore &#123;Restore-DscConfiguration, Restore-NetworkSwit... 5 Restart &#123;Restart-NetAdapter, Restart-PcsvDevice, Resta... 5 Select &#123;Select-Date, Select-UIType, Select-Object, Se... 5 Mount &#123;Mount-DiskImage, Mount-AppvClientConnectionGr... 4 Uninstall &#123;Uninstall-Dtc, Uninstall-Module, Uninstall-Sc... 4 Disconnect &#123;Disconnect-IscsiTarget, Disconnect-VirtualDis... 4 Connect &#123;Connect-IscsiTarget, Connect-VirtualDisk, Con... 4 Receive &#123;Receive-DtcDiagnosticTransaction, Receive-Job... 4 Unblock &#123;Unblock-FileShareAccess, Unblock-SmbShareAcce... 4 Assert &#123;Assert-MockCalled, Assert-MockCalled, Assert-... 4 Wait &#123;Wait-Debugger, Wait-Event, Wait-Job, Wait-Pro... 3 Complete &#123;Complete-BitsTransfer, Complete-DtcDiagnostic... 3 Resize &#123;Resize-Partition, Resize-StorageTier, Resize-... 3 Optimize &#123;Optimize-StoragePool, Optimize-Volume, Optimi... 3 Initialize &#123;Initialize-Disk, Initialize-EventHandler, Ini... 3 Expand &#123;Expand-Archive, Expand-WindowsCustomDataImage... 3 Dismount &#123;Dismount-DiskImage, Dismount-AppxVolume, Dism... 3 Close &#123;Close-Control, Close-SmbOpenFile, Close-SmbSe... 3 Convert &#123;Convert-Alias, Convert-Path, Convert-String&#125; 2 Use &#123;Use-Transaction, Use-WindowsUnattend&#125; 2 Undo &#123;Undo-DtcDiagnosticTransaction, Undo-Transaction&#125; 2 Trace &#123;Trace-Command, Trace-SteroidsOutput&#125; 2 Split &#123;Split-Path, Split-WindowsImage&#125; 2 Resolve &#123;Resolve-DnsName, Resolve-Path&#125; 2 Measure &#123;Measure-Command, Measure-Object&#125; 2 Join &#123;Join-DtcDiagnosticResourceManager, Join-Path&#125; 2 Exit &#123;Exit-PSHostProcess, Exit-PSSession&#125; 2 Read &#123;Read-PrinterNfcTag, Read-Host&#125; 2 Block &#123;Block-FileShareAccess, Block-SmbShareAccess&#125; 2 Enter &#123;Enter-PSHostProcess, Enter-PSSession&#125; 2 Revoke &#123;Revoke-FileShareAccess, Revoke-SmbShareAccess&#125; 2 Do &#123;Do-Something, Do-SomethingWeird&#125; 2 Sync &#123;Sync-NetIPsecRule, Sync-AppvPublishingServer&#125; 2 Edit &#123;Edit-StringList, Edit-CIPolicyRule&#125; 2 Hide &#123;Hide-UIElement, Hide-VirtualDisk&#125; 2 Grant &#123;Grant-FileShareAccess, Grant-SmbShareAccess&#125; 1 Unlock &#123;Unlock-BitLocker&#125; 1 Unpublish &#123;Unpublish-AppvClientPackage&#125; 1 Unprotect &#123;Unprotect-CmsMessage&#125; 1 Open &#123;Open-NetGPO&#125; 1 Lock &#123;Lock-BitLocker&#125; 1 Tee &#123;Tee-Object&#125; 1 Switch &#123;Switch-Certificate&#125; 1 Sort &#123;Sort-Object&#125; 1 Backup &#123;Backup-BitLockerKeyProtector&#125; 1 Protect &#123;Protect-CmsMessage&#125; 1 Compress &#123;Compress-Archive&#125; 1 Pop &#123;Pop-Location&#125; 1 Merge &#123;Merge-CIPolicy&#125; 1 Encrypt &#123;Encrypt-Text&#125; 1 Limit &#123;Limit-EventLog&#125; 1 Group &#123;Group-Object&#125; 1 ForEach &#123;ForEach-Object&#125; 1 Confirm &#123;Confirm-SecureBootUEFI&#125; 1 Decrypt &#123;Decrypt-Text&#125; 1 Compare &#123;Compare-Object&#125; 1 Checkpoint &#123;Checkpoint-Computer&#125; 1 Push &#123;Push-Location&#125; 1 Where &#123;Where-Object&#125; 更有趣的是，以下是 PowerShell cmdlet 前六个最常用的动词： 1234567891011121314PS C:\\&gt; Get-Command -CommandType cmdlet, function | Group-Object -Property Verb | Sort-Object -Property Count -Descending |Where-Object &#123; $_.Name &#125; |Select-Object -First 6 -Property Count, NameCount Name ----- ---- 456 Get 210 Set 120 Remove 102 New 72 Enable 67 Add 所以说这头六个动词只占动词总数的 6%，但是占了所有命令的 60% 以上。","text":"让我们来看看您的 PowerShell 中哪个命令动词是最常用的： 123Get-Command -CommandType cmdlet, function | Group-Object -Property Verb | Sort-Object -Property Count -Descending 这是我们系统的输出结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798Count Name Group ----- ---- ----- 456 Get &#123;Get-AppBackgroundTask, Get-AppvVirtualProcess... 210 Set &#123;Set-AssignedAccess, Set-AutologgerConfig, Set... 120 Remove &#123;Remove-AutologgerConfig, Remove-BCDataCacheEx... 102 New &#123;New-AutologgerConfig, New-DAEntryPointTableIt... 72 Enable &#123;Enable-BCDistributed, Enable-BCDowngrading, E... 70 &#123;A:, ABC, AfterAll, AfterAll...&#125; 67 Add &#123;Add-BCDataCacheExtension, Add-BitLockerKeyPro... 65 Disable &#123;Disable-BC, Disable-BCDowngrading, Disable-BC... 28 Start &#123;Start-Animation, Start-AppBackgroundTask, Sta... 26 Update &#123;Update-Disk, Update-DscConfiguration, Update-... 24 Clear &#123;Clear-AssignedAccess, Clear-BCCache, Clear-Bi... 22 Export &#123;Export-Application, Export-BCCachePackage, Ex... 22 Invoke &#123;Invoke-AsWorkflow, Invoke-Background, Invoke-... 20 Import &#123;Import-BCCachePackage, Import-BCSecretKey, Im... 19 Stop &#123;Stop-DscConfiguration, Stop-Dtc, Stop-DtcTran... 19 Rename &#123;Rename-DAEntryPointTableItem, Rename-MaskingS... 19 Test &#123;Test-Ancestor, Test-Descendent, Test-Dtc, Tes... 16 Register &#123;Register-ClusteredScheduledTask, Register-Dns... 15 ConvertTo &#123;ConvertTo-DataTemplate, ConvertTo-GridLength,... 14 Write &#123;Write-DtcTransactionsTraceSession, Write-Prin... 14 Show &#123;Show-Clock, Show-Details, Show-NetFirewallRul... 14 Reset &#123;Reset-BC, Reset-DAClientExperienceConfigurati... 13 Unregister &#123;Unregister-AppBackgroundTask, Unregister-Clus... 11 Out &#123;Out-GridViewVertical, Out-Notepad, Out-Voice,... 11 Copy &#123;Copy-DependencyProperty, Copy-NetFirewallRule... 9 Send &#123;Send-EtwTraceSession, Send-PSCONFConfirmation... 9 Find &#123;Find-Command, Find-DscResource, Find-Module, ... 9 ConvertFrom &#123;ConvertFrom-SddlString, ConvertFrom-TypeToScr... 7 Save &#123;Save-Module, Save-NetGPO, Save-NetworkSwitchC... 7 Repair &#123;Repair-FileIntegrity, Repair-VirtualDisk, Rep... 7 Debug &#123;Debug-FileShare, Debug-MMAppPrelaunch, Debug-... 7 Format &#123;Format-Hex, Format-Volume, Format-Custom, For... 6 Suspend &#123;Suspend-BitLocker, Suspend-PrintJob, Suspend-... 6 Install &#123;Install-Dtc, Install-ISEPreviewShortcut, Inst... 6 Publish &#123;Publish-BCFileContent, Publish-BCWebContent, ... 6 Resume &#123;Resume-BitLocker, Resume-PrintJob, Resume-Bit... 6 Move &#123;Move-Control, Move-SmbWitnessClient, Move-App... 5 Restore &#123;Restore-DscConfiguration, Restore-NetworkSwit... 5 Restart &#123;Restart-NetAdapter, Restart-PcsvDevice, Resta... 5 Select &#123;Select-Date, Select-UIType, Select-Object, Se... 5 Mount &#123;Mount-DiskImage, Mount-AppvClientConnectionGr... 4 Uninstall &#123;Uninstall-Dtc, Uninstall-Module, Uninstall-Sc... 4 Disconnect &#123;Disconnect-IscsiTarget, Disconnect-VirtualDis... 4 Connect &#123;Connect-IscsiTarget, Connect-VirtualDisk, Con... 4 Receive &#123;Receive-DtcDiagnosticTransaction, Receive-Job... 4 Unblock &#123;Unblock-FileShareAccess, Unblock-SmbShareAcce... 4 Assert &#123;Assert-MockCalled, Assert-MockCalled, Assert-... 4 Wait &#123;Wait-Debugger, Wait-Event, Wait-Job, Wait-Pro... 3 Complete &#123;Complete-BitsTransfer, Complete-DtcDiagnostic... 3 Resize &#123;Resize-Partition, Resize-StorageTier, Resize-... 3 Optimize &#123;Optimize-StoragePool, Optimize-Volume, Optimi... 3 Initialize &#123;Initialize-Disk, Initialize-EventHandler, Ini... 3 Expand &#123;Expand-Archive, Expand-WindowsCustomDataImage... 3 Dismount &#123;Dismount-DiskImage, Dismount-AppxVolume, Dism... 3 Close &#123;Close-Control, Close-SmbOpenFile, Close-SmbSe... 3 Convert &#123;Convert-Alias, Convert-Path, Convert-String&#125; 2 Use &#123;Use-Transaction, Use-WindowsUnattend&#125; 2 Undo &#123;Undo-DtcDiagnosticTransaction, Undo-Transaction&#125; 2 Trace &#123;Trace-Command, Trace-SteroidsOutput&#125; 2 Split &#123;Split-Path, Split-WindowsImage&#125; 2 Resolve &#123;Resolve-DnsName, Resolve-Path&#125; 2 Measure &#123;Measure-Command, Measure-Object&#125; 2 Join &#123;Join-DtcDiagnosticResourceManager, Join-Path&#125; 2 Exit &#123;Exit-PSHostProcess, Exit-PSSession&#125; 2 Read &#123;Read-PrinterNfcTag, Read-Host&#125; 2 Block &#123;Block-FileShareAccess, Block-SmbShareAccess&#125; 2 Enter &#123;Enter-PSHostProcess, Enter-PSSession&#125; 2 Revoke &#123;Revoke-FileShareAccess, Revoke-SmbShareAccess&#125; 2 Do &#123;Do-Something, Do-SomethingWeird&#125; 2 Sync &#123;Sync-NetIPsecRule, Sync-AppvPublishingServer&#125; 2 Edit &#123;Edit-StringList, Edit-CIPolicyRule&#125; 2 Hide &#123;Hide-UIElement, Hide-VirtualDisk&#125; 2 Grant &#123;Grant-FileShareAccess, Grant-SmbShareAccess&#125; 1 Unlock &#123;Unlock-BitLocker&#125; 1 Unpublish &#123;Unpublish-AppvClientPackage&#125; 1 Unprotect &#123;Unprotect-CmsMessage&#125; 1 Open &#123;Open-NetGPO&#125; 1 Lock &#123;Lock-BitLocker&#125; 1 Tee &#123;Tee-Object&#125; 1 Switch &#123;Switch-Certificate&#125; 1 Sort &#123;Sort-Object&#125; 1 Backup &#123;Backup-BitLockerKeyProtector&#125; 1 Protect &#123;Protect-CmsMessage&#125; 1 Compress &#123;Compress-Archive&#125; 1 Pop &#123;Pop-Location&#125; 1 Merge &#123;Merge-CIPolicy&#125; 1 Encrypt &#123;Encrypt-Text&#125; 1 Limit &#123;Limit-EventLog&#125; 1 Group &#123;Group-Object&#125; 1 ForEach &#123;ForEach-Object&#125; 1 Confirm &#123;Confirm-SecureBootUEFI&#125; 1 Decrypt &#123;Decrypt-Text&#125; 1 Compare &#123;Compare-Object&#125; 1 Checkpoint &#123;Checkpoint-Computer&#125; 1 Push &#123;Push-Location&#125; 1 Where &#123;Where-Object&#125; 更有趣的是，以下是 PowerShell cmdlet 前六个最常用的动词： 1234567891011121314PS C:\\&gt; Get-Command -CommandType cmdlet, function | Group-Object -Property Verb | Sort-Object -Property Count -Descending |Where-Object &#123; $_.Name &#125; |Select-Object -First 6 -Property Count, NameCount Name ----- ---- 456 Get 210 Set 120 Remove 102 New 72 Enable 67 Add 所以说这头六个动词只占动词总数的 6%，但是占了所有命令的 60% 以上。 本文国际来源：Most Popular Verbs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 安全地对文本加解密","slug":"safely-encrypting-and-decrypting-text","date":"2016-12-06T08:00:00.000Z","updated":"2017-03-17T15:26:27.300Z","comments":true,"path":"2016/12/06/safely-encrypting-and-decrypting-text/","link":"","permalink":"http://blog.vichamp.com/2016/12/06/safely-encrypting-and-decrypting-text/","excerpt":"当您加密保密信息时，主要的问题是要寻找一个合适的密钥。一个特别安全的密钥是您的 Windows 身份，它和您的计算机身份绑定。这可以用来在特定的机器上加密敏感的个人信息。 以两个函数演示了如何实现： 123456789101112131415161718192021222324252627282930313233343536function Decrypt-Text&#123; param ( [String] [Parameter(Mandatory,ValueFromPipeline)] $EncryptedText ) process &#123; $secureString = $EncryptedText | ConvertTo-SecureString $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($secureString) [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) &#125;&#125;function Encrypt-Text&#123; param ( [String] [Parameter(Mandatory,ValueFromPipeline)] $Text ) process &#123; $Text | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString &#125;&#125;'PowerShell Rocks' | Encrypt-Text 'Hello, World!' | Encrypt-Text | Decrypt-Text 您可以将密文安全地保存到文件里。只有您可以读取并解密该文件，而且只能在加密用的电脑上完成。","text":"当您加密保密信息时，主要的问题是要寻找一个合适的密钥。一个特别安全的密钥是您的 Windows 身份，它和您的计算机身份绑定。这可以用来在特定的机器上加密敏感的个人信息。 以两个函数演示了如何实现： 123456789101112131415161718192021222324252627282930313233343536function Decrypt-Text&#123; param ( [String] [Parameter(Mandatory,ValueFromPipeline)] $EncryptedText ) process &#123; $secureString = $EncryptedText | ConvertTo-SecureString $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($secureString) [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) &#125;&#125;function Encrypt-Text&#123; param ( [String] [Parameter(Mandatory,ValueFromPipeline)] $Text ) process &#123; $Text | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString &#125;&#125;'PowerShell Rocks' | Encrypt-Text 'Hello, World!' | Encrypt-Text | Decrypt-Text 您可以将密文安全地保存到文件里。只有您可以读取并解密该文件，而且只能在加密用的电脑上完成。 本文国际来源：Safely Encrypting and Decrypting Text","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 同时使用 -Force 和 -WhatIf 时请注意","slug":"watch-out-when-combining-force-and-whatif","date":"2016-12-05T08:00:00.000Z","updated":"2017-03-17T15:26:27.290Z","comments":true,"path":"2016/12/05/watch-out-when-combining-force-and-whatif/","link":"","permalink":"http://blog.vichamp.com/2016/12/05/watch-out-when-combining-force-and-whatif/","excerpt":"-WhatIf 通用参数可以打开模拟模式，这样一个 cmdlet 执行的时候并不会改变任何东西，而是汇报它“将会”改变什么。它能工作得很好， 除非开发者没有正确地实现 -WhatIf。 有一种比较少见的情况：当您同时指定了 -Force 和 -WhatIf 参数，正确的结果是 -WhatIf 具有更高的优先级。有一些开发者过于关注 -Force 的功能，而让 -Force 优先级更高。例如请试试 Remove-SmbShare。","text":"-WhatIf 通用参数可以打开模拟模式，这样一个 cmdlet 执行的时候并不会改变任何东西，而是汇报它“将会”改变什么。它能工作得很好， 除非开发者没有正确地实现 -WhatIf。 有一种比较少见的情况：当您同时指定了 -Force 和 -WhatIf 参数，正确的结果是 -WhatIf 具有更高的优先级。有一些开发者过于关注 -Force 的功能，而让 -Force 优先级更高。例如请试试 Remove-SmbShare。 本文国际来源：Watch Out When Combining -Force and -WhatIf!","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建文件共享","slug":"creating-file-shares","date":"2016-12-04T08:00:00.000Z","updated":"2017-03-17T15:26:27.286Z","comments":true,"path":"2016/12/04/creating-file-shares/","link":"","permalink":"http://blog.vichamp.com/2016/12/04/creating-file-shares/","excerpt":"在 Server 2012 R2 和 Windows .1 中，有许多有用的新模块，包含了许多新的 cmdlet，例如 New-SmbShare 可以快速地创建新的文件共享。 如果您没有这些 cmdlet，您通常可以使用 WMI。那需要更多的研究和搜索，但是一旦您有了一个代码模板，它就能很好地工作了。 例如要以管理员身份创建一个新的文件共享，试试以下代码： 1234567$share = [wmiclass]\"Win32_Share\" $path = 'c:\\logs'$name = 'LogShare'$maxallowed = 10$description = 'Place log files here'$share.Create( $path, $name, 0, $maxallowed,$description,$null,$null)","text":"在 Server 2012 R2 和 Windows .1 中，有许多有用的新模块，包含了许多新的 cmdlet，例如 New-SmbShare 可以快速地创建新的文件共享。 如果您没有这些 cmdlet，您通常可以使用 WMI。那需要更多的研究和搜索，但是一旦您有了一个代码模板，它就能很好地工作了。 例如要以管理员身份创建一个新的文件共享，试试以下代码： 1234567$share = [wmiclass]\"Win32_Share\" $path = 'c:\\logs'$name = 'LogShare'$maxallowed = 10$description = 'Place log files here'$share.Create( $path, $name, 0, $maxallowed,$description,$null,$null) 本文国际来源：Creating File Shares","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用自定义作用域来屏蔽任何输出","slug":"using-custom-scopes-to-discard-any-output","date":"2016-12-01T08:00:00.000Z","updated":"2017-03-17T15:26:27.277Z","comments":true,"path":"2016/12/01/using-custom-scopes-to-discard-any-output/","link":"","permalink":"http://blog.vichamp.com/2016/12/01/using-custom-scopes-to-discard-any-output/","excerpt":"昨天我们看了自定义作用域能够自动还原变量并在您的代码之后清除现场。 自定义作用域也可以用来忽略域里任何一段代码输出的任何结果。要实现它，请使用这样的解构：$null = .{[code]}。无论您在方括号里执行什么代码，您创建的所有的变量和函数在域外都能使用，但是不会产生任何输出。 让我们看看这个函数： 1234567function Out-Voice ($Text)&#123; $sapi = New-Object -ComObject Sapi.SpVoice $sapi.Speak($Text)&#125;Out-Voice -Text 'Hello, Dude.' 当你运行它时，它将能播放语音，但也输出了数字“1”。所以 Speak() 方法会造成这样的现象——当您的代码变得庞大而复杂时，有许多地方在输出不必要的数字。 以下是一个极简单的“补丁”函数能产生相同的小郭，但是保证不会返回任何值： 123456789function Out-Voice ($Text)&#123; $null = . &#123; $sapi = New-Object -ComObject Sapi.SpVoice $sapi.Speak($Text) &#125;&#125;Out-Voice -Text 'Hello, Dude.'","text":"昨天我们看了自定义作用域能够自动还原变量并在您的代码之后清除现场。 自定义作用域也可以用来忽略域里任何一段代码输出的任何结果。要实现它，请使用这样的解构：$null = .{[code]}。无论您在方括号里执行什么代码，您创建的所有的变量和函数在域外都能使用，但是不会产生任何输出。 让我们看看这个函数： 1234567function Out-Voice ($Text)&#123; $sapi = New-Object -ComObject Sapi.SpVoice $sapi.Speak($Text)&#125;Out-Voice -Text 'Hello, Dude.' 当你运行它时，它将能播放语音，但也输出了数字“1”。所以 Speak() 方法会造成这样的现象——当您的代码变得庞大而复杂时，有许多地方在输出不必要的数字。 以下是一个极简单的“补丁”函数能产生相同的小郭，但是保证不会返回任何值： 123456789function Out-Voice ($Text)&#123; $null = . &#123; $sapi = New-Object -ComObject Sapi.SpVoice $sapi.Speak($Text) &#125;&#125;Out-Voice -Text 'Hello, Dude.' 本文国际来源：Using Custom Scopes to Discard Any Output","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用自定义域","slug":"using-custom-scopes","date":"2016-11-30T08:00:00.000Z","updated":"2017-03-17T15:26:27.274Z","comments":true,"path":"2016/11/30/using-custom-scopes/","link":"","permalink":"http://blog.vichamp.com/2016/11/30/using-custom-scopes/","excerpt":"当您改变变量时，您可能需要在稍后清除它们并且确保它们回退到缺省值——用自定义作用域就可以做到。昨天，我们学习了如何处理控制台程序的错误。并且回顾那段代码，您会发现重置 $ErrorActionPreference 系统变量要费很多事： 123456789101112131415161718192021222324try&#123; # set the preference to STOP $old = $ErrorActionPreference $ErrorActionPreference = 'Stop' # RUN THE CONSOLE EXE THAT MIGHT EMIT AN ERROR, # and redirect the error channel #2 to the # output channel #1 net user doesnotexist 2&gt;&amp;1&#125;catch [System.Management.Automation.RemoteException]&#123; # catch the error emitted by the EXE, # and do what you want $errmsg = $_.Exception.Message Write-Warning $errmsg&#125;finally&#123; # reset the erroractionpreference to what it was before $ErrorActionPreference = $old&#125; 一个简单得多的办法是使用自定义作用域： 12345678910111213141516171819&amp; &#123; try &#123; # set the preference to STOP $ErrorActionPreference = 'Stop' # RUN THE CONSOLE EXE THAT MIGHT EMIT AN ERROR, # and redirect the error channel #2 to the # output channel #1 net user doesnotexist 2&gt;&amp;1 &#125; catch [System.Management.Automation.RemoteException] &#123; # catch the error emitted by the EXE, # and do what you want: $errmsg = $_.Exception.Message Write-Warning $errmsg &#125;&#125; ${[code]} 这段代码创建了一个新的作用域，并且任何在其中定义的变量都会在退出该作用域时删除。这是为何在上述例子中，$ErrorActionPreference 能够自动还原为它之前的值。","text":"当您改变变量时，您可能需要在稍后清除它们并且确保它们回退到缺省值——用自定义作用域就可以做到。昨天，我们学习了如何处理控制台程序的错误。并且回顾那段代码，您会发现重置 $ErrorActionPreference 系统变量要费很多事： 123456789101112131415161718192021222324try&#123; # set the preference to STOP $old = $ErrorActionPreference $ErrorActionPreference = 'Stop' # RUN THE CONSOLE EXE THAT MIGHT EMIT AN ERROR, # and redirect the error channel #2 to the # output channel #1 net user doesnotexist 2&gt;&amp;1&#125;catch [System.Management.Automation.RemoteException]&#123; # catch the error emitted by the EXE, # and do what you want $errmsg = $_.Exception.Message Write-Warning $errmsg&#125;finally&#123; # reset the erroractionpreference to what it was before $ErrorActionPreference = $old&#125; 一个简单得多的办法是使用自定义作用域： 12345678910111213141516171819&amp; &#123; try &#123; # set the preference to STOP $ErrorActionPreference = 'Stop' # RUN THE CONSOLE EXE THAT MIGHT EMIT AN ERROR, # and redirect the error channel #2 to the # output channel #1 net user doesnotexist 2&gt;&amp;1 &#125; catch [System.Management.Automation.RemoteException] &#123; # catch the error emitted by the EXE, # and do what you want: $errmsg = $_.Exception.Message Write-Warning $errmsg &#125;&#125; ${[code]} 这段代码创建了一个新的作用域，并且任何在其中定义的变量都会在退出该作用域时删除。这是为何在上述例子中，$ErrorActionPreference 能够自动还原为它之前的值。 本文国际来源：Using Custom Scopes","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 捕获 Native EXE 的错误","slug":"catching-errors-from-native-exes","date":"2016-11-29T08:00:00.000Z","updated":"2017-03-17T15:26:27.267Z","comments":true,"path":"2016/11/29/catching-errors-from-native-exes/","link":"","permalink":"http://blog.vichamp.com/2016/11/29/catching-errors-from-native-exes/","excerpt":"是否想知道如何捕获 native 控制台 EXE 程序的错误？PowerShell 的错误处理器只能处理 .NET 代码的错误。 这段代码是捕获控制台应用程序错误的框架： 123456789101112131415161718192021222324try&#123; # set the preference to STOP $old = $ErrorActionPreference $ErrorActionPreference = 'Stop' # RUN THE CONSOLE EXE THAT MIGHT EMIT AN ERROR, # and redirect the error channel #2 to the # output channel #1 net user doesnotexist 2&gt;&amp;1&#125;catch [System.Management.Automation.RemoteException]&#123; # catch the error emitted by the EXE, # and do what you want $errmsg = $_.Exception.Message Write-Warning $errmsg&#125;finally&#123; # reset the erroractionpreference to what it was before $ErrorActionPreference = $old&#125; 一旦控制台程序发出一个错误，它就会输出到控制台的 #2 通道。由于示例代码中该通道直接重定向到普通的 output，所以 PowerShell 能接收到它。当 ErrorActionPreference 设成 “Stop“ 时，PowerShell 会将任何该通道的输入数据转发到一个 .NET RemoteException，这样您就可以捕获它。 1WARNING: The user name could not be found.","text":"是否想知道如何捕获 native 控制台 EXE 程序的错误？PowerShell 的错误处理器只能处理 .NET 代码的错误。 这段代码是捕获控制台应用程序错误的框架： 123456789101112131415161718192021222324try&#123; # set the preference to STOP $old = $ErrorActionPreference $ErrorActionPreference = 'Stop' # RUN THE CONSOLE EXE THAT MIGHT EMIT AN ERROR, # and redirect the error channel #2 to the # output channel #1 net user doesnotexist 2&gt;&amp;1&#125;catch [System.Management.Automation.RemoteException]&#123; # catch the error emitted by the EXE, # and do what you want $errmsg = $_.Exception.Message Write-Warning $errmsg&#125;finally&#123; # reset the erroractionpreference to what it was before $ErrorActionPreference = $old&#125; 一旦控制台程序发出一个错误，它就会输出到控制台的 #2 通道。由于示例代码中该通道直接重定向到普通的 output，所以 PowerShell 能接收到它。当 ErrorActionPreference 设成 “Stop“ 时，PowerShell 会将任何该通道的输入数据转发到一个 .NET RemoteException，这样您就可以捕获它。 1WARNING: The user name could not be found. 本文国际来源：Catching Errors from Native EXEs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 高级错误处理：重新抛出异常","slug":"advanced-error-handling-rethrowing-exceptions","date":"2016-11-28T08:00:00.000Z","updated":"2017-03-17T15:26:27.260Z","comments":true,"path":"2016/11/28/advanced-error-handling-rethrowing-exceptions/","link":"","permalink":"http://blog.vichamp.com/2016/11/28/advanced-error-handling-rethrowing-exceptions/","excerpt":"在处理错误时，您有时会希望将原始的异常替换成您自己的。以下是一个例子： 123456789101112131415161718192021function Do-Something&#123; # function uses internal error handling try &#123; Get-Process -Name NotThereOhWell -ErrorAction Stop &#125; # catch this error type catch [Microsoft.PowerShell.Commands.ProcessCommandException] &#123; $oldE = $_.Exception # handle the error, OR SHOWN HERE: issue a new exception to the caller $newE = New-Object -TypeName System.InvalidOperationException('Do-Something: A fatal error occured', $oldE) Throw $newE &#125;&#125;# function will encounter an internal error# error message shows error message generated by function insteadDo-Something 调用者看到的内容如下： 1234567PS C:\\&gt; Do-SomethingDo-Something: A fatal error occuredAt line:18 char:5+ Throw $newException+ ~~~~~~~~~~~~~~~~~~~ + CategoryInfo : OperationStopped: (:) [], InvalidOperationException + FullyQualifiedErrorId : Do-Something: A fatal error occured 如果调用者也用一个错误处理函数来接收它，则会出现这种情况： 1234567891011try&#123; Do-Something&#125;catch [System.InvalidOperationException]&#123; [PSCustomObject]@&#123; Message = $_.Exception.Message Originalmessage = $_.Exception.InnerException.Message &#125;&#125; 结果看起来如下： 12345Message Originalmessage ------- --------------- Do-Something: A fatal error occured Cannot find a process with the name \"NotThereOhWell\". Verify the process name and call the cmdlet again. 这样调用者可以看到返回的错误信息，并且经过内部处理之后，还可以传递原始的错误信息。","text":"在处理错误时，您有时会希望将原始的异常替换成您自己的。以下是一个例子： 123456789101112131415161718192021function Do-Something&#123; # function uses internal error handling try &#123; Get-Process -Name NotThereOhWell -ErrorAction Stop &#125; # catch this error type catch [Microsoft.PowerShell.Commands.ProcessCommandException] &#123; $oldE = $_.Exception # handle the error, OR SHOWN HERE: issue a new exception to the caller $newE = New-Object -TypeName System.InvalidOperationException('Do-Something: A fatal error occured', $oldE) Throw $newE &#125;&#125;# function will encounter an internal error# error message shows error message generated by function insteadDo-Something 调用者看到的内容如下： 1234567PS C:\\&gt; Do-SomethingDo-Something: A fatal error occuredAt line:18 char:5+ Throw $newException+ ~~~~~~~~~~~~~~~~~~~ + CategoryInfo : OperationStopped: (:) [], InvalidOperationException + FullyQualifiedErrorId : Do-Something: A fatal error occured 如果调用者也用一个错误处理函数来接收它，则会出现这种情况： 1234567891011try&#123; Do-Something&#125;catch [System.InvalidOperationException]&#123; [PSCustomObject]@&#123; Message = $_.Exception.Message Originalmessage = $_.Exception.InnerException.Message &#125;&#125; 结果看起来如下： 12345Message Originalmessage ------- --------------- Do-Something: A fatal error occured Cannot find a process with the name \"NotThereOhWell\". Verify the process name and call the cmdlet again. 这样调用者可以看到返回的错误信息，并且经过内部处理之后，还可以传递原始的错误信息。 本文国际来源：Advanced Error Handling: Rethrowing Exceptions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用其他身份启动程序","slug":"launching-applications-as-someone-else","date":"2016-11-27T08:00:00.000Z","updated":"2017-03-17T15:26:27.248Z","comments":true,"path":"2016/11/27/launching-applications-as-someone-else/","link":"","permalink":"http://blog.vichamp.com/2016/11/27/launching-applications-as-someone-else/","excerpt":"假设您想以不同的身份打开多个 PowerShell 控制台，或以其他人的身份打开任何程序。 要实现这个目标，您需要以其他人的身份登录，这很明显是个负担。以下是将凭据以安全的方式保存到文件的方法：密码采用您的身份和您的机器加密成密文。只有保存它们的那个人可以取回它，而且只能在保存该文件的机器上操作： 12# saving credential securely to fileGet-Credential | Export-Clixml -Path \"$home\\login.xml\" 这个凭据将保存到用户配置中。如果您希望保存到其它地方，请改变路径。喜欢保存多少份，就调用多少次该方法。 下一步，假设您加载了一个保存的凭据，并且使用该身份启动了一个程序： 1234# getting back saved credential$cred = Import-Clixml -Path \"$home\\login.xml\"# launch applicationStart-Process -FilePath powershell -Credential $cred -Work c:\\ -LoadUserProfile 这将以您之前指定的用户身份创建一个新的 PowerShell 实例——无需手动登录。","text":"假设您想以不同的身份打开多个 PowerShell 控制台，或以其他人的身份打开任何程序。 要实现这个目标，您需要以其他人的身份登录，这很明显是个负担。以下是将凭据以安全的方式保存到文件的方法：密码采用您的身份和您的机器加密成密文。只有保存它们的那个人可以取回它，而且只能在保存该文件的机器上操作： 12# saving credential securely to fileGet-Credential | Export-Clixml -Path \"$home\\login.xml\" 这个凭据将保存到用户配置中。如果您希望保存到其它地方，请改变路径。喜欢保存多少份，就调用多少次该方法。 下一步，假设您加载了一个保存的凭据，并且使用该身份启动了一个程序： 1234# getting back saved credential$cred = Import-Clixml -Path \"$home\\login.xml\"# launch applicationStart-Process -FilePath powershell -Credential $cred -Work c:\\ -LoadUserProfile 这将以您之前指定的用户身份创建一个新的 PowerShell 实例——无需手动登录。 本文国际来源：Launching Applications as Someone Else","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 轻轻跳进 PowerShell 版本的丛林","slug":"shed-light-into-the-powershell-version-jungle","date":"2016-11-24T08:00:00.000Z","updated":"2017-03-17T15:26:27.245Z","comments":true,"path":"2016/11/24/shed-light-into-the-powershell-version-jungle/","link":"","permalink":"http://blog.vichamp.com/2016/11/24/shed-light-into-the-powershell-version-jungle/","excerpt":"PowerShell 同时有五个主要版本在发行。除掉最新的小版本，例如 Windows 10 和 Server 2016 上的 PowerShell 5.1。加上 beta 版和预发行版本，以及 Linux 和 Nano 服务器上的 PowerShell。哇哦！ 要跟踪这些版本，并知道正在用哪个版本、它从哪里来、可能有哪些兼容性问题很不容易。MVP 大学里的 Egil Ring 维护着一个很酷的模块。如果您装了 PowerShell 5 或从 powershellgallery.com 安装了 PowerShellGet，您可以用一行代码下载这个模块： 1PS C:\\&gt; Install-Module -Name PSVersion -Scope CurrentUser 回答几个问题后，该模块安装完成。它只包含两个命令： 123456PS C:\\&gt; Get-Command -Module PSVersionCommandType Name Version Source ----------- ---- ------- ------ Function Get-PSVersion 1.6 PSVersion Function Update-PSVersionData 1.6 PSVersion PSVersion 是一个社区项目，跟踪 PowerShell 的发行编号、它们的含义、它们的来源： 123456789101112131415161718PS C:\\&gt; Get-PSVersion -ListVersionName FriendlyName ApplicableOS ---- ------------ ------------ 5.1.14393.0 Windows PowerShell 5.1 Preview Windows 10 Anniversar...5.1.14300.1000 Windows PowerShell 5.1 Preview Windows Server 2016 T...5.0.10586.494 Windows PowerShell 5 RTM Windows 10 1511 + KB3...5.0.10586.122 Windows PowerShell 5 RTM Windows 10 1511 + KB3...5.0.10586.117 Windows PowerShell 5 RTM 1602 Windows Server 2012 R...5.0.10586.63 Windows PowerShell 5 RTM Windows 10 1511 + KB3...5.0.10586.51 Windows PowerShell 5 RTM 1512 Windows Server 2012 R...5.0.10514.6 Windows PowerShell 5 Production Preview 1508 Windows Server 2012 R2 5.0.10018.0 Windows PowerShell 5 Preview 1502 Windows Server 2012 R2 5.0.9883.0 Windows PowerShell 5 Preview November 2014 Windows Server 2012 R...4.0 Windows PowerShell 4 RTM Windows Server 2012 R...3.0 Windows PowerShell 3 RTM Windows Server 2012, ...2.0 Windows PowerShell 2 RTM Windows Server 2008 R...1.0 Windows PowerShell 1 RTM Windows Server 2008, ... 这是在您的企业中以友好的 PowerShell 版本名称获得 PowerShell 版本号的方法： 12345PS C:\\&gt; Get-PSVersion PSComputerName PSVersion PSVersionFriendlyName-------------- --------- ---------------------CLIENT12 5.1.14393.0 Windows PowerShell 5.1 Preview","text":"PowerShell 同时有五个主要版本在发行。除掉最新的小版本，例如 Windows 10 和 Server 2016 上的 PowerShell 5.1。加上 beta 版和预发行版本，以及 Linux 和 Nano 服务器上的 PowerShell。哇哦！ 要跟踪这些版本，并知道正在用哪个版本、它从哪里来、可能有哪些兼容性问题很不容易。MVP 大学里的 Egil Ring 维护着一个很酷的模块。如果您装了 PowerShell 5 或从 powershellgallery.com 安装了 PowerShellGet，您可以用一行代码下载这个模块： 1PS C:\\&gt; Install-Module -Name PSVersion -Scope CurrentUser 回答几个问题后，该模块安装完成。它只包含两个命令： 123456PS C:\\&gt; Get-Command -Module PSVersionCommandType Name Version Source ----------- ---- ------- ------ Function Get-PSVersion 1.6 PSVersion Function Update-PSVersionData 1.6 PSVersion PSVersion 是一个社区项目，跟踪 PowerShell 的发行编号、它们的含义、它们的来源： 123456789101112131415161718PS C:\\&gt; Get-PSVersion -ListVersionName FriendlyName ApplicableOS ---- ------------ ------------ 5.1.14393.0 Windows PowerShell 5.1 Preview Windows 10 Anniversar...5.1.14300.1000 Windows PowerShell 5.1 Preview Windows Server 2016 T...5.0.10586.494 Windows PowerShell 5 RTM Windows 10 1511 + KB3...5.0.10586.122 Windows PowerShell 5 RTM Windows 10 1511 + KB3...5.0.10586.117 Windows PowerShell 5 RTM 1602 Windows Server 2012 R...5.0.10586.63 Windows PowerShell 5 RTM Windows 10 1511 + KB3...5.0.10586.51 Windows PowerShell 5 RTM 1512 Windows Server 2012 R...5.0.10514.6 Windows PowerShell 5 Production Preview 1508 Windows Server 2012 R2 5.0.10018.0 Windows PowerShell 5 Preview 1502 Windows Server 2012 R2 5.0.9883.0 Windows PowerShell 5 Preview November 2014 Windows Server 2012 R...4.0 Windows PowerShell 4 RTM Windows Server 2012 R...3.0 Windows PowerShell 3 RTM Windows Server 2012, ...2.0 Windows PowerShell 2 RTM Windows Server 2008 R...1.0 Windows PowerShell 1 RTM Windows Server 2008, ... 这是在您的企业中以友好的 PowerShell 版本名称获得 PowerShell 版本号的方法： 12345PS C:\\&gt; Get-PSVersion PSComputerName PSVersion PSVersionFriendlyName-------------- --------- ---------------------CLIENT12 5.1.14393.0 Windows PowerShell 5.1 Preview 本文国际来源：Shed Light into the PowerShell Version Jungle","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 修复 PowerShell 5 帮助的 Bug","slug":"fixing-powershell-5-help-bug","date":"2016-11-23T08:00:00.000Z","updated":"2017-03-17T15:26:27.243Z","comments":true,"path":"2016/11/23/fixing-powershell-5-help-bug/","link":"","permalink":"http://blog.vichamp.com/2016/11/23/fixing-powershell-5-help-bug/","excerpt":"使用 Update-Help 下载 PowerShell 的帮助文件时，PowerShell 5 有一个 bug，目前可以修复：基于文本的帮助文件扩展名是“.txt”而不是“.help.txt”，所以 PowerShell 帮助系统会忽略它们。您可以自己试验一下——以下命令可能会返回一大堆关于主题： 123456789101112131415161718192021PS C:\\&gt; Get-Help about*Name Category Module Synopsis ---- -------- ------ -------- about_Aliases HelpFile SHORT DESCRIPTION about_Arithmetic_Operators HelpFile SHORT DESCRIPTION about_Arrays HelpFile SHORT DESCRIPTION about_Assignment_Operators HelpFile SHORT DESCRIPTION about_Automatic_Variables HelpFile SHORT DESCRIPTION about_Break HelpFile SHORT DESCRIPTION about_Classes HelpFile SHORT DESCRIPTION about_Command_Precedence HelpFile SHORT DESCRIPTION about_Command_Syntax HelpFile SHORT DESCRIPTION about_Comment_Based_Help HelpFile SHORT DESCRIPTION about_CommonParameters HelpFile SHORT DESCRIPTION about_Comparison_Operators HelpFile SHORT DESCRIPTION about_Continue HelpFile SHORT DESCRIPTION about_Core_Commands HelpFile SHORT DESCRIPTION about_Data_Sections HelpFile SHORT DESCRIPTION about_Debuggers HelpFile SHORT DESCRIPTION about_DesiredStateConfiguration HelpFile SHORT DESCRIPTION 如果没有显示上述的内容，您也许还没有事先运行过 Update-Help 来下载帮助文件，或者您被 bug 吃了。 无论这个 bug 是否正在修复中，用 PowerShell 您可以轻松地修改这些东西。以下是一个用于修复这些受影响的帮助文件的扩展名的脚本。 这个脚本需要管理员权限，因为帮助文件是位于受保护的 Windows 文件夹中： 1234567# find all text files inside the PowerShell folder that start# with \"about\"Get-ChildItem -Path $pshome -Filter about*.txt -Recurse | # identify those that do not end with \".help.txt\" Where-Object &#123; $_.Name -notlike '*.help.txt' &#125; | # rename the extension using a regex: Rename-Item -NewName &#123; $_.Name -replace '\\.txt$', '.help.txt'&#125;","text":"使用 Update-Help 下载 PowerShell 的帮助文件时，PowerShell 5 有一个 bug，目前可以修复：基于文本的帮助文件扩展名是“.txt”而不是“.help.txt”，所以 PowerShell 帮助系统会忽略它们。您可以自己试验一下——以下命令可能会返回一大堆关于主题： 123456789101112131415161718192021PS C:\\&gt; Get-Help about*Name Category Module Synopsis ---- -------- ------ -------- about_Aliases HelpFile SHORT DESCRIPTION about_Arithmetic_Operators HelpFile SHORT DESCRIPTION about_Arrays HelpFile SHORT DESCRIPTION about_Assignment_Operators HelpFile SHORT DESCRIPTION about_Automatic_Variables HelpFile SHORT DESCRIPTION about_Break HelpFile SHORT DESCRIPTION about_Classes HelpFile SHORT DESCRIPTION about_Command_Precedence HelpFile SHORT DESCRIPTION about_Command_Syntax HelpFile SHORT DESCRIPTION about_Comment_Based_Help HelpFile SHORT DESCRIPTION about_CommonParameters HelpFile SHORT DESCRIPTION about_Comparison_Operators HelpFile SHORT DESCRIPTION about_Continue HelpFile SHORT DESCRIPTION about_Core_Commands HelpFile SHORT DESCRIPTION about_Data_Sections HelpFile SHORT DESCRIPTION about_Debuggers HelpFile SHORT DESCRIPTION about_DesiredStateConfiguration HelpFile SHORT DESCRIPTION 如果没有显示上述的内容，您也许还没有事先运行过 Update-Help 来下载帮助文件，或者您被 bug 吃了。 无论这个 bug 是否正在修复中，用 PowerShell 您可以轻松地修改这些东西。以下是一个用于修复这些受影响的帮助文件的扩展名的脚本。 这个脚本需要管理员权限，因为帮助文件是位于受保护的 Windows 文件夹中： 1234567# find all text files inside the PowerShell folder that start# with \"about\"Get-ChildItem -Path $pshome -Filter about*.txt -Recurse | # identify those that do not end with \".help.txt\" Where-Object &#123; $_.Name -notlike '*.help.txt' &#125; | # rename the extension using a regex: Rename-Item -NewName &#123; $_.Name -replace '\\.txt$', '.help.txt'&#125; 本文国际来源：Fixing PowerShell 5 Help Bug","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 禁止按位置的参数","slug":"prohibiting-positional-parameters","date":"2016-11-22T08:00:00.000Z","updated":"2017-03-17T15:26:27.233Z","comments":true,"path":"2016/11/22/prohibiting-positional-parameters/","link":"","permalink":"http://blog.vichamp.com/2016/11/22/prohibiting-positional-parameters/","excerpt":"当您创建 PowerShell 函数时，参数可以是命名的也可以是按位置的。以下是一个例子： 如果您想检测文件系统中的非法字符，以下是一个简单的适配： 12345678910111213function Test-Command&#123; param ( [string]$Name, [int]$Id ) \"Name: $Name ID: $ID\"&#125;Test-Command -Name Weltner -Id 12Test-Command Weltner 12 如您所见，使用按位置的参数（只需要指定参数，不需要显式地指定参数名）可能更适用于为特定目的编写的代码，但是可读性更差。这是有可能的，因为上述函数的语法看起来如下： 1Test-Command [[-Name] &lt;string&gt;] [[-Id] &lt;int&gt;] 那么一个编写一个效果相反的 PowerShell 函数，实现这种语法呢： 1Test-Command [-Name &lt;string&gt;] [-Id &lt;int&gt;] [&lt;CommonParameters&gt;] 目前这个方法比较生僻，不过是完全可行的： 12345678910111213function Test-Command&#123; param ( [Parameter(ParameterSetName='xy')] [string]$Name, [Parameter(ParameterSetName='xy')] [int]$Id ) \"Name: $Name ID: $ID\"&#125; 一旦开始使用参数集合，缺省情况下所有参数都是命名的参数。","text":"当您创建 PowerShell 函数时，参数可以是命名的也可以是按位置的。以下是一个例子： 如果您想检测文件系统中的非法字符，以下是一个简单的适配： 12345678910111213function Test-Command&#123; param ( [string]$Name, [int]$Id ) \"Name: $Name ID: $ID\"&#125;Test-Command -Name Weltner -Id 12Test-Command Weltner 12 如您所见，使用按位置的参数（只需要指定参数，不需要显式地指定参数名）可能更适用于为特定目的编写的代码，但是可读性更差。这是有可能的，因为上述函数的语法看起来如下： 1Test-Command [[-Name] &lt;string&gt;] [[-Id] &lt;int&gt;] 那么一个编写一个效果相反的 PowerShell 函数，实现这种语法呢： 1Test-Command [-Name &lt;string&gt;] [-Id &lt;int&gt;] [&lt;CommonParameters&gt;] 目前这个方法比较生僻，不过是完全可行的： 12345678910111213function Test-Command&#123; param ( [Parameter(ParameterSetName='xy')] [string]$Name, [Parameter(ParameterSetName='xy')] [int]$Id ) \"Name: $Name ID: $ID\"&#125; 一旦开始使用参数集合，缺省情况下所有参数都是命名的参数。本文国际来源：Prohibiting Positional Parameters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 PowerShell 函数中使用命名的函数","slug":"using-named-parameters-in-powershell-functions","date":"2016-11-21T08:00:00.000Z","updated":"2017-03-17T15:26:27.231Z","comments":true,"path":"2016/11/21/using-named-parameters-in-powershell-functions/","link":"","permalink":"http://blog.vichamp.com/2016/11/21/using-named-parameters-in-powershell-functions/","excerpt":"当您创建一个 PowerShell 函数时，所有参数都有默认的位置，除非人为地加上“Position”属性。一旦加上这个属性，所有不带“Position”的参数将立刻变为命名的必须参数。让我们看看例子： 这是一个经典的函数定义，创建了三个固定位置的参数： 1234567891011function Test-Command&#123; param ( [string]$Name, [int]$ID, [string]$Email ) # TODO: Code using the parameter values&#125; 语法如下： 1Test-Command [[-Name] &lt;string&gt;] [[-ID] &lt;int&gt;] [[-Email] &lt;string&gt;] 一旦您在任何一个参数上添加“Position”属性，其它的就变为命名的参数： 12345678910111213function Test-Command&#123; param ( [Parameter(Position=0)] [string]$Name, [Parameter(Position=1)] [int]$ID, [string]$Email ) # TODO: Code using the parameter values&#125; 以下是它的语法： 1Test-Command [[-Name] &lt;string&gt;] [[-ID] &lt;int&gt;] [-Email &lt;string&gt;] [&lt;CommonParameters&gt;] 区别在哪？您不需要指定参数名 -Name 和 -ID，但如果您希望为第三个参数指定一个值，必须指定 -Email。在第一个例子中，所有三个参数都可以按照位置来定位。","text":"当您创建一个 PowerShell 函数时，所有参数都有默认的位置，除非人为地加上“Position”属性。一旦加上这个属性，所有不带“Position”的参数将立刻变为命名的必须参数。让我们看看例子： 这是一个经典的函数定义，创建了三个固定位置的参数： 1234567891011function Test-Command&#123; param ( [string]$Name, [int]$ID, [string]$Email ) # TODO: Code using the parameter values&#125; 语法如下： 1Test-Command [[-Name] &lt;string&gt;] [[-ID] &lt;int&gt;] [[-Email] &lt;string&gt;] 一旦您在任何一个参数上添加“Position”属性，其它的就变为命名的参数： 12345678910111213function Test-Command&#123; param ( [Parameter(Position=0)] [string]$Name, [Parameter(Position=1)] [int]$ID, [string]$Email ) # TODO: Code using the parameter values&#125; 以下是它的语法： 1Test-Command [[-Name] &lt;string&gt;] [[-ID] &lt;int&gt;] [-Email &lt;string&gt;] [&lt;CommonParameters&gt;] 区别在哪？您不需要指定参数名 -Name 和 -ID，但如果您希望为第三个参数指定一个值，必须指定 -Email。在第一个例子中，所有三个参数都可以按照位置来定位。 本文国际来源：Using Named Parameters in PowerShell Functions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 隐藏启动 PowerShell","slug":"launching-powershell-hidden","date":"2016-11-20T08:00:00.000Z","updated":"2017-03-17T15:26:27.221Z","comments":true,"path":"2016/11/20/launching-powershell-hidden/","link":"","permalink":"http://blog.vichamp.com/2016/11/20/launching-powershell-hidden/","excerpt":"有时候 PowerShell 脚本只是用来生成某些东西，比如说生成报告，而不需要用 Excel 或记事本打开它。这时候您不会希望执行 PowerShell 的时候显示 PowerShell 控制台窗口。 并没有很简单的方法能隐藏 PowerShell 的控制台窗口，因为即使用了 -WindowsStyle Hidden 参数，也会先显示控制台，然后隐藏它（一闪而过）。 一种方法是使用 Windows 快捷方式来启动脚本。右键单击桌面的空白区域，然后选择新建/快捷方式。就可以新建一个快捷方式。当提示输入地址的时候，键入这行代码： 1powershell -noprofile -executionpolicy bypass -file \"c:\\path\\to\\script.ps1\" 点击“下一步”，然后添加脚本的名称，再点击“下一步”，就接近完成了。这个快捷方式显示蓝色的 PowerShell 图标。单击它的时候，脚本即可运行，只是还不是隐藏的。 您现在只需要右键单击新创建的快捷方式，选择“属性”，然后将“运行”的设置从“正常窗口”改为您想要的设置。您也可以设置一个快捷方式，这需要管理员权限。 一个缺点是，在 Windows 10 中，“运行”的设置不再包含隐藏程序的选项。您最多可以最小化执行。","text":"有时候 PowerShell 脚本只是用来生成某些东西，比如说生成报告，而不需要用 Excel 或记事本打开它。这时候您不会希望执行 PowerShell 的时候显示 PowerShell 控制台窗口。 并没有很简单的方法能隐藏 PowerShell 的控制台窗口，因为即使用了 -WindowsStyle Hidden 参数，也会先显示控制台，然后隐藏它（一闪而过）。 一种方法是使用 Windows 快捷方式来启动脚本。右键单击桌面的空白区域，然后选择新建/快捷方式。就可以新建一个快捷方式。当提示输入地址的时候，键入这行代码： 1powershell -noprofile -executionpolicy bypass -file \"c:\\path\\to\\script.ps1\" 点击“下一步”，然后添加脚本的名称，再点击“下一步”，就接近完成了。这个快捷方式显示蓝色的 PowerShell 图标。单击它的时候，脚本即可运行，只是还不是隐藏的。 您现在只需要右键单击新创建的快捷方式，选择“属性”，然后将“运行”的设置从“正常窗口”改为您想要的设置。您也可以设置一个快捷方式，这需要管理员权限。 一个缺点是，在 Windows 10 中，“运行”的设置不再包含隐藏程序的选项。您最多可以最小化执行。 本文国际来源：Launching PowerShell Hidden","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - PowerShell 5.1 中的时区管理","slug":"time-zone-management-in-powershell-5-1","date":"2016-11-17T08:00:00.000Z","updated":"2017-03-17T15:26:27.217Z","comments":true,"path":"2016/11/17/time-zone-management-in-powershell-5-1/","link":"","permalink":"http://blog.vichamp.com/2016/11/17/time-zone-management-in-powershell-5-1/","excerpt":"PowerShell 5.1（随 Windows 10 和 Server 2016 发布）带来一系列管理计算机时区的新 cmdlet。Get-TimeZone 返回当前的设置，而 Set-TimeZone 可以改变时区设置： PS C:\\&gt; Get-TimeZone Id : W. Europe Standard Time DisplayName : (UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna StandardName : W. Europe Standard Time DaylightName : W. Europe Daylight Time BaseUtcOffset : 01:00:00 SupportsDaylightSavingTime : True","text":"PowerShell 5.1（随 Windows 10 和 Server 2016 发布）带来一系列管理计算机时区的新 cmdlet。Get-TimeZone 返回当前的设置，而 Set-TimeZone 可以改变时区设置： PS C:\\&gt; Get-TimeZone Id : W. Europe Standard Time DisplayName : (UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna StandardName : W. Europe Standard Time DaylightName : W. Europe Daylight Time BaseUtcOffset : 01:00:00 SupportsDaylightSavingTime : True 本文国际来源：Time Zone Management in PowerShell 5.1","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 探索函数源码","slug":"exploring-function-source-code","date":"2016-11-16T08:00:00.000Z","updated":"2017-03-17T15:26:27.206Z","comments":true,"path":"2016/11/16/exploring-function-source-code/","link":"","permalink":"http://blog.vichamp.com/2016/11/16/exploring-function-source-code/","excerpt":"在 PowerShell 中，cmdlet 和 function 的唯一根本区别是它们是怎么编程的：函数用的是纯粹的 PowerShell 代码，这也是查看它们的源代码，并学习新东西的有趣之处。 这行代码列出所有当前从 module 中加载的所有 PowerShell function： 1Get-Module | ForEach-Object &#123; Get-Command -Module $_.Name -CommandType Function &#125; 一旦您知道了内存中某个函数的名字，可以用这种方法快捷查看它的源代码。在这些例子中，我们将探索 Format-Hex 函数。只需要将这个名字替换成内存中存在的其它函数名即可： 1$&#123;function:Format-Hex&#125; | clip.exe 这行代码将源代码存入剪贴板，您可以将它粘贴到您喜欢的编辑器中。另外，您也可以用这种方式运行： 123Get-Command -Name Format-Hex -CommandType Function | Select-Object -ExpandProperty Definition | clip.exe","text":"在 PowerShell 中，cmdlet 和 function 的唯一根本区别是它们是怎么编程的：函数用的是纯粹的 PowerShell 代码，这也是查看它们的源代码，并学习新东西的有趣之处。 这行代码列出所有当前从 module 中加载的所有 PowerShell function： 1Get-Module | ForEach-Object &#123; Get-Command -Module $_.Name -CommandType Function &#125; 一旦您知道了内存中某个函数的名字，可以用这种方法快捷查看它的源代码。在这些例子中，我们将探索 Format-Hex 函数。只需要将这个名字替换成内存中存在的其它函数名即可： 1$&#123;function:Format-Hex&#125; | clip.exe 这行代码将源代码存入剪贴板，您可以将它粘贴到您喜欢的编辑器中。另外，您也可以用这种方式运行： 123Get-Command -Name Format-Hex -CommandType Function | Select-Object -ExpandProperty Definition | clip.exe 本文国际来源：Exploring Function Source Code","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在同一台机器上运行 32 位代码","slug":"running-32-bit-code-on-the-same-machine","date":"2016-11-15T08:00:00.000Z","updated":"2017-03-17T15:26:27.198Z","comments":true,"path":"2016/11/15/running-32-bit-code-on-the-same-machine/","link":"","permalink":"http://blog.vichamp.com/2016/11/15/running-32-bit-code-on-the-same-machine/","excerpt":"如果您需要在 64 位脚本中运行 32 位 PowerShell 代码，假设您是管理员，并且使用远程操作功能，您可以远程操作您的系统： 1234567$code = &#123; [IntPtr]::Size Get-Process&#125;Invoke-Command -ScriptBlock $code -ConfigurationName microsoft.powershell32 -ComputerName $env:COMPUTERNAME 这将在 32 位环境中运行 $code 中的脚本块。该指针返回的 size 是 4，这是 32 位的证据。当您直接运行脚本块，返回的是 8 字节（64 比特）。","text":"如果您需要在 64 位脚本中运行 32 位 PowerShell 代码，假设您是管理员，并且使用远程操作功能，您可以远程操作您的系统： 1234567$code = &#123; [IntPtr]::Size Get-Process&#125;Invoke-Command -ScriptBlock $code -ConfigurationName microsoft.powershell32 -ComputerName $env:COMPUTERNAME 这将在 32 位环境中运行 $code 中的脚本块。该指针返回的 size 是 4，这是 32 位的证据。当您直接运行脚本块，返回的是 8 字节（64 比特）。 本文国际来源：Running 32-bit Code on the Same Machine","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - systeminfo.exe 的最新替代","slug":"modern-replacement-for-systeminfo-exe","date":"2016-11-14T08:00:00.000Z","updated":"2017-03-17T15:26:27.188Z","comments":true,"path":"2016/11/14/modern-replacement-for-systeminfo-exe/","link":"","permalink":"http://blog.vichamp.com/2016/11/14/modern-replacement-for-systeminfo-exe/","excerpt":"曾几何时，systeminfo.exe 返回一台电脑所有的分析信息，并且有一些能够在 PowerShell 中变成面向对象的： PS C:\\&gt; $info = systeminfo.exe /FO CSV | ConvertFrom-Csv PS C:\\&gt; $info.Domain WORKGROUP PS C:\\&gt; $info.&apos;Logon Server&apos; \\\\DESKTOP-7AAMJLF 在 PowerShell 5.1 （Windows 10 和 Server 2016 ）中，有一个现代的替代品： PS C:\\&gt; Get-ComputerInfo WindowsBuildLabEx : 14393.321.amd64fre.rs1_release_inmarket.161004-2338 WindowsCurrentVersion : 6.3 WindowsEditionId : Professional WindowsInstallationType : Client WindowsInstallDateFromRegistry : 8/17/2016 1:40:27 PM WindowsProductId : 00350-50721-50845-ACOEM WindowsProductName : Windows 10 Pro WindowsRegisteredOrganization : WindowsRegisteredOwner : topoftheworld WindowsSystemRoot : C:\\WINDOWS BiosCharacteristics : {7, 9, 11, 12...} BiosBIOSVersion : {DELL - 1072009, 1.4.4, American Megatrends - 5000B} BiosBuildNumber : BiosCaption : 1.4.4 BiosCodeSet : BiosCurrentLanguage : en|US|iso8859-1 BiosDescription : 1.4.4 BiosEmbeddedControllerMajorVersion : 255 BiosEmbeddedControllerMinorVersion : 255 BiosFirmwareType : Uefi BiosIdentificationCode : BiosInstallableLanguages : 2 BiosInstallDate : BiosLanguageEdition : BiosListOfLanguages : {en|US|iso8859-1, } BiosManufacturer : Dell Inc. BiosName : 1.4.4 BiosOtherTargetOS : BiosPrimaryBIOS : True BiosReleaseDate : 6/14/2016 2:00:00 AM BiosSeralNumber : DLGQD72 BiosSMBIOSBIOSVersion : 1.4.4 BiosSMBIOSMajorVersion : 2 BiosSMBIOSMinorVersion : 8 BiosSMBIOSPresent : True BiosSoftwareElementState : Running BiosStatus : OK BiosSystemBiosMajorVersion : 1 BiosSystemBiosMinorVersion : 4 BiosTargetOperatingSystem : 0 BiosVersion : DELL - 1072009 CsAdminPasswordStatus : Unknown CsAutomaticManagedPagefile : True CsAutomaticResetBootOption : True CsAutomaticResetCapability : True CsBootOptionOnLimit : CsBootOptionOnWatchDog : CsBootROMSupported : True CsBootStatus : {0, 0, 0, 0...} CsBootupState : Normal boot CsCaption : CLIENT CsChassisBootupState : Safe CsChassisSKUNumber : Laptop CsCurrentTimeZone : 120 CsDaylightInEffect : True CsDescription : AT/AT COMPATIBLE CsDNSHostName : DESKTOP-7AAMJLF CsDomain : WORKGROUP CsDomainRole : StandaloneWorkstation CsEnableDaylightSavingsTime : True CsFrontPanelResetStatus : Unknown CsHypervisorPresent : False CsInfraredSupported : False CsInitialLoadInfo : CsInstallDate : CsKeyboardPasswordStatus : Unknown CsLastLoadInfo : CsManufacturer : Dell Inc. CsModel : XPS 13 9350 CsName : CLIENT CsNetworkAdapters : {WiFi, Bluetooth-Netzwerkverbindung} CsNetworkServerModeEnabled : True CsNumberOfLogicalProcessors : 4 CsNumberOfProcessors : 1 CsProcessors : {Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz} CsOEMStringArray : {Dell System, 1[0704], 3[1.0], 12[www.dell.com]...} CsPartOfDomain : False CsPauseAfterReset : -1 CsPCSystemType : Mobile CsPCSystemTypeEx : Mobile CsPowerManagementCapabilities : CsPowerManagementSupported : CsPowerOnPasswordStatus : Unknown CsPowerState : Unknown CsPowerSupplyState : Safe CsPrimaryOwnerContact : CsPrimaryOwnerName : user@company.de CsResetCapability : Other CsResetCount : -1 CsResetLimit : -1 CsRoles : {LM_Workstation, LM_Server, NT, Potential_Browser...} CsStatus : OK CsSupportContactDescription : CsSystemFamily : CsSystemSKUNumber : 0704 CsSystemType : x64-based PC CsThermalState : Safe CsTotalPhysicalMemory : 17045016576 CsPhyicallyInstalledMemory : 16777216 CsUserName : CLIENT12\\TEST CsWakeUpType : PowerSwitch CsWorkgroup : WORKGROUP OsName : Microsoft Windows 10 Pro OsType : WINNT OsOperatingSystemSKU : 48 OsVersion : 10.0.14393 OsCSDVersion : OsBuildNumber : 14393 OsHotFixes : {KB3176936, KB3194343, KB3199209, KB3199986...} OsBootDevice : \\Device\\HarddiskVolume1 OsSystemDevice : \\Device\\HarddiskVolume3 OsSystemDirectory : C:\\WINDOWS\\system32 OsSystemDrive : C: OsWindowsDirectory : C:\\WINDOWS OsCountryCode : 1 OsCurrentTimeZone : 120 OsLocaleID : 0409 OsLocale : en-US OsLocalDateTime : 10/28/2016 4:11:51 PM OsLastBootUpTime : 10/19/2016 7:48:03 AM OsUptime : 9.08:23:47.7627676 OsBuildType : Multiprocessor Free OsCodeSet : 1252 OsDataExecutionPreventionAvailable : True OsDataExecutionPrevention32BitApplications : True OsDataExecutionPreventionDrivers : True OsDataExecutionPreventionSupportPolicy : OptIn OsDebug : False OsDistributed : False OsEncryptionLevel : 256 OsForegroundApplicationBoost : Maximum OsTotalVisibleMemorySize : 16645524 OsFreePhysicalMemory : 9128212 OsTotalVirtualMemorySize : 19135892 OsFreeVirtualMemory : 8607696 OsInUseVirtualMemory : 10528196 OsTotalSwapSpaceSize : OsSizeStoredInPagingFiles : 2490368 OsFreeSpaceInPagingFiles : 2442596 OsPagingFiles : {C:\\pagefile.sys} OsHardwareAbstractionLayer : 10.0.14393.206 OsInstallDate : 8/17/2016 3:40:27 PM OsManufacturer : Microsoft Corporation OsMaxNumberOfProcesses : 4294967295 OsMaxProcessMemorySize : 137438953344 OsMuiLanguages : {de-DE, en-US} OsNumberOfLicensedUsers : OsNumberOfProcesses : 157 OsNumberOfUsers : 2 OsOrganization : OsArchitecture : 64-bit OsLanguage : de-DE OsProductSuites : {TerminalServicesSingleSession} OsOtherTypeDescription : OsPAEEnabled : OsPortableOperatingSystem : False OsPrimary : True OsProductType : WorkStation OsRegisteredUser : test@company.com OsSerialNumber : 00330-50021-50665-AAOEM OsServicePackMajorVersion : 0 OsServicePackMinorVersion : 0 OsStatus : OK OsSuites : {TerminalServices, TerminalServicesSingleSession} OsServerLevel : KeyboardLayout : de-DE TimeZone : (UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna LogonServer : \\\\CLIENT PowerPlatformRole : Mobile HyperVisorPresent : False HyperVRequirementDataExecutionPreventionAvailable : True HyperVRequirementSecondLevelAddressTranslation : True HyperVRequirementVirtualizationFirmwareEnabled : True HyperVRequirementVMMonitorModeExtensions : True DeviceGuardSmartStatus : Off DeviceGuardRequiredSecurityProperties : DeviceGuardAvailableSecurityProperties : DeviceGuardSecurityServicesConfigured : DeviceGuardSecurityServicesRunning : DeviceGuardCodeIntegrityPolicyEnforcementStatus : DeviceGuardUserModeCodeIntegrityPolicyEnforcementStatus :","text":"曾几何时，systeminfo.exe 返回一台电脑所有的分析信息，并且有一些能够在 PowerShell 中变成面向对象的： PS C:\\&gt; $info = systeminfo.exe /FO CSV | ConvertFrom-Csv PS C:\\&gt; $info.Domain WORKGROUP PS C:\\&gt; $info.&apos;Logon Server&apos; \\\\DESKTOP-7AAMJLF 在 PowerShell 5.1 （Windows 10 和 Server 2016 ）中，有一个现代的替代品： PS C:\\&gt; Get-ComputerInfo WindowsBuildLabEx : 14393.321.amd64fre.rs1_release_inmarket.161004-2338 WindowsCurrentVersion : 6.3 WindowsEditionId : Professional WindowsInstallationType : Client WindowsInstallDateFromRegistry : 8/17/2016 1:40:27 PM WindowsProductId : 00350-50721-50845-ACOEM WindowsProductName : Windows 10 Pro WindowsRegisteredOrganization : WindowsRegisteredOwner : topoftheworld WindowsSystemRoot : C:\\WINDOWS BiosCharacteristics : {7, 9, 11, 12...} BiosBIOSVersion : {DELL - 1072009, 1.4.4, American Megatrends - 5000B} BiosBuildNumber : BiosCaption : 1.4.4 BiosCodeSet : BiosCurrentLanguage : en|US|iso8859-1 BiosDescription : 1.4.4 BiosEmbeddedControllerMajorVersion : 255 BiosEmbeddedControllerMinorVersion : 255 BiosFirmwareType : Uefi BiosIdentificationCode : BiosInstallableLanguages : 2 BiosInstallDate : BiosLanguageEdition : BiosListOfLanguages : {en|US|iso8859-1, } BiosManufacturer : Dell Inc. BiosName : 1.4.4 BiosOtherTargetOS : BiosPrimaryBIOS : True BiosReleaseDate : 6/14/2016 2:00:00 AM BiosSeralNumber : DLGQD72 BiosSMBIOSBIOSVersion : 1.4.4 BiosSMBIOSMajorVersion : 2 BiosSMBIOSMinorVersion : 8 BiosSMBIOSPresent : True BiosSoftwareElementState : Running BiosStatus : OK BiosSystemBiosMajorVersion : 1 BiosSystemBiosMinorVersion : 4 BiosTargetOperatingSystem : 0 BiosVersion : DELL - 1072009 CsAdminPasswordStatus : Unknown CsAutomaticManagedPagefile : True CsAutomaticResetBootOption : True CsAutomaticResetCapability : True CsBootOptionOnLimit : CsBootOptionOnWatchDog : CsBootROMSupported : True CsBootStatus : {0, 0, 0, 0...} CsBootupState : Normal boot CsCaption : CLIENT CsChassisBootupState : Safe CsChassisSKUNumber : Laptop CsCurrentTimeZone : 120 CsDaylightInEffect : True CsDescription : AT/AT COMPATIBLE CsDNSHostName : DESKTOP-7AAMJLF CsDomain : WORKGROUP CsDomainRole : StandaloneWorkstation CsEnableDaylightSavingsTime : True CsFrontPanelResetStatus : Unknown CsHypervisorPresent : False CsInfraredSupported : False CsInitialLoadInfo : CsInstallDate : CsKeyboardPasswordStatus : Unknown CsLastLoadInfo : CsManufacturer : Dell Inc. CsModel : XPS 13 9350 CsName : CLIENT CsNetworkAdapters : {WiFi, Bluetooth-Netzwerkverbindung} CsNetworkServerModeEnabled : True CsNumberOfLogicalProcessors : 4 CsNumberOfProcessors : 1 CsProcessors : {Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz} CsOEMStringArray : {Dell System, 1[0704], 3[1.0], 12[www.dell.com]...} CsPartOfDomain : False CsPauseAfterReset : -1 CsPCSystemType : Mobile CsPCSystemTypeEx : Mobile CsPowerManagementCapabilities : CsPowerManagementSupported : CsPowerOnPasswordStatus : Unknown CsPowerState : Unknown CsPowerSupplyState : Safe CsPrimaryOwnerContact : CsPrimaryOwnerName : user@company.de CsResetCapability : Other CsResetCount : -1 CsResetLimit : -1 CsRoles : {LM_Workstation, LM_Server, NT, Potential_Browser...} CsStatus : OK CsSupportContactDescription : CsSystemFamily : CsSystemSKUNumber : 0704 CsSystemType : x64-based PC CsThermalState : Safe CsTotalPhysicalMemory : 17045016576 CsPhyicallyInstalledMemory : 16777216 CsUserName : CLIENT12\\TEST CsWakeUpType : PowerSwitch CsWorkgroup : WORKGROUP OsName : Microsoft Windows 10 Pro OsType : WINNT OsOperatingSystemSKU : 48 OsVersion : 10.0.14393 OsCSDVersion : OsBuildNumber : 14393 OsHotFixes : {KB3176936, KB3194343, KB3199209, KB3199986...} OsBootDevice : \\Device\\HarddiskVolume1 OsSystemDevice : \\Device\\HarddiskVolume3 OsSystemDirectory : C:\\WINDOWS\\system32 OsSystemDrive : C: OsWindowsDirectory : C:\\WINDOWS OsCountryCode : 1 OsCurrentTimeZone : 120 OsLocaleID : 0409 OsLocale : en-US OsLocalDateTime : 10/28/2016 4:11:51 PM OsLastBootUpTime : 10/19/2016 7:48:03 AM OsUptime : 9.08:23:47.7627676 OsBuildType : Multiprocessor Free OsCodeSet : 1252 OsDataExecutionPreventionAvailable : True OsDataExecutionPrevention32BitApplications : True OsDataExecutionPreventionDrivers : True OsDataExecutionPreventionSupportPolicy : OptIn OsDebug : False OsDistributed : False OsEncryptionLevel : 256 OsForegroundApplicationBoost : Maximum OsTotalVisibleMemorySize : 16645524 OsFreePhysicalMemory : 9128212 OsTotalVirtualMemorySize : 19135892 OsFreeVirtualMemory : 8607696 OsInUseVirtualMemory : 10528196 OsTotalSwapSpaceSize : OsSizeStoredInPagingFiles : 2490368 OsFreeSpaceInPagingFiles : 2442596 OsPagingFiles : {C:\\pagefile.sys} OsHardwareAbstractionLayer : 10.0.14393.206 OsInstallDate : 8/17/2016 3:40:27 PM OsManufacturer : Microsoft Corporation OsMaxNumberOfProcesses : 4294967295 OsMaxProcessMemorySize : 137438953344 OsMuiLanguages : {de-DE, en-US} OsNumberOfLicensedUsers : OsNumberOfProcesses : 157 OsNumberOfUsers : 2 OsOrganization : OsArchitecture : 64-bit OsLanguage : de-DE OsProductSuites : {TerminalServicesSingleSession} OsOtherTypeDescription : OsPAEEnabled : OsPortableOperatingSystem : False OsPrimary : True OsProductType : WorkStation OsRegisteredUser : test@company.com OsSerialNumber : 00330-50021-50665-AAOEM OsServicePackMajorVersion : 0 OsServicePackMinorVersion : 0 OsStatus : OK OsSuites : {TerminalServices, TerminalServicesSingleSession} OsServerLevel : KeyboardLayout : de-DE TimeZone : (UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna LogonServer : \\\\CLIENT PowerPlatformRole : Mobile HyperVisorPresent : False HyperVRequirementDataExecutionPreventionAvailable : True HyperVRequirementSecondLevelAddressTranslation : True HyperVRequirementVirtualizationFirmwareEnabled : True HyperVRequirementVMMonitorModeExtensions : True DeviceGuardSmartStatus : Off DeviceGuardRequiredSecurityProperties : DeviceGuardAvailableSecurityProperties : DeviceGuardSecurityServicesConfigured : DeviceGuardSecurityServicesRunning : DeviceGuardCodeIntegrityPolicyEnforcementStatus : DeviceGuardUserModeCodeIntegrityPolicyEnforcementStatus : 本文国际来源：Modern Replacement for systeminfo.exe","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 本地帐户的内置支持","slug":"built-in-support-for-local-accounts","date":"2016-11-13T08:00:00.000Z","updated":"2017-03-17T15:26:27.177Z","comments":true,"path":"2016/11/13/built-in-support-for-local-accounts/","link":"","permalink":"http://blog.vichamp.com/2016/11/13/built-in-support-for-local-accounts/","excerpt":"从 PowerShell 5.1 开始，终于内置支持了本地用户账户。PowerShell 5.1 现在支持 Windows 10 和 Windows Server 2016： PS C:\\&gt; Get-Command -Module *LocalAccounts | Select-Object -ExpandProperty Name Add-LocalGroupMember Disable-LocalUser Enable-LocalUser Get-LocalGroup Get-LocalGroupMember Get-LocalUser New-LocalGroup New-LocalUser Remove-LocalGroup Remove-LocalGroupMember Remove-LocalUser Rename-LocalGroup Rename-LocalUser Set-LocalGroup Set-LocalUser","text":"从 PowerShell 5.1 开始，终于内置支持了本地用户账户。PowerShell 5.1 现在支持 Windows 10 和 Windows Server 2016： PS C:\\&gt; Get-Command -Module *LocalAccounts | Select-Object -ExpandProperty Name Add-LocalGroupMember Disable-LocalUser Enable-LocalUser Get-LocalGroup Get-LocalGroupMember Get-LocalUser New-LocalGroup New-LocalUser Remove-LocalGroup Remove-LocalGroupMember Remove-LocalUser Rename-LocalGroup Rename-LocalUser Set-LocalGroup Set-LocalUser 本文国际来源：Built-In Support for Local Accounts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 Add-Member 时请注意！","slug":"careful-with-add-member","date":"2016-11-10T08:00:00.000Z","updated":"2017-03-17T15:26:27.174Z","comments":true,"path":"2016/11/10/careful-with-add-member/","link":"","permalink":"http://blog.vichamp.com/2016/11/10/careful-with-add-member/","excerpt":"Add-Member 常用来创建自定义对象，例如： 12345$o = New-Object -TypeName PSObject$o | Add-Member -MemberType NoteProperty -Name Notes -Value 'Something'$o | Add-Member -MemberType NoteProperty -Name Date -Value (Get-Date)$o 这可以工作，结果类似这样： PS C:\\&gt; $o Notes Date ----- ---- Something 10/28/2016 3:56:53 PM 然而，这样做效率不高。因为 Add-Member 时动态地扩展现有的对象，而不是创建新的对象。以上代码可以用这种方法更容易地实现： 123456$o = [PSCustomObject]@&#123; Notes = 'Something' Date = Get-Date &#125;$o Add-Member 可以做更多高级的事情，例如添加脚本属性和方法。请检查当您向以上对象添加动态脚本属性时发生了什么： 123456$o = [PSCustomObject]@&#123; Notes = 'Something' Date = Get-Date &#125;$o | Add-Member -MemberType ScriptProperty -Name CurrentDate -Value &#123; Get-Date &#125; 现在请看多次查询该对象时，它的 Date 和 CurrentDate 属性 123456789101112131415161718192021PS C:\\&gt; $o Notes Date CurrentDate ----- ---- ----------- Something 10/28/2016 4:01:54 PM 10/28/2016 4:01:57 PM​ PS C:\\&gt; $o Notes Date CurrentDate ----- ---- ----------- Something 10/28/2016 4:01:54 PM 10/28/2016 4:02:00 PM​ PS C:\\&gt; $o Notes Date CurrentDate ----- ---- ----------- Something 10/28/2016 4:01:54 PM 10/28/2016 4:02:02 PM Date 属性返回的是静态信息；而CurrentDate 属性总是返回当前时间，因为它的值是一个脚本，每次查询这个属性的时候都会执行一次。","text":"Add-Member 常用来创建自定义对象，例如： 12345$o = New-Object -TypeName PSObject$o | Add-Member -MemberType NoteProperty -Name Notes -Value 'Something'$o | Add-Member -MemberType NoteProperty -Name Date -Value (Get-Date)$o 这可以工作，结果类似这样： PS C:\\&gt; $o Notes Date ----- ---- Something 10/28/2016 3:56:53 PM 然而，这样做效率不高。因为 Add-Member 时动态地扩展现有的对象，而不是创建新的对象。以上代码可以用这种方法更容易地实现： 123456$o = [PSCustomObject]@&#123; Notes = 'Something' Date = Get-Date &#125;$o Add-Member 可以做更多高级的事情，例如添加脚本属性和方法。请检查当您向以上对象添加动态脚本属性时发生了什么： 123456$o = [PSCustomObject]@&#123; Notes = 'Something' Date = Get-Date &#125;$o | Add-Member -MemberType ScriptProperty -Name CurrentDate -Value &#123; Get-Date &#125; 现在请看多次查询该对象时，它的 Date 和 CurrentDate 属性 123456789101112131415161718192021PS C:\\&gt; $o Notes Date CurrentDate ----- ---- ----------- Something 10/28/2016 4:01:54 PM 10/28/2016 4:01:57 PM​ PS C:\\&gt; $o Notes Date CurrentDate ----- ---- ----------- Something 10/28/2016 4:01:54 PM 10/28/2016 4:02:00 PM​ PS C:\\&gt; $o Notes Date CurrentDate ----- ---- ----------- Something 10/28/2016 4:01:54 PM 10/28/2016 4:02:02 PM Date 属性返回的是静态信息；而CurrentDate 属性总是返回当前时间，因为它的值是一个脚本，每次查询这个属性的时候都会执行一次。 本文国际来源：Careful with Add-Member!","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - PSCustomObject 到底如何工作","slug":"how-pscustomobject-really-works","date":"2016-11-09T08:00:00.000Z","updated":"2017-03-17T15:26:27.171Z","comments":true,"path":"2016/11/09/how-pscustomobject-really-works/","link":"","permalink":"http://blog.vichamp.com/2016/11/09/how-pscustomobject-really-works/","excerpt":"在前一个技能中我们介绍了如何快速用 PSCustomObject 创建一个新对象： $o = [PSCustomObject]@{ Date = Get-Date BIOS = Get-WmiObject -Class Win32_BIOS Computer = $env:COMPUTERNAME OS = [Environment]::OSVersion Remark = &apos;Some remark&apos; } 实际中，[PSCustomObject] 并不是一个类型，并且也不是在转型一个哈希表。这个场景背后实际发生的是两个步骤的组合，您也可以分别执行这两个步骤： 12345678910111213#requires -Version 3.0# create an ordered hash table$hash = [Ordered]@&#123; Date = Get-Date BIOS = Get-WmiObject -Class Win32_BIOS Computer = $env:COMPUTERNAME OS = [Environment]::OSVersion Remark = 'Some remark'&#125;# turn hash table in object$o = New-Object -TypeName PSObject -Property $hash 由于这段代码用到了 PowerShell 3.0 引入的排序的哈希表，所以无法在 PowerShell 2.0 中使用相同的做法。要支持 PowerShell 2.0 ，请用无序的（传统的）哈希表代替： 123456789101112131415#requires -Version 2.0# create a hash table$hash = @&#123; Date = Get-Date BIOS = Get-WmiObject -Class Win32_BIOS Computer = $env:COMPUTERNAME OS = [Environment]::OSVersion Remark = 'Some remark'&#125;# turn hash table in object$o = New-Object -TypeName PSObject -Property $hash$o","text":"在前一个技能中我们介绍了如何快速用 PSCustomObject 创建一个新对象： $o = [PSCustomObject]@{ Date = Get-Date BIOS = Get-WmiObject -Class Win32_BIOS Computer = $env:COMPUTERNAME OS = [Environment]::OSVersion Remark = &apos;Some remark&apos; } 实际中，[PSCustomObject] 并不是一个类型，并且也不是在转型一个哈希表。这个场景背后实际发生的是两个步骤的组合，您也可以分别执行这两个步骤： 12345678910111213#requires -Version 3.0# create an ordered hash table$hash = [Ordered]@&#123; Date = Get-Date BIOS = Get-WmiObject -Class Win32_BIOS Computer = $env:COMPUTERNAME OS = [Environment]::OSVersion Remark = 'Some remark'&#125;# turn hash table in object$o = New-Object -TypeName PSObject -Property $hash 由于这段代码用到了 PowerShell 3.0 引入的排序的哈希表，所以无法在 PowerShell 2.0 中使用相同的做法。要支持 PowerShell 2.0 ，请用无序的（传统的）哈希表代替： 123456789101112131415#requires -Version 2.0# create a hash table$hash = @&#123; Date = Get-Date BIOS = Get-WmiObject -Class Win32_BIOS Computer = $env:COMPUTERNAME OS = [Environment]::OSVersion Remark = 'Some remark'&#125;# turn hash table in object$o = New-Object -TypeName PSObject -Property $hash$o 本文国际来源：How PSCustomObject Really Works","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建新对象的快速方法","slug":"fast-approach-to-creating-new-objects","date":"2016-11-08T08:00:00.000Z","updated":"2017-03-17T15:26:27.162Z","comments":true,"path":"2016/11/08/fast-approach-to-creating-new-objects/","link":"","permalink":"http://blog.vichamp.com/2016/11/08/fast-approach-to-creating-new-objects/","excerpt":"要将一系列信息打包起来的最好方法就是将它们存储在自定义对象中。最简单最快捷的方法就是用 PSCustomObject： 12345678#requires -Version 3.0$o = [PSCustomObject]@&#123; Date = Get-Date BIOS = Get-WmiObject -Class Win32_BIOS Computer = $env:COMPUTERNAME OS = [Environment]::OSVersion Remark = 'Some remark'&#125; 在大括号内，将一系列信息（或命令执行结果）存储在键中。这将创建一个将包含一系列信息的对象： PS C:\\&gt; $o ​ Date : 10/28/2016 3:47:27 PM BIOS : \\DESKTOP-7AAMJLF\\root\\cimv2:Win32_BIOS.Name=”1.4.4”,SoftwareElementID=”1.4.4”,SoftwareElementState=3,TargetOpera tingSystem=0,Version=”DELL - 1072009” Computer : DESKTOP-7AAMJLF OS : Microsoft Windows NT 10.0.14393.0 Remark : Some remark ​​ PS C:> $o.Remark Some remark PS C:\\&gt; $o.OS Platform ServicePack Version VersionString -------- ----------- ------- ------------- Win32NT 10.0.14393.0 Microsoft Windows NT 10.0.14393.0 ​ PS C:> $o.OS.VersionString Microsoft Windows NT 10.0.14393.0 PS C:\\&gt;","text":"要将一系列信息打包起来的最好方法就是将它们存储在自定义对象中。最简单最快捷的方法就是用 PSCustomObject： 12345678#requires -Version 3.0$o = [PSCustomObject]@&#123; Date = Get-Date BIOS = Get-WmiObject -Class Win32_BIOS Computer = $env:COMPUTERNAME OS = [Environment]::OSVersion Remark = 'Some remark'&#125; 在大括号内，将一系列信息（或命令执行结果）存储在键中。这将创建一个将包含一系列信息的对象： PS C:\\&gt; $o ​ Date : 10/28/2016 3:47:27 PM BIOS : \\DESKTOP-7AAMJLF\\root\\cimv2:Win32_BIOS.Name=”1.4.4”,SoftwareElementID=”1.4.4”,SoftwareElementState=3,TargetOpera tingSystem=0,Version=”DELL - 1072009” Computer : DESKTOP-7AAMJLF OS : Microsoft Windows NT 10.0.14393.0 Remark : Some remark ​​ PS C:> $o.Remark Some remark PS C:\\&gt; $o.OS Platform ServicePack Version VersionString -------- ----------- ------- ------------- Win32NT 10.0.14393.0 Microsoft Windows NT 10.0.14393.0 ​ PS C:> $o.OS.VersionString Microsoft Windows NT 10.0.14393.0 PS C:\\&gt; 本文国际来源：Fast Approach to Creating New Objects","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 利用命令行历史","slug":"exploiting-your-command-history","date":"2016-11-07T08:00:00.000Z","updated":"2017-03-17T15:26:27.156Z","comments":true,"path":"2016/11/07/exploiting-your-command-history/","link":"","permalink":"http://blog.vichamp.com/2016/11/07/exploiting-your-command-history/","excerpt":"PowerShell 将您的所有交互命令行输入“记录”到它的命令行历史中，而 Get-History 负责显示它们。如果您运行了一段时间 PowerShell 并且觉得运行的效果不错，那么可以用以下脚本将所有的交互命令从命令行历史中复制到剪贴板中。接下来您可以将它们粘贴到 PowerShell ISE 中，并使之成为一个脚本： 1234567891011121314151617# define how old your commands may be at most to be included$MaxAgeHours = 4# get all command history items that were started after this$DateLimit = (Get-Date).AddHours(-$MaxAgeHours)# get all command-line commandsGet-History | # exclude all that were aborted Where-Object ExecutionStatus -eq Completed | # exclude all that are older than the limit set above Where-Object StartExecutionTime -gt $DateLimit | # get just the command-line Select-Object -ExpandProperty CommandLine | # copy all to clipboard clip.exe","text":"PowerShell 将您的所有交互命令行输入“记录”到它的命令行历史中，而 Get-History 负责显示它们。如果您运行了一段时间 PowerShell 并且觉得运行的效果不错，那么可以用以下脚本将所有的交互命令从命令行历史中复制到剪贴板中。接下来您可以将它们粘贴到 PowerShell ISE 中，并使之成为一个脚本： 1234567891011121314151617# define how old your commands may be at most to be included$MaxAgeHours = 4# get all command history items that were started after this$DateLimit = (Get-Date).AddHours(-$MaxAgeHours)# get all command-line commandsGet-History | # exclude all that were aborted Where-Object ExecutionStatus -eq Completed | # exclude all that are older than the limit set above Where-Object StartExecutionTime -gt $DateLimit | # get just the command-line Select-Object -ExpandProperty CommandLine | # copy all to clipboard clip.exe 本文国际来源：Exploiting Your Command History","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取PowerShell Gallery 模块的最新版本","slug":"getting-latest-powershell-gallery-module-version","date":"2016-11-06T08:00:00.000Z","updated":"2017-03-17T15:26:27.149Z","comments":true,"path":"2016/11/06/getting-latest-powershell-gallery-module-version/","link":"","permalink":"http://blog.vichamp.com/2016/11/06/getting-latest-powershell-gallery-module-version/","excerpt":"在 www.powershellgallery.com ，Microsoft 发布了一个公开的脚本和模块的仓库。您可以在这里和其他人交流 PowerShell 代码（请见网站）。 要使用这个仓库，您需要 PowerShell 5 或者手动安装 PowerShellGet 模块（在 powershellgallery.com 可以下载到）。接下来您可以使用诸如 Find/Save/Install/Update/Remove-Script/Module 等 cmdlet。 目前缺乏的是一个查看模块当前最新版本号的方法。以下是解决方案： 123456789101112131415161718192021222324function Get-PublishedModuleVersion($Name)&#123; # access the main module page, and add a random number to trick proxies $url = \"https://www.powershellgallery.com/packages/$Name/?dummy=$(Get-Random)\" $request = [System.Net.WebRequest]::Create($url) # do not allow to redirect. The result is a \"MovedPermanently\" $request.AllowAutoRedirect=$false try &#123; # send the request $response = $request.GetResponse() # get back the URL of the true destination page, and split off the version $response.GetResponseHeader(\"Location\").Split(\"/\")[-1] -as [Version] # make sure to clean up $response.Close() $response.Dispose() &#125; catch &#123; Write-Warning $_.Exception.Message &#125;&#125;Get-PublishedModuleVersion -Name ISESteroids 当您运行 Get-PublishedModuleVersion 并传入发布的模块名，执行结果类似如下： PS C:\\&gt; Get-PublishedModuleVersion -Name ISESteroids Major Minor Build Revision ----- ----- ----- -------- 2 6 3 25 这个操作非常非常快，而且可以用来检测已安装的模块，看它们是否是最新版本。","text":"在 www.powershellgallery.com ，Microsoft 发布了一个公开的脚本和模块的仓库。您可以在这里和其他人交流 PowerShell 代码（请见网站）。 要使用这个仓库，您需要 PowerShell 5 或者手动安装 PowerShellGet 模块（在 powershellgallery.com 可以下载到）。接下来您可以使用诸如 Find/Save/Install/Update/Remove-Script/Module 等 cmdlet。 目前缺乏的是一个查看模块当前最新版本号的方法。以下是解决方案： 123456789101112131415161718192021222324function Get-PublishedModuleVersion($Name)&#123; # access the main module page, and add a random number to trick proxies $url = \"https://www.powershellgallery.com/packages/$Name/?dummy=$(Get-Random)\" $request = [System.Net.WebRequest]::Create($url) # do not allow to redirect. The result is a \"MovedPermanently\" $request.AllowAutoRedirect=$false try &#123; # send the request $response = $request.GetResponse() # get back the URL of the true destination page, and split off the version $response.GetResponseHeader(\"Location\").Split(\"/\")[-1] -as [Version] # make sure to clean up $response.Close() $response.Dispose() &#125; catch &#123; Write-Warning $_.Exception.Message &#125;&#125;Get-PublishedModuleVersion -Name ISESteroids 当您运行 Get-PublishedModuleVersion 并传入发布的模块名，执行结果类似如下： PS C:\\&gt; Get-PublishedModuleVersion -Name ISESteroids Major Minor Build Revision ----- ----- ----- -------- 2 6 3 25 这个操作非常非常快，而且可以用来检测已安装的模块，看它们是否是最新版本。 本文国际来源：Getting Latest PowerShell Gallery Module Version","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - （分别）测试文件和文件夹","slug":"testing-files-and-folders-separately","date":"2016-11-03T08:00:00.000Z","updated":"2017-03-17T15:26:27.147Z","comments":true,"path":"2016/11/03/testing-files-and-folders-separately/","link":"","permalink":"http://blog.vichamp.com/2016/11/03/testing-files-and-folders-separately/","excerpt":"Test-Path 在测试一个文件或文件夹是否存在时十分有用，它可以用在任何 PowerShell 驱动器上。所以它也可以测试一个变量、一个函数，或一个证书是否存在（举个例子）。 In recent PowerShell versions, Test-Path can now differentiate between containers (i.e. folders) and leafs (i.e. files), too: 在近期的 PowerShell 版本中，Test-Path 还可以区分容器（例如文件夹）和叶子（例如文件）： 1234567$path = 'c:\\windows\\explorer.exe'# any item typeTest-Path -Path $path# just filesTest-Path -Path $path -PathType Leaf# just foldersTest-Path -Path $path -PathType Container","text":"Test-Path 在测试一个文件或文件夹是否存在时十分有用，它可以用在任何 PowerShell 驱动器上。所以它也可以测试一个变量、一个函数，或一个证书是否存在（举个例子）。 In recent PowerShell versions, Test-Path can now differentiate between containers (i.e. folders) and leafs (i.e. files), too: 在近期的 PowerShell 版本中，Test-Path 还可以区分容器（例如文件夹）和叶子（例如文件）： 1234567$path = 'c:\\windows\\explorer.exe'# any item typeTest-Path -Path $path# just filesTest-Path -Path $path -PathType Leaf# just foldersTest-Path -Path $path -PathType Container 本文国际来源：Testing Files and Folders (separately)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取 Cmdlet 参数的帮助","slug":"getting-help-for-cmdlet-parameters","date":"2016-11-02T08:00:00.000Z","updated":"2017-03-17T15:26:27.140Z","comments":true,"path":"2016/11/02/getting-help-for-cmdlet-parameters/","link":"","permalink":"http://blog.vichamp.com/2016/11/02/getting-help-for-cmdlet-parameters/","excerpt":"在 PowerShell 5.0 中似乎有个 bug，限制了内置帮助窗口的作用。当您以 -ShowWindow 参数运行 Get-Help 命令时，该窗口只显示该 cmdlet 的语法和例子。许多额外信息并没有显示出来。 要获得某个 cmdlet 支持的参数的详细信息，请直接请求该信息。以下代码将解释 Get-Date 中的 -Format 参数是做什么的： PS C:\\&gt; Get-Help -Name Get-Date -Parameter Format -Format [] Displays the date and time in the Microsoft .NET Framework format indicated by the format specifier. Enter a format specifier. For a list of available format specifiers, see DateTimeFormatInfo Class (http://msdn.microsoft.com/library/system.globalization.datetimeformatinfo.aspx) in MSDN. When you use the Format parameter, Windows PowerShell gets only the properties of the DateTime object that it needs to display the date in the format that you specify. As a result, some of the properties and methods of DateTime objects might not be available. Starting in Windows PowerShell 5.0, you can use the following additional formats as values for the Format parameter. -- FileDate. A file or path-friendly representation of the current date in local time. It is in the form of yyyymmdd ( using 4 digits, 2 digits, and 2 digits). An example of results when you use this format is 20150302. -- FileDateUniversal. A file or path-friendly representation of the current date in universal time. It is in the form of yyyymmdd + &apos;Z&apos; (using 4 digits, 2 digits, and 2 digits). An example of results when you use this format is 20150302Z. -- FileDateTime. A file or path-friendly representation of the current date and time in local time, in 24-hour format. It is in the form of yyyymmdd + &apos;T&apos; + hhmmssmsms, where msms is a four-character representation of milliseconds. An example of results when you use this format is 20150302T1240514987. -- FileDateTimeUniversal. A file or path-friendly representation of the current date and time in universal time, in 24-hour format. It is in the form of yyyymmdd + &apos;T&apos; + hhmmssmsms, where msms is a four-character representation of milliseconds, + &apos;Z&apos;. An example of results when you use this format is 20150302T0840539947Z. Required? false Position? named Default value none Accept pipeline input? false Accept wildcard characters? false 通过这些信息，您现在可以知道如何格式化日期和时间： 123$date = Read-Host -Prompt 'Enter a date'$weekday = Get-Date -Date $date -Format 'dddd'\"$date is a $weekday\"","text":"在 PowerShell 5.0 中似乎有个 bug，限制了内置帮助窗口的作用。当您以 -ShowWindow 参数运行 Get-Help 命令时，该窗口只显示该 cmdlet 的语法和例子。许多额外信息并没有显示出来。 要获得某个 cmdlet 支持的参数的详细信息，请直接请求该信息。以下代码将解释 Get-Date 中的 -Format 参数是做什么的： PS C:\\&gt; Get-Help -Name Get-Date -Parameter Format -Format [] Displays the date and time in the Microsoft .NET Framework format indicated by the format specifier. Enter a format specifier. For a list of available format specifiers, see DateTimeFormatInfo Class (http://msdn.microsoft.com/library/system.globalization.datetimeformatinfo.aspx) in MSDN. When you use the Format parameter, Windows PowerShell gets only the properties of the DateTime object that it needs to display the date in the format that you specify. As a result, some of the properties and methods of DateTime objects might not be available. Starting in Windows PowerShell 5.0, you can use the following additional formats as values for the Format parameter. -- FileDate. A file or path-friendly representation of the current date in local time. It is in the form of yyyymmdd ( using 4 digits, 2 digits, and 2 digits). An example of results when you use this format is 20150302. -- FileDateUniversal. A file or path-friendly representation of the current date in universal time. It is in the form of yyyymmdd + &apos;Z&apos; (using 4 digits, 2 digits, and 2 digits). An example of results when you use this format is 20150302Z. -- FileDateTime. A file or path-friendly representation of the current date and time in local time, in 24-hour format. It is in the form of yyyymmdd + &apos;T&apos; + hhmmssmsms, where msms is a four-character representation of milliseconds. An example of results when you use this format is 20150302T1240514987. -- FileDateTimeUniversal. A file or path-friendly representation of the current date and time in universal time, in 24-hour format. It is in the form of yyyymmdd + &apos;T&apos; + hhmmssmsms, where msms is a four-character representation of milliseconds, + &apos;Z&apos;. An example of results when you use this format is 20150302T0840539947Z. Required? false Position? named Default value none Accept pipeline input? false Accept wildcard characters? false 通过这些信息，您现在可以知道如何格式化日期和时间： 123$date = Read-Host -Prompt 'Enter a date'$weekday = Get-Date -Date $date -Format 'dddd'\"$date is a $weekday\" 本文国际来源：Getting Help for Cmdlet Parameters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用一行代码更新 PowerShell 帮助信息","slug":"updating-powershell-help-with-one-liner","date":"2016-11-01T08:00:00.000Z","updated":"2017-03-17T15:26:27.132Z","comments":true,"path":"2016/11/01/updating-powershell-help-with-one-liner/","link":"","permalink":"http://blog.vichamp.com/2016/11/01/updating-powershell-help-with-one-liner/","excerpt":"要获得 PowerShell 最全的输出信息，您需要更新 PowerShell 的帮助至少一次。这将下载并安装当您通过 cmdlet 运行 Get-Help 或是在 PowerShell ISE 中点击一个 cmdlet 并按 F1 时将出现的基础帮助文件集。 更新 PowerShell 帮助需要 Administrator 特权，因为帮助文件存在 Windows 文件夹中。 以下是一个单行命令，演示了如何以管理员特权运行任何 PowerShell 命令。这个命令将更新本地的 PowerShell 帮助文件： 1Start-Process -FilePath powershell -Verb RunAs -ArgumentList \"-noprofile -command Update-Help -UICulture en-us -Force\"","text":"要获得 PowerShell 最全的输出信息，您需要更新 PowerShell 的帮助至少一次。这将下载并安装当您通过 cmdlet 运行 Get-Help 或是在 PowerShell ISE 中点击一个 cmdlet 并按 F1 时将出现的基础帮助文件集。 更新 PowerShell 帮助需要 Administrator 特权，因为帮助文件存在 Windows 文件夹中。 以下是一个单行命令，演示了如何以管理员特权运行任何 PowerShell 命令。这个命令将更新本地的 PowerShell 帮助文件： 1Start-Process -FilePath powershell -Verb RunAs -ArgumentList \"-noprofile -command Update-Help -UICulture en-us -Force\" 本文国际来源：Updating PowerShell Help with One-Liner","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中获得 Cmdlet 的 IntelliSense","slug":"getting-intellisense-for-cmdlet-powershell-ise","date":"2016-10-31T08:00:00.000Z","updated":"2017-03-17T15:26:27.126Z","comments":true,"path":"2016/10/31/getting-intellisense-for-cmdlet-powershell-ise/","link":"","permalink":"http://blog.vichamp.com/2016/10/31/getting-intellisense-for-cmdlet-powershell-ise/","excerpt":"如果您在阅读某些加载到 PowerShell ISE 中的 PowerShell 代码，要获取额外信息十分容易。只需要点击想获得详情的 cmdlet，然后按下 CTRL+SPACE 键即可（译者注：可能会和 IME 切换快捷键冲突）。 这将调出 IntelliSense 菜单，即平时按下 “-“ 和 “.” 触发键时显示的菜单。由于只有一个 cmdlet 匹配成功，所以该列表只有一个项目。过一小会儿，就会弹出一个显示该 cmdlet 支持的所有参数的 tooltip。 如果您想了解更多，请按 F1 键。PowerShell ISE 将把当前位置的 cmdlet 名送给 Get-Help 命令。该帮助将在一个独立的新窗口中显示。","text":"如果您在阅读某些加载到 PowerShell ISE 中的 PowerShell 代码，要获取额外信息十分容易。只需要点击想获得详情的 cmdlet，然后按下 CTRL+SPACE 键即可（译者注：可能会和 IME 切换快捷键冲突）。 这将调出 IntelliSense 菜单，即平时按下 “-“ 和 “.” 触发键时显示的菜单。由于只有一个 cmdlet 匹配成功，所以该列表只有一个项目。过一小会儿，就会弹出一个显示该 cmdlet 支持的所有参数的 tooltip。 如果您想了解更多，请按 F1 键。PowerShell ISE 将把当前位置的 cmdlet 名送给 Get-Help 命令。该帮助将在一个独立的新窗口中显示。 本文国际来源：Getting IntelliSense for Cmdlet (PowerShell ISE)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从网站上下载图片","slug":"downloading-pictures-from-website","date":"2016-10-30T08:00:00.000Z","updated":"2017-03-17T15:26:27.123Z","comments":true,"path":"2016/10/30/downloading-pictures-from-website/","link":"","permalink":"http://blog.vichamp.com/2016/10/30/downloading-pictures-from-website/","excerpt":"有许多有趣的网站，其中一个是 www.metabene.de （至少面向德国访访客），有 33 页内容，艺术家展示了他的绘画，并提供免费下载（只允许私人使用·私人使用）。 在类似这种情况中，PowerShell 可以帮助您将手动从网站下载图片的操作自动化。在 PowerShell 3.0 中，引入了一个称为 Invoke-WebRequest 的“PowerShell 浏览器”，它能够将人类在一个真实浏览器中操作的大多数事情自动化。 当您运行这段脚本时，它访问所有的 33 个网页，检查所有的图片链接，并将它们保存到硬盘上： 12345678910111213141516171819202122232425262728# open destination folder (and create it if needed)$folder = 'c:\\drawings'$exists = Test-Path -Path $folderif (!$exists) &#123; $null = New-Item -Path $folder -ItemType Directory &#125;explorer $folder# walk all 33 web pages that www.metabene.de offers1..33 | ForEach-Object &#123; $url = \"http://www.metabene.de/galerie/page/$_\" # navigate to website... $webpage = Invoke-WebRequest -Uri $url -UseBasicParsing # take sources of all images on this website... $webpage.Images.src | Where-Object &#123; # take only images that were uploaded to this blog $_ -like '*/uploads/*' &#125;&#125; |ForEach-Object &#123; # get filename of URL $filename = $_.Split('/')[-1] # create local file name $destination= Join-Path -Path $Folder -ChildPath $filename # download pictures Invoke-WebRequest -Uri $url -OutFile $destination&#125;","text":"有许多有趣的网站，其中一个是 www.metabene.de （至少面向德国访访客），有 33 页内容，艺术家展示了他的绘画，并提供免费下载（只允许私人使用·私人使用）。 在类似这种情况中，PowerShell 可以帮助您将手动从网站下载图片的操作自动化。在 PowerShell 3.0 中，引入了一个称为 Invoke-WebRequest 的“PowerShell 浏览器”，它能够将人类在一个真实浏览器中操作的大多数事情自动化。 当您运行这段脚本时，它访问所有的 33 个网页，检查所有的图片链接，并将它们保存到硬盘上： 12345678910111213141516171819202122232425262728# open destination folder (and create it if needed)$folder = 'c:\\drawings'$exists = Test-Path -Path $folderif (!$exists) &#123; $null = New-Item -Path $folder -ItemType Directory &#125;explorer $folder# walk all 33 web pages that www.metabene.de offers1..33 | ForEach-Object &#123; $url = \"http://www.metabene.de/galerie/page/$_\" # navigate to website... $webpage = Invoke-WebRequest -Uri $url -UseBasicParsing # take sources of all images on this website... $webpage.Images.src | Where-Object &#123; # take only images that were uploaded to this blog $_ -like '*/uploads/*' &#125;&#125; |ForEach-Object &#123; # get filename of URL $filename = $_.Split('/')[-1] # create local file name $destination= Join-Path -Path $Folder -ChildPath $filename # download pictures Invoke-WebRequest -Uri $url -OutFile $destination&#125; 本文国际来源：Downloading Pictures from Website","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Cmelet 错误报告的简单策略","slug":"simple-strategy-for-cmdlet-error-reporting-directory","date":"2016-10-27T08:00:00.000Z","updated":"2017-03-17T15:26:27.120Z","comments":true,"path":"2016/10/27/simple-strategy-for-cmdlet-error-reporting-directory/","link":"","permalink":"http://blog.vichamp.com/2016/10/27/simple-strategy-for-cmdlet-error-reporting-directory/","excerpt":"在 PowerShell 中，您可以创建复杂的错误处理代码，但有些时候您可能只是想知道出了什么错并且把它记录下来。不需要额外的技能。 以下是两个可能会遇到错误的 cmdlet。当这些 cmdlet 执行完成时，您将能通过 $data1 和 $data2 获得它们的执行结果，并在控制台中见到许多红色的错误信息： 12$data1 = Get-ChildItem -Path c:\\windows -Filter *.ps1 -Recurse $data2 = Get-Process -FileVersionInfo 现在看看这个实验： 12$data1 = Get-ChildItem -Path c:\\windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable errorList$data2 = Get-Process -FileVersionInfo -ErrorAction SilentlyContinue -ErrorVariable +errorList 要禁止错误输出并同时将红色的错误信息写入自定义的错误变量 $errorList 并不需要做太多工作。请注意 -ErrorVariable 参数接受的是一个变量名（不含 “$“ 前缀）。并请注意在这个变量名前添加 “+“ 前缀将能把错误信息附加到变量中，而不是替换变量的值。 现在，两个 cmdlet 运行起来都看不到错误信息了。最后，您可以容易地在 $errorList 中容易地分析错误信息，例如用 Out-File 将它们写入某些错误日志文件： 123$issues = $errorList.CategoryInfo | Select-Object -Property Category, TargetName$issues$issues | Out-File -FilePath $home\\Desktop\\report.txt -Append","text":"在 PowerShell 中，您可以创建复杂的错误处理代码，但有些时候您可能只是想知道出了什么错并且把它记录下来。不需要额外的技能。 以下是两个可能会遇到错误的 cmdlet。当这些 cmdlet 执行完成时，您将能通过 $data1 和 $data2 获得它们的执行结果，并在控制台中见到许多红色的错误信息： 12$data1 = Get-ChildItem -Path c:\\windows -Filter *.ps1 -Recurse $data2 = Get-Process -FileVersionInfo 现在看看这个实验： 12$data1 = Get-ChildItem -Path c:\\windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable errorList$data2 = Get-Process -FileVersionInfo -ErrorAction SilentlyContinue -ErrorVariable +errorList 要禁止错误输出并同时将红色的错误信息写入自定义的错误变量 $errorList 并不需要做太多工作。请注意 -ErrorVariable 参数接受的是一个变量名（不含 “$“ 前缀）。并请注意在这个变量名前添加 “+“ 前缀将能把错误信息附加到变量中，而不是替换变量的值。 现在，两个 cmdlet 运行起来都看不到错误信息了。最后，您可以容易地在 $errorList 中容易地分析错误信息，例如用 Out-File 将它们写入某些错误日志文件： 123$issues = $errorList.CategoryInfo | Select-Object -Property Category, TargetName$issues$issues | Out-File -FilePath $home\\Desktop\\report.txt -Append 本文国际来源：Simple Strategy for Cmdlet Error Reporting","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检查文件名的非法字符","slug":"check-file-names-for-illegal-characters-directory","date":"2016-10-26T08:00:00.000Z","updated":"2017-03-17T15:26:27.114Z","comments":true,"path":"2016/10/26/check-file-names-for-illegal-characters-directory/","link":"","permalink":"http://blog.vichamp.com/2016/10/26/check-file-names-for-illegal-characters-directory/","excerpt":"文件的命名是十分敏感的，不能包含某些特定的保留字符。要验证文件名并确保这些字符是合法的，以下对昨天的脚本（检查文件系统路径）做了一点改进。这个脚本检查文件名的合法性： 12345678910111213141516171819# check path:$filenameToCheck = 'testfile:?.txt'# get invalid characters and escape them for use with RegEx$illegal =[Regex]::Escape(-join [System.Io.Path]::GetInvalidFileNameChars())$pattern = \"[$illegal]\"# find illegal characters$invalid = [regex]::Matches($filenameToCheck, $pattern, 'IgnoreCase').Value | Sort-Object -Unique $hasInvalid = $invalid -ne $nullif ($hasInvalid)&#123; \"Do not use these characters in file names: $invalid\"&#125;else&#123; 'OK!'&#125; 结果如下： Do not use these characters in file names: : ?","text":"文件的命名是十分敏感的，不能包含某些特定的保留字符。要验证文件名并确保这些字符是合法的，以下对昨天的脚本（检查文件系统路径）做了一点改进。这个脚本检查文件名的合法性： 12345678910111213141516171819# check path:$filenameToCheck = 'testfile:?.txt'# get invalid characters and escape them for use with RegEx$illegal =[Regex]::Escape(-join [System.Io.Path]::GetInvalidFileNameChars())$pattern = \"[$illegal]\"# find illegal characters$invalid = [regex]::Matches($filenameToCheck, $pattern, 'IgnoreCase').Value | Sort-Object -Unique $hasInvalid = $invalid -ne $nullif ($hasInvalid)&#123; \"Do not use these characters in file names: $invalid\"&#125;else&#123; 'OK!'&#125; 结果如下： Do not use these characters in file names: : ? 本文国际来源：Check File Names for Illegal Characters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找文件路径中的非法字符（基于文件系统）","slug":"finding-illegal-characters-in-paths-file-system-directory","date":"2016-10-25T08:00:00.000Z","updated":"2017-03-17T15:26:27.106Z","comments":true,"path":"2016/10/25/finding-illegal-characters-in-paths-file-system-directory/","link":"","permalink":"http://blog.vichamp.com/2016/10/25/finding-illegal-characters-in-paths-file-system-directory/","excerpt":"之前我们演示了如何使用简易的基于正则表达式的方法来查找字符串中的非法字符。我们鼓励您将这种策略运用到各种需要验证的字符串中。 如果您希望检测文件系统中的非法字符，以下是一个简单的适配： 12345678910111213141516171819# check path:$pathToCheck = 'c:\\test\\&lt;somefolder&gt;\\f|le.txt'# get invalid characters and escape them for use with RegEx$illegal =[Regex]::Escape(-join [System.Io.Path]::GetInvalidPathChars())$pattern = \"[$illegal]\"# find illegal characters$invalid = [regex]::Matches($pathToCheck, $pattern, 'IgnoreCase').Value | Sort-Object -Unique $hasInvalid = $invalid -ne $nullif ($hasInvalid)&#123; \"Do not use these characters in paths: $invalid\"&#125;else&#123; 'OK!'&#125; 非法的字符是从 GetInvalidPathChars() 中提取的并且用正则表达式转换为转义字符串。这个列表放在方括号中，所以当其中任一字符匹配成功时，RegEx 将能够报告匹配结果。 以下是结果： Do not use these characters in paths: | &lt; &gt;","text":"之前我们演示了如何使用简易的基于正则表达式的方法来查找字符串中的非法字符。我们鼓励您将这种策略运用到各种需要验证的字符串中。 如果您希望检测文件系统中的非法字符，以下是一个简单的适配： 12345678910111213141516171819# check path:$pathToCheck = 'c:\\test\\&lt;somefolder&gt;\\f|le.txt'# get invalid characters and escape them for use with RegEx$illegal =[Regex]::Escape(-join [System.Io.Path]::GetInvalidPathChars())$pattern = \"[$illegal]\"# find illegal characters$invalid = [regex]::Matches($pathToCheck, $pattern, 'IgnoreCase').Value | Sort-Object -Unique $hasInvalid = $invalid -ne $nullif ($hasInvalid)&#123; \"Do not use these characters in paths: $invalid\"&#125;else&#123; 'OK!'&#125; 非法的字符是从 GetInvalidPathChars() 中提取的并且用正则表达式转换为转义字符串。这个列表放在方括号中，所以当其中任一字符匹配成功时，RegEx 将能够报告匹配结果。 以下是结果： Do not use these characters in paths: | &lt; &gt; 本文国际来源：Finding Illegal Characters in Paths (File System)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找多个非法字符","slug":"finding-multiple-illegal-characters-directory","date":"2016-10-24T08:00:00.000Z","updated":"2017-03-17T15:26:27.097Z","comments":true,"path":"2016/10/24/finding-multiple-illegal-characters-directory/","link":"","permalink":"http://blog.vichamp.com/2016/10/24/finding-multiple-illegal-characters-directory/","excerpt":"之前发，我们演示了如何用 -match 操作符来查找一段文本中的非法字符。不过，-match 操作符只能查找第一个匹配项。要列出字符串中的所有非法字符，请使用这种方法： 1234567891011# some email address$mail = 'THOMAS.börßen_senbÖrg@test.com'# list of legal characters, inverted by \"^\"$pattern = '[^a-z0-9\\.@]'# find all matches, case-insensitive$allMatch = [regex]::Matches($mail, $pattern, 'IgnoreCase')# create list of invalid characters$invalid = $allMatch.Value | Sort-Object -Unique 'Illegal characters found: &#123;0&#125;' -f ($invalid -join ', ') 结果看起来如下： Illegal characters found: _, ö, ß","text":"之前发，我们演示了如何用 -match 操作符来查找一段文本中的非法字符。不过，-match 操作符只能查找第一个匹配项。要列出字符串中的所有非法字符，请使用这种方法： 1234567891011# some email address$mail = 'THOMAS.börßen_senbÖrg@test.com'# list of legal characters, inverted by \"^\"$pattern = '[^a-z0-9\\.@]'# find all matches, case-insensitive$allMatch = [regex]::Matches($mail, $pattern, 'IgnoreCase')# create list of invalid characters$invalid = $allMatch.Value | Sort-Object -Unique 'Illegal characters found: &#123;0&#125;' -f ($invalid -join ', ') 结果看起来如下： Illegal characters found: _, ö, ß 本文国际来源：Finding Multiple Illegal Characters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检查电子邮件地址（或其它文本）中的非法字符","slug":"checking-email-addresses-and-other-text-for-illegal-chars-directory","date":"2016-10-23T08:00:00.000Z","updated":"2017-03-17T15:26:27.090Z","comments":true,"path":"2016/10/23/checking-email-addresses-and-other-text-for-illegal-chars-directory/","link":"","permalink":"http://blog.vichamp.com/2016/10/23/checking-email-addresses-and-other-text-for-illegal-chars-directory/","excerpt":"这是一个清晰的检测和验证数据的快捷方法。假设您需要验证一个电子邮件地址是否包含非法字符： 12345678910111213# some email address$mail = 'thomas.börsenberg@test.com'# list of allowed characters$pattern = '[^a-z0-9\\.@]'if ($mail -match $pattern)&#123; ('Invalid character in email address: &#123;0&#125;' -f $matches[0])&#125;else&#123; 'Email address is good.'&#125; 这段代码使用了正则表达式。正则表达式列出所有合法的字符（从 a 到 z，以及某些特殊字符）。在前面加上“^”，列表的含义发生反转，代表所有非法字符。如果找到至少一个字符，则返回第一个非法字符。 Invalid character in email address: ö","text":"这是一个清晰的检测和验证数据的快捷方法。假设您需要验证一个电子邮件地址是否包含非法字符： 12345678910111213# some email address$mail = 'thomas.börsenberg@test.com'# list of allowed characters$pattern = '[^a-z0-9\\.@]'if ($mail -match $pattern)&#123; ('Invalid character in email address: &#123;0&#125;' -f $matches[0])&#125;else&#123; 'Email address is good.'&#125; 这段代码使用了正则表达式。正则表达式列出所有合法的字符（从 a 到 z，以及某些特殊字符）。在前面加上“^”，列表的含义发生反转，代表所有非法字符。如果找到至少一个字符，则返回第一个非法字符。 Invalid character in email address: ö 本文国际来源：Checking Email Addresses (and Other Text) for Illegal Chars","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - PowerShell Remoting and HTTP 403 Error","slug":"powershell-remoting-and-http-403-error","date":"2016-10-20T08:00:00.000Z","updated":"2017-03-17T15:26:27.087Z","comments":true,"path":"2016/10/20/powershell-remoting-and-http-403-error/","link":"","permalink":"http://blog.vichamp.com/2016/10/20/powershell-remoting-and-http-403-error/","excerpt":"如果您在使用 PowerShell 远程操作时遇到“HTTP 403”错误，一个潜在的原因可能是代理服务器影响了请求。 不过，要禁用代理服务器很容易。只需要在您的呼叫中增加一个 session 选项并且将 ProxyAccessType 设置为“NoProxyServer”即可： 12345678# you are connecting to this computer# the computer in $destinationcomputer needs to have # PowerShell remoting enabled$DestinationComputer = 'server12'$option = New-PSSessionOption -ProxyAccessType NoProxyServerInvoke-Command -ScriptBlock &#123; \"Connected to $env:computername\" &#125; -ComputerName $DestinationComputer -SessionOption $option","text":"如果您在使用 PowerShell 远程操作时遇到“HTTP 403”错误，一个潜在的原因可能是代理服务器影响了请求。 不过，要禁用代理服务器很容易。只需要在您的呼叫中增加一个 session 选项并且将 ProxyAccessType 设置为“NoProxyServer”即可： 12345678# you are connecting to this computer# the computer in $destinationcomputer needs to have # PowerShell remoting enabled$DestinationComputer = 'server12'$option = New-PSSessionOption -ProxyAccessType NoProxyServerInvoke-Command -ScriptBlock &#123; \"Connected to $env:computername\" &#125; -ComputerName $DestinationComputer -SessionOption $option 本文国际来源：PowerShell Remoting and HTTP 403 Error","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在单侧启用 CredSSP","slug":"enabling-credssp-trust-from-one-side","date":"2016-10-19T08:00:00.000Z","updated":"2017-03-17T15:26:27.084Z","comments":true,"path":"2016/10/19/enabling-credssp-trust-from-one-side/","link":"","permalink":"http://blog.vichamp.com/2016/10/19/enabling-credssp-trust-from-one-side/","excerpt":"如之前所示，CredSSP 可以用在远程代码上，避免二次连接问题。不过，要使用 CredSSP 验证方式您得在客户端和服务端分别设置，才能使它们彼此信任。 这并不意味着您必须物理接触那台服务器。如果您想在您的计算机和任何一台服务器（假设那台服务器上启用了 PowerShell 远程连接）建立一个 CredSSP 信任关系，只需要做这些： 12345678#requires -Version 2.0 -RunAsAdministrator # this is the server you want to communicate with using CredSSP# the server needs to have PowerShell remoting enabled already$Server = 'NameOfServer'Enable-WSManCredSSP -Role Client -DelegateComputer $Server -ForceInvoke-Command &#123; Enable-WSManCredSSP -Role Server &#125; -ComputerName $Server 如您所见，Enable-WSManCredSSP 可以远程执行。","text":"如之前所示，CredSSP 可以用在远程代码上，避免二次连接问题。不过，要使用 CredSSP 验证方式您得在客户端和服务端分别设置，才能使它们彼此信任。 这并不意味着您必须物理接触那台服务器。如果您想在您的计算机和任何一台服务器（假设那台服务器上启用了 PowerShell 远程连接）建立一个 CredSSP 信任关系，只需要做这些： 12345678#requires -Version 2.0 -RunAsAdministrator # this is the server you want to communicate with using CredSSP# the server needs to have PowerShell remoting enabled already$Server = 'NameOfServer'Enable-WSManCredSSP -Role Client -DelegateComputer $Server -ForceInvoke-Command &#123; Enable-WSManCredSSP -Role Server &#125; -ComputerName $Server 如您所见，Enable-WSManCredSSP 可以远程执行。 本文国际来源：Enabling CredSSP Trust from One Side","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 CredSSP 解决二次远程连接","slug":"solving-double-hop-remoting-with-credssp","date":"2016-10-18T08:00:00.000Z","updated":"2017-03-17T15:26:27.082Z","comments":true,"path":"2016/10/18/solving-double-hop-remoting-with-credssp/","link":"","permalink":"http://blog.vichamp.com/2016/10/18/solving-double-hop-remoting-with-credssp/","excerpt":"在钱一个技能中我们演示了当您的远程代码试图通过第三方身份认证时会遇到的二次远程连接问题。 在您在客户端和服务端之间创建了一个可信的连接之后，可以传递您的凭据（只需要做一次，并且需要管理员权限）。 在客户端，运行这段代码： 1Enable-WSManCredSSP -Role Client -DelegateComputer nameOfServer 在服务端，运行这段代码： 1Enable-WSManCredSSP -Role Server 现在将 PowerShell 代码从客户端发送到服务端并执行时，服务端能够将您的凭据送给第三方验证通过，所以远程代码可以通过文件服务器的身份认证并访问共享文件夹： 12345678#requires -Version 3.0$code = &#123; Get-ChildItem -Path \\\\fls01\\#TRAIN1\\PowerShell\\Class &#125;Invoke-Command -Authentication Credssp -ScriptBlock $code -ComputerName nameOfServer -Credential myCompany\\myName 请注意当您使用 CredSSP 验证时，您必须提交显式的凭据（用 -Credential）且无法通过 Kerberos 透明传输当前的身份。","text":"在钱一个技能中我们演示了当您的远程代码试图通过第三方身份认证时会遇到的二次远程连接问题。 在您在客户端和服务端之间创建了一个可信的连接之后，可以传递您的凭据（只需要做一次，并且需要管理员权限）。 在客户端，运行这段代码： 1Enable-WSManCredSSP -Role Client -DelegateComputer nameOfServer 在服务端，运行这段代码： 1Enable-WSManCredSSP -Role Server 现在将 PowerShell 代码从客户端发送到服务端并执行时，服务端能够将您的凭据送给第三方验证通过，所以远程代码可以通过文件服务器的身份认证并访问共享文件夹： 12345678#requires -Version 3.0$code = &#123; Get-ChildItem -Path \\\\fls01\\#TRAIN1\\PowerShell\\Class &#125;Invoke-Command -Authentication Credssp -ScriptBlock $code -ComputerName nameOfServer -Credential myCompany\\myName 请注意当您使用 CredSSP 验证时，您必须提交显式的凭据（用 -Credential）且无法通过 Kerberos 透明传输当前的身份。 本文国际来源：Solving Double Hop Remoting with CredSSP","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 理解二次远程连接问题","slug":"understanding-the-double-hop-problem-in-remoting","date":"2016-10-17T08:00:00.000Z","updated":"2017-03-17T15:26:27.079Z","comments":true,"path":"2016/10/17/understanding-the-double-hop-problem-in-remoting/","link":"","permalink":"http://blog.vichamp.com/2016/10/17/understanding-the-double-hop-problem-in-remoting/","excerpt":"当您用 Invoke-Command 远程执行 PowerShell 代码时，您的凭据将会锁定在首个连接的机器上。 PowerShell 远程连接默认情况下不会传递您的凭据，不会使用您的凭据来登录别的系统。这听起来是个好主意，不过在某些情况也严重限制了您的代码。 这是一个典型的错误代码： 123456$code = &#123; Get-ChildItem -Path \\\\fls01\\#TRAIN1\\PowerShell\\Class &#125;Invoke-Command -ScriptBlock $code -ComputerName server1 这段代码试图在远程访问一个文件共享。但是即便您有权限访问该共享，这段远程代码也无法使用您的身份进行第三方验证（在这个例子中是文件服务器）。","text":"当您用 Invoke-Command 远程执行 PowerShell 代码时，您的凭据将会锁定在首个连接的机器上。 PowerShell 远程连接默认情况下不会传递您的凭据，不会使用您的凭据来登录别的系统。这听起来是个好主意，不过在某些情况也严重限制了您的代码。 这是一个典型的错误代码： 123456$code = &#123; Get-ChildItem -Path \\\\fls01\\#TRAIN1\\PowerShell\\Class &#125;Invoke-Command -ScriptBlock $code -ComputerName server1 这段代码试图在远程访问一个文件共享。但是即便您有权限访问该共享，这段远程代码也无法使用您的身份进行第三方验证（在这个例子中是文件服务器）。 本文国际来源：Understanding the Double-Hop Problem in Remoting","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找隐藏的自启动程序","slug":"finding-hidden-autostart-programs","date":"2016-10-16T08:00:00.000Z","updated":"2017-03-17T15:26:27.076Z","comments":true,"path":"2016/10/16/finding-hidden-autostart-programs/","link":"","permalink":"http://blog.vichamp.com/2016/10/16/finding-hidden-autostart-programs/","excerpt":"Ever wondered why some programs launch whenever you log into Windows? Here’s a one liner listing autostarts that affect your login:是否好奇为什么有些程序在登录 Windows 的时候会自动启动？这是一行列出登录时自启动项的代码： 12345#requires -Version 3Get-CimInstance -ClassName Win32_StartupCommand | Select-Object -Property Command, Description, User, Location | Out-GridView","text":"Ever wondered why some programs launch whenever you log into Windows? Here’s a one liner listing autostarts that affect your login:是否好奇为什么有些程序在登录 Windows 的时候会自动启动？这是一行列出登录时自启动项的代码： 12345#requires -Version 3Get-CimInstance -ClassName Win32_StartupCommand | Select-Object -Property Command, Description, User, Location | Out-GridView 本文国际来源：Finding Hidden Autostart Programs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Getting List of Current Group Memberships","slug":"getting-list-of-current-group-memberships","date":"2016-10-13T08:00:00.000Z","updated":"2017-03-17T15:26:27.070Z","comments":true,"path":"2016/10/13/getting-list-of-current-group-memberships/","link":"","permalink":"http://blog.vichamp.com/2016/10/13/getting-list-of-current-group-memberships/","excerpt":"当您可以通过 Active Directory 来获取一个用户的组成员，有一个简单的方法是直接通过用户的 access token 获取信息，而不需要 AD 联系人。 这行代码将取出当前用户所在的所有组的 SID： 12#requires -Version 3.0 [System.Security.Principal.WindowsIdentity]::GetCurrent().Groups.Value 这是获取翻译后的组名的方法： 12#requires -Version 3.0 [System.Security.Principal.WindowsIdentity]::GetCurrent().Groups.Translate( [System.Security.Principal.NTAccount]) 如果这个列表中有重复，那么您就可以知道有多个 SID 指向同一个名字。这种情况在您曾经迁移过 AD（SID 历史）时可能会发生。只需要将结果用管道输出到 Sort-Object -Unique 就能移除重复。","text":"当您可以通过 Active Directory 来获取一个用户的组成员，有一个简单的方法是直接通过用户的 access token 获取信息，而不需要 AD 联系人。 这行代码将取出当前用户所在的所有组的 SID： 12#requires -Version 3.0 [System.Security.Principal.WindowsIdentity]::GetCurrent().Groups.Value 这是获取翻译后的组名的方法： 12#requires -Version 3.0 [System.Security.Principal.WindowsIdentity]::GetCurrent().Groups.Translate( [System.Security.Principal.NTAccount]) 如果这个列表中有重复，那么您就可以知道有多个 SID 指向同一个名字。这种情况在您曾经迁移过 AD（SID 历史）时可能会发生。只需要将结果用管道输出到 Sort-Object -Unique 就能移除重复。 本文国际来源：Getting List of Current Group Memberships","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将 SID 翻译为用户名","slug":"translating-sid-to-username","date":"2016-10-12T08:00:00.000Z","updated":"2017-03-17T15:26:27.064Z","comments":true,"path":"2016/10/12/translating-sid-to-username/","link":"","permalink":"http://blog.vichamp.com/2016/10/12/translating-sid-to-username/","excerpt":"是否希望将安全标识符（SID）翻译为一个真实的名称？这个函数将能够帮助您： 123456789101112131415161718#requires -Version 3.0function ConvertFrom-SID&#123; param ( [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)] [Alias('Value')] $Sid ) process &#123; $objSID = New-Object System.Security.Principal.SecurityIdentifier($sid) $objUser = $objSID.Translate( [System.Security.Principal.NTAccount]) $objUser.Value &#125;&#125; 您可以通过参数传入 SID，或通过管道传入一个或多个 SID 给这个函数。","text":"是否希望将安全标识符（SID）翻译为一个真实的名称？这个函数将能够帮助您： 123456789101112131415161718#requires -Version 3.0function ConvertFrom-SID&#123; param ( [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)] [Alias('Value')] $Sid ) process &#123; $objSID = New-Object System.Security.Principal.SecurityIdentifier($sid) $objUser = $objSID.Translate( [System.Security.Principal.NTAccount]) $objUser.Value &#125;&#125; 您可以通过参数传入 SID，或通过管道传入一个或多个 SID 给这个函数。 本文国际来源：Translating SID to Username","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取计算机的地理位置","slug":"get-geolocation-of-computer","date":"2016-10-11T08:00:00.000Z","updated":"2017-03-17T15:26:27.058Z","comments":true,"path":"2016/10/11/get-geolocation-of-computer/","link":"","permalink":"http://blog.vichamp.com/2016/10/11/get-geolocation-of-computer/","excerpt":"这是获取地理位置信息的另一个免费源，它能够获取您当前的公网 IP 和位置信息： 123#requires -Version 3.0Invoke-RestMethod -Uri 'http://ipinfo.io' 结果大概如下： 123456ip : 80.187.113.144hostname : tmo-113-144.customers.d1-online.comregion : country : DEloc : 51.2993,9.4910org : AS3320 Deutsche Telekom AG","text":"这是获取地理位置信息的另一个免费源，它能够获取您当前的公网 IP 和位置信息： 123#requires -Version 3.0Invoke-RestMethod -Uri 'http://ipinfo.io' 结果大概如下： 123456ip : 80.187.113.144hostname : tmo-113-144.customers.d1-online.comregion : country : DEloc : 51.2993,9.4910org : AS3320 Deutsche Telekom AG 本文国际来源：Get GeoLocation of Computer","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找操作系统架构信息","slug":"finding-operating-system-architecture-information","date":"2016-10-10T08:00:00.000Z","updated":"2017-03-17T15:26:27.049Z","comments":true,"path":"2016/10/10/finding-operating-system-architecture-information/","link":"","permalink":"http://blog.vichamp.com/2016/10/10/finding-operating-system-architecture-information/","excerpt":"这是获取您操作系统信息的一行代码： 1Get-WmiObject -Class Win32_OperatingSystem | Select-Object -Property *OS* 结果看起来类似如下： 12345ForegroundApplicationBoost : 2OSArchitecture : 64-bitOSLanguage : 1031OSProductSuite : 256OSType : 18 如果您想知道这些数字代表什么意思，可以在网上搜索 Win32_OperatingSystem 第一个链接就会引导您到对应的 MSDN 文档。 如果您想从一个远程系统中获取信息，请使用 -ComputerName 和 –Credential 参数。","text":"这是获取您操作系统信息的一行代码： 1Get-WmiObject -Class Win32_OperatingSystem | Select-Object -Property *OS* 结果看起来类似如下： 12345ForegroundApplicationBoost : 2OSArchitecture : 64-bitOSLanguage : 1031OSProductSuite : 256OSType : 18 如果您想知道这些数字代表什么意思，可以在网上搜索 Win32_OperatingSystem 第一个链接就会引导您到对应的 MSDN 文档。 如果您想从一个远程系统中获取信息，请使用 -ComputerName 和 –Credential 参数。 本文国际来源：Finding Operating System Architecture Information","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 Active Directory 中查找操作系统版本","slug":"finding-operating-system-versions-in-active-directory","date":"2016-10-09T08:00:00.000Z","updated":"2017-03-17T15:26:27.045Z","comments":true,"path":"2016/10/09/finding-operating-system-versions-in-active-directory/","link":"","permalink":"http://blog.vichamp.com/2016/10/09/finding-operating-system-versions-in-active-directory/","excerpt":"如果您安装了带有 “ActiveDirectory” PowerShell 模块的 Microsoft RSAT 工具，以下是一个快速获取您环境中操作系统清单的快速方法： 1234#requires -Module ActiveDirectoryGet-ADComputer -Filter * -Properties OperatingSystem, OperatingSystemServicePack, OperatingSystemVersion | Select-Object -Property Name, OperatingSystem, OperatingSystemServicePack, OperatingSystemVersion 这将获得所有计算机的信息。您可以将搜索范围限制在指定的计算机名和 AD 位置中。以下命令将搜索范围限制在 $root AD 范围内，以及只包含名字以 “Serv” 开头的计算机中： 123456#requires -Module ActiveDirectory$root = 'OU=North,OU=Clients,DC=yourcompany,DC=com'Get-ADComputer -Filter &#123; Name -like 'Serv*' &#125; -Properties OperatingSystem, OperatingSystemServicePack, OperatingSystemVersion &lt;#-ResultSetSize 10#&gt; -SearchBase $root -SearchScope Subtree | Select-Object -Property Name, OperatingSystem, OperatingSystemServicePack, OperatingSystemVersion","text":"如果您安装了带有 “ActiveDirectory” PowerShell 模块的 Microsoft RSAT 工具，以下是一个快速获取您环境中操作系统清单的快速方法： 1234#requires -Module ActiveDirectoryGet-ADComputer -Filter * -Properties OperatingSystem, OperatingSystemServicePack, OperatingSystemVersion | Select-Object -Property Name, OperatingSystem, OperatingSystemServicePack, OperatingSystemVersion 这将获得所有计算机的信息。您可以将搜索范围限制在指定的计算机名和 AD 位置中。以下命令将搜索范围限制在 $root AD 范围内，以及只包含名字以 “Serv” 开头的计算机中： 123456#requires -Module ActiveDirectory$root = 'OU=North,OU=Clients,DC=yourcompany,DC=com'Get-ADComputer -Filter &#123; Name -like 'Serv*' &#125; -Properties OperatingSystem, OperatingSystemServicePack, OperatingSystemVersion &lt;#-ResultSetSize 10#&gt; -SearchBase $root -SearchScope Subtree | Select-Object -Property Name, OperatingSystem, OperatingSystemServicePack, OperatingSystemVersion 本文国际来源：Finding Operating System Versions in Active Directory","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找一个月中的第一天和最后一天","slug":"finding-first-and-last-day-in-month","date":"2016-10-06T08:00:00.000Z","updated":"2017-03-17T15:26:27.038Z","comments":true,"path":"2016/10/06/finding-first-and-last-day-in-month/","link":"","permalink":"http://blog.vichamp.com/2016/10/06/finding-first-and-last-day-in-month/","excerpt":"您是否曾需要了解某个月的第一天和最后一天？ 以下是一个简单的实现方法： 12345678910111213# specify the date you want to examine# default is today$date = Get-Date$year = $date.Year$month = $date.Month# create a new DateTime object set to the first day of a given month and year$startOfMonth = Get-Date -Year $year -Month $month -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0# add a month and subtract the smallest possible time unit$endOfMonth = ($startOfMonth).AddMonths(1).AddTicks(-1)$startOfMonth$endOfMonth","text":"您是否曾需要了解某个月的第一天和最后一天？ 以下是一个简单的实现方法： 12345678910111213# specify the date you want to examine# default is today$date = Get-Date$year = $date.Year$month = $date.Month# create a new DateTime object set to the first day of a given month and year$startOfMonth = Get-Date -Year $year -Month $month -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0# add a month and subtract the smallest possible time unit$endOfMonth = ($startOfMonth).AddMonths(1).AddTicks(-1)$startOfMonth$endOfMonth 本文国际来源：Finding First and Last Day in Month","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在地图上定位您的地理位置","slug":"geolocating-your-ip-on-a-map","date":"2016-10-05T08:00:00.000Z","updated":"2017-03-17T15:26:27.031Z","comments":true,"path":"2016/10/05/geolocating-your-ip-on-a-map/","link":"","permalink":"http://blog.vichamp.com/2016/10/05/geolocating-your-ip-on-a-map/","excerpt":"在前一个技能当中，通过 Internet 能知道您的 IP 地址，以及地理位置。您可以获得当前公开 IP 地址的经纬度，代码如下： 123456$ip = Invoke-RestMethod -Uri http://checkip.amazonaws.com/ $geo = Invoke-RestMethod -Uri \"http://geoip.nekudo.com/api/$IP\" $latitude = $geo.Location.Latitude$longitude = $geo.Location.Longitude\"Lat $latitude Long $longitude\" 如果您希望看到它究竟在什么位置，可以将这些信息连到 Google Maps 上： 1234567$ip = Invoke-RestMethod -Uri http://checkip.amazonaws.com/ $geo = Invoke-RestMethod -Uri \"http://geoip.nekudo.com/api/$IP\" $latitude = $geo.Location.Latitude$longitude = $geo.Location.Longitude$url = \"https://www.google.com/maps/preview/@$latitude,$longitude,8z\"Start-Process -FilePath $url 这段代码将打开浏览器，导航到 Google Maps，并且在地图上显示当前位置。当前通过 IP 地址定位地理位置还比较粗糙，至少在使用公开地理数据时。","text":"在前一个技能当中，通过 Internet 能知道您的 IP 地址，以及地理位置。您可以获得当前公开 IP 地址的经纬度，代码如下： 123456$ip = Invoke-RestMethod -Uri http://checkip.amazonaws.com/ $geo = Invoke-RestMethod -Uri \"http://geoip.nekudo.com/api/$IP\" $latitude = $geo.Location.Latitude$longitude = $geo.Location.Longitude\"Lat $latitude Long $longitude\" 如果您希望看到它究竟在什么位置，可以将这些信息连到 Google Maps 上： 1234567$ip = Invoke-RestMethod -Uri http://checkip.amazonaws.com/ $geo = Invoke-RestMethod -Uri \"http://geoip.nekudo.com/api/$IP\" $latitude = $geo.Location.Latitude$longitude = $geo.Location.Longitude$url = \"https://www.google.com/maps/preview/@$latitude,$longitude,8z\"Start-Process -FilePath $url 这段代码将打开浏览器，导航到 Google Maps，并且在地图上显示当前位置。当前通过 IP 地址定位地理位置还比较粗糙，至少在使用公开地理数据时。 本文国际来源：Geolocating Your IP on a Map","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找公开 IP 地址","slug":"finding-public-ip-address1","date":"2016-10-04T08:00:00.000Z","updated":"2017-03-17T15:26:27.025Z","comments":true,"path":"2016/10/04/finding-public-ip-address1/","link":"","permalink":"http://blog.vichamp.com/2016/10/04/finding-public-ip-address1/","excerpt":"您是否希望了解您当前连接到 Internet 的公开 IP 地址？以下是一行代码： 12#requires -Version 3.0Invoke-RestMethod -Uri http://checkip.amazonaws.com/ 通过这个 IP 地址，您还可以向 Internet 请求您的地理地址： 1234#requires -Version 3.0$ip = Invoke-RestMethod -Uri http://checkip.amazonaws.com/ Invoke-RestMethod -Uri \"http://geoip.nekudo.com/api/$IP\" | Select-Object -ExpandProperty Country","text":"您是否希望了解您当前连接到 Internet 的公开 IP 地址？以下是一行代码： 12#requires -Version 3.0Invoke-RestMethod -Uri http://checkip.amazonaws.com/ 通过这个 IP 地址，您还可以向 Internet 请求您的地理地址： 1234#requires -Version 3.0$ip = Invoke-RestMethod -Uri http://checkip.amazonaws.com/ Invoke-RestMethod -Uri \"http://geoip.nekudo.com/api/$IP\" | Select-Object -ExpandProperty Country 本文国际来源：Finding Public IP Address","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找 IP 地址的地理位置","slug":"finding-location-of-ip-address","date":"2016-10-03T08:00:00.000Z","updated":"2017-03-17T15:26:27.020Z","comments":true,"path":"2016/10/03/finding-location-of-ip-address/","link":"","permalink":"http://blog.vichamp.com/2016/10/03/finding-location-of-ip-address/","excerpt":"大多数 IP 地址可以用 Web Service 定位到物理地址。以下是一个很简单的函数，能够输入一个 IP 地址并返回它的物理地址： 1234567#requires -Version 3.0function Get-IPLocation([Parameter(Mandatory)]$IPAddress)&#123; Invoke-RestMethod -Method Get -Uri \"http://geoip.nekudo.com/api/$IPAddress\" | Select-Object -ExpandProperty Country -Property City, IP, Location &#125; 这个例子能够演示如何用 Select-Object 配合 -Property 和 -ExpandProperty 参数将一些嵌套的属性移到上一层。 让我们查找 Google DNS 服务器位于什么位置： 1234567PS C:\\&gt; Get-IPLocation -IPAddress 8.8.8.8name : United Statescode : UScity : Mountain Viewip : 8.8.8.8location : @&#123;accuracy_radius=1000; latitude=37,386; longitude=-122,0838; time_zone=America/Los_Angeles&#125; And here is how you can resolve any hostname to an IP address, for example, the famous powershellmagazine.com:以下是如何将任意主机名解析成 IP 地址的代码，例如知名的 powershellmagazine.com： 12PS&gt; [Net.Dns]::GetHostByName('powershellmagazine.com').AddressList.IPAddressToString104.131.21.239 所以如果您想知道该 IP 地址位于哪里，请加上这段代码： 12345678PS&gt; Get-IPLocation -IPAddress 104.131.21.239name : United Statescode : UScity : New Yorkip : 104.131.21.239location : @&#123;accuracy_radius=1000; latitude=40,7143; longitude=-74,006; time_zone=America/New_York&#125; (of course this is just where the server sits, not Aleksandar or Ravi or all the other fine editors（当然这只代表了服务器的所在地，而不是 Aleksandar or Ravi 及其它知名编辑的位置 ）","text":"大多数 IP 地址可以用 Web Service 定位到物理地址。以下是一个很简单的函数，能够输入一个 IP 地址并返回它的物理地址： 1234567#requires -Version 3.0function Get-IPLocation([Parameter(Mandatory)]$IPAddress)&#123; Invoke-RestMethod -Method Get -Uri \"http://geoip.nekudo.com/api/$IPAddress\" | Select-Object -ExpandProperty Country -Property City, IP, Location &#125; 这个例子能够演示如何用 Select-Object 配合 -Property 和 -ExpandProperty 参数将一些嵌套的属性移到上一层。 让我们查找 Google DNS 服务器位于什么位置： 1234567PS C:\\&gt; Get-IPLocation -IPAddress 8.8.8.8name : United Statescode : UScity : Mountain Viewip : 8.8.8.8location : @&#123;accuracy_radius=1000; latitude=37,386; longitude=-122,0838; time_zone=America/Los_Angeles&#125; And here is how you can resolve any hostname to an IP address, for example, the famous powershellmagazine.com:以下是如何将任意主机名解析成 IP 地址的代码，例如知名的 powershellmagazine.com： 12PS&gt; [Net.Dns]::GetHostByName('powershellmagazine.com').AddressList.IPAddressToString104.131.21.239 所以如果您想知道该 IP 地址位于哪里，请加上这段代码： 12345678PS&gt; Get-IPLocation -IPAddress 104.131.21.239name : United Statescode : UScity : New Yorkip : 104.131.21.239location : @&#123;accuracy_radius=1000; latitude=40,7143; longitude=-74,006; time_zone=America/New_York&#125; (of course this is just where the server sits, not Aleksandar or Ravi or all the other fine editors（当然这只代表了服务器的所在地，而不是 Aleksandar or Ravi 及其它知名编辑的位置 ） 本文国际来源：Finding Location of IP Address","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找由 DHCP 分配的 IP 地址","slug":"finding-ip-address-assigned-by-dhcp","date":"2016-10-02T16:00:00.000Z","updated":"2017-03-17T15:26:27.013Z","comments":true,"path":"2016/10/03/finding-ip-address-assigned-by-dhcp/","link":"","permalink":"http://blog.vichamp.com/2016/10/03/finding-ip-address-assigned-by-dhcp/","excerpt":"从 Windows 8 和 Server 2012 起，随着操作系统一起分发了一些扩展的 PowerShell 模块，用于管理服务器和客户端，例如 Get-NetIPAddress 等 cmdlet。 如果您想获得一个所有由 DHCP 分配的 IP 地址列表，可以试试以下方法： 12345#requires -Version 3.0 -Modules NetTCPIPGet-NetIPAddress | Where-Object PrefixOrigin -eq dhcp | Select-Object -ExpandProperty IPAddress","text":"从 Windows 8 和 Server 2012 起，随着操作系统一起分发了一些扩展的 PowerShell 模块，用于管理服务器和客户端，例如 Get-NetIPAddress 等 cmdlet。 如果您想获得一个所有由 DHCP 分配的 IP 地址列表，可以试试以下方法： 12345#requires -Version 3.0 -Modules NetTCPIPGet-NetIPAddress | Where-Object PrefixOrigin -eq dhcp | Select-Object -ExpandProperty IPAddress 本文国际来源：Finding IP Address Assigned by DHCP","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Enum 之周: PowerShell 5 中的枚举","slug":"enum-week-enums-in-powershell-5","date":"2016-09-29T16:00:00.000Z","updated":"2017-03-17T15:26:27.003Z","comments":true,"path":"2016/09/30/enum-week-enums-in-powershell-5/","link":"","permalink":"http://blog.vichamp.com/2016/09/30/enum-week-enums-in-powershell-5/","excerpt":"支持 PowerShell 5 以上版本 这周我们将关注枚举类型：它们是什么，以及如何利用它们。 从 PowerShell 5 开始，您可以用 “Enum“创建您自己的枚举类型。通过这种方式，用户可以用可阅读的名字，而不是幻数。 1234567891011121314151617181920212223#requires -Version 5.0 Enum ComputerType&#123; ManagedServer ManagedClient Server Client&#125;function Connect-Computer &#123; param ( [ComputerType] $Type, [string] $Name ) \"Computername: $Name Type: $Type\" &#125; 当您运行完这段代码，并调用 “Connect-Computer“ 函数之后，PowerShell 自动为您的枚举值提供智能提示，并且只接受枚举类型里规定的值。 1234PS C:\\&gt; Connect-Computer -Type Client -Name TestComputername: Test Type: ClientPS C:\\&gt;","text":"支持 PowerShell 5 以上版本 这周我们将关注枚举类型：它们是什么，以及如何利用它们。 从 PowerShell 5 开始，您可以用 “Enum“创建您自己的枚举类型。通过这种方式，用户可以用可阅读的名字，而不是幻数。 1234567891011121314151617181920212223#requires -Version 5.0 Enum ComputerType&#123; ManagedServer ManagedClient Server Client&#125;function Connect-Computer &#123; param ( [ComputerType] $Type, [string] $Name ) \"Computername: $Name Type: $Type\" &#125; 当您运行完这段代码，并调用 “Connect-Computer“ 函数之后，PowerShell 自动为您的枚举值提供智能提示，并且只接受枚举类型里规定的值。 1234PS C:\\&gt; Connect-Computer -Type Client -Name TestComputername: Test Type: ClientPS C:\\&gt; 本文国际来源：Enum Week: Enums in PowerShell 5","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Enum 之周: 快速关闭 Cmdlet 错误提示","slug":"enum-week-suppressing-cmdlet-errors-fast","date":"2016-09-28T16:00:00.000Z","updated":"2017-03-17T15:26:26.994Z","comments":true,"path":"2016/09/29/enum-week-suppressing-cmdlet-errors-fast/","link":"","permalink":"http://blog.vichamp.com/2016/09/29/enum-week-suppressing-cmdlet-errors-fast/","excerpt":"这周我们将关注枚举类型：它们是什么，以及如何利用它们。 在前一个技能中，我们学习了枚举类型。这个技能教您如何使用最少的代码关闭 Cmdlet 产生的错误信息。 非管理员账户执行这行代码将产生错误信息，因为您无法存取其他用户的进程信息： 1PS&gt; Get-Process -FileVersionInfo 由于这个错误是良性的，并且不可避免，您可能会想将它们屏蔽： 1PS&gt; Get-Process -FileVersionInfo -ErrorAction SilentlyContinue 这对于脚本来说是完美的语法。当您交互式地运行代码时，您完全可以用难看的窍门来缩短关键字的输入，只需要写： 1PS&gt; Get-Process -FileVersionInfo -ea 0 “-ea“ 是 -ErrorAction 参数的别名，而数字 0 相当于 SilentlyContinue 的枚举值。 要查看一个参数的别名，可以使用这样的代码： 12PS&gt; (Get-Command -Name Get-Process).Parameters[&quot;ErrorAction&quot;].Aliasesea 要查看枚举值对应的数字值，首先确定参数的数据类型： 12PS&gt; (Get-Command -Name Get-Process).Parameters[&quot;ErrorAction&quot;].ParameterType.FullNameSystem.Management.Automation.ActionPreference 下一步，将参数转成一个整形： 12PS&gt; [int][System.Management.Automation.ActionPreference]::SilentlyContinue0 So if you’d like to create a shortcut for the parameter value “Ignore” instead of “SilentlyContinue”, try this: 所以如果您想了解参数值 “Ignore“ 而不是 “SilentlyContinue“，请试验以下代码： 12PS&gt; [int][System.Management.Automation.ActionPreference]::Ignore4 “SilientlyContinue“ 和 “Ignore“ 都禁止了错误的输出，但是 “SilentlyContinue“ 还会将禁止输出的错误信息写入 PowerShell 的 $error 变量中。 从现在开始，您在交互式操作 PowerShell 时可以用这种方式使用 “Ignore“ 禁用错误信息： 1PS&gt; Get-Process -FileVersionInfo -ea 4 请注意：您也可以在脚本中使用这些快捷方式，但最好不要这么做。脚本中应当按照 PowerShell 的缺省写法，才能清晰易读。","text":"这周我们将关注枚举类型：它们是什么，以及如何利用它们。 在前一个技能中，我们学习了枚举类型。这个技能教您如何使用最少的代码关闭 Cmdlet 产生的错误信息。 非管理员账户执行这行代码将产生错误信息，因为您无法存取其他用户的进程信息： 1PS&gt; Get-Process -FileVersionInfo 由于这个错误是良性的，并且不可避免，您可能会想将它们屏蔽： 1PS&gt; Get-Process -FileVersionInfo -ErrorAction SilentlyContinue 这对于脚本来说是完美的语法。当您交互式地运行代码时，您完全可以用难看的窍门来缩短关键字的输入，只需要写： 1PS&gt; Get-Process -FileVersionInfo -ea 0 “-ea“ 是 -ErrorAction 参数的别名，而数字 0 相当于 SilentlyContinue 的枚举值。 要查看一个参数的别名，可以使用这样的代码： 12PS&gt; (Get-Command -Name Get-Process).Parameters[&quot;ErrorAction&quot;].Aliasesea 要查看枚举值对应的数字值，首先确定参数的数据类型： 12PS&gt; (Get-Command -Name Get-Process).Parameters[&quot;ErrorAction&quot;].ParameterType.FullNameSystem.Management.Automation.ActionPreference 下一步，将参数转成一个整形： 12PS&gt; [int][System.Management.Automation.ActionPreference]::SilentlyContinue0 So if you’d like to create a shortcut for the parameter value “Ignore” instead of “SilentlyContinue”, try this: 所以如果您想了解参数值 “Ignore“ 而不是 “SilentlyContinue“，请试验以下代码： 12PS&gt; [int][System.Management.Automation.ActionPreference]::Ignore4 “SilientlyContinue“ 和 “Ignore“ 都禁止了错误的输出，但是 “SilentlyContinue“ 还会将禁止输出的错误信息写入 PowerShell 的 $error 变量中。 从现在开始，您在交互式操作 PowerShell 时可以用这种方式使用 “Ignore“ 禁用错误信息： 1PS&gt; Get-Process -FileVersionInfo -ea 4 请注意：您也可以在脚本中使用这些快捷方式，但最好不要这么做。脚本中应当按照 PowerShell 的缺省写法，才能清晰易读。 本文国际来源：Enum Week: Suppressing Cmdlet Errors - Fast","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Enum 之周: 理解枚举值","slug":"enum-week-understanding-enumeration-values","date":"2016-09-27T16:00:00.000Z","updated":"2017-03-17T15:26:26.982Z","comments":true,"path":"2016/09/28/enum-week-understanding-enumeration-values/","link":"","permalink":"http://blog.vichamp.com/2016/09/28/enum-week-understanding-enumeration-values/","excerpt":"这周我们将关注枚举类型：它们是什么，以及如何利用它们。 在前一个技能中，我们探讨了枚举是如何工作的。您可能还记得我们如何改变控制台的前景色： 12345PS&gt; $host.UI.RawUI.ForegroundColor = &apos;Red&apos;PS&gt; $host.UI.RawUI.ForegroundColor = &apos;White&apos;PS&gt; 这些代码先将前景色改为红色，然后改回白色。用字符串表达的颜色名称隐式地转换为对应的 System.ConsoleColor enumeration 值。 多数枚举只是数字值的一种简易的标签。”Red“ 和 “White“ 实际上是 integer 数值： 12345PS&gt; [int][System.ConsoleColor]&apos;Red&apos;12PS&gt; [int][System.ConsoleColor]&apos;White&apos;15 所以如果您知道数字值，您也可以使用它们： 123PS&gt; $host.UI.RawUI.ForegroundColor = 12PS&gt; $host.UI.RawUI.ForegroundColor = 15 当然，很明显地，代码变得很难读懂。不过，还是有一种使用场合。如果您想随机设置您的控制台颜色，您可以使用数值型的值。一共有 16 种控制台颜色，所以这段代码能够用一个随机的背景色和前景色重新为您的控制台着色： 123$background, $foreground = 0..15 | Get-Random -Count 2 $host.UI.RawUI.BackgroundColor = $background $host.UI.RawUI.ForegroundColor = $foreground","text":"这周我们将关注枚举类型：它们是什么，以及如何利用它们。 在前一个技能中，我们探讨了枚举是如何工作的。您可能还记得我们如何改变控制台的前景色： 12345PS&gt; $host.UI.RawUI.ForegroundColor = &apos;Red&apos;PS&gt; $host.UI.RawUI.ForegroundColor = &apos;White&apos;PS&gt; 这些代码先将前景色改为红色，然后改回白色。用字符串表达的颜色名称隐式地转换为对应的 System.ConsoleColor enumeration 值。 多数枚举只是数字值的一种简易的标签。”Red“ 和 “White“ 实际上是 integer 数值： 12345PS&gt; [int][System.ConsoleColor]&apos;Red&apos;12PS&gt; [int][System.ConsoleColor]&apos;White&apos;15 所以如果您知道数字值，您也可以使用它们： 123PS&gt; $host.UI.RawUI.ForegroundColor = 12PS&gt; $host.UI.RawUI.ForegroundColor = 15 当然，很明显地，代码变得很难读懂。不过，还是有一种使用场合。如果您想随机设置您的控制台颜色，您可以使用数值型的值。一共有 16 种控制台颜色，所以这段代码能够用一个随机的背景色和前景色重新为您的控制台着色： 123$background, $foreground = 0..15 | Get-Random -Count 2 $host.UI.RawUI.BackgroundColor = $background $host.UI.RawUI.ForegroundColor = $foreground 本文国际来源：Enum Week: Understanding Enumeration Values","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Enum 之周: 列出枚举值","slug":"enum-week-listing-enumeration-values","date":"2016-09-26T16:00:00.000Z","updated":"2017-03-17T15:26:26.972Z","comments":true,"path":"2016/09/27/enum-week-listing-enumeration-values/","link":"","permalink":"http://blog.vichamp.com/2016/09/27/enum-week-listing-enumeration-values/","excerpt":"这周我们将关注枚举类型：它们是什么，以及如何利用它们。 在前一个技能中我们解释了 PowerShell 如何将字符串转换为枚举值。如果您想知道某个枚举参数可以用接受哪些字符串，请先看一个简单的改变控制台颜色的例子： 12345PS&gt; $host.UI.RawUI.ForegroundColor = 'Red'PS&gt; $host.UI.RawUI.ForegroundColor = 'White'PS&gt; 这些命令先将前景色改为红色，然后改回白色。 但是您怎么知道控制台支持的颜色名称呢？首先您需要知道 ForegroundColor 的真实数据类型： 12PS&gt; $host.UI.RawUI.ForegroundColor.GetType().FullName System.ConsoleColor 它的类型是 “System.ConsoleColor“。现在您可以检查它是否确实是一个枚举型： 12PS&gt; $host.UI.RawUI.ForegroundColor.GetType().IsEnumTrue 如果它确实是，例如这个例子，您可以列出它所有的值的名称： 1234567891011121314151617PS&gt; [System.Enum]::GetNames([System.ConsoleColor])BlackDarkBlueDarkGreenDarkCyanDarkRedDarkMagentaDarkYellowGrayDarkGrayBlueGreenCyanRedMagentaYellowWhite 这些值中的每一个值都可以用来设置控制台的前景色。这种方法可以应用在所有接受枚举值的属性或参数上。 同样地，如果您传入了一个和所有枚举值名称都不相同的值，异常信息中也会列出枚举值的名字。","text":"这周我们将关注枚举类型：它们是什么，以及如何利用它们。 在前一个技能中我们解释了 PowerShell 如何将字符串转换为枚举值。如果您想知道某个枚举参数可以用接受哪些字符串，请先看一个简单的改变控制台颜色的例子： 12345PS&gt; $host.UI.RawUI.ForegroundColor = 'Red'PS&gt; $host.UI.RawUI.ForegroundColor = 'White'PS&gt; 这些命令先将前景色改为红色，然后改回白色。 但是您怎么知道控制台支持的颜色名称呢？首先您需要知道 ForegroundColor 的真实数据类型： 12PS&gt; $host.UI.RawUI.ForegroundColor.GetType().FullName System.ConsoleColor 它的类型是 “System.ConsoleColor“。现在您可以检查它是否确实是一个枚举型： 12PS&gt; $host.UI.RawUI.ForegroundColor.GetType().IsEnumTrue 如果它确实是，例如这个例子，您可以列出它所有的值的名称： 1234567891011121314151617PS&gt; [System.Enum]::GetNames([System.ConsoleColor])BlackDarkBlueDarkGreenDarkCyanDarkRedDarkMagentaDarkYellowGrayDarkGrayBlueGreenCyanRedMagentaYellowWhite 这些值中的每一个值都可以用来设置控制台的前景色。这种方法可以应用在所有接受枚举值的属性或参数上。 同样地，如果您传入了一个和所有枚举值名称都不相同的值，异常信息中也会列出枚举值的名字。 本文国际来源：Enum Week: Listing Enumeration Values","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Enum 之周: 枚举的自动转换","slug":"enum-week-auto-conversion-for-enums","date":"2016-09-25T16:00:00.000Z","updated":"2017-03-17T15:26:26.965Z","comments":true,"path":"2016/09/26/enum-week-auto-conversion-for-enums/","link":"","permalink":"http://blog.vichamp.com/2016/09/26/enum-week-auto-conversion-for-enums/","excerpt":"这周我们将关注枚举类型：它们是什么，以及如何利用它们。 当一个 Cmdlet 或者方法需要一个枚举值时，PowerShell 能毫无障碍地接受不完整的枚举名称。这个方法不为人知。例如这段代码将控制台的前景色改为灰色： 1PS&gt; $host.UI.RawUI.ForegroundColor = 'Gray' 这段代码将前景色改为白色： 1PS&gt; $host.UI.RawUI.ForegroundColor = 'White' ForegroundColor 属性看上去是字符串类型的，但这并不是真相。它只能接受某些字符串。这个属性的类型实际上不是字符串型。它实际上是一个只接受某些字符串值的枚举型： 12345678PS&gt; $host.UI.RawUI | Get-Member -Name ForegroundColor​ TypeName: System.Management.Automation.Internal.Host.InternalHostRawUserInterfaceName MemberType Definition ---- ---------- ---------- ForegroundColor Property System.ConsoleColor ForegroundColor &#123;get;set;&#125; 该属性实际上是 “System.ConsoleColor“ 类型。当您传入一个类似 “Gray“ 或 “White“ 的字符串时，PowerShell 实际上在后台查询 System.ConsoleColor 类型可选的值，并将传入的字符串做转换。 一个不为人知的事实是：不需要严格的匹配。您可以用这种方法写： 1234567891011 PS&gt; $host.UI.RawUI.ForegroundColor = 'R' PS&gt; $host.UI.RawUI.ForegroundColor = 'W'```powershell这段代码将把控制台的前景色改为红色，然后改回白色。PowerShell 只关心指定的值是否有歧义。如果传入了字符串 \"`G`\"，会发生异常，提示信息是名字冲突。对于灰色，至少要指定 \"`Gra`\"，因为任何比这个短的字符串都和 \"`Green`\" 相冲突。为什么这很重要？您必须尽量使用完整的枚举值以提高可读性。只需要记着会自动转换。它帮助您理解为什么这类语句可以工作：```powershell Get-Service | Where-Object &#123; $_.Status -eq 'R' &#125;","text":"这周我们将关注枚举类型：它们是什么，以及如何利用它们。 当一个 Cmdlet 或者方法需要一个枚举值时，PowerShell 能毫无障碍地接受不完整的枚举名称。这个方法不为人知。例如这段代码将控制台的前景色改为灰色： 1PS&gt; $host.UI.RawUI.ForegroundColor = 'Gray' 这段代码将前景色改为白色： 1PS&gt; $host.UI.RawUI.ForegroundColor = 'White' ForegroundColor 属性看上去是字符串类型的，但这并不是真相。它只能接受某些字符串。这个属性的类型实际上不是字符串型。它实际上是一个只接受某些字符串值的枚举型： 12345678PS&gt; $host.UI.RawUI | Get-Member -Name ForegroundColor​ TypeName: System.Management.Automation.Internal.Host.InternalHostRawUserInterfaceName MemberType Definition ---- ---------- ---------- ForegroundColor Property System.ConsoleColor ForegroundColor &#123;get;set;&#125; 该属性实际上是 “System.ConsoleColor“ 类型。当您传入一个类似 “Gray“ 或 “White“ 的字符串时，PowerShell 实际上在后台查询 System.ConsoleColor 类型可选的值，并将传入的字符串做转换。 一个不为人知的事实是：不需要严格的匹配。您可以用这种方法写： 1234567891011 PS&gt; $host.UI.RawUI.ForegroundColor = 'R' PS&gt; $host.UI.RawUI.ForegroundColor = 'W'```powershell这段代码将把控制台的前景色改为红色，然后改回白色。PowerShell 只关心指定的值是否有歧义。如果传入了字符串 \"`G`\"，会发生异常，提示信息是名字冲突。对于灰色，至少要指定 \"`Gra`\"，因为任何比这个短的字符串都和 \"`Green`\" 相冲突。为什么这很重要？您必须尽量使用完整的枚举值以提高可读性。只需要记着会自动转换。它帮助您理解为什么这类语句可以工作：```powershell Get-Service | Where-Object &#123; $_.Status -eq 'R' &#125; 本文国际来源：Enum Week: Auto-Conversion for Enums","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 UTC 时间","slug":"working-with-utc-times","date":"2016-09-22T16:00:00.000Z","updated":"2017-03-17T15:26:26.950Z","comments":true,"path":"2016/09/23/working-with-utc-times/","link":"","permalink":"http://blog.vichamp.com/2016/09/23/working-with-utc-times/","excerpt":"在跨语言环境中，您可能希望有一种方法能将日期和时间“通用化”，例如在写日志的时候。和使用当地时间比起来，用 PowerShell 能够很方便地将 DateTime 对象转化为协调世界时 (UTC)： 1(Get-Date).ToUniversalTime()","text":"在跨语言环境中，您可能希望有一种方法能将日期和时间“通用化”，例如在写日志的时候。和使用当地时间比起来，用 PowerShell 能够很方便地将 DateTime 对象转化为协调世界时 (UTC)： 1(Get-Date).ToUniversalTime() 本文国际来源：Working with UTC Times","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 显示对话框","slug":"displaying-message-boxes","date":"2016-09-22T16:00:00.000Z","updated":"2017-03-17T15:26:26.941Z","comments":true,"path":"2016/09/23/displaying-message-boxes/","link":"","permalink":"http://blog.vichamp.com/2016/09/23/displaying-message-boxes/","excerpt":"PowerShell 可以操作所有公公的 .NET 类，所以创建一个对话框真的很简单： 123$result = [System.Windows.MessageBox]::Show('Do you want to restart?','Restart','YesNo','Warning') $result 然而，您可能需要知道参数所支持的值。PowerShell 可以方便地将 .NET 调用封装成 PowerShell 函数，并提供所有参数的智能感知功能： 123456789101112131415161718192021#requires -Version 3.0Add-Type -AssemblyName PresentationFrameworkfunction Show-MessageBox&#123; param ( [Parameter(Mandatory)] [String] $Prompt, [String]$Title = 'PowerShell', [Windows.MessageBoxButton]$Button = 'OK', [Windows.MessageBoxImage]$Icon = 'Information' ) [Windows.MessageBox]::Show($Prompt, $Title, $Button, $Icon)&#125; 当您运行这段代码后，就得到了一个超级简单的 “Show-MessageBox“ 函数。它可以接受多个参数并且通过自动完成和智能感知为您提供正确的数据。","text":"PowerShell 可以操作所有公公的 .NET 类，所以创建一个对话框真的很简单： 123$result = [System.Windows.MessageBox]::Show('Do you want to restart?','Restart','YesNo','Warning') $result 然而，您可能需要知道参数所支持的值。PowerShell 可以方便地将 .NET 调用封装成 PowerShell 函数，并提供所有参数的智能感知功能： 123456789101112131415161718192021#requires -Version 3.0Add-Type -AssemblyName PresentationFrameworkfunction Show-MessageBox&#123; param ( [Parameter(Mandatory)] [String] $Prompt, [String]$Title = 'PowerShell', [Windows.MessageBoxButton]$Button = 'OK', [Windows.MessageBoxImage]$Icon = 'Information' ) [Windows.MessageBox]::Show($Prompt, $Title, $Button, $Icon)&#125; 当您运行这段代码后，就得到了一个超级简单的 “Show-MessageBox“ 函数。它可以接受多个参数并且通过自动完成和智能感知为您提供正确的数据。 本文国际来源：Displaying Message Boxes","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用秒表测定脚本执行时间","slug":"using-a-stopwatch-to-profile-scripts","date":"2016-09-20T16:00:00.000Z","updated":"2017-03-17T15:26:26.923Z","comments":true,"path":"2016/09/21/using-a-stopwatch-to-profile-scripts/","link":"","permalink":"http://blog.vichamp.com/2016/09/21/using-a-stopwatch-to-profile-scripts/","excerpt":"是否希望了解某个命令或一段脚本运行了多少时间？以下简易的秒表对象能帮您实现这个功能： 1234567891011121314151617181920# create a new stopwatch$stopwatch = [System.Diagnostics.Stopwatch]::StartNew()# run a command$info = Get-Hotfix# stop the stopwatch, and report the milliseconds$stopwatch.Stop()$stopwatch.Elapsed.Milliseconds# continue the stopwatch$stopwatch.Start()# $stopwatch.Restart() # &lt;- resets stopwatch# run another command$files = Get-ChildItem -Path $env:windir# again, stop the stopwatch and report accumulated runtime in milliseconds$stopwatch.Stop()$stopwatch.Elapsed.Milliseconds 这个秒表比自己用 Get-Date 写的好用得多，并且能计算时间差。这个秒表可以停止、继续、复位，并且能随时自动汇报经历的时间。例如，您可以在检查代码时停止秒表，然后在准备执行下一条命令的时候重启秒表。 在上面的例子中，若您将第二处 Start() 改为 Restart() 则秒表将会复位并且报告的时间是第二条命令执行的时间而不是总时间。","text":"是否希望了解某个命令或一段脚本运行了多少时间？以下简易的秒表对象能帮您实现这个功能： 1234567891011121314151617181920# create a new stopwatch$stopwatch = [System.Diagnostics.Stopwatch]::StartNew()# run a command$info = Get-Hotfix# stop the stopwatch, and report the milliseconds$stopwatch.Stop()$stopwatch.Elapsed.Milliseconds# continue the stopwatch$stopwatch.Start()# $stopwatch.Restart() # &lt;- resets stopwatch# run another command$files = Get-ChildItem -Path $env:windir# again, stop the stopwatch and report accumulated runtime in milliseconds$stopwatch.Stop()$stopwatch.Elapsed.Milliseconds 这个秒表比自己用 Get-Date 写的好用得多，并且能计算时间差。这个秒表可以停止、继续、复位，并且能随时自动汇报经历的时间。例如，您可以在检查代码时停止秒表，然后在准备执行下一条命令的时候重启秒表。 在上面的例子中，若您将第二处 Start() 改为 Restart() 则秒表将会复位并且报告的时间是第二条命令执行的时间而不是总时间。 本文国际来源：Using a Stopwatch to Profile Scripts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 色彩之周: 为 PowerShell 控制台中的符号着色","slug":"color-week-using-token-colors-in-the-powershell-console","date":"2016-09-19T16:00:00.000Z","updated":"2017-03-17T15:26:26.920Z","comments":true,"path":"2016/09/20/color-week-using-token-colors-in-the-powershell-console/","link":"","permalink":"http://blog.vichamp.com/2016/09/20/color-week-using-token-colors-in-the-powershell-console/","excerpt":"支持 PowerShell 3 以上版本 本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 当您在 PowerShell ISE 输入命令的时候符号会被着色，而 PowerShell 控制台并不会。如果您喜欢着色的符号，可以试试 PSReadline 这个很棒的模块。以下是下载和安装的方法： 1PS C:\\&gt; Install-Module -Name PSReadLine -Scope CurrentUser -Force 如果不支持 “Install-Module“ 命令，那么请到 www.powershellgallery.com 下载 “PowerShellGet” MSI 安装包。它为非 PowerShell 5 的环境添加了一系列操作 Microsoft PowerShell Gallery 的功能。 安装好该模块以后，您需要加载它（在 PowerShell 控制台中，而不是在 PowerShell ISE 中）： 1PS C:\\&gt; Import-Module -Name PSReadLine 当它加载完成后，PowerShell 控制台就可以显示彩色的符号。","text":"支持 PowerShell 3 以上版本 本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 当您在 PowerShell ISE 输入命令的时候符号会被着色，而 PowerShell 控制台并不会。如果您喜欢着色的符号，可以试试 PSReadline 这个很棒的模块。以下是下载和安装的方法： 1PS C:\\&gt; Install-Module -Name PSReadLine -Scope CurrentUser -Force 如果不支持 “Install-Module“ 命令，那么请到 www.powershellgallery.com 下载 “PowerShellGet” MSI 安装包。它为非 PowerShell 5 的环境添加了一系列操作 Microsoft PowerShell Gallery 的功能。 安装好该模块以后，您需要加载它（在 PowerShell 控制台中，而不是在 PowerShell ISE 中）： 1PS C:\\&gt; Import-Module -Name PSReadLine 当它加载完成后，PowerShell 控制台就可以显示彩色的符号。 本文国际来源：Color Week: Using Token Colors in the PowerShell Console","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 色彩之周: 改变 PowerShell ISE 中的错误信息颜色","slug":"color-week-changing-error-message-colors-in-the-powershell-ise","date":"2016-09-18T16:00:00.000Z","updated":"2017-03-17T15:26:26.916Z","comments":true,"path":"2016/09/19/color-week-changing-error-message-colors-in-the-powershell-ise/","link":"","permalink":"http://blog.vichamp.com/2016/09/19/color-week-changing-error-message-colors-in-the-powershell-ise/","excerpt":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 在前一个技能中我们介绍了如何改变 PowerShell 预设的颜色，例如错误信息颜色。 在 PowerShell ISE 中，您可将这些颜色设置为指定的 16 种控制台颜色之一： 12$host.PrivateData.ErrorBackgroundColor=\"White\"$host.PrivateData.ErrorForegroundColor= 而且，PowerShell ISE 也接受自定义的 WPF 颜色。以下代码将设置错误信息为透明底橙色： 12$host.PrivateData.ErrorBackgroundColor=\"#00000000\"$host.PrivateData.ErrorForegroundColor=[System.Windows.Media.Colors]::OrangeRed","text":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 在前一个技能中我们介绍了如何改变 PowerShell 预设的颜色，例如错误信息颜色。 在 PowerShell ISE 中，您可将这些颜色设置为指定的 16 种控制台颜色之一： 12$host.PrivateData.ErrorBackgroundColor=\"White\"$host.PrivateData.ErrorForegroundColor= 而且，PowerShell ISE 也接受自定义的 WPF 颜色。以下代码将设置错误信息为透明底橙色： 12$host.PrivateData.ErrorBackgroundColor=\"#00000000\"$host.PrivateData.ErrorForegroundColor=[System.Windows.Media.Colors]::OrangeRed 本文国际来源：Color Week: Changing Error Message Colors in the PowerShell ISE","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 色彩之周: 改变错误信息颜色","slug":"color-week-changing-error-message-colors","date":"2016-09-15T16:00:00.000Z","updated":"2017-03-17T15:26:26.912Z","comments":true,"path":"2016/09/16/color-week-changing-error-message-colors/","link":"","permalink":"http://blog.vichamp.com/2016/09/16/color-week-changing-error-message-colors/","excerpt":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 PowerShell 使用预定义的颜色来显示错误信息、警告信息、详细信息，以及其他输出信息。这些颜色也可以更改。 这段代码将把错误信息改为白底红字。这个颜色更好阅读，特别在演示的时候： 12$host.PrivateData.ErrorBackgroundColor=\"White\"$host.PrivateData.ErrorForegroundColor='Red'","text":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 PowerShell 使用预定义的颜色来显示错误信息、警告信息、详细信息，以及其他输出信息。这些颜色也可以更改。 这段代码将把错误信息改为白底红字。这个颜色更好阅读，特别在演示的时候： 12$host.PrivateData.ErrorBackgroundColor=\"White\"$host.PrivateData.ErrorForegroundColor='Red' 本文国际来源：Color Week: Changing Error Message Colors","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 色彩之周: 在 PowerShell ISE 控制台中使用透明度","slug":"color-week-using-transparency-in-the-powershell-ise-console","date":"2016-09-14T16:00:00.000Z","updated":"2017-03-17T15:26:26.907Z","comments":true,"path":"2016/09/15/color-week-using-transparency-in-the-powershell-ise-console/","link":"","permalink":"http://blog.vichamp.com/2016/09/15/color-week-using-transparency-in-the-powershell-ise-console/","excerpt":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 在钱一个技能中您学到了三个设置控制 PowerShell ISE 控制台面板中的颜色。如果您希望的话，还可以为输入和输出设置不同的背景色： 123$psise.Options.ConsolePaneForegroundColor=[System.Windows.Media.Colors]::LightSkyBlue$psise.Options.ConsolePaneBackgroundColor=[System.Windows.Media.Colors]::DarkGreen$psise.Options.ConsolePaneTextBackgroundColor=[System.Windows.Media.Colors]::Yellow 结果类似这样： 123456789101112131415PS C:\\&gt;\"Hello\"HelloPS C:\\&gt;$HostName : Windows PowerShell ISE HostVersion : 4.0InstanceId : 840b9f0e-0c05-4b6d-84fc-c104971ac647UI : System.Management.Automation.Internal.Host.InternalHostUserInterfaceCurrentCulture : de-DECurrentUICulture: de-DEPrivateData : Microsoft.PowerShell.Host.ISE.ISEOptionsIsRunspacePushed: FalseRunspace : System.Management.Automation.Runspaces.LocalRunspace 如果您只希望将输出高亮一点点，那么可以使用透明色。文字的背景色可以变成透明，首先要确定希望使用的颜色的代码，然后用 alpha 通道创建自定义的颜色。它操作起来很简单。 在前一个例子中，文字的背景色被设置成 “Yellow”。以下是查找 “Yellow” 实际颜色值的方法： 12PS C:\\&gt; [System.Windows.Media.Colors]::Yellow.ToString()#FFFFFF00 第一个十六进制值代表 alpha 通道（不透明度）。要使黄色变得更透明，请调低这个值： 1PS&gt;$psise.Options.ConsolePaneTextBackgroundColor=\"#33FFFF00\"","text":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 在钱一个技能中您学到了三个设置控制 PowerShell ISE 控制台面板中的颜色。如果您希望的话，还可以为输入和输出设置不同的背景色： 123$psise.Options.ConsolePaneForegroundColor=[System.Windows.Media.Colors]::LightSkyBlue$psise.Options.ConsolePaneBackgroundColor=[System.Windows.Media.Colors]::DarkGreen$psise.Options.ConsolePaneTextBackgroundColor=[System.Windows.Media.Colors]::Yellow 结果类似这样： 123456789101112131415PS C:\\&gt;\"Hello\"HelloPS C:\\&gt;$HostName : Windows PowerShell ISE HostVersion : 4.0InstanceId : 840b9f0e-0c05-4b6d-84fc-c104971ac647UI : System.Management.Automation.Internal.Host.InternalHostUserInterfaceCurrentCulture : de-DECurrentUICulture: de-DEPrivateData : Microsoft.PowerShell.Host.ISE.ISEOptionsIsRunspacePushed: FalseRunspace : System.Management.Automation.Runspaces.LocalRunspace 如果您只希望将输出高亮一点点，那么可以使用透明色。文字的背景色可以变成透明，首先要确定希望使用的颜色的代码，然后用 alpha 通道创建自定义的颜色。它操作起来很简单。 在前一个例子中，文字的背景色被设置成 “Yellow”。以下是查找 “Yellow” 实际颜色值的方法： 12PS C:\\&gt; [System.Windows.Media.Colors]::Yellow.ToString()#FFFFFF00 第一个十六进制值代表 alpha 通道（不透明度）。要使黄色变得更透明，请调低这个值： 1PS&gt;$psise.Options.ConsolePaneTextBackgroundColor=\"#33FFFF00\" 本文国际来源：Color Week: Using Transparency in the PowerShell ISE Console","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 色彩之周: 设置 PowerShell ISE 的背景色","slug":"color-week-setting-powershell-ise-background-color","date":"2016-09-13T16:00:00.000Z","updated":"2017-03-17T15:26:26.893Z","comments":true,"path":"2016/09/14/color-week-setting-powershell-ise-background-color/","link":"","permalink":"http://blog.vichamp.com/2016/09/14/color-week-setting-powershell-ise-background-color/","excerpt":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 在前一个技能中我们介绍了如何设置 PowerShell ISE 控制台的前景色，以及通过 red、green 和 blue 值指定颜色。 PowerShell ISE 的控制台的背景色也可以用这种方法，不过会产生一些副作用，需要规避。 首先我们将 PowerShell ISE 控制台面板的颜色改为绿底浅灰字： 1234567891011PS C:\\&gt; $psise.Options.ConsolePaneForegroundColor =[System.Windows.Media.Colors]::LightGray PS C:\\&gt; $psise.Options.ConsolePaneBackgroundColor =[System.Windows.Media.Colors]::DarkGreenPS C:\\&gt;PS C:\\&gt;\"Hello\"Hello PS C:\\&gt; 颜色改变了，但是提示符以及所有其它的输出还是原来的颜色。这是因为在 PowerShell ISE 中还有第三个设置，它决定了文字的背景色： 12345PS C:\\&gt;$psise.Options.ConsolePaneTextBackgroundColor =[System.Windows.Media.Colors]::DarkGreen PS C:\\&gt; \"Hello\"Hello 现在看起来一切完美了。","text":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 在前一个技能中我们介绍了如何设置 PowerShell ISE 控制台的前景色，以及通过 red、green 和 blue 值指定颜色。 PowerShell ISE 的控制台的背景色也可以用这种方法，不过会产生一些副作用，需要规避。 首先我们将 PowerShell ISE 控制台面板的颜色改为绿底浅灰字： 1234567891011PS C:\\&gt; $psise.Options.ConsolePaneForegroundColor =[System.Windows.Media.Colors]::LightGray PS C:\\&gt; $psise.Options.ConsolePaneBackgroundColor =[System.Windows.Media.Colors]::DarkGreenPS C:\\&gt;PS C:\\&gt;\"Hello\"Hello PS C:\\&gt; 颜色改变了，但是提示符以及所有其它的输出还是原来的颜色。这是因为在 PowerShell ISE 中还有第三个设置，它决定了文字的背景色： 12345PS C:\\&gt;$psise.Options.ConsolePaneTextBackgroundColor =[System.Windows.Media.Colors]::DarkGreen PS C:\\&gt; \"Hello\"Hello 现在看起来一切完美了。 本文国际来源：Color Week: Setting PowerShell ISE Background Color","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 色彩之周: 为 PowerShell ISE 指定命名的颜色","slug":"color-week-using-clear-names-for-powershell-ise-colors","date":"2016-09-12T16:00:00.000Z","updated":"2017-03-17T15:26:26.871Z","comments":true,"path":"2016/09/13/color-week-using-clear-names-for-powershell-ise-colors/","link":"","permalink":"http://blog.vichamp.com/2016/09/13/color-week-using-clear-names-for-powershell-ise-colors/","excerpt":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 在前一个技能中我们将 PowerShell ISE 控制台的前景色改为任意的自定义 RGB 颜色。您也可以从预定义的颜色种选一个： 123PS&gt; $psise.Options.ConsolePaneForegroundColor = [System.Windows.Media.Colors]::AzurePS&gt; $psise.Options.ConsolePaneForegroundColor = [System.Windows.Media.Colors]::White 在 PowerShell 控制台面板中键入这些代码时，当按下两个冒号后，智能提示将打开一个清单，列出所有预定义的颜色名。这对查找已有的名字十分有用。如果知道一个颜色名，您也可以这样写： 12345PS C:\\&gt; $psise.Options.ConsolePaneForegroundColor = 'Azure'PS C:\\&gt; $psise.Options.ConsolePaneForegroundColor = 'DarkGray'PS C:\\&gt; $psise.Options.ConsolePaneForegroundColor = 'White'","text":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 在前一个技能中我们将 PowerShell ISE 控制台的前景色改为任意的自定义 RGB 颜色。您也可以从预定义的颜色种选一个： 123PS&gt; $psise.Options.ConsolePaneForegroundColor = [System.Windows.Media.Colors]::AzurePS&gt; $psise.Options.ConsolePaneForegroundColor = [System.Windows.Media.Colors]::White 在 PowerShell 控制台面板中键入这些代码时，当按下两个冒号后，智能提示将打开一个清单，列出所有预定义的颜色名。这对查找已有的名字十分有用。如果知道一个颜色名，您也可以这样写： 12345PS C:\\&gt; $psise.Options.ConsolePaneForegroundColor = 'Azure'PS C:\\&gt; $psise.Options.ConsolePaneForegroundColor = 'DarkGray'PS C:\\&gt; $psise.Options.ConsolePaneForegroundColor = 'White' 本文国际来源：Color Week: Using Clear Names for PowerShell ISE Colors","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 颜色之周: 设置 PowerShell ISE 控制台的颜色","slug":"color-week-setting-powershell-ise-console-colors","date":"2016-09-11T16:00:00.000Z","updated":"2017-03-17T15:26:26.866Z","comments":true,"path":"2016/09/12/color-week-setting-powershell-ise-console-colors/","link":"","permalink":"http://blog.vichamp.com/2016/09/12/color-week-setting-powershell-ise-console-colors/","excerpt":"支持 PowerShell 3 以上版本 本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 您可以通过 $host 对象改变 PowerShell ISE 控制台的背景色和前景色，这种方式提供了 16 中预设的颜色可选择： 12345PS&gt; $host.UI.RawUI.ForegroundColor = 'Red'PS&gt; $host.UI.RawUI.ForegroundColor = 'White'PS&gt; 这些命令将前景色先改为红色，然后改回白色。 在 PowerShell ISE 中，您也可以通过 $psISE 变量修改这些颜色。在这里可以用 RGB 值构成您自己的背景色和前景色。让我们把 PowerShell ISE 控制台的前景色改为一些别的： 123PS&gt; $psise.Options.ConsolePaneForegroundColor = '#FFDD98'PS&gt; $psise.Options.ConsolePaneForegroundColor = '#FFFFFF' 第一行将前景色改为微带青色的颜色，下一行将颜色改为白色。 颜色可以用三个十六进制值构成，分别由红色、绿色和蓝色分量组成。","text":"支持 PowerShell 3 以上版本 本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 您可以通过 $host 对象改变 PowerShell ISE 控制台的背景色和前景色，这种方式提供了 16 中预设的颜色可选择： 12345PS&gt; $host.UI.RawUI.ForegroundColor = 'Red'PS&gt; $host.UI.RawUI.ForegroundColor = 'White'PS&gt; 这些命令将前景色先改为红色，然后改回白色。 在 PowerShell ISE 中，您也可以通过 $psISE 变量修改这些颜色。在这里可以用 RGB 值构成您自己的背景色和前景色。让我们把 PowerShell ISE 控制台的前景色改为一些别的： 123PS&gt; $psise.Options.ConsolePaneForegroundColor = '#FFDD98'PS&gt; $psise.Options.ConsolePaneForegroundColor = '#FFFFFF' 第一行将前景色改为微带青色的颜色，下一行将颜色改为白色。 颜色可以用三个十六进制值构成，分别由红色、绿色和蓝色分量组成。 本文国际来源：Color Week: Setting PowerShell ISE Console Colors","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Saving PowerShell User Defaults","slug":"saving-powershell-user-defaults","date":"2016-09-08T16:00:00.000Z","updated":"2017-03-17T15:26:26.861Z","comments":true,"path":"2016/09/09/saving-powershell-user-defaults/","link":"","permalink":"http://blog.vichamp.com/2016/09/09/saving-powershell-user-defaults/","excerpt":"我们将要进入的“色彩之周”将带来许多改变 PowerShell ISE 编辑器和控制台颜色的技能。多数应用到 PowerShell 的改变并没有保存。PowerShell ISE 并不会保存一些颜色设置，但一个更健壮的方法是在 PowerShell 的一个描述脚本中改变您的自定义设置。 任何一个 PowerShell 宿主（控制台或 PowerShell ISE 或其它支持 PowerShell 的程序）都会执行的脚本如下： 12PS C:\\&gt; $profile.CurrentUserAllHostsC:\\Users\\Tobias\\Documents\\WindowsPowerShell\\profile.ps1 Anything that applies to a specific host like the console only, or the PowerShell ISE only, goes here: 任何一个特定的 PowerShell 宿主，例如特指控制台或特指 PowerShell ISE 启动执行的脚本如下： 12PS C:\\&gt; $profile.CurrentUserCurrentHost C:\\Users\\Tobias\\Documents\\WindowsPowerShell\\XXXXXXXXXXXXXX_profile.ps1 请注意路径中的 “XXX”。需要在指定的宿主内运行上面的代码才有效。根据不同的宿主，这行代码会返回不同的路径。 另外请注意这些调用只是返回描述脚本的路径。它缺省情况下并不存在。您可能需要自己创建它，包括 “WindowsPowerShell” 文件夹。当描述脚本存在时，PowerShell 宿主启动的时候就会执行它。 请注意需要打开脚本执行功能。所以您可能需要一次性地允许脚本执行，比如： 1PS&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned -Force","text":"我们将要进入的“色彩之周”将带来许多改变 PowerShell ISE 编辑器和控制台颜色的技能。多数应用到 PowerShell 的改变并没有保存。PowerShell ISE 并不会保存一些颜色设置，但一个更健壮的方法是在 PowerShell 的一个描述脚本中改变您的自定义设置。 任何一个 PowerShell 宿主（控制台或 PowerShell ISE 或其它支持 PowerShell 的程序）都会执行的脚本如下： 12PS C:\\&gt; $profile.CurrentUserAllHostsC:\\Users\\Tobias\\Documents\\WindowsPowerShell\\profile.ps1 Anything that applies to a specific host like the console only, or the PowerShell ISE only, goes here: 任何一个特定的 PowerShell 宿主，例如特指控制台或特指 PowerShell ISE 启动执行的脚本如下： 12PS C:\\&gt; $profile.CurrentUserCurrentHost C:\\Users\\Tobias\\Documents\\WindowsPowerShell\\XXXXXXXXXXXXXX_profile.ps1 请注意路径中的 “XXX”。需要在指定的宿主内运行上面的代码才有效。根据不同的宿主，这行代码会返回不同的路径。 另外请注意这些调用只是返回描述脚本的路径。它缺省情况下并不存在。您可能需要自己创建它，包括 “WindowsPowerShell” 文件夹。当描述脚本存在时，PowerShell 宿主启动的时候就会执行它。 请注意需要打开脚本执行功能。所以您可能需要一次性地允许脚本执行，比如： 1PS&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned -Force 本文国际来源：Saving PowerShell User Defaults","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查看 ASCII 码","slug":"finding-ascii-codes","date":"2016-09-07T16:00:00.000Z","updated":"2017-03-17T15:26:26.852Z","comments":true,"path":"2016/09/08/finding-ascii-codes/","link":"","permalink":"http://blog.vichamp.com/2016/09/08/finding-ascii-codes/","excerpt":"这是一种查看任何字符 ASCII 码的简单办法。字符可能截取自网站或者来自从 internet 上下载的脚本。 只需要打开 PowerShell 然后输入以下代码： 1234567891011# paste character(s) inside the quotes $text = '' foreach($char in [char[]]$text) &#123; 'Character &#123;0,-3&#125; Decimal &#123;1,-5&#125; Hex &#123;1,-4:X&#125;' -f $char, [int]$char &#125; 下一步，将字符（可以多个）粘贴在引号内，然后运行代码。为了测试，可以在 PowerShell 中运行以下代码： 1PS C:\\&gt; charmap 这将打开字符映射表。您可以在其中选择一种字体，例如 DingBats，以及一个或多个字符。将它们复制到剪贴板，然后将它们粘贴到上面的 PowerShell 代码中。当您运行代码时，它将以十进制和十进制两种方式返回所选字符的 ASCII 码值。它们应该和字符映射表工具状态栏显示的值相同。","text":"这是一种查看任何字符 ASCII 码的简单办法。字符可能截取自网站或者来自从 internet 上下载的脚本。 只需要打开 PowerShell 然后输入以下代码： 1234567891011# paste character(s) inside the quotes $text = '' foreach($char in [char[]]$text) &#123; 'Character &#123;0,-3&#125; Decimal &#123;1,-5&#125; Hex &#123;1,-4:X&#125;' -f $char, [int]$char &#125; 下一步，将字符（可以多个）粘贴在引号内，然后运行代码。为了测试，可以在 PowerShell 中运行以下代码： 1PS C:\\&gt; charmap 这将打开字符映射表。您可以在其中选择一种字体，例如 DingBats，以及一个或多个字符。将它们复制到剪贴板，然后将它们粘贴到上面的 PowerShell 代码中。当您运行代码时，它将以十进制和十进制两种方式返回所选字符的 ASCII 码值。它们应该和字符映射表工具状态栏显示的值相同。 本文国际来源：Finding ASCII Codes","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检查（本地和远程的）硬盘容量","slug":"checking-hard-drive-size-local-and-remote","date":"2016-09-06T16:00:00.000Z","updated":"2017-03-17T15:26:26.845Z","comments":true,"path":"2016/09/07/checking-hard-drive-size-local-and-remote/","link":"","permalink":"http://blog.vichamp.com/2016/09/07/checking-hard-drive-size-local-and-remote/","excerpt":"WMI 可以提供硬盘的容量和剩余空间。PowerShell 会用返回这样的友好信息： 123456789101112131415PS C:\\&gt; # localPS C:\\&gt; Get-HardDriveSizeDriveLetter Free(GB) Size(GB) Percent----------- -------- -------- -------C: 823,7 942,3 87,4PS C:\\&gt; # remotePS C:\\&gt; Get-HardDriveSize -ComputerName server2 -Credential server2\\TobiasDriveLetter Free(GB) Size(GB) Percent----------- -------- -------- -------C: 87,3 436,9 20D: 5,3 25 21,3 以下是代码： 12345678910111213141516171819202122232425262728293031323334function Get-HardDriveSize&#123; param ( $ComputerName, $Credential ) # get calculated properties: $prop1 = @&#123; Name = 'DriveLetter' Expression = &#123; $_.DeviceID &#125; &#125; $prop2 = @&#123; Name = 'Free(GB)' Expression = &#123; [Math]::Round(($_.FreeSpace / 1GB),1) &#125; &#125; $prop3 = @&#123; Name = 'Size(GB)' Expression = &#123; [Math]::Round(($_.Size / 1GB),1) &#125; &#125; $prop4 = @&#123; Name = 'Percent' Expression = &#123; [Math]::Round(($_.Freespace * 100 / $_.Size),1) &#125; &#125; # get all hard drives Get-CimInstance -ClassName Win32_LogicalDisk @PSBoundParameters -Filter \"DriveType=3\" | Select-Object -Property $prop1, $prop2, $prop3, $prop4&#125;","text":"WMI 可以提供硬盘的容量和剩余空间。PowerShell 会用返回这样的友好信息： 123456789101112131415PS C:\\&gt; # localPS C:\\&gt; Get-HardDriveSizeDriveLetter Free(GB) Size(GB) Percent----------- -------- -------- -------C: 823,7 942,3 87,4PS C:\\&gt; # remotePS C:\\&gt; Get-HardDriveSize -ComputerName server2 -Credential server2\\TobiasDriveLetter Free(GB) Size(GB) Percent----------- -------- -------- -------C: 87,3 436,9 20D: 5,3 25 21,3 以下是代码： 12345678910111213141516171819202122232425262728293031323334function Get-HardDriveSize&#123; param ( $ComputerName, $Credential ) # get calculated properties: $prop1 = @&#123; Name = 'DriveLetter' Expression = &#123; $_.DeviceID &#125; &#125; $prop2 = @&#123; Name = 'Free(GB)' Expression = &#123; [Math]::Round(($_.FreeSpace / 1GB),1) &#125; &#125; $prop3 = @&#123; Name = 'Size(GB)' Expression = &#123; [Math]::Round(($_.Size / 1GB),1) &#125; &#125; $prop4 = @&#123; Name = 'Percent' Expression = &#123; [Math]::Round(($_.Freespace * 100 / $_.Size),1) &#125; &#125; # get all hard drives Get-CimInstance -ClassName Win32_LogicalDisk @PSBoundParameters -Filter \"DriveType=3\" | Select-Object -Property $prop1, $prop2, $prop3, $prop4&#125; 本文国际来源：Checking Hard Drive Size (Local and Remote)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 启用远程管理","slug":"enabling-remote-administration","date":"2016-09-05T16:00:00.000Z","updated":"2017-03-17T15:26:26.843Z","comments":true,"path":"2016/09/06/enabling-remote-administration/","link":"","permalink":"http://blog.vichamp.com/2016/09/06/enabling-remote-administration/","excerpt":"支持 PowerShell 2 以上版本 许多早先基于 DCOM 的命令需要打开“远程管理防火墙例外”，才能访问远程系统。其中包含 Get-WmiObject 等 Cmdlet。 一个启用该功能的简单办法是在管理员权限下运行以下命令： 1netsh firewall set service remoteadmin enable 虽然该命令已经准备淘汰，不过它仍然能用，而且是配置防火墙的最简单方法。","text":"支持 PowerShell 2 以上版本 许多早先基于 DCOM 的命令需要打开“远程管理防火墙例外”，才能访问远程系统。其中包含 Get-WmiObject 等 Cmdlet。 一个启用该功能的简单办法是在管理员权限下运行以下命令： 1netsh firewall set service remoteadmin enable 虽然该命令已经准备淘汰，不过它仍然能用，而且是配置防火墙的最简单方法。 本文国际来源：Enabling Remote Administration","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找自启动项","slug":"finding-auto-starts","date":"2016-09-04T16:00:00.000Z","updated":"2017-03-17T15:26:26.839Z","comments":true,"path":"2016/09/05/finding-auto-starts/","link":"","permalink":"http://blog.vichamp.com/2016/09/05/finding-auto-starts/","excerpt":"支持 PowerShell 3 以上版本 If you’d like to know which programs start automatically on your machine, WMI may help: 如果您想了解有多少个程序随着您的机器自动启动，WMI 也许能帮上忙： 123456789101112131415161718192021222324252627PS C:\\&gt; Get-CimInstance -ClassName Win32_StartupCommand | Select-Object -Property Name, Location, User, Command, DescriptionName : OneDriveLocation : HKU\\S-1-5-21-2012478179-265285931-690539891-1001\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunUser : DESKTOP-7AAMJLF\\tobweCommand : &quot;C:\\Users\\tobwe\\AppData\\Local\\Microsoft\\OneDrive\\OneDrive.exe&quot; /backgroundDescription : OneDriveName : BluetoothLocation : Common StartupUser : PublicCommand : C:\\PROGRA~1\\WIDCOMM\\BLUETO~1\\BTTray.exe Description : BluetoothName : Snagit 12Location : Common StartupUser : PublicCommand : C:\\PROGRA~2\\TECHSM~1\\SNAGIT~1\\Snagit32.exe Description : Snagit 12Name : RTHDVCPLLocation : HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunUser : PublicCommand : &quot;C:\\Program Files\\Realtek\\Audio\\HDA\\RtkNGUI64.exe&quot; -sDescription : RTHDVCPL...","text":"支持 PowerShell 3 以上版本 If you’d like to know which programs start automatically on your machine, WMI may help: 如果您想了解有多少个程序随着您的机器自动启动，WMI 也许能帮上忙： 123456789101112131415161718192021222324252627PS C:\\&gt; Get-CimInstance -ClassName Win32_StartupCommand | Select-Object -Property Name, Location, User, Command, DescriptionName : OneDriveLocation : HKU\\S-1-5-21-2012478179-265285931-690539891-1001\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunUser : DESKTOP-7AAMJLF\\tobweCommand : &quot;C:\\Users\\tobwe\\AppData\\Local\\Microsoft\\OneDrive\\OneDrive.exe&quot; /backgroundDescription : OneDriveName : BluetoothLocation : Common StartupUser : PublicCommand : C:\\PROGRA~1\\WIDCOMM\\BLUETO~1\\BTTray.exe Description : BluetoothName : Snagit 12Location : Common StartupUser : PublicCommand : C:\\PROGRA~2\\TECHSM~1\\SNAGIT~1\\Snagit32.exe Description : Snagit 12Name : RTHDVCPLLocation : HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunUser : PublicCommand : &quot;C:\\Program Files\\Realtek\\Audio\\HDA\\RtkNGUI64.exe&quot; -sDescription : RTHDVCPL... 本文国际来源：Finding Auto Starts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 替换 CSV 文件列名","slug":"replacing-csv-file-headers","date":"2016-09-01T16:00:00.000Z","updated":"2017-03-17T15:26:26.830Z","comments":true,"path":"2016/09/02/replacing-csv-file-headers/","link":"","permalink":"http://blog.vichamp.com/2016/09/02/replacing-csv-file-headers/","excerpt":"支持 PowerShell 2 以上版本 当读取 CSV 数据的时候，可能会希望重命名 CSV 的列名，以下是一个简单的实现：只需要一行一行地读取文本，并跳过第一行（第一行包括 CSV 的列名）。然后，将表头替换成一个自定义的列名： 12345$header = ‘NewHeader1’, 'NewHeader2', 'NewHeader3'Get-Content N:\\somepathtofile\\userlist.csv -Encoding Default | Select-Object -Skip 1 | ConvertFrom-CSV -UseCulture -Header $header","text":"支持 PowerShell 2 以上版本 当读取 CSV 数据的时候，可能会希望重命名 CSV 的列名，以下是一个简单的实现：只需要一行一行地读取文本，并跳过第一行（第一行包括 CSV 的列名）。然后，将表头替换成一个自定义的列名： 12345$header = ‘NewHeader1’, 'NewHeader2', 'NewHeader3'Get-Content N:\\somepathtofile\\userlist.csv -Encoding Default | Select-Object -Skip 1 | ConvertFrom-CSV -UseCulture -Header $header 本文国际来源：Replacing CSV File Headers","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通过管道输入数据","slug":"receiving-input-via-pipeline","date":"2016-08-31T16:00:00.000Z","updated":"2017-03-17T15:26:26.825Z","comments":true,"path":"2016/09/01/receiving-input-via-pipeline/","link":"","permalink":"http://blog.vichamp.com/2016/09/01/receiving-input-via-pipeline/","excerpt":"在前一个技能里我们演示了 Convert-Umlaut 如何转换一个字符串中的特殊字符。这在一个函数接受管道输入的时候更有用。让我们来看看增加这种特性所需要做的改变。 在不支持管道的情况下，该函数大概长这个样子： 123456789101112131415161718#requires -Version 3function Convert-Umlaut&#123; param ( [Parameter(Mandatory)] $Text ) $output = $Text.Replace('ö','oe').Replace('ä','ae').Replace('ü','ue').Replace('ß','ss').Replace('Ö','Oe').Replace('Ü','Ue').Replace('Ä','Ae') $isCapitalLetter = $Text -ceq $Text.toUpper() if ($isCapitalLetter) &#123; $output = $output.toUpper() &#125; $output&#125; 可以通过这种方式执行： 12PS C:\\&gt; Convert-Umlaut -Text &quot;Mößler, Christiansön&quot; Moessler, Christiansoen 然而，它不能像这样执行： 1PS C:\\&gt; &quot;Mößler, Christiansön&quot; | Convert-Umlaut 要增加管道功能，需要做两件事： 参数需要标记为支持管道数据。 在迭代中对每个输入的元素进行处理的代码需要放置在 “process“ 代码块中。 以下是改变后的代码： 123456789101112131415161718192021#requires -Version 3function Convert-Umlaut&#123; param ( [Parameter(Mandatory, ValueFromPipeline)] $Text ) process &#123; $output = $Text.Replace('ö','oe').Replace('ä','ae').Replace('ü','ue').Replace('ß','ss').Replace('Ö','Oe').Replace('Ü','Ue').Replace('Ä','Ae') $isCapitalLetter = $Text -ceq $Text.toUpper() if ($isCapitalLetter) &#123; $output = $output.toUpper() &#125; $output &#125;&#125; 现在，也可以通过管道传输数据了： 12PS C:\\&gt; &quot;Mößler, Christiansön&quot; | Convert-Umlaut Moessler, Christiansoen","text":"在前一个技能里我们演示了 Convert-Umlaut 如何转换一个字符串中的特殊字符。这在一个函数接受管道输入的时候更有用。让我们来看看增加这种特性所需要做的改变。 在不支持管道的情况下，该函数大概长这个样子： 123456789101112131415161718#requires -Version 3function Convert-Umlaut&#123; param ( [Parameter(Mandatory)] $Text ) $output = $Text.Replace('ö','oe').Replace('ä','ae').Replace('ü','ue').Replace('ß','ss').Replace('Ö','Oe').Replace('Ü','Ue').Replace('Ä','Ae') $isCapitalLetter = $Text -ceq $Text.toUpper() if ($isCapitalLetter) &#123; $output = $output.toUpper() &#125; $output&#125; 可以通过这种方式执行： 12PS C:\\&gt; Convert-Umlaut -Text &quot;Mößler, Christiansön&quot; Moessler, Christiansoen 然而，它不能像这样执行： 1PS C:\\&gt; &quot;Mößler, Christiansön&quot; | Convert-Umlaut 要增加管道功能，需要做两件事： 参数需要标记为支持管道数据。 在迭代中对每个输入的元素进行处理的代码需要放置在 “process“ 代码块中。 以下是改变后的代码： 123456789101112131415161718192021#requires -Version 3function Convert-Umlaut&#123; param ( [Parameter(Mandatory, ValueFromPipeline)] $Text ) process &#123; $output = $Text.Replace('ö','oe').Replace('ä','ae').Replace('ü','ue').Replace('ß','ss').Replace('Ö','Oe').Replace('Ü','Ue').Replace('Ä','Ae') $isCapitalLetter = $Text -ceq $Text.toUpper() if ($isCapitalLetter) &#123; $output = $output.toUpper() &#125; $output &#125;&#125; 现在，也可以通过管道传输数据了： 12PS C:\\&gt; &quot;Mößler, Christiansön&quot; | Convert-Umlaut Moessler, Christiansoen 本文国际来源：Receiving Input via Pipeline","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 替换类似 “Umlauts” 的特殊字符","slug":"replacing-special-chars-like-umlauts","date":"2016-08-30T16:00:00.000Z","updated":"2017-03-17T15:26:26.821Z","comments":true,"path":"2016/08/31/replacing-special-chars-like-umlauts/","link":"","permalink":"http://blog.vichamp.com/2016/08/31/replacing-special-chars-like-umlauts/","excerpt":"支持 PowerShell 2.0 以上版本 有些时候我们需要将一些字符替换，例如德语的 “Umlauts”，来适应用户名或邮箱地址。 以下是一个演示如何实现这个功能的小函数： 123456789101112131415161718#requires -Version 3function Convert-Umlaut&#123; param ( [Parameter(Mandatory)] $Text ) $output = $Text.Replace('ö','oe').Replace('ä','ae').Replace('ü','ue').Replace('ß','ss').Replace('Ö','Oe').Replace('Ü','Ue').Replace('Ä','Ae') $isCapitalLetter = $Text -ceq $Text.toUpper() if ($isCapitalLetter) &#123; $output = $output.toUpper() &#125; $output&#125; 要转换一个字符串，请这样使用： 12PS C:\\&gt; Convert-Umlaut -Text &quot;Mößler, Christiansön&quot; Moessler, Christiansoen","text":"支持 PowerShell 2.0 以上版本 有些时候我们需要将一些字符替换，例如德语的 “Umlauts”，来适应用户名或邮箱地址。 以下是一个演示如何实现这个功能的小函数： 123456789101112131415161718#requires -Version 3function Convert-Umlaut&#123; param ( [Parameter(Mandatory)] $Text ) $output = $Text.Replace('ö','oe').Replace('ä','ae').Replace('ü','ue').Replace('ß','ss').Replace('Ö','Oe').Replace('Ü','Ue').Replace('Ä','Ae') $isCapitalLetter = $Text -ceq $Text.toUpper() if ($isCapitalLetter) &#123; $output = $output.toUpper() &#125; $output&#125; 要转换一个字符串，请这样使用： 12PS C:\\&gt; Convert-Umlaut -Text &quot;Mößler, Christiansön&quot; Moessler, Christiansoen 本文国际来源：Replacing Special Chars like “Umlauts”","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 友好地使用 Robocopy","slug":"using-friendly-robocopy","date":"2016-08-29T16:00:00.000Z","updated":"2017-03-17T15:26:26.812Z","comments":true,"path":"2016/08/30/using-friendly-robocopy/","link":"","permalink":"http://blog.vichamp.com/2016/08/30/using-friendly-robocopy/","excerpt":"支持 PowerShell 2.0 以上版本 Robocopy 是一个用于拷贝文件的工具，它在 PowerShell 里的功能也是一样。然而您可以用 PowerShell 将 robocopy 封装在一个对用户友好的 PowerShell 函数中。通过这种方式，您不再需要记忆 robocopy 别扭的命令行选项。取而代之的是 PowerShell 参数和智能提示功能。 一次 robocopy 的调用可能看起来如下： 1PS C:\\&gt; Invoke-Robocopy -Source $env:windir -Destination c:\\logs -Filter *.log -Recurse -Open 以下是封装函数： 12345678910111213141516171819202122232425262728293031323334353637383940#requires -Version 3function Invoke-Robocopy&#123; param ( [String] [Parameter(Mandatory)] $Source, [String] [Parameter(Mandatory)] $Destination, [String] $Filter = '*', [Switch] $Recurse, [Switch] $Open ) if ($Recurse) &#123; $DoRecurse = '/S' &#125; else &#123; $DoRecurse = '' &#125; robocopy $Source $Destination $Filter $DoRecurse /R:0 if ($Open) &#123; explorer.exe $Destination &#125; &#125;","text":"支持 PowerShell 2.0 以上版本 Robocopy 是一个用于拷贝文件的工具，它在 PowerShell 里的功能也是一样。然而您可以用 PowerShell 将 robocopy 封装在一个对用户友好的 PowerShell 函数中。通过这种方式，您不再需要记忆 robocopy 别扭的命令行选项。取而代之的是 PowerShell 参数和智能提示功能。 一次 robocopy 的调用可能看起来如下： 1PS C:\\&gt; Invoke-Robocopy -Source $env:windir -Destination c:\\logs -Filter *.log -Recurse -Open 以下是封装函数： 12345678910111213141516171819202122232425262728293031323334353637383940#requires -Version 3function Invoke-Robocopy&#123; param ( [String] [Parameter(Mandatory)] $Source, [String] [Parameter(Mandatory)] $Destination, [String] $Filter = '*', [Switch] $Recurse, [Switch] $Open ) if ($Recurse) &#123; $DoRecurse = '/S' &#125; else &#123; $DoRecurse = '' &#125; robocopy $Source $Destination $Filter $DoRecurse /R:0 if ($Open) &#123; explorer.exe $Destination &#125; &#125; 本文国际来源：Using Friendly Robocopy","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 直接使用 .NET 类型","slug":"using-net-types-directly","date":"2016-02-23T04:00:00.000Z","updated":"2017-03-17T15:26:26.807Z","comments":true,"path":"2016/02/23/using-net-types-directly/","link":"","permalink":"http://blog.vichamp.com/2016/02/23/using-net-types-directly/","excerpt":"Cmdlet 内含了纯 .NET 代码，所以感谢 cmdlet，我们通常无需接触 .NET 代码。不过，如果您需要的话仍然可以使用。以下是一系列调用示例，演示了如何调用 .NET 方法： #requires -Version 2 [System.Convert]::ToString(687687687, 2) [Math]::Round(4.6) [Guid]::NewGuid() [System.IO.Path]::ChangeExtension(&apos;c:\\test.txt&apos;, &apos;bak&apos;) [System.Net.DNS]::GetHostByName(&apos;dell1&apos;) [System.Net.DNS]::GetHostByAddress(&apos;192.168.1.124&apos;) [Environment]::SetEnvironmentVariable() # dangerous, save your work first [Environment]::FailFast(&apos;Oops&apos;) Add-Type -AssemblyName PresentationFramework $dialog = New-Object Microsoft.Win32.OpenFileDialog $dialog.ShowDialog() $dialog.FileName","text":"Cmdlet 内含了纯 .NET 代码，所以感谢 cmdlet，我们通常无需接触 .NET 代码。不过，如果您需要的话仍然可以使用。以下是一系列调用示例，演示了如何调用 .NET 方法： #requires -Version 2 [System.Convert]::ToString(687687687, 2) [Math]::Round(4.6) [Guid]::NewGuid() [System.IO.Path]::ChangeExtension(&apos;c:\\test.txt&apos;, &apos;bak&apos;) [System.Net.DNS]::GetHostByName(&apos;dell1&apos;) [System.Net.DNS]::GetHostByAddress(&apos;192.168.1.124&apos;) [Environment]::SetEnvironmentVariable() # dangerous, save your work first [Environment]::FailFast(&apos;Oops&apos;) Add-Type -AssemblyName PresentationFramework $dialog = New-Object Microsoft.Win32.OpenFileDialog $dialog.ShowDialog() $dialog.FileName 本文国际来源：Using .NET Types Directly","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用工作流来并发执行代码","slug":"using-workflows-to-parallelize-code","date":"2016-02-22T04:00:00.000Z","updated":"2017-03-17T15:26:26.803Z","comments":true,"path":"2016/02/22/using-workflows-to-parallelize-code/","link":"","permalink":"http://blog.vichamp.com/2016/02/22/using-workflows-to-parallelize-code/","excerpt":"如果您希望同时执行多个任务，以下有多种方法用 Powershell 实现。一种是使用工作流。它们是 PowerShell 3.0 中引入的： #requires -Version 3 workflow Test-ParallelForeach { param ( [String[]] $ComputerName ) foreach -parallel -throttlelimit 8 ($Machine in $ComputerName) { &quot;Begin $Machine&quot; Start-Sleep -Seconds (Get-Random -min 3 -max 5) &quot;End $Machine&quot; } } $list = 1..20 Test-ParallelForeach -ComputerName $list | Out-GridView Test-ParallelForeach 处理一个计算机列表（在这个例子中，是一个数字列表）。它们同时执行。要控制资源的使用，并行循环将节流限制为 8，所以所以在这个例子中的 20 台计算机是 8 个一组处理的。 请注意使用工作流需要更多地了解它们的架构和限制。这个例子关注于工作流提供的并行循环技术。","text":"如果您希望同时执行多个任务，以下有多种方法用 Powershell 实现。一种是使用工作流。它们是 PowerShell 3.0 中引入的： #requires -Version 3 workflow Test-ParallelForeach { param ( [String[]] $ComputerName ) foreach -parallel -throttlelimit 8 ($Machine in $ComputerName) { &quot;Begin $Machine&quot; Start-Sleep -Seconds (Get-Random -min 3 -max 5) &quot;End $Machine&quot; } } $list = 1..20 Test-ParallelForeach -ComputerName $list | Out-GridView Test-ParallelForeach 处理一个计算机列表（在这个例子中，是一个数字列表）。它们同时执行。要控制资源的使用，并行循环将节流限制为 8，所以所以在这个例子中的 20 台计算机是 8 个一组处理的。 请注意使用工作流需要更多地了解它们的架构和限制。这个例子关注于工作流提供的并行循环技术。 本文国际来源：Using Workflows to Parallelize Code","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 #requires 语句装饰脚本","slug":"decorate-scripts-with-requires-statements","date":"2016-02-19T04:00:00.000Z","updated":"2017-03-17T15:26:26.798Z","comments":true,"path":"2016/02/19/decorate-scripts-with-requires-statements/","link":"","permalink":"http://blog.vichamp.com/2016/02/19/decorate-scripts-with-requires-statements/","excerpt":"PowerShell 支持一系列 #requires 语句。技术上它们是注释，但是 PowerShell 会检查这些语句所申明的必要条件，并且如果条件不满足，它将不会执行这个脚本。另外，#requires 语句能快速地告知您运行脚本的前提条件。 #requires -Modules PrintManagement #requires -Version 3 #Requires -RunAsAdministrator #requires 语句必须是一个脚本的第一条语句，并且它只对保存的脚本有效。","text":"PowerShell 支持一系列 #requires 语句。技术上它们是注释，但是 PowerShell 会检查这些语句所申明的必要条件，并且如果条件不满足，它将不会执行这个脚本。另外，#requires 语句能快速地告知您运行脚本的前提条件。 #requires -Modules PrintManagement #requires -Version 3 #Requires -RunAsAdministrator #requires 语句必须是一个脚本的第一条语句，并且它只对保存的脚本有效。 本文国际来源：Decorate Scripts with #requires Statements","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"},{"name":"tip个","slug":"tip个","permalink":"http://blog.vichamp.com/tags/tip个/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 不要混合不同的对象","slug":"do-not-mix-different-objects","date":"2016-02-17T21:00:00.000Z","updated":"2017-03-17T15:26:26.789Z","comments":true,"path":"2016/02/18/do-not-mix-different-objects/","link":"","permalink":"http://blog.vichamp.com/2016/02/18/do-not-mix-different-objects/","excerpt":"如果您连续输出完全不同的对象，您可能丢失信息。请看这个例子： #requires -Version 2 $hash = @{ Name = &apos;PowerShell Conference EU&apos; Date = &apos;April 20, 2016&apos; City = &apos;Hannover&apos; URL = &apos;www.psconf.eu&apos; } New-Object -TypeName PSObject -Property $hash $b = Get-Process -Id $pid $b 当您运行这段代码时，您将得到这样的结果： Date URL Name City ---- --- ---- ---- April 20, 2016 www.psconf.eu PowerShell Conference EU Hannover powershell_ise 看起来 $b (process) 的几乎所有属性都丢失了。原因是 PowerShell 是实时输出对象的，而且首次提交的对象决定了在表格中显示哪些属性。所有接下来的对象都将纳入这张表格中。 如果您必须要输出不同的对象，请将它们用管道输出到 Out-Host。每次您输出到 Out-Host，PowerShell 都将创建一个具有新的表格标题的输出。","text":"如果您连续输出完全不同的对象，您可能丢失信息。请看这个例子： #requires -Version 2 $hash = @{ Name = &apos;PowerShell Conference EU&apos; Date = &apos;April 20, 2016&apos; City = &apos;Hannover&apos; URL = &apos;www.psconf.eu&apos; } New-Object -TypeName PSObject -Property $hash $b = Get-Process -Id $pid $b 当您运行这段代码时，您将得到这样的结果： Date URL Name City ---- --- ---- ---- April 20, 2016 www.psconf.eu PowerShell Conference EU Hannover powershell_ise 看起来 $b (process) 的几乎所有属性都丢失了。原因是 PowerShell 是实时输出对象的，而且首次提交的对象决定了在表格中显示哪些属性。所有接下来的对象都将纳入这张表格中。 如果您必须要输出不同的对象，请将它们用管道输出到 Out-Host。每次您输出到 Out-Host，PowerShell 都将创建一个具有新的表格标题的输出。 本文国际来源：Do Not Mix Different Objects!","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 得到一个借口","slug":"getting-an-excuse","date":"2016-02-17T04:00:00.000Z","updated":"2017-03-17T15:26:26.781Z","comments":true,"path":"2016/02/17/getting-an-excuse/","link":"","permalink":"http://blog.vichamp.com/2016/02/17/getting-an-excuse/","excerpt":"以下是一个快速的方法来得到一个借口——假设您有 Internet 连接： #requires -Version 3 function Get-Excuse { $url = &apos;http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl&apos; $ProgressPreference = &apos;SilentlyContinue&apos; $page = Invoke-WebRequest -Uri $url -UseBasicParsing $pattern = &apos;(?m)&lt;br&gt;&lt;font size = &quot;\\+2&quot;&gt;(.+)&apos; if ($page.Content -match $pattern) { $matches[1] } } 它演示了如何使用 Invoke-WebRequest 来下载一个网页的 HTML 内容，然后使用正则表达式来抓取网页的内容。","text":"以下是一个快速的方法来得到一个借口——假设您有 Internet 连接： #requires -Version 3 function Get-Excuse { $url = &apos;http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl&apos; $ProgressPreference = &apos;SilentlyContinue&apos; $page = Invoke-WebRequest -Uri $url -UseBasicParsing $pattern = &apos;(?m)&lt;br&gt;&lt;font size = &quot;\\+2&quot;&gt;(.+)&apos; if ($page.Content -match $pattern) { $matches[1] } } 它演示了如何使用 Invoke-WebRequest 来下载一个网页的 HTML 内容，然后使用正则表达式来抓取网页的内容。 本文国际来源：Getting an Excuse","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 谁在监听？（第二部分）","slug":"who-is-listening-part-2","date":"2016-02-16T04:00:00.000Z","updated":"2017-03-17T15:26:26.777Z","comments":true,"path":"2016/02/16/who-is-listening-part-2/","link":"","permalink":"http://blog.vichamp.com/2016/02/16/who-is-listening-part-2/","excerpt":"如果您的系统是 Windows 8 或 Windows Server 2012 或以上版本，您可以使用 Get-NetTcpConnection 来找出哪个网络端口正在使用中，以及谁在监听这些端口。 以下脚本不仅列出正在使用的端口而且列出了正在监听该端口的进程。如果进程是 “svchost”，该脚本还会找出是哪个服务启动了这个进程： 1234567891011121314151617181920212223242526#requires -Version 3 -Modules NetTCPIP$service = @&#123;&#125;$Process = @&#123; Name = 'Name' Expression = &#123; $id = $_.OwningProcess $name = (Get-Process -Id $id).Name if ($name -eq 'svchost') &#123; if ($service.ContainsKey($id) -eq $false) &#123; $service.$id = Get-WmiObject -Class win32_Service -Filter \"ProcessID=$id\" | Select-Object -ExpandProperty Name &#125; $service.$id -join ',' &#125; else &#123; $name &#125; &#125;&#125;Get-NetTCPConnection | Select-Object -Property LocalPort, OwningProcess, $Process | Sort-Object -Property LocalPort, Name -Unique 结果类似如下： LocalPort OwningProcess Name --------- ------------- ---- 135 916 RpcEptMapper,RpcSs 139 4 System 445 4 System 5354 2480 mDNSResponder 5985 4 System 7680 544 Appinfo,BITS,Browser,CertPropSvc,DoSvc,iphlpsvc,Lanm... 7779 4 System 15292 7364 Adobe Desktop Service 27015 2456 AppleMobileDeviceService (...)","text":"如果您的系统是 Windows 8 或 Windows Server 2012 或以上版本，您可以使用 Get-NetTcpConnection 来找出哪个网络端口正在使用中，以及谁在监听这些端口。 以下脚本不仅列出正在使用的端口而且列出了正在监听该端口的进程。如果进程是 “svchost”，该脚本还会找出是哪个服务启动了这个进程： 1234567891011121314151617181920212223242526#requires -Version 3 -Modules NetTCPIP$service = @&#123;&#125;$Process = @&#123; Name = 'Name' Expression = &#123; $id = $_.OwningProcess $name = (Get-Process -Id $id).Name if ($name -eq 'svchost') &#123; if ($service.ContainsKey($id) -eq $false) &#123; $service.$id = Get-WmiObject -Class win32_Service -Filter \"ProcessID=$id\" | Select-Object -ExpandProperty Name &#125; $service.$id -join ',' &#125; else &#123; $name &#125; &#125;&#125;Get-NetTCPConnection | Select-Object -Property LocalPort, OwningProcess, $Process | Sort-Object -Property LocalPort, Name -Unique 结果类似如下： LocalPort OwningProcess Name --------- ------------- ---- 135 916 RpcEptMapper,RpcSs 139 4 System 445 4 System 5354 2480 mDNSResponder 5985 4 System 7680 544 Appinfo,BITS,Browser,CertPropSvc,DoSvc,iphlpsvc,Lanm... 7779 4 System 15292 7364 Adobe Desktop Service 27015 2456 AppleMobileDeviceService (...) 本文国际来源：Who is Listening? (Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 谁在监听？（第一部分）","slug":"who-is-listening-part-1","date":"2016-02-15T04:00:00.000Z","updated":"2017-03-17T15:26:26.774Z","comments":true,"path":"2016/02/15/who-is-listening-part-1/","link":"","permalink":"http://blog.vichamp.com/2016/02/15/who-is-listening-part-1/","excerpt":"一个过去十分好用的 netstat.exe 可以告诉您应用程序在监听哪些端口，不过结果是纯文本。PowerShell 可以用正则表达式将文本分割成 CSV 数据，ConvertFrom-Csv 可以将文本转换为真实的对象。 这是一个如何用 PowerShell 处理最基础数据的例子： 1234567891011121314#requires -Version 2NETSTAT.EXE -anop tcp| Select-Object -Skip 4|ForEach-Object -Process &#123; [regex]::replace($_.trim(),'\\s+',' ')&#125;|ConvertFrom-Csv -d ' ' -Header 'proto', 'src', 'dst', 'state', 'pid'|Select-Object -Property src, state, @&#123; name = 'process' expression = &#123; (Get-Process -PipelineVariable $_.pid).name &#125;&#125; |Format-List 结果类似如下： src : 0.0.0.0:135 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...} src : 0.0.0.0:445 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...} src : 0.0.0.0:5985 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...} src : 0.0.0.0:7680 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...} src : 0.0.0.0:7779 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...}","text":"一个过去十分好用的 netstat.exe 可以告诉您应用程序在监听哪些端口，不过结果是纯文本。PowerShell 可以用正则表达式将文本分割成 CSV 数据，ConvertFrom-Csv 可以将文本转换为真实的对象。 这是一个如何用 PowerShell 处理最基础数据的例子： 1234567891011121314#requires -Version 2NETSTAT.EXE -anop tcp| Select-Object -Skip 4|ForEach-Object -Process &#123; [regex]::replace($_.trim(),'\\s+',' ')&#125;|ConvertFrom-Csv -d ' ' -Header 'proto', 'src', 'dst', 'state', 'pid'|Select-Object -Property src, state, @&#123; name = 'process' expression = &#123; (Get-Process -PipelineVariable $_.pid).name &#125;&#125; |Format-List 结果类似如下： src : 0.0.0.0:135 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...} src : 0.0.0.0:445 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...} src : 0.0.0.0:5985 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...} src : 0.0.0.0:7680 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...} src : 0.0.0.0:7779 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...} 本文国际来源：Who Is Listening? (Part 1)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将对象发送到记事本","slug":"sending-objects-to-notepad","date":"2016-02-12T04:00:00.000Z","updated":"2017-03-17T15:26:26.770Z","comments":true,"path":"2016/02/12/sending-objects-to-notepad/","link":"","permalink":"http://blog.vichamp.com/2016/02/12/sending-objects-to-notepad/","excerpt":"在前一个技能里我们演示了如何将文本发送到一个全新的记事本实例中。今天，您会获得一个增强版的 Out-Notepad：您现在可以通过管道传输任何东西到记事本了。如果内容不是字符串，Out-Notepad 会使用内置的 PowerShell ETS 将它转换为文本并且合适地显示出来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#requires -Version 2function Out-Notepad&#123; param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [Object] [AllowEmptyString()] $Object, [Int] $Width = 150 ) begin &#123; $al = New-Object System.Collections.ArrayList &#125; process &#123; $null = $al.Add($Object) &#125; end &#123; $text = $al | Format-Table -AutoSize -Wrap | Out-String -Width $Width $process = Start-Process notepad -PassThru $null = $process.WaitForInputIdle() $sig = ' [DllImport(\"user32.dll\", EntryPoint = \"FindWindowEx\")]public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow); [DllImport(\"User32.dll\")]public static extern int SendMessage(IntPtr hWnd, int uMsg, int wParam, string lParam); ' $type = Add-Type -MemberDefinition $sig -Name APISendMessage2 -PassThru $hwnd = $process.MainWindowHandle [IntPtr]$child = $type::FindWindowEx($hwnd, [IntPtr]::Zero, \"Edit\", $null) $null = $type::SendMessage($child, 0x000C, 0, $text) &#125;&#125; 您现在可以通过管道传输任何东西到 Out-Notepad。它将原样显示： PS C:\\&gt; Get-Content $env:windir\\system32\\drivers\\etc\\hosts | Out-Notepad 如果您通过管道传送对象，Out-Notepad 会将它们转换为文本并且不会截断任何东西。您可能会希望用 -Width 参数来确定页宽，以便正常显示： PS C:\\&gt; Get-EventLog -LogName System -EntryType Error, Warning -Newest 10 | Out-Notepad -Width 130 另外您可能需要最大化记事本或禁用换行来查看正确的格式。","text":"在前一个技能里我们演示了如何将文本发送到一个全新的记事本实例中。今天，您会获得一个增强版的 Out-Notepad：您现在可以通过管道传输任何东西到记事本了。如果内容不是字符串，Out-Notepad 会使用内置的 PowerShell ETS 将它转换为文本并且合适地显示出来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#requires -Version 2function Out-Notepad&#123; param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [Object] [AllowEmptyString()] $Object, [Int] $Width = 150 ) begin &#123; $al = New-Object System.Collections.ArrayList &#125; process &#123; $null = $al.Add($Object) &#125; end &#123; $text = $al | Format-Table -AutoSize -Wrap | Out-String -Width $Width $process = Start-Process notepad -PassThru $null = $process.WaitForInputIdle() $sig = ' [DllImport(\"user32.dll\", EntryPoint = \"FindWindowEx\")]public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow); [DllImport(\"User32.dll\")]public static extern int SendMessage(IntPtr hWnd, int uMsg, int wParam, string lParam); ' $type = Add-Type -MemberDefinition $sig -Name APISendMessage2 -PassThru $hwnd = $process.MainWindowHandle [IntPtr]$child = $type::FindWindowEx($hwnd, [IntPtr]::Zero, \"Edit\", $null) $null = $type::SendMessage($child, 0x000C, 0, $text) &#125;&#125; 您现在可以通过管道传输任何东西到 Out-Notepad。它将原样显示： PS C:\\&gt; Get-Content $env:windir\\system32\\drivers\\etc\\hosts | Out-Notepad 如果您通过管道传送对象，Out-Notepad 会将它们转换为文本并且不会截断任何东西。您可能会希望用 -Width 参数来确定页宽，以便正常显示： PS C:\\&gt; Get-EventLog -LogName System -EntryType Error, Warning -Newest 10 | Out-Notepad -Width 130 另外您可能需要最大化记事本或禁用换行来查看正确的格式。 本文国际来源：Sending Objects to Notepad","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 发送文本到记事本","slug":"send-text-to-notepad","date":"2016-02-11T04:00:00.000Z","updated":"2017-03-17T15:26:26.765Z","comments":true,"path":"2016/02/11/send-text-to-notepad/","link":"","permalink":"http://blog.vichamp.com/2016/02/11/send-text-to-notepad/","excerpt":"记事本可以用来显示文本结果。通常，您需要将文本保存到文件，然后用记事本打开该文件。不过还有一个更好的办法：打开一个空白的记事本，然后用 Windows 消息直接把文本发送到未命名的记事本编辑器中。 这个函数称为 Out-Notepad。无论您传给这个函数什么文本，它都会在记事本的一个未命名实例中显示： 123456789101112131415161718192021222324252627282930313233343536373839#requires -Version 2function Out-Notepad&#123; param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [String] [AllowEmptyString()] $Text ) begin &#123; $sb = New-Object System.Text.StringBuilder &#125; process &#123; $null = $sb.AppendLine($Text) &#125; end &#123; $text = $sb.ToString() $process = Start-Process notepad -PassThru $null = $process.WaitForInputIdle() $sig = ' [DllImport(\"user32.dll\", EntryPoint = \"FindWindowEx\")]public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow); [DllImport(\"User32.dll\")]public static extern int SendMessage(IntPtr hWnd, int uMsg, int wParam, string lParam); ' $type = Add-Type -MemberDefinition $sig -Name APISendMessage -PassThru $hwnd = $process.MainWindowHandle [IntPtr]$child = $type::FindWindowEx($hwnd, [IntPtr]::Zero, \"Edit\", $null) $null = $type::SendMessage($child, 0x000C, 0, $text) &#125;&#125; 这是一些示例调用： PS C:\\&gt; Get-Content $env:windir\\system32\\drivers\\etc\\hosts | Out-Notepad PS C:\\&gt; Get-Process | Out-String | Out-Notepad","text":"记事本可以用来显示文本结果。通常，您需要将文本保存到文件，然后用记事本打开该文件。不过还有一个更好的办法：打开一个空白的记事本，然后用 Windows 消息直接把文本发送到未命名的记事本编辑器中。 这个函数称为 Out-Notepad。无论您传给这个函数什么文本，它都会在记事本的一个未命名实例中显示： 123456789101112131415161718192021222324252627282930313233343536373839#requires -Version 2function Out-Notepad&#123; param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [String] [AllowEmptyString()] $Text ) begin &#123; $sb = New-Object System.Text.StringBuilder &#125; process &#123; $null = $sb.AppendLine($Text) &#125; end &#123; $text = $sb.ToString() $process = Start-Process notepad -PassThru $null = $process.WaitForInputIdle() $sig = ' [DllImport(\"user32.dll\", EntryPoint = \"FindWindowEx\")]public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow); [DllImport(\"User32.dll\")]public static extern int SendMessage(IntPtr hWnd, int uMsg, int wParam, string lParam); ' $type = Add-Type -MemberDefinition $sig -Name APISendMessage -PassThru $hwnd = $process.MainWindowHandle [IntPtr]$child = $type::FindWindowEx($hwnd, [IntPtr]::Zero, \"Edit\", $null) $null = $type::SendMessage($child, 0x000C, 0, $text) &#125;&#125; 这是一些示例调用： PS C:\\&gt; Get-Content $env:windir\\system32\\drivers\\etc\\hosts | Out-Notepad PS C:\\&gt; Get-Process | Out-String | Out-Notepad 本文国际来源：Send Text to Notepad","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 神奇的下划线变量","slug":"magic-underscore-variable","date":"2016-02-10T04:00:00.000Z","updated":"2017-03-17T15:26:26.755Z","comments":true,"path":"2016/02/10/magic-underscore-variable/","link":"","permalink":"http://blog.vichamp.com/2016/02/10/magic-underscore-variable/","excerpt":"以下是一个非常特别（并且有详细文档的）的使用 PowerShell 变量的方法。请看这个函数： 12345678910111213141516#requires -Version 2function Test-DollarUnderscore&#123; param ( [Parameter(Mandatory=$true, ValueFromPipelineByPropertyName=$true)] [string] $Test ) process &#123; \"received: $Test\" &#125;&#125; 它初看起来并没有什么特别之处。您可以将数值赋给 -Test 参数，并且该函数返回它们： 12PS C:\\&gt; Test-DollarUnderscore -Test 'Some Data'received: Some Data 但是请看当您通过管道传送一个数据给该函数时发生了什么： 12345PS C:\\&gt; 1..4 | Test-DollarUnderscore -Test &#123; &quot;I am receiving $_&quot; &#125;received: I am receiving 1received: I am receiving 2received: I am receiving 3received: I am receiving 4 -Test 参数瞬间自动神奇地接受脚本块了（虽然赋予的类型是 string）。而且在脚本块中，您可以存取输入管道的数据。 您能得到这个非常特别的参数支持功能是因为您为一个必选参数设置了 ValueFromPipelineByPropertyName=$true，并且输入的数据没有一个属性和该参数匹配。","text":"以下是一个非常特别（并且有详细文档的）的使用 PowerShell 变量的方法。请看这个函数： 12345678910111213141516#requires -Version 2function Test-DollarUnderscore&#123; param ( [Parameter(Mandatory=$true, ValueFromPipelineByPropertyName=$true)] [string] $Test ) process &#123; \"received: $Test\" &#125;&#125; 它初看起来并没有什么特别之处。您可以将数值赋给 -Test 参数，并且该函数返回它们： 12PS C:\\&gt; Test-DollarUnderscore -Test 'Some Data'received: Some Data 但是请看当您通过管道传送一个数据给该函数时发生了什么： 12345PS C:\\&gt; 1..4 | Test-DollarUnderscore -Test &#123; &quot;I am receiving $_&quot; &#125;received: I am receiving 1received: I am receiving 2received: I am receiving 3received: I am receiving 4 -Test 参数瞬间自动神奇地接受脚本块了（虽然赋予的类型是 string）。而且在脚本块中，您可以存取输入管道的数据。 您能得到这个非常特别的参数支持功能是因为您为一个必选参数设置了 ValueFromPipelineByPropertyName=$true，并且输入的数据没有一个属性和该参数匹配。 本文国际来源：Magic Underscore Variable","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 换算货币","slug":"converting-currencies","date":"2016-02-09T04:00:00.000Z","updated":"2017-03-17T15:26:26.744Z","comments":true,"path":"2016/02/09/converting-currencies/","link":"","permalink":"http://blog.vichamp.com/2016/02/09/converting-currencies/","excerpt":"PowerShell 是一个非常有用的语言，可以调用 Web Service 和访问网页。如果您将两者合并成一个动态参数，就能得到一个专业的，支持实时汇率的货币换算器。 以下 ConvertTo-Euro 函数可以输入其他货币并转换成欧元。该函数有一个 -Currency 参数，并可以动态地传入欧洲中央银行支持的货币。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function ConvertTo-Euro&#123; [CmdletBinding()] param( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [Double] $Value ) dynamicparam &#123; $Bucket = New-Object -TypeName System.Management.Automation.RuntimeDefinedParameterDictionary $Attributes = New-Object -TypeName System.Collections.ObjectModel.Collection[System.Attribute] $AttribParameter = New-Object System.Management.Automation.ParameterAttribute $AttribParameter.Mandatory = $true $Attributes.Add($AttribParameter) if ($script:currencies -eq $null) &#123; $url = 'http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml' $result = Invoke-RestMethod -Uri $url $script:currencies = $result.Envelope.Cube.Cube.Cube.currency &#125; $AttribValidateSet = New-Object System.Management.Automation.ValidateSetAttribute($script:currencies) $Attributes.Add($AttribValidateSet) $Parameter = New-Object -TypeName System.Management.Automation.RuntimeDefinedParameter('Currency',[String], $Attributes) $Bucket.Add('Currency', $Parameter) $Bucket &#125; begin &#123; foreach ($key in $PSBoundParameters.Keys) &#123; if ($MyInvocation.MyCommand.Parameters.$key.isDynamic) &#123; Set-Variable -Name $key -Value $PSBoundParameters.$key &#125; &#125; $url = 'http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml' $rates = Invoke-RestMethod -Uri $url $rate = $rates.Envelope.Cube.Cube.Cube | Where-Object &#123; $_.currency -eq $Currency&#125; | Select-Object -ExpandProperty Rate &#125; process &#123; $result = [Ordered]@&#123; Value = $Value Currency = $Currency Rate = $rate Euro = ($Value / $rate) Date = Get-Date &#125; New-Object -TypeName PSObject -Property $result &#125;&#125; 该函数演示了如何向动态参数填充动态数据，以及该数据如何缓存以免智能感知每次触发一个新的请求过程。 以下使一些您可能期待的例子（需要 Internet 连接）： PS C:\\&gt; 100, 66.9 | ConvertTo-Euro -Currency DKK Value : 100 Currency : DKK Rate : 7.4622 Euro : 13,4008737369677 Date : 26.01.2016 21:32:44 Value : 66,9 Currency : DKK Rate : 7.4622 Euro : 8,96518453003136 Date : 26.01.2016 21:32:45 PS C:\\&gt; ConvertTo-Euro -Currency USD -Value 99.78 Value : 99,78 Currency : USD Rate : 1.0837 Euro : 92,0734520623789 Date : 26.01.2016 21:33:01","text":"PowerShell 是一个非常有用的语言，可以调用 Web Service 和访问网页。如果您将两者合并成一个动态参数，就能得到一个专业的，支持实时汇率的货币换算器。 以下 ConvertTo-Euro 函数可以输入其他货币并转换成欧元。该函数有一个 -Currency 参数，并可以动态地传入欧洲中央银行支持的货币。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function ConvertTo-Euro&#123; [CmdletBinding()] param( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [Double] $Value ) dynamicparam &#123; $Bucket = New-Object -TypeName System.Management.Automation.RuntimeDefinedParameterDictionary $Attributes = New-Object -TypeName System.Collections.ObjectModel.Collection[System.Attribute] $AttribParameter = New-Object System.Management.Automation.ParameterAttribute $AttribParameter.Mandatory = $true $Attributes.Add($AttribParameter) if ($script:currencies -eq $null) &#123; $url = 'http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml' $result = Invoke-RestMethod -Uri $url $script:currencies = $result.Envelope.Cube.Cube.Cube.currency &#125; $AttribValidateSet = New-Object System.Management.Automation.ValidateSetAttribute($script:currencies) $Attributes.Add($AttribValidateSet) $Parameter = New-Object -TypeName System.Management.Automation.RuntimeDefinedParameter('Currency',[String], $Attributes) $Bucket.Add('Currency', $Parameter) $Bucket &#125; begin &#123; foreach ($key in $PSBoundParameters.Keys) &#123; if ($MyInvocation.MyCommand.Parameters.$key.isDynamic) &#123; Set-Variable -Name $key -Value $PSBoundParameters.$key &#125; &#125; $url = 'http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml' $rates = Invoke-RestMethod -Uri $url $rate = $rates.Envelope.Cube.Cube.Cube | Where-Object &#123; $_.currency -eq $Currency&#125; | Select-Object -ExpandProperty Rate &#125; process &#123; $result = [Ordered]@&#123; Value = $Value Currency = $Currency Rate = $rate Euro = ($Value / $rate) Date = Get-Date &#125; New-Object -TypeName PSObject -Property $result &#125;&#125; 该函数演示了如何向动态参数填充动态数据，以及该数据如何缓存以免智能感知每次触发一个新的请求过程。 以下使一些您可能期待的例子（需要 Internet 连接）： PS C:\\&gt; 100, 66.9 | ConvertTo-Euro -Currency DKK Value : 100 Currency : DKK Rate : 7.4622 Euro : 13,4008737369677 Date : 26.01.2016 21:32:44 Value : 66,9 Currency : DKK Rate : 7.4622 Euro : 8,96518453003136 Date : 26.01.2016 21:32:45 PS C:\\&gt; ConvertTo-Euro -Currency USD -Value 99.78 Value : 99,78 Currency : USD Rate : 1.0837 Euro : 92,0734520623789 Date : 26.01.2016 21:33:01 本文国际来源：Converting Currencies","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 统计一个 Word 文档中的页数","slug":"counting-pages-in-a-word-document","date":"2016-02-08T04:00:00.000Z","updated":"2017-03-17T15:26:26.741Z","comments":true,"path":"2016/02/08/counting-pages-in-a-word-document/","link":"","permalink":"http://blog.vichamp.com/2016/02/08/counting-pages-in-a-word-document/","excerpt":"假设您有一系列 Word 文档，并且希望知道它们共有多少页。以下是一个函数，传入一个 Word 文件参数，便能得到它包含多少页： #requires -Version 1 # adjust path to point to an existing Word file: $Path = &quot;C:\\...\\SomeChapter.doc&quot; $word = New-Object -ComObject Word.Application $word.Visible = $true $binding = &apos;System.Reflection.BindingFlags&apos; -as [type] $doc = $word.Documents.Open($Path) $doc.Repaginate() $prop = $doc.BuiltInDocumentProperties(14) $pages = [System.__ComObject].invokemember(&apos;value&apos;,$binding::GetProperty,$null,$prop,$null) $doc.Close(0) $word.Quit() &quot;$Path has $Pages pages.&quot; 如果这对您有用，可以将它改为一个函数，您就可以用 PowerShell 来统计多个 Word 文档共有多少页。","text":"假设您有一系列 Word 文档，并且希望知道它们共有多少页。以下是一个函数，传入一个 Word 文件参数，便能得到它包含多少页： #requires -Version 1 # adjust path to point to an existing Word file: $Path = &quot;C:\\...\\SomeChapter.doc&quot; $word = New-Object -ComObject Word.Application $word.Visible = $true $binding = &apos;System.Reflection.BindingFlags&apos; -as [type] $doc = $word.Documents.Open($Path) $doc.Repaginate() $prop = $doc.BuiltInDocumentProperties(14) $pages = [System.__ComObject].invokemember(&apos;value&apos;,$binding::GetProperty,$null,$prop,$null) $doc.Close(0) $word.Quit() &quot;$Path has $Pages pages.&quot; 如果这对您有用，可以将它改为一个函数，您就可以用 PowerShell 来统计多个 Word 文档共有多少页。 本文国际来源：Counting Pages in a Word Document","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将窗口置于前台","slug":"bringing-window-in-the-foreground","date":"2016-02-05T04:00:00.000Z","updated":"2017-03-17T15:26:26.737Z","comments":true,"path":"2016/02/05/bringing-window-in-the-foreground/","link":"","permalink":"http://blog.vichamp.com/2016/02/05/bringing-window-in-the-foreground/","excerpt":"PowerShell 可以使用 Add-Type 来操作 Windows 内置的 API 功能。通过这种方法，可以很容易地将所有进程的窗口置于前台。以下是您需要的函数： #requires -Version 2 function Show-Process($Process, [Switch]$Maximize) { $sig = &apos; [DllImport(&quot;user32.dll&quot;)] public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow); [DllImport(&quot;user32.dll&quot;)] public static extern int SetForegroundWindow(IntPtr hwnd); &apos; if ($Maximize) { $Mode = 3 } else { $Mode = 4 } $type = Add-Type -MemberDefinition $sig -Name WindowAPI -PassThru $hwnd = $process.MainWindowHandle $null = $type::ShowWindowAsync($hwnd, $Mode) $null = $type::SetForegroundWindow($hwnd) } 要测试 Show-Process，以下是一段示例代码，演示如何使用它： # launch Notepad minimized, then make it visible $notepad = Start-Process notepad -WindowStyle Minimized -PassThru Start-Sleep -Seconds 2 Show-Process -Process $notepad # switch back to PowerShell, maximized Start-Sleep -Seconds 2 Show-Process -Process (Get-Process -Id $PID) -Maximize # switch back to Notepad, maximized Start-Sleep -Seconds 2 Show-Process -Process $notepad -Maximize # switch back to PowerShell, normal window Start-Sleep -Seconds 2 Show-Process -Process (Get-Process -Id $PID)","text":"PowerShell 可以使用 Add-Type 来操作 Windows 内置的 API 功能。通过这种方法，可以很容易地将所有进程的窗口置于前台。以下是您需要的函数： #requires -Version 2 function Show-Process($Process, [Switch]$Maximize) { $sig = &apos; [DllImport(&quot;user32.dll&quot;)] public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow); [DllImport(&quot;user32.dll&quot;)] public static extern int SetForegroundWindow(IntPtr hwnd); &apos; if ($Maximize) { $Mode = 3 } else { $Mode = 4 } $type = Add-Type -MemberDefinition $sig -Name WindowAPI -PassThru $hwnd = $process.MainWindowHandle $null = $type::ShowWindowAsync($hwnd, $Mode) $null = $type::SetForegroundWindow($hwnd) } 要测试 Show-Process，以下是一段示例代码，演示如何使用它： # launch Notepad minimized, then make it visible $notepad = Start-Process notepad -WindowStyle Minimized -PassThru Start-Sleep -Seconds 2 Show-Process -Process $notepad # switch back to PowerShell, maximized Start-Sleep -Seconds 2 Show-Process -Process (Get-Process -Id $PID) -Maximize # switch back to Notepad, maximized Start-Sleep -Seconds 2 Show-Process -Process $notepad -Maximize # switch back to PowerShell, normal window Start-Sleep -Seconds 2 Show-Process -Process (Get-Process -Id $PID) 本文国际来源：Bringing Window in the Foreground","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 处理数据（第 3 部分）","slug":"process-data-part-3","date":"2016-02-04T04:00:00.000Z","updated":"2017-03-17T15:26:26.734Z","comments":true,"path":"2016/02/04/process-data-part-3/","link":"","permalink":"http://blog.vichamp.com/2016/02/04/process-data-part-3/","excerpt":"在第 1 和 第 2 部分，您学到了如何 PowerShell 函数如何处理通过参数和通过管道传入的信息。在这部分中，我们打算介绍一个函数如何接收多行文本并将它加工成一个字符串。 这个函数同时接受参数和管道传入的多行文本。该函数使用 StringBuilder 对象来收集所有的文本行，然后将收到的所有文本行合并成单个字符串： #requires -Version 2 function Collect-Text { param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [String[]] [AllowEmptyString()] $Text ) begin { $sb = New-Object System.Text.StringBuilder } process { foreach ($line in $Text) { $null = $sb.AppendLine($line) } } end { $result = $sb.ToString() $result } } 请注意如何既支持通过参数，也支持通过管道传递文本行： PS C:\\&gt; Collect-Text -Text &apos;Line 1&apos;, &apos;&apos;, &apos;Line 2&apos; Line 1 Line 2 PS C:\\&gt; &apos;Line 1&apos;, &apos;&apos;, &apos;Line 2&apos; | Collect-Text Line 1 Line 2 请注意参数：它使用了 [AllowEmptyString()] 属性。它确保可以接受空字符串参数。在 mandatory （必须）参数中，如果没有这个属性，是不允许空字符串的。","text":"在第 1 和 第 2 部分，您学到了如何 PowerShell 函数如何处理通过参数和通过管道传入的信息。在这部分中，我们打算介绍一个函数如何接收多行文本并将它加工成一个字符串。 这个函数同时接受参数和管道传入的多行文本。该函数使用 StringBuilder 对象来收集所有的文本行，然后将收到的所有文本行合并成单个字符串： #requires -Version 2 function Collect-Text { param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [String[]] [AllowEmptyString()] $Text ) begin { $sb = New-Object System.Text.StringBuilder } process { foreach ($line in $Text) { $null = $sb.AppendLine($line) } } end { $result = $sb.ToString() $result } } 请注意如何既支持通过参数，也支持通过管道传递文本行： PS C:\\&gt; Collect-Text -Text &apos;Line 1&apos;, &apos;&apos;, &apos;Line 2&apos; Line 1 Line 2 PS C:\\&gt; &apos;Line 1&apos;, &apos;&apos;, &apos;Line 2&apos; | Collect-Text Line 1 Line 2 请注意参数：它使用了 [AllowEmptyString()] 属性。它确保可以接受空字符串参数。在 mandatory （必须）参数中，如果没有这个属性，是不允许空字符串的。 本文国际来源：Process Data (Part 3)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 处理数据（第 1 部分）","slug":"process-data-part-1","date":"2016-02-03T04:00:00.000Z","updated":"2017-03-17T15:26:26.721Z","comments":true,"path":"2016/02/03/process-data-part-1/","link":"","permalink":"http://blog.vichamp.com/2016/02/03/process-data-part-1/","excerpt":"这是关于 PowerShell 函数如何通过管道或参数接受数据的三个技巧中的第一个。 在第一部分中，函数实时处理输入的信息。这消耗最少的内存并且快速提供结果： 123456789101112131415#requires -Version 2function Process-Data&#123; param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [Object[]] $Object ) process &#123; foreach ($element in $Object) &#123; \"Processing received element $element...\" &#125; &#125;&#125; 请注意如何通过参数调用函数： 12345678PS C:\\&gt; Process-Data -Object 1Processing received element 1...PS C:\\&gt; Process-Data -Object 1,2,3,4Processing received element 1...Processing received element 2...Processing received element 3...Processing received element 4... 您也可以通过管道传送信息： 12345PS C:\\&gt; 1..4 | Process-DataProcessing received element 1...Processing received element 2...Processing received element 3...Processing received element 4...","text":"这是关于 PowerShell 函数如何通过管道或参数接受数据的三个技巧中的第一个。 在第一部分中，函数实时处理输入的信息。这消耗最少的内存并且快速提供结果： 123456789101112131415#requires -Version 2function Process-Data&#123; param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [Object[]] $Object ) process &#123; foreach ($element in $Object) &#123; \"Processing received element $element...\" &#125; &#125;&#125; 请注意如何通过参数调用函数： 12345678PS C:\\&gt; Process-Data -Object 1Processing received element 1...PS C:\\&gt; Process-Data -Object 1,2,3,4Processing received element 1...Processing received element 2...Processing received element 3...Processing received element 4... 您也可以通过管道传送信息： 12345PS C:\\&gt; 1..4 | Process-DataProcessing received element 1...Processing received element 2...Processing received element 3...Processing received element 4... 本文国际来源：Process Data (Part 1)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 处理数据（第 2 部分）","slug":"process-data-part-2","date":"2016-02-03T04:00:00.000Z","updated":"2017-03-17T15:26:26.727Z","comments":true,"path":"2016/02/03/process-data-part-2/","link":"","permalink":"http://blog.vichamp.com/2016/02/03/process-data-part-2/","excerpt":"在第 1 部分中我们演示了一个 PowerShell 函数如何同时从参数和管道获取输入，并且实时处理它。这是最有效的方法并节省内存开销。 然而，有时需要先收集所有数据，待所有数据收集完成以后，一次性处理所有数据。以下是一个收集所有收到的数据并等所有数据都到齐以后才开始处理的例子： #requires -Version 2 function Collect-Data { param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [Object] [AllowEmptyString()] $Object ) begin { $bucket = New-Object System.Collections.ArrayList } process { $null = $bucket.Add($Object) } end { $count = $bucket.Count Write-Host &quot;Received $count objects.&quot; -ForegroundColor Yellow $bucket | Out-String } } 请注意 Collect-Data 如何既从参数又从管道获取信息： PS C:\\&gt; Collect-Data -Object 1,2,3 Received 3 objects. 1 2 3 PS C:\\&gt; 1..3 | Collect-Data Received 3 objects. 1 2 3 有两件事值得一提：千万不要用一个纯数组来收集信息。而是使用一个 ArraryList 对象，因为它添加新的元素比较快。并且避免将 $input 用于类似用途的自动变量。$input 只能用于管道输入并且忽略提交到参数的值。","text":"在第 1 部分中我们演示了一个 PowerShell 函数如何同时从参数和管道获取输入，并且实时处理它。这是最有效的方法并节省内存开销。 然而，有时需要先收集所有数据，待所有数据收集完成以后，一次性处理所有数据。以下是一个收集所有收到的数据并等所有数据都到齐以后才开始处理的例子： #requires -Version 2 function Collect-Data { param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [Object] [AllowEmptyString()] $Object ) begin { $bucket = New-Object System.Collections.ArrayList } process { $null = $bucket.Add($Object) } end { $count = $bucket.Count Write-Host &quot;Received $count objects.&quot; -ForegroundColor Yellow $bucket | Out-String } } 请注意 Collect-Data 如何既从参数又从管道获取信息： PS C:\\&gt; Collect-Data -Object 1,2,3 Received 3 objects. 1 2 3 PS C:\\&gt; 1..3 | Collect-Data Received 3 objects. 1 2 3 有两件事值得一提：千万不要用一个纯数组来收集信息。而是使用一个 ArraryList 对象，因为它添加新的元素比较快。并且避免将 $input 用于类似用途的自动变量。$input 只能用于管道输入并且忽略提交到参数的值。 本文国际来源：Process Data (Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找当前文件系统路径","slug":"finding-current-file-system-path","date":"2016-01-11T04:00:00.000Z","updated":"2017-03-17T15:26:26.717Z","comments":true,"path":"2016/01/11/finding-current-file-system-path/","link":"","permalink":"http://blog.vichamp.com/2016/01/11/finding-current-file-system-path/","excerpt":"PowerShell 不仅支持文件系统，您可以将当前路径设置为别的 provider（用 Set-Location 命令）。以下是一个始终返回当前文件系统，无论当前激活的是那个 provider 的技巧： 1234567891011121314151617181920PS C:\\&gt; cd hkcu:\\PS HKCU:\\&gt; $ExecutionContext.SessionState.PathCurrentLocation CurrentFileSystemLocation--------------- -------------------------HKCU:\\ C:\\ ​ PS HKCU:\\&gt; $ExecutionContext.SessionState.Path.CurrentFileSystemLocationPath----C:\\ ​ PS HKCU:\\&gt; $ExecutionContext.SessionState.Path.CurrentFileSystemLocation.PathC:\\","text":"PowerShell 不仅支持文件系统，您可以将当前路径设置为别的 provider（用 Set-Location 命令）。以下是一个始终返回当前文件系统，无论当前激活的是那个 provider 的技巧： 1234567891011121314151617181920PS C:\\&gt; cd hkcu:\\PS HKCU:\\&gt; $ExecutionContext.SessionState.PathCurrentLocation CurrentFileSystemLocation--------------- -------------------------HKCU:\\ C:\\ ​ PS HKCU:\\&gt; $ExecutionContext.SessionState.Path.CurrentFileSystemLocationPath----C:\\ ​ PS HKCU:\\&gt; $ExecutionContext.SessionState.Path.CurrentFileSystemLocation.PathC:\\ 本文国际来源：Finding Current File System Path","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通过哈希表转换创建新的对象","slug":"creating-new-objects-by-hash-table-conversion","date":"2016-01-08T04:00:00.000Z","updated":"2017-03-17T15:26:26.709Z","comments":true,"path":"2016/01/08/creating-new-objects-by-hash-table-conversion/","link":"","permalink":"http://blog.vichamp.com/2016/01/08/creating-new-objects-by-hash-table-conversion/","excerpt":"从 PowerShell 3.0 开始，您可以通过哈希表创建预先初始化好的对象。只需要添加您希望预先初始化的属性，然后将哈希表转换为期望的类型。 以下是一个实际的例子： 12345678910#requires -Version 3$preInit = @&#123; Rate = -10 Volume = 100&#125;Add-Type -AssemblyName System.Speech$speaker = [System.Speech.Synthesis.SpeechSynthesizer] $preInit$null = $Speaker.SpeakAsync(“Oh boy, that was a New Year’s party. I guess I need a little break.”) 当您运行这段代码时，PowerShell 创建一个新的 System.Speech 对象并且预先初始化了 rate 和 volume 的值。当您用 SpeakAsync() 方法将文本输出到语音时，文本会被很慢地念出来。Rate 的取值在 -10 到 10 之间。","text":"从 PowerShell 3.0 开始，您可以通过哈希表创建预先初始化好的对象。只需要添加您希望预先初始化的属性，然后将哈希表转换为期望的类型。 以下是一个实际的例子： 12345678910#requires -Version 3$preInit = @&#123; Rate = -10 Volume = 100&#125;Add-Type -AssemblyName System.Speech$speaker = [System.Speech.Synthesis.SpeechSynthesizer] $preInit$null = $Speaker.SpeakAsync(“Oh boy, that was a New Year’s party. I guess I need a little break.”) 当您运行这段代码时，PowerShell 创建一个新的 System.Speech 对象并且预先初始化了 rate 和 volume 的值。当您用 SpeakAsync() 方法将文本输出到语音时，文本会被很慢地念出来。Rate 的取值在 -10 到 10 之间。 本文国际来源：Creating New Objects by Hash Table Conversion","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 DCOM 协议运行 Get-CimInstance","slug":"use-get-ciminstance-with-dcom","date":"2016-01-07T04:00:00.000Z","updated":"2017-03-17T15:26:26.701Z","comments":true,"path":"2016/01/07/use-get-ciminstance-with-dcom/","link":"","permalink":"http://blog.vichamp.com/2016/01/07/use-get-ciminstance-with-dcom/","excerpt":"PowerShell 3.0 增加了Get-WmiObject 的另一个选择：Get-CimInstance，它工作起来十分相似但可以从内部 的 WMI 服务中获取信息： 123456789101112131415PS C:\\&gt; Get-WmiObject -Class Win32_BIOSSMBIOSBIOSVersion : A03Manufacturer : Dell Inc.Name : A03SerialNumber : 5TQLM32Version : DELL - 1072009PS C:\\&gt; Get-CimInstance -Class Win32_BIOSSMBIOSBIOSVersion : A03Manufacturer : Dell Inc.Name : A03SerialNumber : 5TQLM32Version : DELL - 1072009 虽然 Get-WmiObject 仍然存在，但 Get-CimInstance 绝对是未来的选择。这个 Cmdlet 支持 WMI 类的智能提示（在 PowerShell ISE 中），并且返回的数据可读性更好：例如日期是以人类可读的日期格式返回，而 Get-WmiObject 显示 WMI 内部原始的日期格式。 最重要的区别是它们远程工作的方法。Get-WmiObject 使用的是旧的 DCOM 协议，而 Get-CimInstance 缺省使用的是新的 WSMan 协议，不过它是灵活的，可以根据需要退回 DCOM 协议。 以下示例函数通过 Get-CimInstance 远程获取 BIOS 信息。该函数缺省采用 DCOM，通过 -Protocol 参数您可以选择希望的通信协议： 1234567891011121314#requires -Version 3function Get-BIOS&#123; param ( $ComputerName = $env:COMPUTERNAME, [Microsoft.Management.Infrastructure.CimCmdlets.ProtocolType] $Protocol = 'DCOM' ) $option = New-CimSessionOption -Protocol $protocol $session = New-CimSession -ComputerName $ComputerName -SessionOption $option Get-CimInstance -CimSession $session -ClassName Win32_BIOS&#125;","text":"PowerShell 3.0 增加了Get-WmiObject 的另一个选择：Get-CimInstance，它工作起来十分相似但可以从内部 的 WMI 服务中获取信息： 123456789101112131415PS C:\\&gt; Get-WmiObject -Class Win32_BIOSSMBIOSBIOSVersion : A03Manufacturer : Dell Inc.Name : A03SerialNumber : 5TQLM32Version : DELL - 1072009PS C:\\&gt; Get-CimInstance -Class Win32_BIOSSMBIOSBIOSVersion : A03Manufacturer : Dell Inc.Name : A03SerialNumber : 5TQLM32Version : DELL - 1072009 虽然 Get-WmiObject 仍然存在，但 Get-CimInstance 绝对是未来的选择。这个 Cmdlet 支持 WMI 类的智能提示（在 PowerShell ISE 中），并且返回的数据可读性更好：例如日期是以人类可读的日期格式返回，而 Get-WmiObject 显示 WMI 内部原始的日期格式。 最重要的区别是它们远程工作的方法。Get-WmiObject 使用的是旧的 DCOM 协议，而 Get-CimInstance 缺省使用的是新的 WSMan 协议，不过它是灵活的，可以根据需要退回 DCOM 协议。 以下示例函数通过 Get-CimInstance 远程获取 BIOS 信息。该函数缺省采用 DCOM，通过 -Protocol 参数您可以选择希望的通信协议： 1234567891011121314#requires -Version 3function Get-BIOS&#123; param ( $ComputerName = $env:COMPUTERNAME, [Microsoft.Management.Infrastructure.CimCmdlets.ProtocolType] $Protocol = 'DCOM' ) $option = New-CimSessionOption -Protocol $protocol $session = New-CimSession -ComputerName $ComputerName -SessionOption $option Get-CimInstance -CimSession $session -ClassName Win32_BIOS&#125; 本文国际来源：Use Get-CimInstance with DCOM","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 理解 PowerShell 的流","slug":"understanding-powershell-streams","date":"2016-01-06T04:00:00.000Z","updated":"2017-03-17T15:26:26.694Z","comments":true,"path":"2016/01/06/understanding-powershell-streams/","link":"","permalink":"http://blog.vichamp.com/2016/01/06/understanding-powershell-streams/","excerpt":"PowerShell 提供七种不同的流，可以用来输出信息。流可以帮助筛选信息，因为流可以不输出。实际上一些流默认是不输出的。以下是一个名为 Test-Stream 的示例函数。它运行后会将信息发送给所有七种流。 请注意：Write-Information 是 PowerShell 5.0 新加入的。如果您想在早期的 PowerShell 版本中运行，请移除调用 Write-Information 的语句！ 1234567891011121314151617function Test-Stream&#123; #region These are all the same and define return values 'Return Value 1' echo 'Return Value 2' 'Return Value 3' | Write-Output #endregion Write-Verbose 'Additional Information' Write-Debug 'Developer Information' Write-Host 'Mandatory User Information' Write-Warning 'Warning Information' Write-Error 'Error Information' # new in PowerShell 5.0 Write-Information 'Auxiliary Information' &#125; 这应该是您运行 Test-Stream 能看到的结果： 1234567891011121314151617181920212223242526272829PS C:\\&gt; Test-StreamReturn Value 1Return Value 2Return Value 3Mandatory User InformationWARNING: Warning InformationTest-Stream : Error InformationAt line:1 char:1+ Test-Stream+ ~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Write-Error], WriteErrorException + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Test-Stream PS C:\\&gt; $result = Test-StreamMandatory User InformationWARNING: Warning InformationTest-Stream : Error InformationAt line:1 char:1+ Test-Stream+ ~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Write-Error], WriteErrorException + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Test-Stream PS C:\\&gt; $resultReturn Value 1Return Value 2Return Value 3 PS C:\\&gt; 如您所见，echo 和 Write-Output 工作起来效果相同，而且实际上它们确实是相同的（因为echo 是 Write-Output 的别名）。它们定义了一个或多个返回值。它们可以赋值给一个变量。同理，这个规则适用于函数留下的未赋值的变量：它们也被送到 Write-Output 流中。 Write-Host 直接将输出送到控制台，所以它一定可见。这个 Cmdlet 只能用于向用户传递信息的场景。 其他的流是静默的。要查看其它流的输出，您首先需要打开它们： 123$VerbosePreference = 'Continue'$DebugPreference = 'Continue'$InformationPreference = 'Continue' 当打开之后，Test-Stream 将输出这样的信息： 12345678PS C:\\&gt; Test-StreamReturn Value 1Return Value 2Return Value 3VERBOSE: Additional InformationDEBUG: Developer InformationMandatory User InformationAuxiliary Information 要恢复缺省值，请复位 preference 变量： 123$VerbosePreference = 'SilentlyContinue'$DebugPreference = 'SilentlyContinue'$InformationPreference = 'SilentlyContinue' 如果在函数中加入了通用参数，您就可以在调用函数时使用使用 -Verbose 和 -Debug 开关。Test-CommonParameter 演示了如何添加通用参数支持。 12345678function Test-CommonParameter&#123; [CmdletBinding()] param() \"VerbosePreference = $VerbosePreference\" \"DebugPreference = $DebugPreference\"&#125; 当运行 Test-CommonParameter 时，您将立即明白 -Verbose 和 Debug 通用参数是如何工作的：它们只是改变了本地 preference 变量： 1234567PS C:\\&gt; Test-CommonParameterVerbosePreference = SilentlyContinueDebugPreference = SilentlyContinuePS C:\\&gt; Test-CommonParameters -Debug -VerboseVerbosePreference = ContinueDebugPreference = Inquire","text":"PowerShell 提供七种不同的流，可以用来输出信息。流可以帮助筛选信息，因为流可以不输出。实际上一些流默认是不输出的。以下是一个名为 Test-Stream 的示例函数。它运行后会将信息发送给所有七种流。 请注意：Write-Information 是 PowerShell 5.0 新加入的。如果您想在早期的 PowerShell 版本中运行，请移除调用 Write-Information 的语句！ 1234567891011121314151617function Test-Stream&#123; #region These are all the same and define return values 'Return Value 1' echo 'Return Value 2' 'Return Value 3' | Write-Output #endregion Write-Verbose 'Additional Information' Write-Debug 'Developer Information' Write-Host 'Mandatory User Information' Write-Warning 'Warning Information' Write-Error 'Error Information' # new in PowerShell 5.0 Write-Information 'Auxiliary Information' &#125; 这应该是您运行 Test-Stream 能看到的结果： 1234567891011121314151617181920212223242526272829PS C:\\&gt; Test-StreamReturn Value 1Return Value 2Return Value 3Mandatory User InformationWARNING: Warning InformationTest-Stream : Error InformationAt line:1 char:1+ Test-Stream+ ~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Write-Error], WriteErrorException + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Test-Stream PS C:\\&gt; $result = Test-StreamMandatory User InformationWARNING: Warning InformationTest-Stream : Error InformationAt line:1 char:1+ Test-Stream+ ~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Write-Error], WriteErrorException + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Test-Stream PS C:\\&gt; $resultReturn Value 1Return Value 2Return Value 3 PS C:\\&gt; 如您所见，echo 和 Write-Output 工作起来效果相同，而且实际上它们确实是相同的（因为echo 是 Write-Output 的别名）。它们定义了一个或多个返回值。它们可以赋值给一个变量。同理，这个规则适用于函数留下的未赋值的变量：它们也被送到 Write-Output 流中。 Write-Host 直接将输出送到控制台，所以它一定可见。这个 Cmdlet 只能用于向用户传递信息的场景。 其他的流是静默的。要查看其它流的输出，您首先需要打开它们： 123$VerbosePreference = 'Continue'$DebugPreference = 'Continue'$InformationPreference = 'Continue' 当打开之后，Test-Stream 将输出这样的信息： 12345678PS C:\\&gt; Test-StreamReturn Value 1Return Value 2Return Value 3VERBOSE: Additional InformationDEBUG: Developer InformationMandatory User InformationAuxiliary Information 要恢复缺省值，请复位 preference 变量： 123$VerbosePreference = 'SilentlyContinue'$DebugPreference = 'SilentlyContinue'$InformationPreference = 'SilentlyContinue' 如果在函数中加入了通用参数，您就可以在调用函数时使用使用 -Verbose 和 -Debug 开关。Test-CommonParameter 演示了如何添加通用参数支持。 12345678function Test-CommonParameter&#123; [CmdletBinding()] param() \"VerbosePreference = $VerbosePreference\" \"DebugPreference = $DebugPreference\"&#125; 当运行 Test-CommonParameter 时，您将立即明白 -Verbose 和 Debug 通用参数是如何工作的：它们只是改变了本地 preference 变量： 1234567PS C:\\&gt; Test-CommonParameterVerbosePreference = SilentlyContinueDebugPreference = SilentlyContinuePS C:\\&gt; Test-CommonParameters -Debug -VerboseVerbosePreference = ContinueDebugPreference = Inquire 本文国际来源：Understanding PowerShell Streams","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 WPF 窗口加载 Base64 编码的图片","slug":"loading-a-base64-encoded-picture-into-wpf-window","date":"2016-01-05T04:00:00.000Z","updated":"2017-03-17T15:26:26.685Z","comments":true,"path":"2016/01/05/loading-a-base64-encoded-picture-into-wpf-window/","link":"","permalink":"http://blog.vichamp.com/2016/01/05/loading-a-base64-encoded-picture-into-wpf-window/","excerpt":"在前一个技能中我们演示了如何将任何图片转换为 Base64 编码的字符串。今天，我们将演示如何加载 Base64 编码的图片并显示它。 这个窗口显示官方会议 logo 并且不需要独立的图片文件。该图像已经嵌入到脚本中并且直接从内存中加载。 在脚本头部的嵌入图片十分大。最重要的部分是在 Base64 编码字符串之后的 Convert-Base64Bitmap2Picture 函数。它接受 Base64 编码的文本并且返回一个 bitmap 对象。这个对象可以设为任何 WPF image 控件的源。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281Add-Type -AssemblyName PresentationFramework$picture1 ='/9j/4AAQSkZJRgABAAEBLAEsAAD/4QB2RXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAZKGAAcAAABAAAAALAAAAABVTklDT0RFAABMAEUAQQBEACAAVABlAGMAaABuAG8AbABvAGcAaQBlAHMAIABJAG4AYwAuACAAVgAxAC4AMAAxAAD/2wBDAAUFBQgFCAwHBwwMCQkJDA0MDAwMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ3/2wBDAQUICAoHCgwHBwwNDAoMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ3/wAARCADIAMgDAREAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD7LoAKACgAoAKACgAoArXd5Bp8ZnupEgiXq8jBFH4sQKuMJVHywTk+yV3+BE5xpLmqNRiuraS/E8w1n4w6PppKWgkvpB/cGyPP++43fiqMPevbpZVWqa1LU156y+5fq0eDWzehT0pKVR+Wkfvf6JnmWpfGjV7okWiQ2i9iF8xx/wACfKH/AL9ivZp5VQh/Ecpv15V9y1/E8Opm+IlpTUIL05n970/A4m78c67e/wCtvrgeySGIflHsH6V6McJh6fw0ofNc3/pVzzJ4zEz+KrP5PlX/AJLYwp9Tu7n/AF00sn++7N/MmupQhH4YxXpFL8kcjnOXxSk/WTf5spZ71oZl2DU7u1/1E0sWP7jsv8iKzcIS+KMX6xT/ADRopzj8MpL0k1+TN208c67Y/wCqvrjjoHkMg/KTeP0rllhMPP4qUPkuX/0mx1wxmJp/DVn83zL7pXO10340axakC7SG7UdSV8tz/wACTCD/AL9mvOqZVQl/DcoP15l9z1/E9Onm+Ih/EUJr05X960/A9N0b4w6PqBCXYksZD3cb48/76Dd+LIo968arlVanrTaqLy0l9z/Rs9ujm9CppVUqb89Y/ev1SPULS9gv4xPayJNE3R42DKfxUkV4koSpvlmnFro1Z/ie9Ccai5qclKPdNNfgWag0CgAoAKACgAoAKACgAoAKACgAoAgubmKyiae4dYooxlnchVUepJwBVRi5tRgm29kldsiUo005zajFbtuyR4d4p+MsVuWt9DQSsODcSAhB/wBc4+C3sz4Gf4GFfT4fKm7TxTsv5I7/ADey9Fd+aPlcTm6jeGEV/wC/Lb/t2O79XZeTPB9V1y+1yXzr+aSd+248LnsqjCqPZQB7V9PTpU6C5aMVFeW79Xu/mz5SrWqV3zVpOT83ovRbL5Iya2MAoAKACgAoAKACgAoAKANXStcvtDl86wmkgfvtPB9mU5Vh7MCPasalKFZctWKkvNbej3XyZvSq1KD56MnB+T0fqtn80e8eFvjNHMVt9cQRMeBcRA7PrJHyV92TIz/Ao5r5jEZU1eeFd/7kt/k9n6O3qz6vDZunaGLVv78Vp/29HdequvJHuVtdRXsSz27rLFIMq6EMrD1BGQa+YlFwbhNNNbpqzR9VGUZpTg04vZp3TJ6ksKACgAoAKACgAoAKACgDlvFPi+x8JQebdtulcHyoVI3yEe38KA/ec8DoMthT3YbC1MXLlpq0V8Unsv8AN9ktfzPPxWLp4OPNUd5P4YreX+S7t6fPQ+UfFXjXUPFcu66fZApPlwISI09CR/E2Ortk9cbVO0fdYfC08IrU173WT+J/5LyXzufAYnF1cXK9R2itoL4V/m/N/KxyFdx54UAFABQAUAFABQAUAFABQAUAFABQB13hbxpqHhOXdavvgYjzIHJMbjvgfwtjo64PTOV+U8OIwtPFK1RWktpL4l/mvJ/Kx34bF1cHK9J+71g/hf8Ak/NfO59XeFfGFj4sg820bbKgHmwMRvjJ/wDQkJ6OOD0IVsqPhcThamElyzV4v4ZLZ/5Punr8tT9AwuLp4yPNTdpL4oveP+a7NafPQ6quE9AKACgAoAKACgAoA4Xxx44t/B9v2lvJQfJhz+HmSY5CA9OhcjauAGZfUweDli5fy018Uv0Xm/w3fZ+TjcbHBR01qP4Y/wDt0u0V+Oy6tfImq6tda1cveXshlmkOST2HZVHRVHQKAABwBX3tOnCjFU6S5YrZfq+7fVn53UqTrTdWq3KT3f6Lsl0SM6tTIKACgAoAKACgAoAKACgAoAKACgAoAKACgDR0rVbrRblLyykaGaM5DD9QR0KnoVIII4IIrKpTjVi6dRJxe6/Vdn2ZrTqToTVSk3GS2a/J90+qe59deBvHNv4ut8HEV7EB50OevbzI88lCeo5KE7WyCrN8FjMHLBy01pv4Zfo+z/PddUv0TBY2OMjb4asfij/7dHun+D0fRvu68s9YKACgAoAKAOW8X+KYPCVi13LhpWysMWcGSTH5hF6u3YcD5mUHuwuGli6ipx0itZS/lX+b2S7+Vzz8Xio4Om6ktZPSMe7/AMlu30XnY+M9W1W51q6kvbxzJNKcknoPQAdlUYCgcAAAV+h06caMFSpq0Vsv1fdvds/NalSdabq1XeUnq/0XZLZIzq1MgoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA0dK1S40W5jvbNzHNC2VI/UEdCrDIYHggkHg1lUpxqxdKorxejX6rs10ZrTqSozVWk7Si7p/o+6ezXU+y/B/iqDxZYrdxYSVcLPFnmN8du5RuqN3GQfmVgPzzFYaWEqOm9YvWMu6/zWzX6WP0rCYqOMpqpHSS0lH+V/5PdPt53OqrhPQCgAoAhubmKyie4nYRxRKzux6KqjJJ+gFVGLm1CCu20kvNkykoRc5u0Um2+yW58W+NfFUvivUHumysCZSCM/wRg8Ejpvb7znnk4B2quP0bC4dYSmqa+J6yfeX+S2X39T8yxeJljKrqPSK0gu0f8AN7v7uhyNdx553PgnwvD4pN1BK7QyQxI8TryFYsQdy/xKR1GQR1B7HzsVXlhuSUUmm2mvK3R9GelhcPHE88ZNppJp9nfquqMTXvDV94bl8q9TCMfklXmKT/dbsfVGww9Mc10Ua8K6vTevVPdeq/VaHPWoTw7tNadGtn/XZ6mDXScoUAFABQB3XgnwtB4p+1wyu0MkMcbRSLyFZmYHcv8AEpAGRkEdQfXzsVXlhuSUUmm2mvK3R9GelhcPHEc8ZNppJp9nd7rqjD17w1feG5fLvUwjHCSrzFJ/ut2PqjYYemOa6KNeFdXpvXqno18v1Whz1qE8O7TWnRrZ/wBdnqYNdJyhQAUAFABQAUAFABQAUAFAHW+C/FMvhPUEuky0L/JPGP44yecDpuX7yHjkYJ2lgeHFYdYqm6b0ktYvtL/J7P7+h34TEywdVVV8O013j/mt193U+0rW5ivYUuIGDxSqrow6MrDII+oNfnMouDcJKzTaa7Nbn6bGSnFTg7xaTTXVPYnqSwoA8H+M3ikwRpodu2GlAluCOyA/u4/+BEb2HBAVOzGvqcqw928VNbe7D16v5LRebfY+SzfE8qWEg9X70/T7Mfm9X5Jdz5xr60+NCgD2D4P/APH1ef8AXGL/ANGGvDzH4af+J/ke9lvxVPRfme23VrDexNb3KLLE4wyOAVP4evoRgjqCDXz0ZODUoNprZrRn0EoqScZJNPdM8P8AFHwwltN11ou6aIcm3Y5lT/rmx/1i/wCyfnHbfX0NDHKVoV9H/N0fqunrt6Hz2IwDjeeH1X8vVenf039TyNlKEqwKlTggjBBHUEHkEdwa9vzR4e2jEpiCgD2H4P8A/Hxe/wDXKL/0Nq8LMfhp+r/JHvZb8VT0j+bPbbq1hvYmt7lFlicYZHAKn8D39CMEdQQa+fjJwalBtNbNaNH0EoqScZJNPdPY8P8AFHwwltd11ou6aLq1sxzIv/XNj/rB/sn5x2L19DQxylaFfR/zdH6rp67eh89iMA43nh9V/L1Xp39N/U8iZShKsCrKcEEYII6gg8gjuDXt+aPDtbR6WEpiCgAoAKACgAoAKACgAoA+jPgz4pMsb6FcN80YMtuT/dJzJGPoT5ijkkGQ9FFfJZrh7NYqC392fr9l/NaP0Xc+yyfE3Twk3teUPT7Ufk9V6vse9V8sfWla8u49PgkupztigRpHPoqAsf0FXCLnJQju2kvV6ETmqcXUlpGKbfoldnwvrmqy65fTX83355C2Ou0dFUeyKAo9gK/TaVNUKcaMNoq3q+r+buz8qrVXXqSrT3k2/RdF8lZGVWxgFAHsHwf/AOPq8/64xf8Aow14eY/DT/xP8j3st+Kp6L8z3WvnD6IKAON8T+CbHxKDIw+z3ePlnQcn0Eq8CQe/Djs3au+hip4fRaw/lf6Pp+XkcNfCwxGr92fSS/Vdfz8z5617w1feG5fKvUwjH93KvMUn+63Y+qNhh6Y5r6ejXhXV6b16p7r1X6rQ+XrUJ4d2mtOjWz/rs9TBrpOU6Twz4nufC1w09uqyJKAssb8B1ByMMOUYEnBGR6giuSvQjiI8srprVNdH6dUddCvLDS5opNPRp9fn0Po3w94qsfEse60bbMoy8D4Eiepx0df9tcj12nivlq2Hnh3aa06SWz/yfkz6ujXhiFeD1W8Xuv8ANeaOkrkOo47xP4JsfEoMjD7Pd4+WdAMn0Eq8CQe5w47N2rvoYqeH0WsP5X+j6fl5HDXwsMRq/dn0kv1XX8/M+ede8NX3huXy7xMIxwkq8xSf7rdj6o2GHpjmvp6NeFdXpvXqno18v1Wh8vWoTw7tNadGtn/XZ6mDXScoUAFABQAUAFABQAUAamiarLod9DfwcPbyBwOmR/Ep9mUlW9iaxq01WhKlLaSt6dn8nZm1Kq6FSNaG8Gn69181dfM+6bK8j1C3juoDuinRZEPqrgMPxweR2NfmU4unJwlo4tp+q0P1WE1UjGpD4ZJNejVzy/4w6ydO0cWaHEl9IE9D5ceHcj/gXlqfUMa9vKqXPX9o9qav/wBvPRfq/keFm9b2dD2S3qSt/wBurWX6L5nylX3B8CFABQB7B8H/APj6vP8ArjF/6MNeHmPw0/8AE/yPey34qnovzPda+cPojitS8b2mi6qdLvwYozHG6TjlQXBysi9VHHDjIH8QA5r0IYWdWl7anq7tOOz07f5fccE8VClV9jU0Vk1Lpr37ev3nZRusqiSMh0cZVlIKkHoQRwQfUVwNW0ejXQ7k7q626NEV1aw3sTW9yiyxOMMjgFT+Hr6EYI6gg04ycGpQbTWzWjFKKknGSTT3TPD/ABR8MJbTddaLumiHJt2OZU/65sf9Yo/un94O2+voaGOUrQr6P+bo/VdPXb0PnsRgHG88Pqv5eq9O/pv6nkbKUJVgVKnBBGCCOoIPII7g17fmjw9tGSQTyWsizQM0UkZyroSrKfUEcik0pJxkk0909hxk4NSi2mtmtLHtXhf4oK+211vCNwFulHyn/rsg+6fV0G3+8o614FfAWvPD7fydf+3X+j+8+gw+PTtDEaP+Zbf9vLp6r7j2OORZVEkZDo4yrKQVYHoQRwR7ivCacXZ6Nbrax7qaautuliO6tYb2Jre5RZYnGGRwCp/A9/QjBHUEGnGTg1KDaa2a0YpRUk4ySae6ex4f4o+GEtruutFzNEOWtmOZF/65sf8AWD/ZPzjsXr6GhjlK0K+j/m6P1XT129D57EYBxvPD6r+XqvTv6b+p5EylCVYFWU4IIwQR1BB5BHcGvb80eHa2j0sJTEFABQAUAFABQAUAfVnwc1k6ho7WbnMljIVHr5cmXTP/AALzFHoFFfEZrS9nWVRbVFf/ALeWj/R/M+9yit7Sg6T3pyt/269V+q+R5p8aNSNzrCWgPy2kKgj0eT52P4oY/wAq9jKqfJQdTrOT+6Oi/G54mcVOauqa2hBffLV/hY8er3z50KACgD2D4P8A/H1ef9cYv/Rhrw8x+Gn/AIn+R72W/FU9F+Z7rXzh9EfN/wAUv+Q4f+veH+TV9VgP4P8A29I+Ux/8b/t2Ji+GvGN94ZbbCfNtictbuTs9yh6xt7rwf4lauivhoYhXlpLpJb/PuvX5MwoYmeH0WsesXt8uz/pn0P4e8VWPiWPdaNtlUZeB8CRPU46Ov+2uR64PFfMVsPPDu01p0ktn/k/Jn1FGvDEK8Hr1i91/mvNHR1yHUcb4n8E2PiUGRh9nu8fLOg5PoJV4Eg9+HHZu1d9DFTw+i96H8r/R9Py8jhr4WGI1fuz6SX6rr+fmfPWveGr7w3L5V6mEY/JKvMUn+63Y+qNhh6Y5r6ejXhXV6b16p6Neq/VaHy9ahPDu01p0a2f9dnqYNdJynV+GvGN94ZbbAfNtictbuTsPqUPWNvdeD/ErVxV8NDEL3tJdJLf5916/I7qGJnh9I6x6xe3y7P8Apn0N4e8VWPiWPdaNtmUZeB8CRPU46Ov+2uR67TxXzFbDzw7tNadJLZ/5PyZ9RRrwxCvB2a3i91/mvNHSVyHUcd4n8E2PiQGRh9nu8fLOg5PoJV4Eg9zhx2btXfQxU8PotYfyv9H0/LyOGvhYYjV+7PpJfquv5+Z88694avvDcvl3iYRjhJV5ik/3W7H1RsMPTHNfT0a8K6vTevVPRr5fqtD5etQnh3aa06NbP+uz1MGuk5QoAKACgAoAKAPX/gxqX2TWHtCcLdwsAPV4/wB4p/BBIPxrwc1p81BVFvCS+6Wj/Gx9DlFTkxDp9Jxf3x1X4XOL8c3n23Xb6X0uJEH0iPlj9EFehhI8mHpR/uJ/+Be9+p5uMlz4mrL++18o+7+hyldxwBQAUAewfB//AI+rz/rjF/6MNeHmPw0/8T/I97Lfiqei/M91r5w+iPm/4pf8hw/9e8P8mr6rAfwf+3pHymP/AI3/AG7E86r1TyiWCeS1kWaBmikjOVdCVZT6gjkf5zUtKScZJNPdPYqMnBqUW01s1pY9r8L/ABQWTba63hG4C3SjCn/rsg+6fV0G3+8o614FfANXnh9v5Ov/AG6+vo/vPoMPj07QxGj/AJlt/wBvLp6r7j2KN1lUSRkOjjKspBUg9CCOCD6ivCato9Guh7qd1dbdGiK6tYb2Jre5RZYnGGRwCp/A9/QjBHUEGnGTg1KDaa2a0YpRUk4ySae6ex4f4o+GEtpuutF3TRDk27HMqf8AXNj/AKxR/dP7wdt9fQ0McpWhX0f83R+vb129D56vgHG88Pqv5eq9O/pv6nkbKUJVgVKnBBGCCOoIPII7g17fmjw9tGSQTyWsizQM0UkZyroSrKfUEcik0pJxkk0909hxbg1KLaa2a0se1eF/igr7bXW8I3AW6UfKf+uyD7p9XQbf7yjrXgV8Ba88Pqv5Ov8A26/0f3n0GHx6doYjR/zLb/t5dPVfcexxyLKokjIdHGVZSCrA9CCOCPcV4TTi7PRrddj3U01dbdLEd1aw3sTW9yiyxOMMjgFT+B7+hGCOoINOMnBqUG01s1oxSipJxkk0909jw/xR8MJbXddaLumi6tbMcyL/ANc2P+sH+yfnHYvX0NDHKVoV9H/N0fqunrt6Hz2IwDjeeH1X8vVenf039TyJlKEqwKspwQRggjqCDyCO4Ne35o8O1tHpYSmIKACgAoA6rwPd/YddsZRx/pEaH6SMI2/8dY1xYuPPh6sf7jf/AID736Hdg5ezxFKX99L5S939TD1Of7TdzTf89JXf/vpif610wXLCMe0Yr7kkcs3zTlLvKT+9tlGtDMKACgD2D4P/APH1ef8AXGL/ANGGvDzH4af+J/ke9lvxVPRfme6184fRHzf8Uv8AkOH/AK94f5NX1WA/g/8Ab0j5TH/xv+3YnnVeqeUFABQB1fhrxjfeGW2wnzbYnLW7k7Pcoesbe68H+JWrir4aFdXekuklv8+69fkzuoYmeH0jrHrF7fLs/wCmfQ/h7xVY+JY91o22VRl4HwJE9Tjo6/7a5Hrg8V8xWw88O7TWnSS2f+T8mfUUa8MQrweq3i91/mvNHR1yHUcb4n8E2PiUGRh9nu8fLOg5PoJV4Eg9+HHZu1d9DFTw+i96H8r/AEfT8vI4a+FhiNX7s/5l+q6/n5nz1r3hq+8Ny+VephGPySrzFJ/ut2PqjYYemOa+no14V1em9eqe69V+q0Pl61CeHdprTo1s/wCuz1MGuk5Tq/DXjG+8MttgPm2xOWt3J2H1KHrG3uvB/iVq4q+GhiF72kuklv8APuvX5HdQxM8PpHWPWL2+XZ/0z6G8PeKrHxLHutG2zKMvA+BInqcdHX/bXI9dp4r5ith54d2mtOkls/8AJ+TPqKNeGIV4PVbxe6/zXmjpK5DqOO8T+CbHxKDIw+z3ePlnQDJ9BKvAkHucOOzdq76GKnh9FrD+V/o+n5eRw18LCvq/dn0kv1XX8/M+ede8NX3huXy7xMIxwkq8xSf7rdj6o2GHpjmvp6NeFdXpvXqno18v1Wh8vWoTw7tNadGtn/XZ6mDXScoUAFAFzT5/stzFMP8AllIj/wDfLA/0qJrmjKPeLX3pouD5ZRl2kn9zTKh96sgSgAoAKAPYPg//AMfV5/1xi/8ARhrw8x+Gn/if5HvZb8VT0X5nutfOH0R83/FL/kOH/r3h/k1fVYD+D/29I+Ux/wDG/wC3YnnVeqeUFABQAUAdB4b0TUtYul/ssMjxEEzglFh92kHQ/wCyMs3TaRXLXq06UX7a1n9ndy+X67HXQpVKsl7G6a+1so/P9Nz6p0+Ge3t447uUXE6qA8oQRhz67RwPT36kAnFfHTcXJuC5Y9Fe9vmfZQUoxSm+aS3drX+RcrMs5fxTrml6RatHqu2ZZRxbYDvL9FP3R/00JUL2OeK7MPSq1ZJ0bq32tkvn+nU5K9WlSjatZ3+zu38unqfLV1JFLM728ZgiZiUjLlyinou8gFsepFfYRTSSk7u2rta7726Hxsmm24Llj0V72+ZXqyDovDWhalrNyp0sNG0TAm4yUSE+pcc59EXLN6Yrkr1adGNq1mn9ndv5fq9DroUalWSdG6t9rZR+f6LU+qLCGe3t0iupftMyqA8uwR7z67RwP69Tya+Om4uTcFyxvor3t8z7KCcYpTfNJLV2tf5FuoLOV8Va/pej2zRaoFn81eLXAZ5PQ7Twi/8ATRsY/hJPFdmHo1ask6N42+3sl8+vovmceIrUqUbVrO/2N2/l09fuPlu6kjlld4E8mJmJSPcX2Kei7zgtj1NfYxTSSk7u2rta7726Hx0mm24rlXRXvbyuQVRAUAFAF3UoPst3ND/zzldP++WI/pWcHzQjLvGL+9Jmk1yTlHtKS+5tFKtDMKACgD2D4P8A/H1ef9cYv/Rhrw8x+Gn/AIn+R72W/FU9F+Z7rXzh9EfN/wAUv+Q4f+veH+TV9VgP4P8A29I+Ux/8b/t2J51XqnlBQAAEkAcknAA5JJ6ADuT6UB5I9Z8LfDGa923WsbreHgrAOJnH+2f+WSn0/wBYfReteJXxyheFC0pfzfZXp3f4ep7mHwDladf3Y/y/afr2X4+h7nZ2cGnQrbWsawwp91EGAPf3J7sck9ya+elKU25TbbfVn0MYxppRgkkuiJ2YIpZiFVQSSSAAB1JJ4AHcnip8kXtq9EeQeKPifHb7rXRMSychrlhmNf8Arkp++f8Abb5PQN1r26GAbtOvov5er9X09Fr6Hh4jHqN4YfV/zdF6Lr6vT1PEbm5lvJWnuHaWVzlnclmJ9yf0HQdAMV9DGKglGCSS2S0R87KTm3KTbb3bIgCxCqCSTgADJJPQADkk9gKe2ot9Eet+FvhhLdbbrWd0EXVbcHErj/pof+WSn+6P3h77K8SvjlC8MPq/5ui9O/rt6nt4fAOVp19F/L1fr29N/Q9xtLSGwiW3tkWGKMYVEGFH4dye5OSepJr5+UnNuUm23u2fRRioJRgkktkiZ3WJS7kIiDLMxAVQOpJOAB7mpSvot+iG9NXol8jx3xR8UEh3WuiYduQ10w+Uf9cUP3j6Ow2/3VbrXuUMA3aeI0X8i3/7efT0WvmeHiMeo3hh9X/N0Xouvq9PI8TuLiW6kaad2llkOWdyWZj6knn/AA7V9AoqKUYpJLZLRI+elJyblJtt7tkVUSFABQBc0+D7VcxQD/lpIif99MB/Wom+WMpdot/cmy4LmlGPeSX3tI3/ABzZ/Yddvoun+kSOB7SnzB+jiuTCS58PSl/cS/8AAfd/Q7MZD2eJqx/vt/KXvfqcpXccAUAFAHsHwf8A+Pq8/wCuMX/ow14eY/DT/wAT/I97Lfiqei/M91r5w+iPm/4pf8hw/wDXvD/Jq+qwH8H/ALekfKY/+N/27E86r1Tyjb0Lw7feIpvJsY9wX78jfLHGPV29fRRlj2Fc9WtDDrmqO3ZLd+i/XY6aNCdd8tNer6L1f6bn0L4X8DWPhsCY/wCk3mOZnHCnuIk5CD/a5c+oHFfMV8VOv7vww/lXX/E+vpsfUUMLDD6/FP8AmfT0XT13O1rzzvOf1/xNY+GovMvH/eMMpCmDK/0X+FfV2wo9SeK6qNCdd2prTrJ7L/g+S1OatXhh1eb16RW7+X6vQ+efE3jS+8SsY5D5FqD8tuhO0+hkbgyN9cKP4VFfT0MLDD6rWf8AM/0XRfj5ny9fFTr6P3YdIr9e/wCXkchXccBu6D4bvvEcvlWSZVT88rfLFH/vN6+irlj2HeuarXhh1eo9eiW79F+ux00aE67tTWnVvZer/Tc+hfDHgix8NASqPtF3jmdx931ES8iMe/Lnu3avmK+KnX934Yfyr9X1/LyPqKGFhh9VrP8Amf6Lp+fmdnXAd5zviHxTY+Go912+ZWGUgTBlf3x0Vf8AbbA9MniuqjQnXdoLRbyey/zfkjlrV4YdXm9ekVu/8l5s+ePEvjK+8StslPk2oOVt0J2+xc8GRvduB/Cor6ihhoYfWOsusnv8uy/ps+Xr4qeI0ekOkVt8+7/pHJ12nCFABQAUAFAHVeB7P7brtjEP+fiNyPaNhI3/AI6prixcuTD1Zf3Gv/Avd/U7sHDnxFKP9+L+Ufef5HbfGjTTaawl2BhbuFST6vH8jD8EEf515uVVOag6fWEn90tV+Nz1M3p8mIVRbTgvvjo/wseP17586FABQB7B8H/+Pq8/64xf+jDXh5j8NP8AxP8AI97Lfiqei/M91r5w+iPnD4ognXCByTBAAB1JIbAA7k+lfVYD+B/29I+Vx/8AHsv5Ymn4W+GM17tutY3W8PBWAcTOP9s/8slPp/rD6L1rKvjlC8KFnL+b7K9O7/D1NcPgHK06/ux/l+0/Xsvx9D3Ozs4NOhW2tY1hhT7qIMAe/uT3Y5J7k187KUptym22+rPooxjTSjBJJdETswjUuxCqoJJJAAA6kk8ADuTxU+SL21eiR5B4o+J8dvutdExLJyGuWGY1/wCuSn75/wBtvk9A3WvboYBu08Rov5er9X09Fr6Hh4jHqN4YfV/zdF6Lr6vT1PEbm5lvJWnuHaWVzlnclmJ9yf0HQdAMV9DGKglGCSS2S0R87KTm3KTbb3bIgCxCqCSTgADJJPQADkk9gKe2ot9Eet+FvhhLdbbrWd0EXVbcHErj/pof+WSn+6P3h77K8SvjlG8MPq/5ui9O/rt6nt4fAOVp19F/L1fr29N/Q9xtLSGwiW3tkWGKMYVEGFH4dye5OSepJr5+UnNuU223u2fRRioJRgkktkiZ3WJS7kIiDLMxAVQOpJOAB7mpSvot+iHtq9Ejx3xR8UEi3WuiYduQ10w+Uf8AXFD94+jsNv8AdVute5QwDdp4jRfyLf8A7efT0WvmeHiMeo3hh9X/ADdF/hXX1enkeJ3FxLdSNNO7Syucs7kszH1JPP8Ah2r6BRUEoxSSWyWiR89KTk3KTbb3bIqokKACgAoAKACgD1/4MaabrWWuyPltIWYH0eT92o/FTIfwrwc1qclBU+s5L7o6v8bH0OUU+fEOp0hFv5y0X4XPTvjFox1DRxeIMyWMgc+vlyYRwP8AgXlsfQKa8XKqvs6zpvaorf8Aby1X6r5nu5vR9pQVVb05X/7dej/R/I+Uq+4PgQoAKAPYPg//AMfV5/1xi/8ARhrw8x+Gn/if5HvZb8VT0X5nutfOH0Rlf2JZm+OqNGHuyiortzsVAQPLB4UnJyw+Y9iBxW3tZ8nsU7Qu3ZaXv37+mxj7KHP7Vr37JXfS3bt6mrWJsc/r/iex8NReZeP+8YZSFMGV/ov8K+rthR6k8V1UaE67tTWnWT2X/B8lqc1avDDq9R69Ird/L9XofPPibxpfeJWMch8i1BytuhO0+hkbgyN9cKP4VFfT0MLDD6rWf8z/AEXRfj5ny9fFTxGj92HSK/Xv+XkchXccBu6D4bvvEcvlWSZVT88rfLFH/vN6+irlj2HeuarXhh1eo9eiW79F+ux00aE67tTWnVvZer/Tc+hfDHgix8NASqPtF3jmdx931ES8iMe/Lnu3avmK+KnX934Yfyr9X1/LyPqKGFhh9VrP+Z/oun5+Z2dcB3nO+IfFNj4aj3Xb5lYZSBMGV/fHRV/22wPTJ4rqo0J13aC0W8nsv835I5a1eGHV5vXpFbv/ACXmz548S+Mr7xK2yU+Tag5W3Qnb7FzwZG924H8KivqKGGhh9Y6y6ye/y7L+mz5evip4jR6Q6RW3z7v+kcnXacIUAFABQAUAFABQAUAfVfwc0Y6dpDXjjD30hYdj5ceUTP8AwLzCPUMDXxGa1eesqS2pq3/bz1f6L5H3uUUfZ0HVe9SV/wDt2Oi/G7+Z6le2kd/BJazjdFOjRuPVXBU/oa8OEnTkpx0cWmvVanvzgqkZU5fDJNP0asz4X1vSpdDvprCbh7eQrnpkdVYezqQw9iK/TaVRVoRqw2kr+j6r5O6PyqtSeHqSoy3i2vVdH81ZmVWxgFAHsHwf/wCPq8/64xf+jDXh5j8NP/E/yPey34qnovzPda+cPohrMEUuxCqoJJJAAA6kk8ADuTxT8kG2r0SPIPFHxPjt91romJZOQ1ywzGv/AFyU/fP+23yegbrXt0MA3aeI0X8q3fq+notfQ8PEY9RvDD6v+bovRdfV6ep4jc3Mt5K09w7Syucs7ksxPuT+g6DoBivoYxUEowSSWyWiPnZSc25Sbbe7ZDVEneeAfC9v4mupRdswhtkVyicGTcxAUt1VeOcDcegI615uLryw8VyJXk2rvpZdurPTweHjiJPnbtFJ2XW779D6RtLSGwiW3tkWGKMYVEGFH4dye5OSepJr5WUnNuUm23u2fVxioJRgkktkiZ3WJS7kIiDLMxAVQOpJOAB7mpSvot+iG9NXol8jx3xR8UEi3WuiYduQ1yw+Uf8AXFD94+jsNv8AdVute5QwDdp4jRfyLf8A7efT0WvmeHiMeo3hh9X/ADdF/hXX1enkeJ3FxLdSNNO7Syucs7kszH1JPP8Ah2r6CMVBKMUklslokfPSk5Nyk2292xkcbSsEjBZmOAqjJJ9gKbaSu9EhJNvlirvokbw8Laif+WQH/A0/xrm+sU+/4M7fqlb+Vf8AgS/zD/hFtR/55D/v4n+NH1in3/Bh9Urfyr/wJf5h/wAItqP/ADyH/fxP8aPrFPv+DD6pW/lX/gS/zD/hFtR/55D/AL+J/jR9Yp9/wYfVK38q/wDAl/mH/CLaj/zyH/fxP8aPrFPv+DD6pW/lX/gS/wAzGuraSylaCYbXQ4YZBxkA9Rx0NbxkpJSjszknB05OEtGtyCrINTRdKl1q9hsIPvzyKg9gfvMfZVyzewNY1aioQlVltFN/5L5uyNqVJ16kaMN5NL07v5K7Puixs49Ot47SAbYoEWNB6KgCj8cDk9zzX5lOTqSc5bybb9XqfqsIKlGNOGkYpJeiVi1UGh4N8ZvCxmjTXbdfmiAiuAP7hOI5D/uk7GPJIKdlNfU5ViLN4Wb396Hr1XzWq80+58lnGGuli4Lb3Z+n2ZfJ6Pya7HzlX1p8aFAHsHwf/wCPq8/64xf+jDXh5j8NP/E/yPey34qnovzPVdf8TWPhqLzLx/3jDKQpgyv9F/hX1dsKPUnivGo0J13amtOsnsv+D5LU9mtXhh1eb16RW7+X6vQ+efE3jS+8SsY5D5FqDlbdCdp9DI3Bkb64UfwqOtfT0MLDD6rWf8z/AEXRfj5ny9fFTxGj92HSK/Xv+XkchXccAUAFAHsPwf8A+Pi9/wCuUX/obV4WY/DT9X+SPey34qnovzZ6l4h8U2PhqPddvmVhlIEwZX98dFX/AG2wPTJ4rx6NCdd2gtFvJ7L/ADfkj2K1eGHV5vXpFbv/ACXmz548S+Mr7xK2yU+Tag5W3QnZ7FzwZG924H8KivqKGGhh9Y6y6ye/y7L+mz5evip4jR6Q6RW3z7v+kcnXacJsaVolxqpzGNkQPMjfdHsvdj7Dj1IrnqVY0t9X2W//AADro4edf4dI9ZPb5d2emaZo1vpK4hGXI+aRvvH/AOJH+yPxzXkVKsqj97bolsfQ0qEKC9xa9ZPd/wCS8katYnSFABQAUAFAHkPiT/kIz/7y/wDoC17lD+HH0f5s+WxX8afqvyRiV0nGfRfwZ8LGFH124XBkBitgf7ucSSD6keWp4PEg6EV8lmuI1WFg9ven6/Zj8lq/Vdj7HJ8NZPFzW94w9PtS+b0Xo+573Xyx9cFAEF1bRXkT286h4pVZHU9GVhgg/UGqjJwanF2aaafZoiUVOLhNXi0013T3Pi7xp4Wl8J6g9q2WgfLwSH+OMnjJ6bl+6445GQNpUn9GwuIWKpqotJLSS7S/ye6+7ofmWLw0sHVdJ/C9YPvH/NbP7+pyNdxwHR+H/E1z4aFwbML5tyioHYZ8sKxYsq9GY5wN3A64NclahHEcvPe0W3Zdbra/Reh10a8sOpezSvJJXfT5dzCubmW8lae4dpZXOWdyWYn3J/QdB0HFdMYqCUYJJLZLRHNKTm3KTbb3bIaokKACgAoA6LQPE114bW4+xBRLdIieYwyYwpJyqn5SxzwWyB1wT05K1CNdx9pe0W3Zdb9329Dro15YdS9na8klftbsu5hXFxLdSNNO7Syucs7kszH1JPP+HaulRUEoxSSWyWiRzSk5Nyk2292yKqJLdnLBBJvuIzOo6Ju2An/a4JI9hjPf0rOSk1aD5fO1/uNabjB3nHmXa9l89DsF8aiMBVtgqqMAB8AD0ACYFcP1Xq5/h/wT1VjktFTslsr/APAF/wCE3/6d/wDyJ/8AYUvqv978P+CP6/8A3P8Ayb/gB/wm/wD07/8AkT/7Cj6r/e/D/gh9f/uf+Tf8AP8AhN/+nf8A8if/AGFH1X+9+H/BD6//AHP/ACb/AIAf8Jv/ANO//kT/AOwo+q/3vw/4IfX/AO5/5N/wA/4Tf/p3/wDIn/2FH1X+9+H/AAQ+v/3P/Jv+AH/Cb/8ATv8A+RP/ALCj6r/e/D/gh9f/ALn/AJN/wDkNSvP7QuXuduzzCDtznGAB1wM9PSu+EfZxUL7HlVZ+1m6lrX6fKxv+DPC03ivUEtEysK/PPIBwkYPPtub7qDnk5I2hiOXFYiOEpuo/i2iu8v8AJbv7up04TDSxdVUo6RWs32j/AJvZff0Z9p2trFYwpbW6iOKFVRFHRVUYAH0A/wAa/OpSc5OcneTbbfds/TYxVOKhBWjFJJLokT1BYUAFAHK+MPCsHiyxa0lwkq5aCXHMb4/Mo3R17jBHzKpHdhcTLCVFUjrF6Sj3X+a3T7+Vzz8XhY4ym6ctJLWMv5X/AJPZrqvOx8aarpVxol1JZXiGOaFsMD+hB6FWGCpHBBBHBr9Dp1I1YqpTd4vZ/o+zXVH5rUpyozdKorSi7Nfqu6e6ZnVqZBQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQBoaXpdxrNzHZWaGSaVtqgfqSegUDJYngAEngVlUqRoxdSo7Rjq3/l5vouprTpyrTVKkryk7Jfq+yW7fRH2X4O8KQeEbFbSLDzPhp5ccu+O3cIvRB2GSfmZifz3FYmWLqc70itIx7L/ADe7f6WP0rCYWOCpqnHWT1lLu/8AJbJdvNs6uuA9AKACgAoAKAOE8c+Brfxfb5GIr2IHyZsde/lyY5KE9DyUJLLkFlb1MHjJYOVnrTfxR/Vdn+ez6NeTjcFHGRuvdqx+GX/tsu6f4PVdU/kXVdKutEuHs72Nopozgqf0IPQqRyGBII5BIr72nUjViqlJ3i9mvyfZrqj87qU50JOlVTjJbp/mu6fRrRmdWpkFABQAUAFABQAUAFABQAUAFABQAUAFABQBoaXpVzrNwlnZRtLNIcBV/Uk9AoHJYkADkkCsqlSNGLqVGoxW7/Rd2+i6mtOnOtJUqScpPZL832S6t6I+ufA3ga38H2+TiW9lA82XHAHXy488hAep4LkAnACqvweMxksXKy92nH4Y/q/P8tl1b/Q8Fgo4KN3rVl8Uv/bY9l+Ler6Jd7XlHrhQAUAFABQAUAFAHK+KvB9j4sg8q7XbKgPlTKBvjJ7f7SE9UPB6gq2GHfhsVUwkuanrF/FF7P8AyfZr8tDz8VhKeMjy1FaS+GS3j/mu6enz1PlDxT4L1DwnLsuk3QsT5c6AmNx25/hbHVGweuMr8x+5w+Kp4pXpu0lvF/Ev815r52Pz/E4Srg5Wqr3ek18L/wAn5P5XOSruOAKACgAoAKACgAoAKACgAoAKACgAoA63wt4M1DxXLstE2wqR5k75EaDvz/E2OiLk9M4XLDhxGKp4SN6j97pFfE/8l5v8Tvw2Eq4uVqStFbzfwr/N+S+dtz6u8KeDrHwjB5Vou6ZwPNnYDe59P9lAeiDgdSWbLH4bE4qpi5XnpFfDFbL/ADfdv8tD9AwuDp4OPLTV5P4pPd/5Lsl+L1OrrgPQCgAoAKACgAoAKACgAoAgurWG9iaC4RZYpBhkcBlYehB4NVGTg1KDaa2a0aIlGM04TScXumrp/I8M8U/BmOYtcaE4iY8m3lJ2/SOQ5K+yvkZ/jUV9Ph81atDFK/8Afjv/ANvR2fqrejPlMTk6d54R2/uSen/bst16O/qjwjVdEvtDl8i/hkt3HTeMA+6sMqw91JHvX09OrCsualJSXl09Vuvmj5SrSqUHyVouD81v6PZ/JmVWxiFABQAUAFABQAUAFABQBqaXol7rUvkWEMk7+iLwPdm+6o92IHvWNSrCguarJRXm9/Rbv5I2pUqleXJRi5PyW3q9l82e7+FvgykJW411xIRyLeInb9JJBgn3VMc9HIr5jEZq9YYVW/vy3/7dj09Xf0R9XhsnStPFu/8Aci9P+3pbv0VvVnulraw2MS29siwxRjCogCqo9ABgCvmZSlNuU23J7tu7Pq4xjTShBKMVskrJfInqCwoAKACgAoAKACgAoAKACgAoAKAK15ZW+oRmC6jSeJuqSKHX8mBGffrVwnKm+am3FrqnZ/gZzhGouSpFSj2aTX4nl2s/B3R9QJezMljIeynzI8/7jnd+CyKB6V7lLNa1PSolUXnpL71+qZ4NbKKFTWk5U35ax+5/o0eZal8GNYtCTaPDdr2Aby3P1WTCj/v4a9mnmtCXxqUH6cy+9a/geHUyjEQ/huM15Plf3PT8TirvwPrtjxLY3HHdI2kH/fUe5f1r0Y4vDz+GrD5vl/Ox5ksHiKfxUp/Jcy/8luYM+n3NrxNFJFj++jL/ADArqU4y+GUX6NP8mcjhKHxRkvVNfminVkFyDT7m64gikk/3EZv5A1DnGPxSivVpfmy1CUvhjJ+ib/JG9Z+B9dveIrG49i8bRj/vqQKv61yyxeHp/FVh8nf8I3OuGDxE/hpT+ceVf+TWO1034MaxdEG7eG0XuC3mOPoseVP/AH2K86pmtCH8NSm/Jcq+96/genTyjET/AIjjBeb5n9y0/E9M0b4OaRpxD3jSXrjsx8uPP+4h3fgZCD6V41XNa09KSVNeWsvvf6JHuUcooU9arlUfn7sfuWv3tnqNnY2+nRiC0jSCJeiRqEUfgoAz79TXhznKo+abcn3bu/xPehCNJclOKjFdEkl+BaqDQKACgAoAKACgAoA//9k='function Convert-Base64Bitmap2Picture&#123; param([Parameter(Mandatory=$true)]$Base64Text) $bitmap = New-Object System.Windows.Media.Imaging.BitmapImage $bitmap.BeginInit() $bitmap.StreamSource = [System.IO.MemoryStream][System.Convert]::FromBase64String($base64Text) $bitmap.EndInit() $bitmap.Freeze() $bitmap&#125;$xaml = @'&lt;Window xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" FontFamily=\"SegoeUI\" Foreground=\"White\" SizeToContent=\"Width\" Title=\"Join the PowerShell Conference EU 2016, April 20-22\"&gt; &lt;Grid&gt; &lt;Image Name=\"Img1\" Margin=\"20\" HorizontalAlignment=\"Center\"/&gt; &lt;TextBlock TextAlignment=\"Center\" VerticalAlignment=\"Center\" FontSize=\"40\" HorizontalAlignment=\"Center\"&gt; &lt;TextBlock.Effect&gt;&lt;DropShadowEffect ShadowDepth=\"4\" Color=\"DarkGray\" BlurRadius=\"4\"/&gt;&lt;/TextBlock.Effect&gt; Join the PowerShell&lt;LineBreak/&gt;Conference EU 2016!&lt;LineBreak/&gt;&lt;LineBreak/&gt;www.psconf.eu &lt;/TextBlock&gt; &lt;/Grid&gt;&lt;/Window&gt;'@$reader = [System.XML.XMLReader]::Create([System.IO.StringReader]$XAML)$window = [System.Windows.Markup.XAMLReader]::Load($reader)$image = $window.FindName('Img1') $image.Source = Convert-Base64Bitmap2Picture -Base64Text $Picture1$window.ShowDialog()","text":"在前一个技能中我们演示了如何将任何图片转换为 Base64 编码的字符串。今天，我们将演示如何加载 Base64 编码的图片并显示它。 这个窗口显示官方会议 logo 并且不需要独立的图片文件。该图像已经嵌入到脚本中并且直接从内存中加载。 在脚本头部的嵌入图片十分大。最重要的部分是在 Base64 编码字符串之后的 Convert-Base64Bitmap2Picture 函数。它接受 Base64 编码的文本并且返回一个 bitmap 对象。这个对象可以设为任何 WPF image 控件的源。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281Add-Type -AssemblyName PresentationFramework$picture1 ='/9j/4AAQSkZJRgABAAEBLAEsAAD/4QB2RXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAZKGAAcAAABAAAAALAAAAABVTklDT0RFAABMAEUAQQBEACAAVABlAGMAaABuAG8AbABvAGcAaQBlAHMAIABJAG4AYwAuACAAVgAxAC4AMAAxAAD/2wBDAAUFBQgFCAwHBwwMCQkJDA0MDAwMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ3/2wBDAQUICAoHCgwHBwwNDAoMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ3/wAARCADIAMgDAREAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD7LoAKACgAoAKACgAoArXd5Bp8ZnupEgiXq8jBFH4sQKuMJVHywTk+yV3+BE5xpLmqNRiuraS/E8w1n4w6PppKWgkvpB/cGyPP++43fiqMPevbpZVWqa1LU156y+5fq0eDWzehT0pKVR+Wkfvf6JnmWpfGjV7okWiQ2i9iF8xx/wACfKH/AL9ivZp5VQh/Ecpv15V9y1/E8Opm+IlpTUIL05n970/A4m78c67e/wCtvrgeySGIflHsH6V6McJh6fw0ofNc3/pVzzJ4zEz+KrP5PlX/AJLYwp9Tu7n/AF00sn++7N/MmupQhH4YxXpFL8kcjnOXxSk/WTf5spZ71oZl2DU7u1/1E0sWP7jsv8iKzcIS+KMX6xT/ADRopzj8MpL0k1+TN208c67Y/wCqvrjjoHkMg/KTeP0rllhMPP4qUPkuX/0mx1wxmJp/DVn83zL7pXO10340axakC7SG7UdSV8tz/wACTCD/AL9mvOqZVQl/DcoP15l9z1/E9Onm+Ih/EUJr05X960/A9N0b4w6PqBCXYksZD3cb48/76Dd+LIo968arlVanrTaqLy0l9z/Rs9ujm9CppVUqb89Y/ev1SPULS9gv4xPayJNE3R42DKfxUkV4koSpvlmnFro1Z/ie9Ccai5qclKPdNNfgWag0CgAoAKACgAoAKACgAoAKACgAoAgubmKyiae4dYooxlnchVUepJwBVRi5tRgm29kldsiUo005zajFbtuyR4d4p+MsVuWt9DQSsODcSAhB/wBc4+C3sz4Gf4GFfT4fKm7TxTsv5I7/ADey9Fd+aPlcTm6jeGEV/wC/Lb/t2O79XZeTPB9V1y+1yXzr+aSd+248LnsqjCqPZQB7V9PTpU6C5aMVFeW79Xu/mz5SrWqV3zVpOT83ovRbL5Iya2MAoAKACgAoAKACgAoAKANXStcvtDl86wmkgfvtPB9mU5Vh7MCPasalKFZctWKkvNbej3XyZvSq1KD56MnB+T0fqtn80e8eFvjNHMVt9cQRMeBcRA7PrJHyV92TIz/Ao5r5jEZU1eeFd/7kt/k9n6O3qz6vDZunaGLVv78Vp/29HdequvJHuVtdRXsSz27rLFIMq6EMrD1BGQa+YlFwbhNNNbpqzR9VGUZpTg04vZp3TJ6ksKACgAoAKACgAoAKACgDlvFPi+x8JQebdtulcHyoVI3yEe38KA/ec8DoMthT3YbC1MXLlpq0V8Unsv8AN9ktfzPPxWLp4OPNUd5P4YreX+S7t6fPQ+UfFXjXUPFcu66fZApPlwISI09CR/E2Ortk9cbVO0fdYfC08IrU173WT+J/5LyXzufAYnF1cXK9R2itoL4V/m/N/KxyFdx54UAFABQAUAFABQAUAFABQAUAFABQB13hbxpqHhOXdavvgYjzIHJMbjvgfwtjo64PTOV+U8OIwtPFK1RWktpL4l/mvJ/Kx34bF1cHK9J+71g/hf8Ak/NfO59XeFfGFj4sg820bbKgHmwMRvjJ/wDQkJ6OOD0IVsqPhcThamElyzV4v4ZLZ/5Punr8tT9AwuLp4yPNTdpL4oveP+a7NafPQ6quE9AKACgAoAKACgAoA4Xxx44t/B9v2lvJQfJhz+HmSY5CA9OhcjauAGZfUweDli5fy018Uv0Xm/w3fZ+TjcbHBR01qP4Y/wDt0u0V+Oy6tfImq6tda1cveXshlmkOST2HZVHRVHQKAABwBX3tOnCjFU6S5YrZfq+7fVn53UqTrTdWq3KT3f6Lsl0SM6tTIKACgAoAKACgAoAKACgAoAKACgAoAKACgDR0rVbrRblLyykaGaM5DD9QR0KnoVIII4IIrKpTjVi6dRJxe6/Vdn2ZrTqToTVSk3GS2a/J90+qe59deBvHNv4ut8HEV7EB50OevbzI88lCeo5KE7WyCrN8FjMHLBy01pv4Zfo+z/PddUv0TBY2OMjb4asfij/7dHun+D0fRvu68s9YKACgAoAKAOW8X+KYPCVi13LhpWysMWcGSTH5hF6u3YcD5mUHuwuGli6ipx0itZS/lX+b2S7+Vzz8Xio4Om6ktZPSMe7/AMlu30XnY+M9W1W51q6kvbxzJNKcknoPQAdlUYCgcAAAV+h06caMFSpq0Vsv1fdvds/NalSdabq1XeUnq/0XZLZIzq1MgoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA0dK1S40W5jvbNzHNC2VI/UEdCrDIYHggkHg1lUpxqxdKorxejX6rs10ZrTqSozVWk7Si7p/o+6ezXU+y/B/iqDxZYrdxYSVcLPFnmN8du5RuqN3GQfmVgPzzFYaWEqOm9YvWMu6/zWzX6WP0rCYqOMpqpHSS0lH+V/5PdPt53OqrhPQCgAoAhubmKyie4nYRxRKzux6KqjJJ+gFVGLm1CCu20kvNkykoRc5u0Um2+yW58W+NfFUvivUHumysCZSCM/wRg8Ejpvb7znnk4B2quP0bC4dYSmqa+J6yfeX+S2X39T8yxeJljKrqPSK0gu0f8AN7v7uhyNdx553PgnwvD4pN1BK7QyQxI8TryFYsQdy/xKR1GQR1B7HzsVXlhuSUUmm2mvK3R9GelhcPHE88ZNppJp9nfquqMTXvDV94bl8q9TCMfklXmKT/dbsfVGww9Mc10Ua8K6vTevVPdeq/VaHPWoTw7tNadGtn/XZ6mDXScoUAFABQB3XgnwtB4p+1wyu0MkMcbRSLyFZmYHcv8AEpAGRkEdQfXzsVXlhuSUUmm2mvK3R9GelhcPHEc8ZNppJp9nd7rqjD17w1feG5fLvUwjHCSrzFJ/ut2PqjYYemOa6KNeFdXpvXqno18v1Whz1qE8O7TWnRrZ/wBdnqYNdJyhQAUAFABQAUAFABQAUAFAHW+C/FMvhPUEuky0L/JPGP44yecDpuX7yHjkYJ2lgeHFYdYqm6b0ktYvtL/J7P7+h34TEywdVVV8O013j/mt193U+0rW5ivYUuIGDxSqrow6MrDII+oNfnMouDcJKzTaa7Nbn6bGSnFTg7xaTTXVPYnqSwoA8H+M3ikwRpodu2GlAluCOyA/u4/+BEb2HBAVOzGvqcqw928VNbe7D16v5LRebfY+SzfE8qWEg9X70/T7Mfm9X5Jdz5xr60+NCgD2D4P/APH1ef8AXGL/ANGGvDzH4af+J/ke9lvxVPRfme23VrDexNb3KLLE4wyOAVP4evoRgjqCDXz0ZODUoNprZrRn0EoqScZJNPdM8P8AFHwwltN11ou6aIcm3Y5lT/rmx/1i/wCyfnHbfX0NDHKVoV9H/N0fqunrt6Hz2IwDjeeH1X8vVenf039TyNlKEqwKlTggjBBHUEHkEdwa9vzR4e2jEpiCgD2H4P8A/Hxe/wDXKL/0Nq8LMfhp+r/JHvZb8VT0j+bPbbq1hvYmt7lFlicYZHAKn8D39CMEdQQa+fjJwalBtNbNaNH0EoqScZJNPdPY8P8AFHwwltd11ou6aLq1sxzIv/XNj/rB/sn5x2L19DQxylaFfR/zdH6rp67eh89iMA43nh9V/L1Xp39N/U8iZShKsCrKcEEYII6gg8gjuDXt+aPDtbR6WEpiCgAoAKACgAoAKACgAoA+jPgz4pMsb6FcN80YMtuT/dJzJGPoT5ijkkGQ9FFfJZrh7NYqC392fr9l/NaP0Xc+yyfE3Twk3teUPT7Ufk9V6vse9V8sfWla8u49PgkupztigRpHPoqAsf0FXCLnJQju2kvV6ETmqcXUlpGKbfoldnwvrmqy65fTX83355C2Ou0dFUeyKAo9gK/TaVNUKcaMNoq3q+r+buz8qrVXXqSrT3k2/RdF8lZGVWxgFAHsHwf/AOPq8/64xf8Aow14eY/DT/xP8j3st+Kp6L8z3WvnD6IKAON8T+CbHxKDIw+z3ePlnQcn0Eq8CQe/Djs3au+hip4fRaw/lf6Pp+XkcNfCwxGr92fSS/Vdfz8z5617w1feG5fKvUwjH93KvMUn+63Y+qNhh6Y5r6ejXhXV6b16p7r1X6rQ+XrUJ4d2mtOjWz/rs9TBrpOU6Twz4nufC1w09uqyJKAssb8B1ByMMOUYEnBGR6giuSvQjiI8srprVNdH6dUddCvLDS5opNPRp9fn0Po3w94qsfEse60bbMoy8D4Eiepx0df9tcj12nivlq2Hnh3aa06SWz/yfkz6ujXhiFeD1W8Xuv8ANeaOkrkOo47xP4JsfEoMjD7Pd4+WdAMn0Eq8CQe5w47N2rvoYqeH0WsP5X+j6fl5HDXwsMRq/dn0kv1XX8/M+ede8NX3huXy7xMIxwkq8xSf7rdj6o2GHpjmvp6NeFdXpvXqno18v1Wh8vWoTw7tNadGtn/XZ6mDXScoUAFABQAUAFABQAUAamiarLod9DfwcPbyBwOmR/Ep9mUlW9iaxq01WhKlLaSt6dn8nZm1Kq6FSNaG8Gn69181dfM+6bK8j1C3juoDuinRZEPqrgMPxweR2NfmU4unJwlo4tp+q0P1WE1UjGpD4ZJNejVzy/4w6ydO0cWaHEl9IE9D5ceHcj/gXlqfUMa9vKqXPX9o9qav/wBvPRfq/keFm9b2dD2S3qSt/wBurWX6L5nylX3B8CFABQB7B8H/APj6vP8ArjF/6MNeHmPw0/8AE/yPey34qnovzPda+cPojitS8b2mi6qdLvwYozHG6TjlQXBysi9VHHDjIH8QA5r0IYWdWl7anq7tOOz07f5fccE8VClV9jU0Vk1Lpr37ev3nZRusqiSMh0cZVlIKkHoQRwQfUVwNW0ejXQ7k7q626NEV1aw3sTW9yiyxOMMjgFT+Hr6EYI6gg04ycGpQbTWzWjFKKknGSTT3TPD/ABR8MJbTddaLumiHJt2OZU/65sf9Yo/un94O2+voaGOUrQr6P+bo/VdPXb0PnsRgHG88Pqv5eq9O/pv6nkbKUJVgVKnBBGCCOoIPII7g17fmjw9tGSQTyWsizQM0UkZyroSrKfUEcik0pJxkk0909hxk4NSi2mtmtLHtXhf4oK+211vCNwFulHyn/rsg+6fV0G3+8o614FfAWvPD7fydf+3X+j+8+gw+PTtDEaP+Zbf9vLp6r7j2OORZVEkZDo4yrKQVYHoQRwR7ivCacXZ6Nbrax7qaautuliO6tYb2Jre5RZYnGGRwCp/A9/QjBHUEGnGTg1KDaa2a0YpRUk4ySae6ex4f4o+GEtruutFzNEOWtmOZF/65sf8AWD/ZPzjsXr6GhjlK0K+j/m6P1XT129D57EYBxvPD6r+XqvTv6b+p5EylCVYFWU4IIwQR1BB5BHcGvb80eHa2j0sJTEFABQAUAFABQAUAfVnwc1k6ho7WbnMljIVHr5cmXTP/AALzFHoFFfEZrS9nWVRbVFf/ALeWj/R/M+9yit7Sg6T3pyt/269V+q+R5p8aNSNzrCWgPy2kKgj0eT52P4oY/wAq9jKqfJQdTrOT+6Oi/G54mcVOauqa2hBffLV/hY8er3z50KACgD2D4P8A/H1ef9cYv/Rhrw8x+Gn/AIn+R72W/FU9F+Z7rXzh9EfN/wAUv+Q4f+veH+TV9VgP4P8A29I+Ux/8b/t2Ji+GvGN94ZbbCfNtictbuTs9yh6xt7rwf4lauivhoYhXlpLpJb/PuvX5MwoYmeH0WsesXt8uz/pn0P4e8VWPiWPdaNtlUZeB8CRPU46Ov+2uR64PFfMVsPPDu01p0ktn/k/Jn1FGvDEK8Hr1i91/mvNHR1yHUcb4n8E2PiUGRh9nu8fLOg5PoJV4Eg9+HHZu1d9DFTw+i96H8r/R9Py8jhr4WGI1fuz6SX6rr+fmfPWveGr7w3L5V6mEY/JKvMUn+63Y+qNhh6Y5r6ejXhXV6b16p6Neq/VaHy9ahPDu01p0a2f9dnqYNdJynV+GvGN94ZbbAfNtictbuTsPqUPWNvdeD/ErVxV8NDEL3tJdJLf5916/I7qGJnh9I6x6xe3y7P8Apn0N4e8VWPiWPdaNtmUZeB8CRPU46Ov+2uR67TxXzFbDzw7tNadJLZ/5PyZ9RRrwxCvB2a3i91/mvNHSVyHUcd4n8E2PiQGRh9nu8fLOg5PoJV4Eg9zhx2btXfQxU8PotYfyv9H0/LyOGvhYYjV+7PpJfquv5+Z88694avvDcvl3iYRjhJV5ik/3W7H1RsMPTHNfT0a8K6vTevVPRr5fqtD5etQnh3aa06NbP+uz1MGuk5QoAKACgAoAKAPX/gxqX2TWHtCcLdwsAPV4/wB4p/BBIPxrwc1p81BVFvCS+6Wj/Gx9DlFTkxDp9Jxf3x1X4XOL8c3n23Xb6X0uJEH0iPlj9EFehhI8mHpR/uJ/+Be9+p5uMlz4mrL++18o+7+hyldxwBQAUAewfB//AI+rz/rjF/6MNeHmPw0/8T/I97Lfiqei/M91r5w+iPm/4pf8hw/9e8P8mr6rAfwf+3pHymP/AI3/AG7E86r1TyiWCeS1kWaBmikjOVdCVZT6gjkf5zUtKScZJNPdPYqMnBqUW01s1pY9r8L/ABQWTba63hG4C3SjCn/rsg+6fV0G3+8o614FfANXnh9v5Ov/AG6+vo/vPoMPj07QxGj/AJlt/wBvLp6r7j2KN1lUSRkOjjKspBUg9CCOCD6ivCato9Guh7qd1dbdGiK6tYb2Jre5RZYnGGRwCp/A9/QjBHUEGnGTg1KDaa2a0YpRUk4ySae6ex4f4o+GEtpuutF3TRDk27HMqf8AXNj/AKxR/dP7wdt9fQ0McpWhX0f83R+vb129D56vgHG88Pqv5eq9O/pv6nkbKUJVgVKnBBGCCOoIPII7g17fmjw9tGSQTyWsizQM0UkZyroSrKfUEcik0pJxkk0909hxbg1KLaa2a0se1eF/igr7bXW8I3AW6UfKf+uyD7p9XQbf7yjrXgV8Ba88Pqv5Ov8A26/0f3n0GHx6doYjR/zLb/t5dPVfcexxyLKokjIdHGVZSCrA9CCOCPcV4TTi7PRrddj3U01dbdLEd1aw3sTW9yiyxOMMjgFT+B7+hGCOoINOMnBqUG01s1oxSipJxkk0909jw/xR8MJbXddaLumi6tbMcyL/ANc2P+sH+yfnHYvX0NDHKVoV9H/N0fqunrt6Hz2IwDjeeH1X8vVenf039TyJlKEqwKspwQRggjqCDyCO4Ne35o8O1tHpYSmIKACgAoA6rwPd/YddsZRx/pEaH6SMI2/8dY1xYuPPh6sf7jf/AID736Hdg5ezxFKX99L5S939TD1Of7TdzTf89JXf/vpif610wXLCMe0Yr7kkcs3zTlLvKT+9tlGtDMKACgD2D4P/APH1ef8AXGL/ANGGvDzH4af+J/ke9lvxVPRfme6184fRHzf8Uv8AkOH/AK94f5NX1WA/g/8Ab0j5TH/xv+3YnnVeqeUFABQB1fhrxjfeGW2wnzbYnLW7k7Pcoesbe68H+JWrir4aFdXekuklv8+69fkzuoYmeH0jrHrF7fLs/wCmfQ/h7xVY+JY91o22VRl4HwJE9Tjo6/7a5Hrg8V8xWw88O7TWnSS2f+T8mfUUa8MQrweq3i91/mvNHR1yHUcb4n8E2PiUGRh9nu8fLOg5PoJV4Eg9+HHZu1d9DFTw+i96H8r/AEfT8vI4a+FhiNX7s/5l+q6/n5nz1r3hq+8Ny+VephGPySrzFJ/ut2PqjYYemOa+no14V1em9eqe69V+q0Pl61CeHdprTo1s/wCuz1MGuk5Tq/DXjG+8MttgPm2xOWt3J2H1KHrG3uvB/iVq4q+GhiF72kuklv8APuvX5HdQxM8PpHWPWL2+XZ/0z6G8PeKrHxLHutG2zKMvA+BInqcdHX/bXI9dp4r5ith54d2mtOkls/8AJ+TPqKNeGIV4PVbxe6/zXmjpK5DqOO8T+CbHxKDIw+z3ePlnQDJ9BKvAkHucOOzdq76GKnh9FrD+V/o+n5eRw18LCvq/dn0kv1XX8/M+ede8NX3huXy7xMIxwkq8xSf7rdj6o2GHpjmvp6NeFdXpvXqno18v1Wh8vWoTw7tNadGtn/XZ6mDXScoUAFAFzT5/stzFMP8AllIj/wDfLA/0qJrmjKPeLX3pouD5ZRl2kn9zTKh96sgSgAoAKAPYPg//AMfV5/1xi/8ARhrw8x+Gn/if5HvZb8VT0X5nutfOH0R83/FL/kOH/r3h/k1fVYD+D/29I+Ux/wDG/wC3YnnVeqeUFABQAUAdB4b0TUtYul/ssMjxEEzglFh92kHQ/wCyMs3TaRXLXq06UX7a1n9ndy+X67HXQpVKsl7G6a+1so/P9Nz6p0+Ge3t447uUXE6qA8oQRhz67RwPT36kAnFfHTcXJuC5Y9Fe9vmfZQUoxSm+aS3drX+RcrMs5fxTrml6RatHqu2ZZRxbYDvL9FP3R/00JUL2OeK7MPSq1ZJ0bq32tkvn+nU5K9WlSjatZ3+zu38unqfLV1JFLM728ZgiZiUjLlyinou8gFsepFfYRTSSk7u2rta7726Hxsmm24Llj0V72+ZXqyDovDWhalrNyp0sNG0TAm4yUSE+pcc59EXLN6Yrkr1adGNq1mn9ndv5fq9DroUalWSdG6t9rZR+f6LU+qLCGe3t0iupftMyqA8uwR7z67RwP69Tya+Om4uTcFyxvor3t8z7KCcYpTfNJLV2tf5FuoLOV8Va/pej2zRaoFn81eLXAZ5PQ7Twi/8ATRsY/hJPFdmHo1ask6N42+3sl8+vovmceIrUqUbVrO/2N2/l09fuPlu6kjlld4E8mJmJSPcX2Kei7zgtj1NfYxTSSk7u2rta7726Hx0mm24rlXRXvbyuQVRAUAFAF3UoPst3ND/zzldP++WI/pWcHzQjLvGL+9Jmk1yTlHtKS+5tFKtDMKACgD2D4P8A/H1ef9cYv/Rhrw8x+Gn/AIn+R72W/FU9F+Z7rXzh9EfN/wAUv+Q4f+veH+TV9VgP4P8A29I+Ux/8b/t2J51XqnlBQAAEkAcknAA5JJ6ADuT6UB5I9Z8LfDGa923WsbreHgrAOJnH+2f+WSn0/wBYfReteJXxyheFC0pfzfZXp3f4ep7mHwDladf3Y/y/afr2X4+h7nZ2cGnQrbWsawwp91EGAPf3J7sck9ya+elKU25TbbfVn0MYxppRgkkuiJ2YIpZiFVQSSSAAB1JJ4AHcnip8kXtq9EeQeKPifHb7rXRMSychrlhmNf8Arkp++f8Abb5PQN1r26GAbtOvov5er9X09Fr6Hh4jHqN4YfV/zdF6Lr6vT1PEbm5lvJWnuHaWVzlnclmJ9yf0HQdAMV9DGKglGCSS2S0R87KTm3KTbb3bIgCxCqCSTgADJJPQADkk9gKe2ot9Eet+FvhhLdbbrWd0EXVbcHErj/pof+WSn+6P3h77K8SvjlC8MPq/5ui9O/rt6nt4fAOVp19F/L1fr29N/Q9xtLSGwiW3tkWGKMYVEGFH4dye5OSepJr5+UnNuUm23u2fRRioJRgkktkiZ3WJS7kIiDLMxAVQOpJOAB7mpSvot+iG9NXol8jx3xR8UEh3WuiYduQ10w+Uf9cUP3j6Ow2/3VbrXuUMA3aeI0X8i3/7efT0WvmeHiMeo3hh9X/N0Xouvq9PI8TuLiW6kaad2llkOWdyWZj6knn/AA7V9AoqKUYpJLZLRI+elJyblJtt7tkVUSFABQBc0+D7VcxQD/lpIif99MB/Wom+WMpdot/cmy4LmlGPeSX3tI3/ABzZ/Yddvoun+kSOB7SnzB+jiuTCS58PSl/cS/8AAfd/Q7MZD2eJqx/vt/KXvfqcpXccAUAFAHsHwf8A+Pq8/wCuMX/ow14eY/DT/wAT/I97Lfiqei/M91r5w+iPm/4pf8hw/wDXvD/Jq+qwH8H/ALekfKY/+N/27E86r1Tyjb0Lw7feIpvJsY9wX78jfLHGPV29fRRlj2Fc9WtDDrmqO3ZLd+i/XY6aNCdd8tNer6L1f6bn0L4X8DWPhsCY/wCk3mOZnHCnuIk5CD/a5c+oHFfMV8VOv7vww/lXX/E+vpsfUUMLDD6/FP8AmfT0XT13O1rzzvOf1/xNY+GovMvH/eMMpCmDK/0X+FfV2wo9SeK6qNCdd2prTrJ7L/g+S1OatXhh1eb16RW7+X6vQ+efE3jS+8SsY5D5FqD8tuhO0+hkbgyN9cKP4VFfT0MLDD6rWf8AM/0XRfj5ny9fFTr6P3YdIr9e/wCXkchXccBu6D4bvvEcvlWSZVT88rfLFH/vN6+irlj2HeuarXhh1eo9eiW79F+ux00aE67tTWnVvZer/Tc+hfDHgix8NASqPtF3jmdx931ES8iMe/Lnu3avmK+KnX934Yfyr9X1/LyPqKGFhh9VrP8Amf6Lp+fmdnXAd5zviHxTY+Go912+ZWGUgTBlf3x0Vf8AbbA9MniuqjQnXdoLRbyey/zfkjlrV4YdXm9ekVu/8l5s+ePEvjK+8StslPk2oOVt0J2+xc8GRvduB/Cor6ihhoYfWOsusnv8uy/ps+Xr4qeI0ekOkVt8+7/pHJ12nCFABQAUAFAHVeB7P7brtjEP+fiNyPaNhI3/AI6prixcuTD1Zf3Gv/Avd/U7sHDnxFKP9+L+Ufef5HbfGjTTaawl2BhbuFST6vH8jD8EEf515uVVOag6fWEn90tV+Nz1M3p8mIVRbTgvvjo/wseP17586FABQB7B8H/+Pq8/64xf+jDXh5j8NP8AxP8AI97Lfiqei/M91r5w+iPnD4ognXCByTBAAB1JIbAA7k+lfVYD+B/29I+Vx/8AHsv5Ymn4W+GM17tutY3W8PBWAcTOP9s/8slPp/rD6L1rKvjlC8KFnL+b7K9O7/D1NcPgHK06/ux/l+0/Xsvx9D3Ozs4NOhW2tY1hhT7qIMAe/uT3Y5J7k187KUptym22+rPooxjTSjBJJdETswjUuxCqoJJJAAA6kk8ADuTxU+SL21eiR5B4o+J8dvutdExLJyGuWGY1/wCuSn75/wBtvk9A3WvboYBu08Rov5er9X09Fr6Hh4jHqN4YfV/zdF6Lr6vT1PEbm5lvJWnuHaWVzlnclmJ9yf0HQdAMV9DGKglGCSS2S0R87KTm3KTbb3bIgCxCqCSTgADJJPQADkk9gKe2ot9Eet+FvhhLdbbrWd0EXVbcHErj/pof+WSn+6P3h77K8SvjlG8MPq/5ui9O/rt6nt4fAOVp19F/L1fr29N/Q9xtLSGwiW3tkWGKMYVEGFH4dye5OSepJr5+UnNuU223u2fRRioJRgkktkiZ3WJS7kIiDLMxAVQOpJOAB7mpSvot+iHtq9Ejx3xR8UEi3WuiYduQ10w+Uf8AXFD94+jsNv8AdVute5QwDdp4jRfyLf8A7efT0WvmeHiMeo3hh9X/ADdF/hXX1enkeJ3FxLdSNNO7Syucs7kszH1JPP8Ah2r6BRUEoxSSWyWiR89KTk3KTbb3bIqokKACgAoAKACgD1/4MaabrWWuyPltIWYH0eT92o/FTIfwrwc1qclBU+s5L7o6v8bH0OUU+fEOp0hFv5y0X4XPTvjFox1DRxeIMyWMgc+vlyYRwP8AgXlsfQKa8XKqvs6zpvaorf8Aby1X6r5nu5vR9pQVVb05X/7dej/R/I+Uq+4PgQoAKAPYPg//AMfV5/1xi/8ARhrw8x+Gn/if5HvZb8VT0X5nutfOH0Rlf2JZm+OqNGHuyiortzsVAQPLB4UnJyw+Y9iBxW3tZ8nsU7Qu3ZaXv37+mxj7KHP7Vr37JXfS3bt6mrWJsc/r/iex8NReZeP+8YZSFMGV/ov8K+rthR6k8V1UaE67tTWnWT2X/B8lqc1avDDq9R69Ird/L9XofPPibxpfeJWMch8i1BytuhO0+hkbgyN9cKP4VFfT0MLDD6rWf8z/AEXRfj5ny9fFTxGj92HSK/Xv+XkchXccBu6D4bvvEcvlWSZVT88rfLFH/vN6+irlj2HeuarXhh1eo9eiW79F+ux00aE67tTWnVvZer/Tc+hfDHgix8NASqPtF3jmdx931ES8iMe/Lnu3avmK+KnX934Yfyr9X1/LyPqKGFhh9VrP+Z/oun5+Z2dcB3nO+IfFNj4aj3Xb5lYZSBMGV/fHRV/22wPTJ4rqo0J13aC0W8nsv835I5a1eGHV5vXpFbv/ACXmz548S+Mr7xK2yU+Tag5W3Qnb7FzwZG924H8KivqKGGhh9Y6y6ye/y7L+mz5evip4jR6Q6RW3z7v+kcnXacIUAFABQAUAFABQAUAfVfwc0Y6dpDXjjD30hYdj5ceUTP8AwLzCPUMDXxGa1eesqS2pq3/bz1f6L5H3uUUfZ0HVe9SV/wDt2Oi/G7+Z6le2kd/BJazjdFOjRuPVXBU/oa8OEnTkpx0cWmvVanvzgqkZU5fDJNP0asz4X1vSpdDvprCbh7eQrnpkdVYezqQw9iK/TaVRVoRqw2kr+j6r5O6PyqtSeHqSoy3i2vVdH81ZmVWxgFAHsHwf/wCPq8/64xf+jDXh5j8NP/E/yPey34qnovzPda+cPohrMEUuxCqoJJJAAA6kk8ADuTxT8kG2r0SPIPFHxPjt91romJZOQ1ywzGv/AFyU/fP+23yegbrXt0MA3aeI0X8q3fq+notfQ8PEY9RvDD6v+bovRdfV6ep4jc3Mt5K09w7Syucs7ksxPuT+g6DoBivoYxUEowSSWyWiPnZSc25Sbbe7ZDVEneeAfC9v4mupRdswhtkVyicGTcxAUt1VeOcDcegI615uLryw8VyJXk2rvpZdurPTweHjiJPnbtFJ2XW779D6RtLSGwiW3tkWGKMYVEGFH4dye5OSepJr5WUnNuUm23u2fVxioJRgkktkiZ3WJS7kIiDLMxAVQOpJOAB7mpSvot+iG9NXol8jx3xR8UEi3WuiYduQ1yw+Uf8AXFD94+jsNv8AdVute5QwDdp4jRfyLf8A7efT0WvmeHiMeo3hh9X/ADdF/hXX1enkeJ3FxLdSNNO7Syucs7kszH1JPP8Ah2r6CMVBKMUklslokfPSk5Nyk2292xkcbSsEjBZmOAqjJJ9gKbaSu9EhJNvlirvokbw8Laif+WQH/A0/xrm+sU+/4M7fqlb+Vf8AgS/zD/hFtR/55D/v4n+NH1in3/Bh9Urfyr/wJf5h/wAItqP/ADyH/fxP8aPrFPv+DD6pW/lX/gS/zD/hFtR/55D/AL+J/jR9Yp9/wYfVK38q/wDAl/mH/CLaj/zyH/fxP8aPrFPv+DD6pW/lX/gS/wAzGuraSylaCYbXQ4YZBxkA9Rx0NbxkpJSjszknB05OEtGtyCrINTRdKl1q9hsIPvzyKg9gfvMfZVyzewNY1aioQlVltFN/5L5uyNqVJ16kaMN5NL07v5K7Puixs49Ot47SAbYoEWNB6KgCj8cDk9zzX5lOTqSc5bybb9XqfqsIKlGNOGkYpJeiVi1UGh4N8ZvCxmjTXbdfmiAiuAP7hOI5D/uk7GPJIKdlNfU5ViLN4Wb396Hr1XzWq80+58lnGGuli4Lb3Z+n2ZfJ6Pya7HzlX1p8aFAHsHwf/wCPq8/64xf+jDXh5j8NP/E/yPey34qnovzPVdf8TWPhqLzLx/3jDKQpgyv9F/hX1dsKPUnivGo0J13amtOsnsv+D5LU9mtXhh1eb16RW7+X6vQ+efE3jS+8SsY5D5FqDlbdCdp9DI3Bkb64UfwqOtfT0MLDD6rWf8z/AEXRfj5ny9fFTxGj92HSK/Xv+XkchXccAUAFAHsPwf8A+Pi9/wCuUX/obV4WY/DT9X+SPey34qnovzZ6l4h8U2PhqPddvmVhlIEwZX98dFX/AG2wPTJ4rx6NCdd2gtFvJ7L/ADfkj2K1eGHV5vXpFbv/ACXmz548S+Mr7xK2yU+Tag5W3QnZ7FzwZG924H8KivqKGGhh9Y6y6ye/y7L+mz5evip4jR6Q6RW3z7v+kcnXacJsaVolxqpzGNkQPMjfdHsvdj7Dj1IrnqVY0t9X2W//AADro4edf4dI9ZPb5d2emaZo1vpK4hGXI+aRvvH/AOJH+yPxzXkVKsqj97bolsfQ0qEKC9xa9ZPd/wCS8katYnSFABQAUAFAHkPiT/kIz/7y/wDoC17lD+HH0f5s+WxX8afqvyRiV0nGfRfwZ8LGFH124XBkBitgf7ucSSD6keWp4PEg6EV8lmuI1WFg9ven6/Zj8lq/Vdj7HJ8NZPFzW94w9PtS+b0Xo+573Xyx9cFAEF1bRXkT286h4pVZHU9GVhgg/UGqjJwanF2aaafZoiUVOLhNXi0013T3Pi7xp4Wl8J6g9q2WgfLwSH+OMnjJ6bl+6445GQNpUn9GwuIWKpqotJLSS7S/ye6+7ofmWLw0sHVdJ/C9YPvH/NbP7+pyNdxwHR+H/E1z4aFwbML5tyioHYZ8sKxYsq9GY5wN3A64NclahHEcvPe0W3Zdbra/Reh10a8sOpezSvJJXfT5dzCubmW8lae4dpZXOWdyWYn3J/QdB0HFdMYqCUYJJLZLRHNKTm3KTbb3bIaokKACgAoA6LQPE114bW4+xBRLdIieYwyYwpJyqn5SxzwWyB1wT05K1CNdx9pe0W3Zdb9329Dro15YdS9na8klftbsu5hXFxLdSNNO7Syucs7kszH1JPP+HaulRUEoxSSWyWiRzSk5Nyk2292yKqJLdnLBBJvuIzOo6Ju2An/a4JI9hjPf0rOSk1aD5fO1/uNabjB3nHmXa9l89DsF8aiMBVtgqqMAB8AD0ACYFcP1Xq5/h/wT1VjktFTslsr/APAF/wCE3/6d/wDyJ/8AYUvqv978P+CP6/8A3P8Ayb/gB/wm/wD07/8AkT/7Cj6r/e/D/gh9f/uf+Tf8AP8AhN/+nf8A8if/AGFH1X+9+H/BD6//AHP/ACb/AIAf8Jv/ANO//kT/AOwo+q/3vw/4IfX/AO5/5N/wA/4Tf/p3/wDIn/2FH1X+9+H/AAQ+v/3P/Jv+AH/Cb/8ATv8A+RP/ALCj6r/e/D/gh9f/ALn/AJN/wDkNSvP7QuXuduzzCDtznGAB1wM9PSu+EfZxUL7HlVZ+1m6lrX6fKxv+DPC03ivUEtEysK/PPIBwkYPPtub7qDnk5I2hiOXFYiOEpuo/i2iu8v8AJbv7up04TDSxdVUo6RWs32j/AJvZff0Z9p2trFYwpbW6iOKFVRFHRVUYAH0A/wAa/OpSc5OcneTbbfds/TYxVOKhBWjFJJLokT1BYUAFAHK+MPCsHiyxa0lwkq5aCXHMb4/Mo3R17jBHzKpHdhcTLCVFUjrF6Sj3X+a3T7+Vzz8XhY4ym6ctJLWMv5X/AJPZrqvOx8aarpVxol1JZXiGOaFsMD+hB6FWGCpHBBBHBr9Dp1I1YqpTd4vZ/o+zXVH5rUpyozdKorSi7Nfqu6e6ZnVqZBQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQBoaXpdxrNzHZWaGSaVtqgfqSegUDJYngAEngVlUqRoxdSo7Rjq3/l5vouprTpyrTVKkryk7Jfq+yW7fRH2X4O8KQeEbFbSLDzPhp5ccu+O3cIvRB2GSfmZifz3FYmWLqc70itIx7L/ADe7f6WP0rCYWOCpqnHWT1lLu/8AJbJdvNs6uuA9AKACgAoAKAOE8c+Brfxfb5GIr2IHyZsde/lyY5KE9DyUJLLkFlb1MHjJYOVnrTfxR/Vdn+ez6NeTjcFHGRuvdqx+GX/tsu6f4PVdU/kXVdKutEuHs72Nopozgqf0IPQqRyGBII5BIr72nUjViqlJ3i9mvyfZrqj87qU50JOlVTjJbp/mu6fRrRmdWpkFABQAUAFABQAUAFABQAUAFABQAUAFABQBoaXpVzrNwlnZRtLNIcBV/Uk9AoHJYkADkkCsqlSNGLqVGoxW7/Rd2+i6mtOnOtJUqScpPZL832S6t6I+ufA3ga38H2+TiW9lA82XHAHXy488hAep4LkAnACqvweMxksXKy92nH4Y/q/P8tl1b/Q8Fgo4KN3rVl8Uv/bY9l+Ler6Jd7XlHrhQAUAFABQAUAFAHK+KvB9j4sg8q7XbKgPlTKBvjJ7f7SE9UPB6gq2GHfhsVUwkuanrF/FF7P8AyfZr8tDz8VhKeMjy1FaS+GS3j/mu6enz1PlDxT4L1DwnLsuk3QsT5c6AmNx25/hbHVGweuMr8x+5w+Kp4pXpu0lvF/Ev815r52Pz/E4Srg5Wqr3ek18L/wAn5P5XOSruOAKACgAoAKACgAoAKACgAoAKACgAoA63wt4M1DxXLstE2wqR5k75EaDvz/E2OiLk9M4XLDhxGKp4SN6j97pFfE/8l5v8Tvw2Eq4uVqStFbzfwr/N+S+dtz6u8KeDrHwjB5Vou6ZwPNnYDe59P9lAeiDgdSWbLH4bE4qpi5XnpFfDFbL/ADfdv8tD9AwuDp4OPLTV5P4pPd/5Lsl+L1OrrgPQCgAoAKACgAoAKACgAoAgurWG9iaC4RZYpBhkcBlYehB4NVGTg1KDaa2a0aIlGM04TScXumrp/I8M8U/BmOYtcaE4iY8m3lJ2/SOQ5K+yvkZ/jUV9Ph81atDFK/8Afjv/ANvR2fqrejPlMTk6d54R2/uSen/bst16O/qjwjVdEvtDl8i/hkt3HTeMA+6sMqw91JHvX09OrCsualJSXl09Vuvmj5SrSqUHyVouD81v6PZ/JmVWxiFABQAUAFABQAUAFABQBqaXol7rUvkWEMk7+iLwPdm+6o92IHvWNSrCguarJRXm9/Rbv5I2pUqleXJRi5PyW3q9l82e7+FvgykJW411xIRyLeInb9JJBgn3VMc9HIr5jEZq9YYVW/vy3/7dj09Xf0R9XhsnStPFu/8Aci9P+3pbv0VvVnulraw2MS29siwxRjCogCqo9ABgCvmZSlNuU23J7tu7Pq4xjTShBKMVskrJfInqCwoAKACgAoAKACgAoAKACgAoAKAK15ZW+oRmC6jSeJuqSKHX8mBGffrVwnKm+am3FrqnZ/gZzhGouSpFSj2aTX4nl2s/B3R9QJezMljIeynzI8/7jnd+CyKB6V7lLNa1PSolUXnpL71+qZ4NbKKFTWk5U35ax+5/o0eZal8GNYtCTaPDdr2Aby3P1WTCj/v4a9mnmtCXxqUH6cy+9a/geHUyjEQ/huM15Plf3PT8TirvwPrtjxLY3HHdI2kH/fUe5f1r0Y4vDz+GrD5vl/Ox5ksHiKfxUp/Jcy/8luYM+n3NrxNFJFj++jL/ADArqU4y+GUX6NP8mcjhKHxRkvVNfminVkFyDT7m64gikk/3EZv5A1DnGPxSivVpfmy1CUvhjJ+ib/JG9Z+B9dveIrG49i8bRj/vqQKv61yyxeHp/FVh8nf8I3OuGDxE/hpT+ceVf+TWO1034MaxdEG7eG0XuC3mOPoseVP/AH2K86pmtCH8NSm/Jcq+96/genTyjET/AIjjBeb5n9y0/E9M0b4OaRpxD3jSXrjsx8uPP+4h3fgZCD6V41XNa09KSVNeWsvvf6JHuUcooU9arlUfn7sfuWv3tnqNnY2+nRiC0jSCJeiRqEUfgoAz79TXhznKo+abcn3bu/xPehCNJclOKjFdEkl+BaqDQKACgAoAKACgAoA//9k='function Convert-Base64Bitmap2Picture&#123; param([Parameter(Mandatory=$true)]$Base64Text) $bitmap = New-Object System.Windows.Media.Imaging.BitmapImage $bitmap.BeginInit() $bitmap.StreamSource = [System.IO.MemoryStream][System.Convert]::FromBase64String($base64Text) $bitmap.EndInit() $bitmap.Freeze() $bitmap&#125;$xaml = @'&lt;Window xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" FontFamily=\"SegoeUI\" Foreground=\"White\" SizeToContent=\"Width\" Title=\"Join the PowerShell Conference EU 2016, April 20-22\"&gt; &lt;Grid&gt; &lt;Image Name=\"Img1\" Margin=\"20\" HorizontalAlignment=\"Center\"/&gt; &lt;TextBlock TextAlignment=\"Center\" VerticalAlignment=\"Center\" FontSize=\"40\" HorizontalAlignment=\"Center\"&gt; &lt;TextBlock.Effect&gt;&lt;DropShadowEffect ShadowDepth=\"4\" Color=\"DarkGray\" BlurRadius=\"4\"/&gt;&lt;/TextBlock.Effect&gt; Join the PowerShell&lt;LineBreak/&gt;Conference EU 2016!&lt;LineBreak/&gt;&lt;LineBreak/&gt;www.psconf.eu &lt;/TextBlock&gt; &lt;/Grid&gt;&lt;/Window&gt;'@$reader = [System.XML.XMLReader]::Create([System.IO.StringReader]$XAML)$window = [System.Windows.Markup.XAMLReader]::Load($reader)$image = $window.FindName('Img1') $image.Source = Convert-Base64Bitmap2Picture -Base64Text $Picture1$window.ShowDialog() 本文国际来源：Loading a Base64-encoded Picture into WPF Window","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 对图片编码","slug":"encoding-pictures","date":"2016-01-04T04:00:00.000Z","updated":"2017-03-17T15:26:26.660Z","comments":true,"path":"2016/01/04/encoding-pictures/","link":"","permalink":"http://blog.vichamp.com/2016/01/04/encoding-pictures/","excerpt":"如果您的脚本需要图标或图片等资源，您不需要另外发布这些资源。它们可以用 Base64 编码并且以纯文本的方式加到您的脚本中。 这个例子演示了如何将一个 JPG 图片转换为 Base64 编码的字符串： 12345678910111213141516171819202122232425function Convert-JPG2Base64 &#123; param ( [Parameter(Mandatory=$true)] [String] $Path ) $format = [System.Drawing.Imaging.ImageFormat]::Jpeg $image = [System.Drawing.Image]::FromFile($Path) $stream = New-Object -TypeName System.IO.MemoryStream $image.Save($stream, $format) $bytes = [Byte[]]($stream.ToArray()) [System.Convert]::ToBase64String($bytes, 'InsertLineBreaks')&#125;# find a random picture$picture = Get-ChildItem $env:windir\\Web\\Wallpaper *.jpg -Recurse | Select-Object -First 1$pictureString = Convert-JPG2Base64 -Path $picture.FullName$pictureString Convert-JPG2Base64 函数接受一个 JPG 图片路径作为参数并且返回 Base64 编码后的图片。在这个例子中，我们使用 Windows 文件夹中的第一个 JPG 墙纸。请确保您的 Windows 文件夹中包含图片，或者把 JPG 图片的文件夹改为您想要的文件夹。 返回的文本可以嵌入一段脚本中。而且，返回的 Base64 文本可能会非常大，由图片的尺寸和质量决定。 明天，我们将演示如何将 Base64 编码后的图片加载到内存中，并在自己的 WPF 窗口中显示。","text":"如果您的脚本需要图标或图片等资源，您不需要另外发布这些资源。它们可以用 Base64 编码并且以纯文本的方式加到您的脚本中。 这个例子演示了如何将一个 JPG 图片转换为 Base64 编码的字符串： 12345678910111213141516171819202122232425function Convert-JPG2Base64 &#123; param ( [Parameter(Mandatory=$true)] [String] $Path ) $format = [System.Drawing.Imaging.ImageFormat]::Jpeg $image = [System.Drawing.Image]::FromFile($Path) $stream = New-Object -TypeName System.IO.MemoryStream $image.Save($stream, $format) $bytes = [Byte[]]($stream.ToArray()) [System.Convert]::ToBase64String($bytes, 'InsertLineBreaks')&#125;# find a random picture$picture = Get-ChildItem $env:windir\\Web\\Wallpaper *.jpg -Recurse | Select-Object -First 1$pictureString = Convert-JPG2Base64 -Path $picture.FullName$pictureString Convert-JPG2Base64 函数接受一个 JPG 图片路径作为参数并且返回 Base64 编码后的图片。在这个例子中，我们使用 Windows 文件夹中的第一个 JPG 墙纸。请确保您的 Windows 文件夹中包含图片，或者把 JPG 图片的文件夹改为您想要的文件夹。 返回的文本可以嵌入一段脚本中。而且，返回的 Base64 文本可能会非常大，由图片的尺寸和质量决定。 明天，我们将演示如何将 Base64 编码后的图片加载到内存中，并在自己的 WPF 窗口中显示。 本文国际来源：Encoding Pictures","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 Base64 编解码文本","slug":"encode-and-decode-text-as-base64","date":"2016-01-01T04:00:00.000Z","updated":"2017-03-17T15:26:26.660Z","comments":true,"path":"2016/01/01/encode-and-decode-text-as-base64/","link":"","permalink":"http://blog.vichamp.com/2016/01/01/encode-and-decode-text-as-base64/","excerpt":"以下是将文本用 Base64 编码的简单方法： 1234#requires -Version 1$text = 'Hello World!'[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($text), 'InsertLineBreaks') 结果字符串看起来大概如下： SABlAGwAbABvACAAVwBvAHIAbABkACEA 文本编码可以用于简易的混淆文本，或是保护文本防止不小心被错误地格式化。例如 PowerShell.exe 可运行 Base64 编码过的命令。以下是一个例子（请打开您机器的声音）： 1powershell.exe -EncodedCommand ZgBvAHIAKAAkAHgAIAA9ACAAMQAwADAAMAA7ACAAJAB4ACAALQBsAHQAIAAxADIAMAAwADAAOwAgACQAeAArAD0AMQAwADAAMAApACAAewAgAFsAUwB5AHMAdABlAG0ALgBDAG8AbgBzAG8AbABlAF0AOgA6AEIAZQBlAHAAKAAkAHgALAAgADMAMAAwACkAOwAgACIAJAB4ACAASAB6ACIAfQA= 要解码一个 Base64 字符串，您可以使用以下代码。 1234#requires -Version 1$text = 'SABlAGwAbABvACAAVwBvAHIAbABkACEA'[Text.Encoding]::Unicode.GetString([Convert]::FromBase64String($text)) 您也可以使用这段代码来解码上面那段编码后的命令，看看它做了什么。只需要用编码过的命令替换掉 $test。","text":"以下是将文本用 Base64 编码的简单方法： 1234#requires -Version 1$text = 'Hello World!'[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($text), 'InsertLineBreaks') 结果字符串看起来大概如下： SABlAGwAbABvACAAVwBvAHIAbABkACEA 文本编码可以用于简易的混淆文本，或是保护文本防止不小心被错误地格式化。例如 PowerShell.exe 可运行 Base64 编码过的命令。以下是一个例子（请打开您机器的声音）： 1powershell.exe -EncodedCommand ZgBvAHIAKAAkAHgAIAA9ACAAMQAwADAAMAA7ACAAJAB4ACAALQBsAHQAIAAxADIAMAAwADAAOwAgACQAeAArAD0AMQAwADAAMAApACAAewAgAFsAUwB5AHMAdABlAG0ALgBDAG8AbgBzAG8AbABlAF0AOgA6AEIAZQBlAHAAKAAkAHgALAAgADMAMAAwACkAOwAgACIAJAB4ACAASAB6ACIAfQA= 要解码一个 Base64 字符串，您可以使用以下代码。 1234#requires -Version 1$text = 'SABlAGwAbABvACAAVwBvAHIAbABkACEA'[Text.Encoding]::Unicode.GetString([Convert]::FromBase64String($text)) 您也可以使用这段代码来解码上面那段编码后的命令，看看它做了什么。只需要用编码过的命令替换掉 $test。 本文国际来源：Encode and Decode Text as Base64","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理 Windows 防火墙","slug":"managing-windows-firewall","date":"2015-12-31T04:00:00.000Z","updated":"2017-03-17T15:26:26.645Z","comments":true,"path":"2015/12/31/managing-windows-firewall/","link":"","permalink":"http://blog.vichamp.com/2015/12/31/managing-windows-firewall/","excerpt":"从 Windows 8 和 Server 2012 开始，有一个 Cmdlet 可以在多个配置中启用客户端防火墙： 1Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled True 在之前的操作系统中，您需要使用依靠 netsh.exe： 1netsh advfirewall set allprofiles state on","text":"从 Windows 8 和 Server 2012 开始，有一个 Cmdlet 可以在多个配置中启用客户端防火墙： 1Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled True 在之前的操作系统中，您需要使用依靠 netsh.exe： 1netsh advfirewall set allprofiles state on 本文国际来源：Managing Windows Firewall","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找递归的 AD 成员","slug":"finding-recursive-ad-memberships","date":"2015-12-30T04:00:00.000Z","updated":"2017-03-17T15:26:26.645Z","comments":true,"path":"2015/12/30/finding-recursive-ad-memberships/","link":"","permalink":"http://blog.vichamp.com/2015/12/30/finding-recursive-ad-memberships/","excerpt":"在 AD 中，有一个看起来很奇怪的过滤器：1.2.840.113556.1.4.1941。它被称为“链式匹配规则”，可以用来快速查找嵌套的成员。 您所需的是某个成员的 DN。然后，您可以像这样使用它： 1234#requires -Version 1 -Modules ActiveDirectory $DN = 'place DN here!'Get-ADGroup -LDAPFilter \"(member:1.2.840.113556.1.4.1941:=$($DN))\" Since this is a native LDAP filter, you can even use it without the ActiveDirectory module, resorting to native .NET methods:由于它是一个原生的 LDAP 过滤器，您甚至可以在没有 ActiveDirectory 模块的情况下以 .NET 原生的方式使用它。 123456789101112131415161718$DN = 'place DN here!'$strFilter = \"(member:1.2.840.113556.1.4.1941:=$DN)\"$objDomain = New-Object System.DirectoryServices.DirectoryEntry('LDAP://rootDSE')$objSearcher = New-Object System.DirectoryServices.DirectorySearcher$objSearcher.SearchRoot = \"LDAP://$($objDomain.rootDomainNamingContext)\"$objSearcher.PageSize = 1000$objSearcher.Filter = $strFilter$objSearcher.SearchScope = 'Subtree'$colProplist = 'name'foreach ($i in $colPropList)&#123; $null = $objSearcher.PropertiesToLoad.Add($i)&#125;$colResults = $objSearcher.FindAll()foreach ($objResult in $colResults)&#123; $objItem = $objResult.Properties $objItem.name&#125;","text":"在 AD 中，有一个看起来很奇怪的过滤器：1.2.840.113556.1.4.1941。它被称为“链式匹配规则”，可以用来快速查找嵌套的成员。 您所需的是某个成员的 DN。然后，您可以像这样使用它： 1234#requires -Version 1 -Modules ActiveDirectory $DN = 'place DN here!'Get-ADGroup -LDAPFilter \"(member:1.2.840.113556.1.4.1941:=$($DN))\" Since this is a native LDAP filter, you can even use it without the ActiveDirectory module, resorting to native .NET methods:由于它是一个原生的 LDAP 过滤器，您甚至可以在没有 ActiveDirectory 模块的情况下以 .NET 原生的方式使用它。 123456789101112131415161718$DN = 'place DN here!'$strFilter = \"(member:1.2.840.113556.1.4.1941:=$DN)\"$objDomain = New-Object System.DirectoryServices.DirectoryEntry('LDAP://rootDSE')$objSearcher = New-Object System.DirectoryServices.DirectorySearcher$objSearcher.SearchRoot = \"LDAP://$($objDomain.rootDomainNamingContext)\"$objSearcher.PageSize = 1000$objSearcher.Filter = $strFilter$objSearcher.SearchScope = 'Subtree'$colProplist = 'name'foreach ($i in $colPropList)&#123; $null = $objSearcher.PropertiesToLoad.Add($i)&#125;$colResults = $objSearcher.FindAll()foreach ($objResult in $colResults)&#123; $objItem = $objResult.Properties $objItem.name&#125; 本文国际来源：Finding Recursive AD Memberships","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 清除回收站","slug":"clearing-recycle-bin","date":"2015-12-29T04:00:00.000Z","updated":"2017-03-17T15:26:26.645Z","comments":true,"path":"2015/12/29/clearing-recycle-bin/","link":"","permalink":"http://blog.vichamp.com/2015/12/29/clearing-recycle-bin/","excerpt":"在 PowerShell 5.0 之前，要清除回收站得手工删除每个驱动器根目录下隐藏的 $Recycle.Bin 文件夹里的内容。 有一些作者推荐使用名为 Shell.Application 的 COM 对象。它不一定可靠，因为回收站不一定可见，取决于资源管理器的设置。 幸运的事，PowerShell 5.0 终于提供了 Clear-RecycleBin Cmdlet。","text":"在 PowerShell 5.0 之前，要清除回收站得手工删除每个驱动器根目录下隐藏的 $Recycle.Bin 文件夹里的内容。 有一些作者推荐使用名为 Shell.Application 的 COM 对象。它不一定可靠，因为回收站不一定可见，取决于资源管理器的设置。 幸运的事，PowerShell 5.0 终于提供了 Clear-RecycleBin Cmdlet。 本文国际来源：Clearing Recycle Bin","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 强制用户修改密码","slug":"force-user-to-change-password","date":"2015-12-28T04:00:00.000Z","updated":"2017-03-17T15:26:26.629Z","comments":true,"path":"2015/12/28/force-user-to-change-password/","link":"","permalink":"http://blog.vichamp.com/2015/12/28/force-user-to-change-password/","excerpt":"使用这段代码片段可以强制用户改变他/她的密码： #requires -Version 1 -Modules ActiveDirectory Set-ADUser -Identity username -ChangePasswordAtNextLogon $true","text":"使用这段代码片段可以强制用户改变他/她的密码： #requires -Version 1 -Modules ActiveDirectory Set-ADUser -Identity username -ChangePasswordAtNextLogon $true 本文国际来源：Force User to Change Password","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 自动获取重要的支持响应信息","slug":"get-automated-first-level-support-response","date":"2015-12-25T04:00:00.000Z","updated":"2017-03-17T15:26:26.629Z","comments":true,"path":"2015/12/25/get-automated-first-level-support-response/","link":"","permalink":"http://blog.vichamp.com/2015/12/25/get-automated-first-level-support-response/","excerpt":"Here is a fun function to provide you with a good first level support response in case everyone is off for Christmas:这是一个有趣的函数，当所有人都下班去过圣诞时将给您提供重要的支持响应信息。 #requires -Version 3 function Get-FirstLevelSupportResponse { $url = &apos;http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl&apos; $ProgressPreference = &apos;SilentlyContinue&apos; $page = Invoke-WebRequest -Uri $url -UseBasicParsing $pattern = &apos;(?s)&lt;br&gt;&lt;font size\\s?=\\s?&quot;\\+2&quot;&gt;(.+)&lt;/font&apos; if ($page.Content -match $pattern) { $matches[1] } } 您需要 Internet 连接来运行这段脚本。","text":"Here is a fun function to provide you with a good first level support response in case everyone is off for Christmas:这是一个有趣的函数，当所有人都下班去过圣诞时将给您提供重要的支持响应信息。 #requires -Version 3 function Get-FirstLevelSupportResponse { $url = &apos;http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl&apos; $ProgressPreference = &apos;SilentlyContinue&apos; $page = Invoke-WebRequest -Uri $url -UseBasicParsing $pattern = &apos;(?s)&lt;br&gt;&lt;font size\\s?=\\s?&quot;\\+2&quot;&gt;(.+)&lt;/font&apos; if ($page.Content -match $pattern) { $matches[1] } } 您需要 Internet 连接来运行这段脚本。 本文国际来源：Get Automated First Level Support Response","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查询当前登录的用户名","slug":"findinglogged-on-user","date":"2015-12-24T04:00:00.000Z","updated":"2017-03-17T15:26:26.613Z","comments":true,"path":"2015/12/24/findinglogged-on-user/","link":"","permalink":"http://blog.vichamp.com/2015/12/24/findinglogged-on-user/","excerpt":"有两种方式可以查询当前登录的用户： # User logged on to a physical box Get-WmiObject -Class Win32_ComputerSystem | Select-object -ExpandProperty UserName # Owners of explorer.exe processes (desktop is an Explorer process) Get-WmiObject -Class Win32_Process -Filter &apos;Name=&quot;explorer.exe&quot;&apos; | ForEach-Object { $owner = $_.GetOwner() &apos;{0}\\{1}&apos; -f $owner.Domain, $owner.User } | Sort-Object -Unique 两种使用 Get-WmiObject 的方式都支持本地和远程方式调用。","text":"有两种方式可以查询当前登录的用户： # User logged on to a physical box Get-WmiObject -Class Win32_ComputerSystem | Select-object -ExpandProperty UserName # Owners of explorer.exe processes (desktop is an Explorer process) Get-WmiObject -Class Win32_Process -Filter &apos;Name=&quot;explorer.exe&quot;&apos; | ForEach-Object { $owner = $_.GetOwner() &apos;{0}\\{1}&apos; -f $owner.Domain, $owner.User } | Sort-Object -Unique 两种使用 Get-WmiObject 的方式都支持本地和远程方式调用。 本文国际来源：Finding Logged On User","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取操作系统清单","slug":"get-list-of-operating-systems","date":"2015-12-23T04:00:00.000Z","updated":"2017-03-17T15:26:26.613Z","comments":true,"path":"2015/12/23/get-list-of-operating-systems/","link":"","permalink":"http://blog.vichamp.com/2015/12/23/get-list-of-operating-systems/","excerpt":"如果您的老板需要一份您 AD 中所有计算机的操作系统清单，这也许是个好办法： #requires -Version 1 -Modules ActiveDirectory $max = 100 $os = Get-ADComputer -Filter * -Properties OperatingSystem -ResultPageSize $max | Group-Object -Property OperatingSystem -NoElement | Select-object -ExpandProperty Name | ForEach-Object { &apos;&quot;{0}&quot;&apos; -f $_ } $list = $os -join &apos;,&apos; $list # copy list to clipboard $list | clip 该脚本将从您的 AD 中获取计算机账户并将它们根据操作系统分组，然后将它整理成一个清单。请注意使用 PageSize 因为在一个大型的组织中获取所有计算机信息可能会花费很长时间。","text":"如果您的老板需要一份您 AD 中所有计算机的操作系统清单，这也许是个好办法： #requires -Version 1 -Modules ActiveDirectory $max = 100 $os = Get-ADComputer -Filter * -Properties OperatingSystem -ResultPageSize $max | Group-Object -Property OperatingSystem -NoElement | Select-object -ExpandProperty Name | ForEach-Object { &apos;&quot;{0}&quot;&apos; -f $_ } $list = $os -join &apos;,&apos; $list # copy list to clipboard $list | clip 该脚本将从您的 AD 中获取计算机账户并将它们根据操作系统分组，然后将它整理成一个清单。请注意使用 PageSize 因为在一个大型的组织中获取所有计算机信息可能会花费很长时间。 本文国际来源：Get List of Operating Systems","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 根据 OU 分析操作系统","slug":"analyze-operating-system-by-organizational-unit","date":"2015-12-22T04:00:00.000Z","updated":"2017-03-17T15:26:26.598Z","comments":true,"path":"2015/12/22/analyze-operating-system-by-organizational-unit/","link":"","permalink":"http://blog.vichamp.com/2015/12/22/analyze-operating-system-by-organizational-unit/","excerpt":"以下是一个快捷的脚本，扫描 Active Directory 中的所有 OU，得到所有的计算机账户，然后将每个 OU 的信息按照操作系统分组： #requires -Version 2 -Modules ActiveDirectory Get-ADOrganizationalUnit -Filter * | ForEach-Object { $OU = $_ Get-ADComputer -Filter * -SearchBase $OU.DistinguishedName -SearchScope SubTree -Properties Enabled, OperatingSystem | Where-Object { $_.Enabled -eq $true } | Group-Object -Property OperatingSystem -NoElement | Select-Object -Property Count, Name, OU, OUDN | ForEach-Object { $_.OU = $OU.Name $_.OUDN = $OU.DistinguishedName $_ } } | Out-GridView","text":"以下是一个快捷的脚本，扫描 Active Directory 中的所有 OU，得到所有的计算机账户，然后将每个 OU 的信息按照操作系统分组： #requires -Version 2 -Modules ActiveDirectory Get-ADOrganizationalUnit -Filter * | ForEach-Object { $OU = $_ Get-ADComputer -Filter * -SearchBase $OU.DistinguishedName -SearchScope SubTree -Properties Enabled, OperatingSystem | Where-Object { $_.Enabled -eq $true } | Group-Object -Property OperatingSystem -NoElement | Select-Object -Property Count, Name, OU, OUDN | ForEach-Object { $_.OU = $OU.Name $_.OUDN = $OU.DistinguishedName $_ } } | Out-GridView 本文国际来源：Analyze Operating System by Organizational Unit","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 理解 -f 操作符","slug":"understanding-the-f-operator","date":"2015-11-25T04:00:00.000Z","updated":"2017-03-17T15:26:26.598Z","comments":true,"path":"2015/11/25/understanding-the-f-operator/","link":"","permalink":"http://blog.vichamp.com/2015/11/25/understanding-the-f-operator/","excerpt":"您也许已经遇到过 -f 操作符并且很好奇它做了什么。它是一个格式化操作符并且提供了一种相当简单的方法来操作数组元素并创建字符串。 让我们从一个值数组开始，比如这个： $info = &apos;PowerShell&apos;, $PSVersionTable.PSVersion.Major, $pshome 您可以通过序号访问单个数组元素。 PS&gt; $info[0] PowerShell PS&gt; $info[1] 4 PS&gt; $info[2] C:\\Windows\\System32\\WindowsPowerShell\\v1.0 如果您需要将该数组的元素合并为一个字符串，这时候 -f 操作符就能够大显身手了。它能够使用相同的序号来读取数组元素并将它们组成一个字符串。以下是一些例子，它们使用 $info 中的信息来组成不同的字符串： PS&gt; &apos;{0} Version is {1}. Location &quot;{2}&apos; -f $info PowerShell Version is 4. Location &quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0 PS&gt; &apos;{0} {1}&apos; -f $info PowerShell 4 PS&gt; &apos;{0} {1:0.0}&apos; -f $info PowerShell 4.0 PS&gt; &apos;{0}: {2}&apos; -f $info PowerShell: C:\\Windows\\System32\\WindowsPowerShell\\v1.0","text":"您也许已经遇到过 -f 操作符并且很好奇它做了什么。它是一个格式化操作符并且提供了一种相当简单的方法来操作数组元素并创建字符串。 让我们从一个值数组开始，比如这个： $info = &apos;PowerShell&apos;, $PSVersionTable.PSVersion.Major, $pshome 您可以通过序号访问单个数组元素。 PS&gt; $info[0] PowerShell PS&gt; $info[1] 4 PS&gt; $info[2] C:\\Windows\\System32\\WindowsPowerShell\\v1.0 如果您需要将该数组的元素合并为一个字符串，这时候 -f 操作符就能够大显身手了。它能够使用相同的序号来读取数组元素并将它们组成一个字符串。以下是一些例子，它们使用 $info 中的信息来组成不同的字符串： PS&gt; &apos;{0} Version is {1}. Location &quot;{2}&apos; -f $info PowerShell Version is 4. Location &quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0 PS&gt; &apos;{0} {1}&apos; -f $info PowerShell 4 PS&gt; &apos;{0} {1:0.0}&apos; -f $info PowerShell 4.0 PS&gt; &apos;{0}: {2}&apos; -f $info PowerShell: C:\\Windows\\System32\\WindowsPowerShell\\v1.0 本文国际来源：Understanding the –f Operator","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 为大量文件建立拷贝备份","slug":"creating-backup-copies-of-many-files","date":"2015-11-24T04:00:00.000Z","updated":"2017-03-17T15:26:26.598Z","comments":true,"path":"2015/11/24/creating-backup-copies-of-many-files/","link":"","permalink":"http://blog.vichamp.com/2015/11/24/creating-backup-copies-of-many-files/","excerpt":"PowerShell 可以为您的文件建立备份。您所需要调整的只是需要备份的文件类型，以及您需要备份的目标文件扩展名。 这个例子将影响（直接）存储在您的用户目录下的 PowerShell 脚本。也许这个文件夹下并没有这类文件，所以要么拷入一个文件来测试这个脚本，要么指定一个不同的文件夹路径。 每个脚本将被备份到相同的主文件名，而扩展名为“.ps1_old”的文件中。 当您改变 $Recurese 的值时，脚本将会为您的用户文件夹下的所有 PowerShell 创建备份。 #requires -Version 1 $ExtensionToBackup = &apos;.ps1&apos; $BackupExtension = &apos;.ps1_old&apos; $FolderToProcess = $HOME $Recurse = $false Get-ChildItem -Path $FolderToProcess -Filter $ExtensionToBackup -Recurse:$Recurse | ForEach-Object { $newpath = [System.IO.Path]::ChangeExtension($_.FullName, $BackupExtension) Copy-Item -Path $_.FullName -Destination $newpath }","text":"PowerShell 可以为您的文件建立备份。您所需要调整的只是需要备份的文件类型，以及您需要备份的目标文件扩展名。 这个例子将影响（直接）存储在您的用户目录下的 PowerShell 脚本。也许这个文件夹下并没有这类文件，所以要么拷入一个文件来测试这个脚本，要么指定一个不同的文件夹路径。 每个脚本将被备份到相同的主文件名，而扩展名为“.ps1_old”的文件中。 当您改变 $Recurese 的值时，脚本将会为您的用户文件夹下的所有 PowerShell 创建备份。 #requires -Version 1 $ExtensionToBackup = &apos;.ps1&apos; $BackupExtension = &apos;.ps1_old&apos; $FolderToProcess = $HOME $Recurse = $false Get-ChildItem -Path $FolderToProcess -Filter $ExtensionToBackup -Recurse:$Recurse | ForEach-Object { $newpath = [System.IO.Path]::ChangeExtension($_.FullName, $BackupExtension) Copy-Item -Path $_.FullName -Destination $newpath } 本文国际来源：Creating Backup Copies of Many Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将结果通过管道直接传给 Office Word","slug":"piping-results-straight-into-office-word","date":"2015-11-23T04:00:00.000Z","updated":"2017-03-17T15:26:26.598Z","comments":true,"path":"2015/11/23/piping-results-straight-into-office-word/","link":"","permalink":"http://blog.vichamp.com/2015/11/23/piping-results-straight-into-office-word/","excerpt":"只需要几行代码，您就可以实现一个 Out-OfficeWord 指令。它接受传入的数据并将它们插入一个新的 Word 文档中（假设 Word 已经安装）。 #requires -Version 1 function Out-OfficeWord { param ( $Font = &apos;Courier&apos;, $FontSize = 12, $Width = 80, [switch] $Landscape ) $Text = $Input | Out-String -Width $Width $WordObj = New-Object -ComObject Word.Application $document = $WordObj.Documents.Add() $document.PageSetup.Orientation = [Int][bool]$Landscape $document.Content.Text = $Text $document.Content.Font.Size = $FontSize $document.Content.Font.Name = $Font $document.Paragraphs | ForEach-Object { $_.SpaceAfter = 0 } $WordObj.Visible = $true } 要在 Word 中建立一个正在运行中的进程列表，只需要运行这段代码： Get-Process | Out-OfficeWord -Landscape -Font Consolas -FontSize 8 接下来，您可以将结果另存为 PDF、改进格式，或打印出来。","text":"只需要几行代码，您就可以实现一个 Out-OfficeWord 指令。它接受传入的数据并将它们插入一个新的 Word 文档中（假设 Word 已经安装）。 #requires -Version 1 function Out-OfficeWord { param ( $Font = &apos;Courier&apos;, $FontSize = 12, $Width = 80, [switch] $Landscape ) $Text = $Input | Out-String -Width $Width $WordObj = New-Object -ComObject Word.Application $document = $WordObj.Documents.Add() $document.PageSetup.Orientation = [Int][bool]$Landscape $document.Content.Text = $Text $document.Content.Font.Size = $FontSize $document.Content.Font.Name = $Font $document.Paragraphs | ForEach-Object { $_.SpaceAfter = 0 } $WordObj.Visible = $true } 要在 Word 中建立一个正在运行中的进程列表，只需要运行这段代码： Get-Process | Out-OfficeWord -Landscape -Font Consolas -FontSize 8 接下来，您可以将结果另存为 PDF、改进格式，或打印出来。 本文国际来源：Piping Results Straight Into Office Word","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从 WMI 中搜索有用的信息","slug":"search-wmi-for-useful-information","date":"2015-11-20T04:00:00.000Z","updated":"2017-03-17T15:26:26.582Z","comments":true,"path":"2015/11/20/search-wmi-for-useful-information/","link":"","permalink":"http://blog.vichamp.com/2015/11/20/search-wmi-for-useful-information/","excerpt":"WMI 是一个很好的信息源，但要找到正确的 WMI 类来查询并不总是那么容易。 一下是一个小小的搜索工具：它提示输入一个关键字，然后根据在 WMI 中搜索所有合适的关键字。结果将显示在一个网格视图窗口中，然后您可以选择一个类并按下“确定”按钮，该工具将查询出匹配的结果： #requires -Version 3 function Search-WMI { param([Parameter(Mandatory=$true)]$Keyword) Get-WmiObject -Class &quot;Win32_*$Keyword*&quot; -List | Where-Object { $_.Properties.Count -gt 6 } | Where-Object { $_.Name -notlike &apos;Win32_Perf*&apos; } | Sort-Object -Property Name | Select-Object -Property @{Name=&apos;Select one of these classes&apos;; Expression={$_.Name }} | Out-GridView -Title &apos;Choose one&apos; -OutputMode Single | ForEach-Object { Get-WmiObject -Class $_.&apos;Select one of these classes&apos; | Out-GridView } } Search-WMI -Keyword network","text":"WMI 是一个很好的信息源，但要找到正确的 WMI 类来查询并不总是那么容易。 一下是一个小小的搜索工具：它提示输入一个关键字，然后根据在 WMI 中搜索所有合适的关键字。结果将显示在一个网格视图窗口中，然后您可以选择一个类并按下“确定”按钮，该工具将查询出匹配的结果： #requires -Version 3 function Search-WMI { param([Parameter(Mandatory=$true)]$Keyword) Get-WmiObject -Class &quot;Win32_*$Keyword*&quot; -List | Where-Object { $_.Properties.Count -gt 6 } | Where-Object { $_.Name -notlike &apos;Win32_Perf*&apos; } | Sort-Object -Property Name | Select-Object -Property @{Name=&apos;Select one of these classes&apos;; Expression={$_.Name }} | Out-GridView -Title &apos;Choose one&apos; -OutputMode Single | ForEach-Object { Get-WmiObject -Class $_.&apos;Select one of these classes&apos; | Out-GridView } } Search-WMI -Keyword network 本文国际来源：Search WMI for Useful Information","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用网格窗口作为一个通用的对话框","slug":"use-a-grid-view-window-as-a-universal-dialog","date":"2015-11-19T04:00:00.000Z","updated":"2017-03-17T15:26:26.582Z","comments":true,"path":"2015/11/19/use-a-grid-view-window-as-a-universal-dialog/","link":"","permalink":"http://blog.vichamp.com/2015/11/19/use-a-grid-view-window-as-a-universal-dialog/","excerpt":"Out-GridView 不止可以用于显示结果。您可以将它转换为一个很有用的通用对话框。 假设您希望显示一系列运行中的程序，然后结束掉选中的程序。传统的方式大概是这样： Get-Process | Where-Object { $_.MainWindowTitle } | Out-GridView -OutputMode Single | Stop-Process -WhatIf 当您将源对象通过管道传给 Out-GridView 命令时，用户将能看到所有的普通对象属性。这也许没问题，但如果您希望用户体验更好一些，您可以使用一些更高级的 PowerShell 技巧： #requires -Version 3 $prompt = &apos;Choose the process you want to terminate:&apos; Get-Process | Where-Object { $_.MainWindowTitle } | ForEach-Object { New-Object PSObject -Property @{$prompt = $_ | Add-Member -MemberType ScriptMethod -Name ToString -Force -Value { &apos;{0} [{1}]&apos; -f $this.Description, $this.Id } -PassThru } } | Out-GridView -OutputMode Single -Title $prompt | Select-Object -ExpandProperty $prompt | Stop-Process -WhatIf 请先看用户体验：该网格窗口不再让人感到疑惑。现在让我们检查一下如何实现这种用户体验。 在结果通过管道传给 Out-GridView 之前，它们被重新打包成一个只有单个属性的对象。该属性包含了您在 $prompt 中定义的名称，所以它基本上就是您想呈现给用户的信息。 当您做完这些并将包裹后的对象通过管道传给 Out-GridView 后，您可以看到该对象的文字呈现。要控制文字呈现的方式，我们将它的 ToString() 方法用一个显示您期望的值的方法来覆盖。在这个例子里，它显示进程的描述和进程的 ID。 最后，被用户选中的对象将再被拆包。通过这种方法，您可以获取源对象。","text":"Out-GridView 不止可以用于显示结果。您可以将它转换为一个很有用的通用对话框。 假设您希望显示一系列运行中的程序，然后结束掉选中的程序。传统的方式大概是这样： Get-Process | Where-Object { $_.MainWindowTitle } | Out-GridView -OutputMode Single | Stop-Process -WhatIf 当您将源对象通过管道传给 Out-GridView 命令时，用户将能看到所有的普通对象属性。这也许没问题，但如果您希望用户体验更好一些，您可以使用一些更高级的 PowerShell 技巧： #requires -Version 3 $prompt = &apos;Choose the process you want to terminate:&apos; Get-Process | Where-Object { $_.MainWindowTitle } | ForEach-Object { New-Object PSObject -Property @{$prompt = $_ | Add-Member -MemberType ScriptMethod -Name ToString -Force -Value { &apos;{0} [{1}]&apos; -f $this.Description, $this.Id } -PassThru } } | Out-GridView -OutputMode Single -Title $prompt | Select-Object -ExpandProperty $prompt | Stop-Process -WhatIf 请先看用户体验：该网格窗口不再让人感到疑惑。现在让我们检查一下如何实现这种用户体验。 在结果通过管道传给 Out-GridView 之前，它们被重新打包成一个只有单个属性的对象。该属性包含了您在 $prompt 中定义的名称，所以它基本上就是您想呈现给用户的信息。 当您做完这些并将包裹后的对象通过管道传给 Out-GridView 后，您可以看到该对象的文字呈现。要控制文字呈现的方式，我们将它的 ToString() 方法用一个显示您期望的值的方法来覆盖。在这个例子里，它显示进程的描述和进程的 ID。 最后，被用户选中的对象将再被拆包。通过这种方法，您可以获取源对象。 本文国际来源：Use a Grid View Window as a Universal Dialog","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 以不同的格式输出文件大小","slug":"outputting-file-sizes-in-different-formats","date":"2015-11-18T04:00:00.000Z","updated":"2017-03-17T15:26:26.582Z","comments":true,"path":"2015/11/18/outputting-file-sizes-in-different-formats/","link":"","permalink":"http://blog.vichamp.com/2015/11/18/outputting-file-sizes-in-different-formats/","excerpt":"当您将一个数值赋给一个变量时，您也许希望按不同的单位显示该数字。字节的方式很清晰，但是有些时候以 KB 或 MB 的方式显示更合适。 以下是一个聪明的技巧，它用一个更多样化的版本覆盖了内置的 ToString() 方法。该方法包括了单位，您希望的位数，以及后缀文字。通过这种方式，您可以根据需要按各种格式显示数字。 变量的内容并没有被改变，所以变量仍然存储着 Integer 数值。您可以安全地用于排序及和其它值比较： #requires -Version 1 $a = 1257657656 $a = $a | Add-Member -MemberType ScriptMethod -Name tostring -Force -Value { param($Unit = 1MB, $Digits=1, $Suffix=&apos; MB&apos;) &quot;{0:n$Digits}$Suffix&quot; -f ($this/($Unit)) } -PassThru 以下是多种使用 $a 的例子： PS&gt; $a 1.199,4 MB PS&gt; $a.ToString(1GB, 0, &apos; GB&apos;) 1 GB PS&gt; $a.ToString(1KB, 2, &apos; KB&apos;) 1.228.181,30 KB PS&gt; $a -eq 1257657656 True PS&gt; $a -eq 1257657657 False PS&gt; $a.GetType().Name Int32","text":"当您将一个数值赋给一个变量时，您也许希望按不同的单位显示该数字。字节的方式很清晰，但是有些时候以 KB 或 MB 的方式显示更合适。 以下是一个聪明的技巧，它用一个更多样化的版本覆盖了内置的 ToString() 方法。该方法包括了单位，您希望的位数，以及后缀文字。通过这种方式，您可以根据需要按各种格式显示数字。 变量的内容并没有被改变，所以变量仍然存储着 Integer 数值。您可以安全地用于排序及和其它值比较： #requires -Version 1 $a = 1257657656 $a = $a | Add-Member -MemberType ScriptMethod -Name tostring -Force -Value { param($Unit = 1MB, $Digits=1, $Suffix=&apos; MB&apos;) &quot;{0:n$Digits}$Suffix&quot; -f ($this/($Unit)) } -PassThru 以下是多种使用 $a 的例子： PS&gt; $a 1.199,4 MB PS&gt; $a.ToString(1GB, 0, &apos; GB&apos;) 1 GB PS&gt; $a.ToString(1KB, 2, &apos; KB&apos;) 1.228.181,30 KB PS&gt; $a -eq 1257657656 True PS&gt; $a -eq 1257657657 False PS&gt; $a.GetType().Name Int32 本文国际来源：Outputting File Sizes in Different Formats","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 转换日期、时间格式","slug":"converting-date-time-formats","date":"2015-11-17T04:00:00.000Z","updated":"2017-03-17T15:26:26.579Z","comments":true,"path":"2015/11/17/converting-date-time-formats/","link":"","permalink":"http://blog.vichamp.com/2015/11/17/converting-date-time-formats/","excerpt":"以下是一个简单的 PowerShell 过滤器，它能够将任意的 DateTime 对象转换为您所需要的日期/时间格式： #requires -Version 1 filter Convert-DateTimeFormat { param($OutputFormat=&apos;yyyy-MM-dd HH:mm:ss fff&apos;) try { ([DateTime]$_).ToString($OutputFormat) } catch {} } 以下是如何运行它的一些例子： PS&gt; Get-Date | Convert-DateTimeFormat 2015-10-23 14:38:37 140 PS&gt; Get-Date | Convert-DateTimeFormat -OutputFormat &apos;dddd&apos; Friday PS&gt; Get-Date | Convert-DateTimeFormat -OutputFormat &apos;MM&quot;/&quot;dd&quot;/&quot;yyyy&apos; 10/23/2015 PS&gt; &apos;2015-12-24&apos; | Convert-DateTimeFormat -OutputFormat &apos;dddd&apos; Thursday 如您所见，您可以将 DateTime 类型数据，或是能够转换为 DateTime 类型的数据通过管道传给 Convert-DateTimeFormat。默认情况下，该函数以 ISO 格式格式化，但是您还可以通过 -OutputFormat 指定您自己的格式。 通过源码，您可以查看到类似日期和时间部分的字母。请注意这些字母是大小写敏感的（“m”代表分钟，而“M”代表月份）。并且您指定了越多的字母，就能显示越多的细节。 所有希望原样显示的文字必须用双引号括起来。","text":"以下是一个简单的 PowerShell 过滤器，它能够将任意的 DateTime 对象转换为您所需要的日期/时间格式： #requires -Version 1 filter Convert-DateTimeFormat { param($OutputFormat=&apos;yyyy-MM-dd HH:mm:ss fff&apos;) try { ([DateTime]$_).ToString($OutputFormat) } catch {} } 以下是如何运行它的一些例子： PS&gt; Get-Date | Convert-DateTimeFormat 2015-10-23 14:38:37 140 PS&gt; Get-Date | Convert-DateTimeFormat -OutputFormat &apos;dddd&apos; Friday PS&gt; Get-Date | Convert-DateTimeFormat -OutputFormat &apos;MM&quot;/&quot;dd&quot;/&quot;yyyy&apos; 10/23/2015 PS&gt; &apos;2015-12-24&apos; | Convert-DateTimeFormat -OutputFormat &apos;dddd&apos; Thursday 如您所见，您可以将 DateTime 类型数据，或是能够转换为 DateTime 类型的数据通过管道传给 Convert-DateTimeFormat。默认情况下，该函数以 ISO 格式格式化，但是您还可以通过 -OutputFormat 指定您自己的格式。 通过源码，您可以查看到类似日期和时间部分的字母。请注意这些字母是大小写敏感的（“m”代表分钟，而“M”代表月份）。并且您指定了越多的字母，就能显示越多的细节。 所有希望原样显示的文字必须用双引号括起来。 本文国际来源：Converting Date/Time Formats","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 等待进程启动","slug":"waiting-for-process-launch","date":"2015-11-16T04:00:00.000Z","updated":"2017-03-17T15:26:26.576Z","comments":true,"path":"2015/11/16/waiting-for-process-launch/","link":"","permalink":"http://blog.vichamp.com/2015/11/16/waiting-for-process-launch/","excerpt":"PowerShell 内置了等待一个进程或多个进程结束的功能：只需要用 Wait-Process 命令。 但是并不支持相反的功能：等待一个进程启动。以下是一个等待任意进程的函数： #requires -Version 1 function Wait-ForProcess { param ( $Name = &apos;notepad&apos;, [Switch] $IgnoreAlreadyRunningProcesses ) if ($IgnoreAlreadyRunningProcesses) { $NumberOfProcesses = (Get-Process -Name $Name -ErrorAction SilentlyContinue).Count } else { $NumberOfProcesses = 0 } Write-Host &quot;Waiting for $Name&quot; -NoNewline while ( (Get-Process -Name $Name -ErrorAction SilentlyContinue).Count -eq $NumberOfProcesses ) { Write-Host &apos;.&apos; -NoNewline Start-Sleep -Milliseconds 400 } Write-Host &apos;&apos; } 当您运行这段代码时，PowerShell 将会暂停直到您运行一个 Notepad 的新实例： Wait-ForProcess -Name notepad -IgnoreAlreadyRunningProcesses 当您忽略了 -IgnoreAlreadyRunningProcesses 参数时，如果已有至少一个 Notepad 的实例在运行，PowerShell 将会立即继续。","text":"PowerShell 内置了等待一个进程或多个进程结束的功能：只需要用 Wait-Process 命令。 但是并不支持相反的功能：等待一个进程启动。以下是一个等待任意进程的函数： #requires -Version 1 function Wait-ForProcess { param ( $Name = &apos;notepad&apos;, [Switch] $IgnoreAlreadyRunningProcesses ) if ($IgnoreAlreadyRunningProcesses) { $NumberOfProcesses = (Get-Process -Name $Name -ErrorAction SilentlyContinue).Count } else { $NumberOfProcesses = 0 } Write-Host &quot;Waiting for $Name&quot; -NoNewline while ( (Get-Process -Name $Name -ErrorAction SilentlyContinue).Count -eq $NumberOfProcesses ) { Write-Host &apos;.&apos; -NoNewline Start-Sleep -Milliseconds 400 } Write-Host &apos;&apos; } 当您运行这段代码时，PowerShell 将会暂停直到您运行一个 Notepad 的新实例： Wait-ForProcess -Name notepad -IgnoreAlreadyRunningProcesses 当您忽略了 -IgnoreAlreadyRunningProcesses 参数时，如果已有至少一个 Notepad 的实例在运行，PowerShell 将会立即继续。 本文国际来源：Waiting for Process Launch","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 根据参数值执行不同的代码","slug":"invoking-different-code-based-on-parameter-value","date":"2015-11-13T04:00:00.000Z","updated":"2017-03-17T15:26:26.560Z","comments":true,"path":"2015/11/13/invoking-different-code-based-on-parameter-value/","link":"","permalink":"http://blog.vichamp.com/2015/11/13/invoking-different-code-based-on-parameter-value/","excerpt":"以下是一个使用一系列选项的操作参数的简单概念。每个选项对应一个将被执行的脚本块。 #requires -Version 2 function Invoke-SomeAction { param ( [String] [Parameter(Mandatory=$true)] [ValidateSet(&apos;Deploy&apos;,&apos;Delete&apos;,&apos;Refresh&apos;)] $Action ) $codeAction = @{} $codeAction.Deploy = { &apos;Doing the Deployment&apos; } $codeAction.Delete = { &apos;Doing the Deletion&apos; } $codeAction.Refresh = { &apos;Doing the Refresh&apos; } &amp; $codeAction.$Action } 当运行这段代码后，键入 Invoke-SomeAction，ISE 将会提供它所支持的“Deployment”、“Deletion”和“Refresh”操作。相对简单的 PowerShell 控制台至少会提供 action 参数的 tab 补全功能。 根据您的选择，PowerShell 将会执行合适的脚本块。如您所见，该操作脚本块可以包括任意代码，甚至多页代码。","text":"以下是一个使用一系列选项的操作参数的简单概念。每个选项对应一个将被执行的脚本块。 #requires -Version 2 function Invoke-SomeAction { param ( [String] [Parameter(Mandatory=$true)] [ValidateSet(&apos;Deploy&apos;,&apos;Delete&apos;,&apos;Refresh&apos;)] $Action ) $codeAction = @{} $codeAction.Deploy = { &apos;Doing the Deployment&apos; } $codeAction.Delete = { &apos;Doing the Deletion&apos; } $codeAction.Refresh = { &apos;Doing the Refresh&apos; } &amp; $codeAction.$Action } 当运行这段代码后，键入 Invoke-SomeAction，ISE 将会提供它所支持的“Deployment”、“Deletion”和“Refresh”操作。相对简单的 PowerShell 控制台至少会提供 action 参数的 tab 补全功能。 根据您的选择，PowerShell 将会执行合适的脚本块。如您所见，该操作脚本块可以包括任意代码，甚至多页代码。 本文国际来源：Invoking Different Code Based on Parameter Value","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找脚本块变量","slug":"finding-script-block-variables","date":"2015-11-12T04:00:00.000Z","updated":"2017-03-17T15:26:26.560Z","comments":true,"path":"2015/11/12/finding-script-block-variables/","link":"","permalink":"http://blog.vichamp.com/2015/11/12/finding-script-block-variables/","excerpt":"脚本块定义了一段 PowerShell 代码而并不执行它。最简单的定义脚本块的方法是将代码放入花括号中。 脚本块有一系列高级功能，能够检测花括号内部的代码。其中的一个功能是直接访问抽象语法树 (AST)。AST 可以分分析代码内容。以下是一个读出脚本块中所有变量名的例子： #requires -Version 3 $scriptblock = { $test = 1 $abc = 2 } $scriptblock.Ast.FindAll( { $args[0] -is [System.Management.Automation.Language.VariableExpressionAst] }, $true ) | Select-Object -ExpandProperty VariablePath | Select-Object -ExpandProperty UserPath","text":"脚本块定义了一段 PowerShell 代码而并不执行它。最简单的定义脚本块的方法是将代码放入花括号中。 脚本块有一系列高级功能，能够检测花括号内部的代码。其中的一个功能是直接访问抽象语法树 (AST)。AST 可以分分析代码内容。以下是一个读出脚本块中所有变量名的例子： #requires -Version 3 $scriptblock = { $test = 1 $abc = 2 } $scriptblock.Ast.FindAll( { $args[0] -is [System.Management.Automation.Language.VariableExpressionAst] }, $true ) | Select-Object -ExpandProperty VariablePath | Select-Object -ExpandProperty UserPath 本文国际来源：Finding Script Block Variables","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 远程获取已安装的软件列表","slug":"getting-installed-software-remotely","date":"2015-11-11T04:00:00.000Z","updated":"2017-03-17T15:26:26.544Z","comments":true,"path":"2015/11/11/getting-installed-software-remotely/","link":"","permalink":"http://blog.vichamp.com/2015/11/11/getting-installed-software-remotely/","excerpt":"在前一个技能中，我们介绍了 Get-Software 函数，它可以获取本地计算机已安装的软件。 如果您在远程系统上已经安装了 PowerShell 远程操作（在 Windows Server 2012 及以上版本中默认是开启的），并且如果您拥有合适的权限，请试试这个增强的版本。它同时支持本地和远程调用： #requires -Version 2 function Get-Software { param ( [string] $DisplayName=&apos;*&apos;, [string] $UninstallString=&apos;*&apos;, [string[]] $ComputerName ) [scriptblock]$code = { param ( [string] $DisplayName=&apos;*&apos;, [string] $UninstallString=&apos;*&apos; ) $keys = &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*&apos;, &apos;HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*&apos; Get-ItemProperty -Path $keys | Where-Object { $_.DisplayName } | Select-Object -Property DisplayName, DisplayVersion, UninstallString | Where-Object { $_.DisplayName -like $DisplayName } | Where-Object { $_.UninstallString -like $UninstallString } } if ($PSBoundParameters.ContainsKey(&apos;ComputerName&apos;)) { Invoke-Command -ScriptBlock $code -ComputerName $ComputerName -ArgumentList $DisplayName, $UninstallString } else { &amp; $code -DisplayName $DisplayName -UninstallString $UninstallString } } 请注意这个函数如何将查找软件的代码包裹在代码块中。接下来，它将检测 $PSBoundParameters 来判断用户是否传入了 -ComputerName 参数。如果没有传入，该代码将在本地执行。 否则，Invoke-Command 将在指定的远程计算机（支持多台）上运行这段代码。在这个例子中，Invoke-Command 将过滤参数传递给远程代码。","text":"在前一个技能中，我们介绍了 Get-Software 函数，它可以获取本地计算机已安装的软件。 如果您在远程系统上已经安装了 PowerShell 远程操作（在 Windows Server 2012 及以上版本中默认是开启的），并且如果您拥有合适的权限，请试试这个增强的版本。它同时支持本地和远程调用： #requires -Version 2 function Get-Software { param ( [string] $DisplayName=&apos;*&apos;, [string] $UninstallString=&apos;*&apos;, [string[]] $ComputerName ) [scriptblock]$code = { param ( [string] $DisplayName=&apos;*&apos;, [string] $UninstallString=&apos;*&apos; ) $keys = &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*&apos;, &apos;HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*&apos; Get-ItemProperty -Path $keys | Where-Object { $_.DisplayName } | Select-Object -Property DisplayName, DisplayVersion, UninstallString | Where-Object { $_.DisplayName -like $DisplayName } | Where-Object { $_.UninstallString -like $UninstallString } } if ($PSBoundParameters.ContainsKey(&apos;ComputerName&apos;)) { Invoke-Command -ScriptBlock $code -ComputerName $ComputerName -ArgumentList $DisplayName, $UninstallString } else { &amp; $code -DisplayName $DisplayName -UninstallString $UninstallString } } 请注意这个函数如何将查找软件的代码包裹在代码块中。接下来，它将检测 $PSBoundParameters 来判断用户是否传入了 -ComputerName 参数。如果没有传入，该代码将在本地执行。 否则，Invoke-Command 将在指定的远程计算机（支持多台）上运行这段代码。在这个例子中，Invoke-Command 将过滤参数传递给远程代码。 本文国际来源：Getting Installed Software Remotely","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从注册表中读取已安装的软件","slug":"reading-installed-software-from-registry","date":"2015-11-10T04:00:00.000Z","updated":"2017-03-17T15:26:26.544Z","comments":true,"path":"2015/11/10/reading-installed-software-from-registry/","link":"","permalink":"http://blog.vichamp.com/2015/11/10/reading-installed-software-from-registry/","excerpt":"以下是查看已安装的软件的快速方法。Get-Software 函数读取所有用户的 32 位和 64 位软件的安装地址。 #requires -Version 1 function Get-Software { param ( [string] $DisplayName=&apos;*&apos;, [string] $UninstallString=&apos;*&apos; ) $keys = &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*&apos;, &apos;HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*&apos; Get-ItemProperty -Path $keys | Where-Object { $_.DisplayName } | Select-Object -Property DisplayName, DisplayVersion, UninstallString | Where-Object { $_.DisplayName -like $DisplayName } | Where-Object { $_.UninstallString -like $UninstallString } } 它甚至包含了过滤参数，所以您可以当您指定 -DisplayName 或 -UninstallString（或两者）时，您可以轻松地过滤结果，仅显示您期望的软件产品。两个参数都支持通配符。 以下是一个调用的示例，显示所有的 Office 组件到一个网格视图窗口中： Get-Software -DisplayName *Office* | Out-GridView","text":"以下是查看已安装的软件的快速方法。Get-Software 函数读取所有用户的 32 位和 64 位软件的安装地址。 #requires -Version 1 function Get-Software { param ( [string] $DisplayName=&apos;*&apos;, [string] $UninstallString=&apos;*&apos; ) $keys = &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*&apos;, &apos;HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*&apos; Get-ItemProperty -Path $keys | Where-Object { $_.DisplayName } | Select-Object -Property DisplayName, DisplayVersion, UninstallString | Where-Object { $_.DisplayName -like $DisplayName } | Where-Object { $_.UninstallString -like $UninstallString } } 它甚至包含了过滤参数，所以您可以当您指定 -DisplayName 或 -UninstallString（或两者）时，您可以轻松地过滤结果，仅显示您期望的软件产品。两个参数都支持通配符。 以下是一个调用的示例，显示所有的 Office 组件到一个网格视图窗口中： Get-Software -DisplayName *Office* | Out-GridView 本文国际来源：Reading Installed Software from Registry","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 显示消息对话框","slug":"display-message-box-dialog","date":"2015-11-09T04:00:00.000Z","updated":"2017-03-17T15:26:26.544Z","comments":true,"path":"2015/11/09/display-message-box-dialog/","link":"","permalink":"http://blog.vichamp.com/2015/11/09/display-message-box-dialog/","excerpt":"PowerShell 是基于控制台的，但有些时候加入一些简单的对话框也很不错。以下是一个称为 Show-MessageBox 的函数，可以显示所有标准消息框，并支持智能显示参数： #requires -Version 2 Add-Type -AssemblyName PresentationFramework function Show-MessageBox { param ( [Parameter(Mandatory=$true)] $Prompt, $Title = &apos;Windows PowerShell&apos;, [Windows.MessageBoxButton] $Buttons = &apos;YesNo&apos;, [Windows.MessageBoxImage] $Icon = &apos;Information&apos; ) [System.Windows.MessageBox]::Show($Prompt, $Title, $Buttons, $Icon) } $result = Show-MessageBox -Prompt &apos;Rebooting.&apos; -Buttons OKCancel -Icon Exclamation if ($result -eq &apos;OK&apos;) { Restart-Computer -Force -WhatIf }","text":"PowerShell 是基于控制台的，但有些时候加入一些简单的对话框也很不错。以下是一个称为 Show-MessageBox 的函数，可以显示所有标准消息框，并支持智能显示参数： #requires -Version 2 Add-Type -AssemblyName PresentationFramework function Show-MessageBox { param ( [Parameter(Mandatory=$true)] $Prompt, $Title = &apos;Windows PowerShell&apos;, [Windows.MessageBoxButton] $Buttons = &apos;YesNo&apos;, [Windows.MessageBoxImage] $Icon = &apos;Information&apos; ) [System.Windows.MessageBox]::Show($Prompt, $Title, $Buttons, $Icon) } $result = Show-MessageBox -Prompt &apos;Rebooting.&apos; -Buttons OKCancel -Icon Exclamation if ($result -eq &apos;OK&apos;) { Restart-Computer -Force -WhatIf } 本文国际来源：Display Message Box Dialog","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 尽可能使用服务端过滤","slug":"use-server-side-filtering-when-possible","date":"2015-11-06T04:00:00.000Z","updated":"2017-03-17T15:26:26.529Z","comments":true,"path":"2015/11/06/use-server-side-filtering-when-possible/","link":"","permalink":"http://blog.vichamp.com/2015/11/06/use-server-side-filtering-when-possible/","excerpt":"当您跨网络获取信息时，请注意只能在最后一步使用客户端技术，例如 Where-Object。服务端过滤技术更有效率。 例如，当您试图根据电子邮箱查找用户时，客户端的 Where-Object 语句将会将所有 AD 用户推到您的计算机上，并且通过本地的 Where-Object 来确认您需要的用户： #requires -Version 1 -Modules ActiveDirectory # inefficient client-side filter Get-ADUser -Filter * | Where-Object { $_.mail -ne $null } 如您猜想的那样，当一个 cmdlet 有一个名为 -Filter 的参数时，它可以在传送数据到您的机器之前，在服务端过滤需要的元素。然而，Get-ADUser 命令的 -Filter 参数有的时候工作起来很困难，需要将类似 PowerShell 的语法转换为 Active Directory 所需的 LDAP 查询。 所以更常见的是，在第一处使用 LDAP 查询字符串更自然。这两条语句将会快速地找出所有包含（和不包含）邮箱地址的用户账户： #requires -Version 1 -Modules ActiveDirectory # any user with a mail address Get-ADUser -LDAPFilter &apos;(mail=*)&apos; # any user with NO mail address Get-ADUser -LDAPFilter &apos;(!mail=*)&apos;","text":"当您跨网络获取信息时，请注意只能在最后一步使用客户端技术，例如 Where-Object。服务端过滤技术更有效率。 例如，当您试图根据电子邮箱查找用户时，客户端的 Where-Object 语句将会将所有 AD 用户推到您的计算机上，并且通过本地的 Where-Object 来确认您需要的用户： #requires -Version 1 -Modules ActiveDirectory # inefficient client-side filter Get-ADUser -Filter * | Where-Object { $_.mail -ne $null } 如您猜想的那样，当一个 cmdlet 有一个名为 -Filter 的参数时，它可以在传送数据到您的机器之前，在服务端过滤需要的元素。然而，Get-ADUser 命令的 -Filter 参数有的时候工作起来很困难，需要将类似 PowerShell 的语法转换为 Active Directory 所需的 LDAP 查询。 所以更常见的是，在第一处使用 LDAP 查询字符串更自然。这两条语句将会快速地找出所有包含（和不包含）邮箱地址的用户账户： #requires -Version 1 -Modules ActiveDirectory # any user with a mail address Get-ADUser -LDAPFilter &apos;(mail=*)&apos; # any user with NO mail address Get-ADUser -LDAPFilter &apos;(!mail=*)&apos; 本文国际来源：Use Server-Side Filtering When Possible","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将数字列表转换为有用的列表","slug":"turning-lists-of-numbers-into-useful-lists","date":"2015-11-05T04:00:00.000Z","updated":"2017-03-17T15:26:26.529Z","comments":true,"path":"2015/11/05/turning-lists-of-numbers-into-useful-lists/","link":"","permalink":"http://blog.vichamp.com/2015/11/05/turning-lists-of-numbers-into-useful-lists/","excerpt":"PowerShell 将 “..“ 操作符的功能定义为生成一个数字列表。通过 -join 操作符，您可以将这些数字转换为几乎您想要的所有东西，例如逗号分隔的值。 当您希望将数字转换为字符时，您也可以将 ASCII 码转换为字母。 用管道将它们输出到 ForEach-Object，您就可以将它进一步处理成驱动器号。 或者使用 -f 操作符来创建服务器列表。以下是示例代码： #requires -Version 1 1..10 -join &apos;,&apos; [Char[]][Byte[]](65..90) -join &apos;,&apos; ([Char[]][Byte[]](65..90) | ForEach-Object { $_ + &apos;:\\&apos; }) -join &apos;,&apos; 1..10 | ForEach-Object { &apos;Server{0:0000}&apos; -f $_ }","text":"PowerShell 将 “..“ 操作符的功能定义为生成一个数字列表。通过 -join 操作符，您可以将这些数字转换为几乎您想要的所有东西，例如逗号分隔的值。 当您希望将数字转换为字符时，您也可以将 ASCII 码转换为字母。 用管道将它们输出到 ForEach-Object，您就可以将它进一步处理成驱动器号。 或者使用 -f 操作符来创建服务器列表。以下是示例代码： #requires -Version 1 1..10 -join &apos;,&apos; [Char[]][Byte[]](65..90) -join &apos;,&apos; ([Char[]][Byte[]](65..90) | ForEach-Object { $_ + &apos;:\\&apos; }) -join &apos;,&apos; 1..10 | ForEach-Object { &apos;Server{0:0000}&apos; -f $_ } 本文国际来源：Turning Lists of Numbers Into Useful Lists","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 和 Powershell 对话","slug":"conversation-with-powershell","date":"2015-10-30T03:00:00.000Z","updated":"2017-03-17T15:26:26.513Z","comments":true,"path":"2015/10/30/conversation-with-powershell/","link":"","permalink":"http://blog.vichamp.com/2015/10/30/conversation-with-powershell/","excerpt":"今日的技能是当您键入一个未知的命令时，使用可编程的 CommandNotFoundHandler 让 PowerShell 和您对话： $ExecutionContext.InvokeCommand.CommandNotFoundAction = { param( [string] $commandName, [System.Management.Automation.CommandLookupEventArgs] $eventArgs ) $Sapi = New-Object -ComObject Sapi.SpVoice $null = $Sapi.Speak(&quot;I don&apos;t know $commandName, stupid.&quot;) } 当您运行这段代码（并且打开您的声音）后，当用户输入一个未知的命令时，PowerShell 将会开口说话，并且抱怨它不知道您的命令。您可能会听到该声音两次：如果该命令不以 “get-“ 开头，PowerShell 首先会试图查找一个以 “get-“ 开头，并以您键入的名字结尾的命令。","text":"今日的技能是当您键入一个未知的命令时，使用可编程的 CommandNotFoundHandler 让 PowerShell 和您对话： $ExecutionContext.InvokeCommand.CommandNotFoundAction = { param( [string] $commandName, [System.Management.Automation.CommandLookupEventArgs] $eventArgs ) $Sapi = New-Object -ComObject Sapi.SpVoice $null = $Sapi.Speak(&quot;I don&apos;t know $commandName, stupid.&quot;) } 当您运行这段代码（并且打开您的声音）后，当用户输入一个未知的命令时，PowerShell 将会开口说话，并且抱怨它不知道您的命令。您可能会听到该声音两次：如果该命令不以 “get-“ 开头，PowerShell 首先会试图查找一个以 “get-“ 开头，并以您键入的名字结尾的命令。 本文国际来源：Conversation with PowerShell","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查看操作系统版本","slug":"finding-operating-system-version","date":"2015-10-29T03:00:00.000Z","updated":"2017-03-17T15:26:26.513Z","comments":true,"path":"2015/10/29/finding-operating-system-version/","link":"","permalink":"http://blog.vichamp.com/2015/10/29/finding-operating-system-version/","excerpt":"一个最简单的查看操作系统版本号的方法是这一行代码： PS&gt; [Environment]::OSVersion Platform ServicePack Version VersionString -------- ----------- ------- ------------- Win32NT Service Pack 1 6.1.7601.65536 Microsoft Windows N... “Environment”类型提供了您计算机很多方面的信息。例如，操作系统核心的个数： PS&gt; [Environment]::ProcessorCount 4 要查看该类型能做什么，请在 PowerShell ISE 中，键入： [Environment]:: 当您按下第二个冒号时，智能提示将打开一个菜单，里面包含了该类型的所有静态属性和方法。","text":"一个最简单的查看操作系统版本号的方法是这一行代码： PS&gt; [Environment]::OSVersion Platform ServicePack Version VersionString -------- ----------- ------- ------------- Win32NT Service Pack 1 6.1.7601.65536 Microsoft Windows N... “Environment”类型提供了您计算机很多方面的信息。例如，操作系统核心的个数： PS&gt; [Environment]::ProcessorCount 4 要查看该类型能做什么，请在 PowerShell ISE 中，键入： [Environment]:: 当您按下第二个冒号时，智能提示将打开一个菜单，里面包含了该类型的所有静态属性和方法。 本文国际来源：Finding Operating System Version","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 为什么捕获不到某些错误 ","slug":"why-some-errors-aren-t-caught","date":"2015-10-28T03:00:00.000Z","updated":"2017-03-17T15:26:26.497Z","comments":true,"path":"2015/10/28/why-some-errors-aren-t-caught/","link":"","permalink":"http://blog.vichamp.com/2015/10/28/why-some-errors-aren-t-caught/","excerpt":"当您在 PowerShell 中收到一条红色的错误信息时，您总是可以用一个 try..catch 代码块将代码包裹起来，然后自行处理该错误： try { 1/0 } catch { Write-Warning &quot;Something crazy happened: $_&quot; } 然而，一些错误，特别是来自 cmdlet 的，并不能被处理。当那些情况发生时，说明缺失的错误是被 cmdlet 内部的错误处理器处理了，并且您可以通过 -ErrorAction 通用参数来控制 cmdlet 的错误处理器。 当您设置 ErrorAction 的值为 Stop 时，您实际上告知 cmdlet 抛出一个异常，该以上可以被您的异常处理器捕获。 要让所有 cmdlet 发出异常，而不是内部处理，您可以用 $ErrorActionPreference = &#39;Stop&#39; 语句，该语句将设置所有 cmdlet 的缺省错误动作为“停止”。 请注意它的副作用：当您告知一个 cmdlet 的错误处理器要在某些错误发生时抛出异常，则该 cmdlet 将会在发生第一个错误的地方抛出异常，并且不会继续执行。","text":"当您在 PowerShell 中收到一条红色的错误信息时，您总是可以用一个 try..catch 代码块将代码包裹起来，然后自行处理该错误： try { 1/0 } catch { Write-Warning &quot;Something crazy happened: $_&quot; } 然而，一些错误，特别是来自 cmdlet 的，并不能被处理。当那些情况发生时，说明缺失的错误是被 cmdlet 内部的错误处理器处理了，并且您可以通过 -ErrorAction 通用参数来控制 cmdlet 的错误处理器。 当您设置 ErrorAction 的值为 Stop 时，您实际上告知 cmdlet 抛出一个异常，该以上可以被您的异常处理器捕获。 要让所有 cmdlet 发出异常，而不是内部处理，您可以用 $ErrorActionPreference = &#39;Stop&#39; 语句，该语句将设置所有 cmdlet 的缺省错误动作为“停止”。 请注意它的副作用：当您告知一个 cmdlet 的错误处理器要在某些错误发生时抛出异常，则该 cmdlet 将会在发生第一个错误的地方抛出异常，并且不会继续执行。 本文国际来源：Why Some Errors Aren’t Caught","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在命令提示符中显示路径","slug":"using-paths-in-prompts","date":"2015-10-27T03:00:00.000Z","updated":"2017-03-17T15:26:26.497Z","comments":true,"path":"2015/10/27/using-paths-in-prompts/","link":"","permalink":"http://blog.vichamp.com/2015/10/27/using-paths-in-prompts/","excerpt":"缺省的 PowerShell 提示符显示当前的位置。当您在很深的嵌套文件夹中时，这将占用您的输入空间，而且会导致需要滚动才能看清。 有很多方法可以解决这个问题。以下是针对这个题的两个 prompt 的替代函数。 第一个是保持在当前提示符中显示当前路径，但实际的输入是在下面一行，所以您的输入总是可见。 function prompt { Write-Host(&quot;PS: $pwd&gt;&quot;) } 另一种方式是在窗体的标题栏显示当前的路径： function prompt { $host.UI.RawUI.WindowTitle = Get-Location &apos;PS&gt; &apos; } 如果您想用这些方法，请将它们放在自启动脚本中（缺省情况下可能不存在）。它的路径可以通过 $profile 变量找到。","text":"缺省的 PowerShell 提示符显示当前的位置。当您在很深的嵌套文件夹中时，这将占用您的输入空间，而且会导致需要滚动才能看清。 有很多方法可以解决这个问题。以下是针对这个题的两个 prompt 的替代函数。 第一个是保持在当前提示符中显示当前路径，但实际的输入是在下面一行，所以您的输入总是可见。 function prompt { Write-Host(&quot;PS: $pwd&gt;&quot;) } 另一种方式是在窗体的标题栏显示当前的路径： function prompt { $host.UI.RawUI.WindowTitle = Get-Location &apos;PS&gt; &apos; } 如果您想用这些方法，请将它们放在自启动脚本中（缺省情况下可能不存在）。它的路径可以通过 $profile 变量找到。 本文国际来源：Using Paths in Prompts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 帮助 PowerShell 做得更好！","slug":"help-make-powershell-a-better-place","date":"2015-10-26T03:00:00.000Z","updated":"2017-03-17T15:26:26.482Z","comments":true,"path":"2015/10/26/help-make-powershell-a-better-place/","link":"","permalink":"http://blog.vichamp.com/2015/10/26/help-make-powershell-a-better-place/","excerpt":"与其批评不正常的功能，或是缺少的功能，不如一起参与建设！PowerShell 团队做了很大努力来改进和扩展 PowerShell。现在只需要您的反馈意见。 这是一站式服务地址：https://connect.microsoft.com/PowerShell 当您打开那个网页时，您可以一键提交 bug、发送反馈，或是为新的功能投票。您需要用一个免费的微软账号登录。","text":"与其批评不正常的功能，或是缺少的功能，不如一起参与建设！PowerShell 团队做了很大努力来改进和扩展 PowerShell。现在只需要您的反馈意见。 这是一站式服务地址：https://connect.microsoft.com/PowerShell 当您打开那个网页时，您可以一键提交 bug、发送反馈，或是为新的功能投票。您需要用一个免费的微软账号登录。 本文国际来源：Help Make PowerShell a Better Place!","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 试试 CTRL+SPACE！","slug":"try-ctrl-space","date":"2015-10-23T03:00:00.000Z","updated":"2017-03-17T15:26:26.482Z","comments":true,"path":"2015/10/23/try-ctrl-space/","link":"","permalink":"http://blog.vichamp.com/2015/10/23/try-ctrl-space/","excerpt":"在 PowerShell ISE 中，有两个键盘快捷键可能对您有用。按下 TAB 键的功能就像在控制台中一样，并且每次您按下 TAB，您会得到一个 Tab 展开的结果。 CTRL + SPACE 是另一个重要的键盘快捷键。它将打开智能感知菜单。由于大多数情况下 ISE 自动打开这些菜单，所以大多数用户从来没有注意过 CTRL + SPACE，但它重打开一个错过的智能感知菜单功能十分有用。 从 PowerShell 5.0 开始，CTRL + SPACE 变得更为重要，特别是当您在书写 DSC（所需状态配置）配置脚本时。PowerShell ISE 提供了针对 DSC 的扩展智能感知帮助，但在许多情况下并不会自动弹出智能感知菜单。仅当按下 CTRL + SPACE 时才能获得智能感知帮助。","text":"在 PowerShell ISE 中，有两个键盘快捷键可能对您有用。按下 TAB 键的功能就像在控制台中一样，并且每次您按下 TAB，您会得到一个 Tab 展开的结果。 CTRL + SPACE 是另一个重要的键盘快捷键。它将打开智能感知菜单。由于大多数情况下 ISE 自动打开这些菜单，所以大多数用户从来没有注意过 CTRL + SPACE，但它重打开一个错过的智能感知菜单功能十分有用。 从 PowerShell 5.0 开始，CTRL + SPACE 变得更为重要，特别是当您在书写 DSC（所需状态配置）配置脚本时。PowerShell ISE 提供了针对 DSC 的扩展智能感知帮助，但在许多情况下并不会自动弹出智能感知菜单。仅当按下 CTRL + SPACE 时才能获得智能感知帮助。 本文国际来源：Try CTRL+SPACE!","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 增加“命令未找到”处理器","slug":"adding-command-not-found-handler","date":"2015-10-22T03:00:00.000Z","updated":"2017-03-17T15:26:26.476Z","comments":true,"path":"2015/10/22/adding-command-not-found-handler/","link":"","permalink":"http://blog.vichamp.com/2015/10/22/adding-command-not-found-handler/","excerpt":"当 PowerShell 遇到一个未知的命令名时，您会见到一条红色的信息。 然而，从 PowerShell 3.0 开始，引入了一个“CommandNotFoundHandler”功能，可以在程序中使用。它可以记录信息，或者尝试解决问题。 这是一个简单的例子。当您运行这段代码后，无论何时遇到一个 PowerShell 不知道的命令，它会运行 Show-Command 并用合法的命令打开一个帮助工具： $ExecutionContext.InvokeCommand.CommandNotFoundAction = { param( [string] $commandName, [System.Management.Automation.CommandLookupEventArgs] $eventArgs ) Write-Warning &quot;Command $commandName was not found. Opening LookilookiTool.&quot; $eventArgs.CommandScriptBlock = { Show-Command } }","text":"当 PowerShell 遇到一个未知的命令名时，您会见到一条红色的信息。 然而，从 PowerShell 3.0 开始，引入了一个“CommandNotFoundHandler”功能，可以在程序中使用。它可以记录信息，或者尝试解决问题。 这是一个简单的例子。当您运行这段代码后，无论何时遇到一个 PowerShell 不知道的命令，它会运行 Show-Command 并用合法的命令打开一个帮助工具： $ExecutionContext.InvokeCommand.CommandNotFoundAction = { param( [string] $commandName, [System.Management.Automation.CommandLookupEventArgs] $eventArgs ) Write-Warning &quot;Command $commandName was not found. Opening LookilookiTool.&quot; $eventArgs.CommandScriptBlock = { Show-Command } } 本文国际来源：Adding Command Not Found Handler","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 自动修正 PowerShell 代码的大小写","slug":"auto-casecorrecting-powershell-code","date":"2015-10-21T03:00:00.000Z","updated":"2017-03-17T15:26:26.460Z","comments":true,"path":"2015/10/21/auto-casecorrecting-powershell-code/","link":"","permalink":"http://blog.vichamp.com/2015/10/21/auto-casecorrecting-powershell-code/","excerpt":"当您编写 PowerShell 脚本时，可能常常没有使用正确的大小写，或只使用部分参数名，或使用别名而不是 cmdlet 名称。这些技术上都是可行的，因为 PowerShell 命令是大小写不敏感的，参数名可以省略，并且别名也是一种合法的命令类型。 然而，当使用正确的的大小写、完整的参数名称，以及 cmdlet 名字而不是别名时，脚本的可读性会更好。 在 PowerShell ISE 中，要纠正这些东西，只需要将光标放置在命令名或参数名处，然后按下 TAB 键。Tab 展开功能将会读取原有的代码并将它替换成大小写正确的、名字完整的版本。","text":"当您编写 PowerShell 脚本时，可能常常没有使用正确的大小写，或只使用部分参数名，或使用别名而不是 cmdlet 名称。这些技术上都是可行的，因为 PowerShell 命令是大小写不敏感的，参数名可以省略，并且别名也是一种合法的命令类型。 然而，当使用正确的的大小写、完整的参数名称，以及 cmdlet 名字而不是别名时，脚本的可读性会更好。 在 PowerShell ISE 中，要纠正这些东西，只需要将光标放置在命令名或参数名处，然后按下 TAB 键。Tab 展开功能将会读取原有的代码并将它替换成大小写正确的、名字完整的版本。 本文国际来源：Auto-CaseCorrecting PowerShell Code","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找已加载的程序集","slug":"finding-loaded-assemblies","date":"2015-10-20T03:00:00.000Z","updated":"2017-03-17T15:26:26.460Z","comments":true,"path":"2015/10/20/finding-loaded-assemblies/","link":"","permalink":"http://blog.vichamp.com/2015/10/20/finding-loaded-assemblies/","excerpt":"要列出一个 PowerShell 会话中加载的所有 .NET 程序集，请试试这段代码： [System.AppDomain]::CurrentDomain.GetAssemblies() | Where-Object Location | Sort-Object -Property FullName | Select-Object -Property Name, Location, Version | Out-GridView 列出和对比已加载的程序集可以有助于对比 PowerShell 会话，并且检查区别。多数时间，区别在于已加载的模块，所以如果缺少了程序集，您可能需要先加载一个 PowerShell 模块来使用它们。 或者，您可以使用 Add-Type 命令根据名字或文件地址手动加载程序集。","text":"要列出一个 PowerShell 会话中加载的所有 .NET 程序集，请试试这段代码： [System.AppDomain]::CurrentDomain.GetAssemblies() | Where-Object Location | Sort-Object -Property FullName | Select-Object -Property Name, Location, Version | Out-GridView 列出和对比已加载的程序集可以有助于对比 PowerShell 会话，并且检查区别。多数时间，区别在于已加载的模块，所以如果缺少了程序集，您可能需要先加载一个 PowerShell 模块来使用它们。 或者，您可以使用 Add-Type 命令根据名字或文件地址手动加载程序集。 本文国际来源：Finding Loaded Assemblies","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找 cmdlet 参数别名","slug":"finding-cmdlet-parameter-aliases","date":"2015-10-19T03:00:00.000Z","updated":"2017-03-17T15:26:26.444Z","comments":true,"path":"2015/10/19/finding-cmdlet-parameter-aliases/","link":"","permalink":"http://blog.vichamp.com/2015/10/19/finding-cmdlet-parameter-aliases/","excerpt":"PowerShell cmdlet 和函数可以带有参数，并且这些参数可以有（更短的）别名。一个典型的例子是 -ErrorAction 通用参数，它也可以通过 -ea 别名访问。 参数别名不是自动完成的。您需要预先知道它们。以下这个脚本可以提取任意 PowerShell 函数或 cmdlet 的参数别名： #requires -Version 3 $command = &apos;Get-Process&apos; (Get-Command $command).Parameters.Values | Select-Object -Property Name, Aliases","text":"PowerShell cmdlet 和函数可以带有参数，并且这些参数可以有（更短的）别名。一个典型的例子是 -ErrorAction 通用参数，它也可以通过 -ea 别名访问。 参数别名不是自动完成的。您需要预先知道它们。以下这个脚本可以提取任意 PowerShell 函数或 cmdlet 的参数别名： #requires -Version 3 $command = &apos;Get-Process&apos; (Get-Command $command).Parameters.Values | Select-Object -Property Name, Aliases 本文国际来源：Finding Cmdlet Parameter Aliases","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 简化参数属性","slug":"simplify-parameter-attributes","date":"2015-10-16T03:00:00.000Z","updated":"2017-03-17T15:26:26.444Z","comments":true,"path":"2015/10/16/simplify-parameter-attributes/","link":"","permalink":"http://blog.vichamp.com/2015/10/16/simplify-parameter-attributes/","excerpt":"如果您的系统运行的是 PowerShell 3.0 及以上版本，您可以简化函数参数的属性。布尔属性的缺省值都为 $true，所以这在 PowerShell 2.0 中是缺省代码： function Get-Sample { Param ( [Parameter(Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)] [string] $Name ) } 从 PowerShell 3.0 开始，它浓缩成： function Get-Sample { Param ( [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)] [string] $Name ) } 新的代码更精炼，但是无法在 PowerShell 2.0 中运行。","text":"如果您的系统运行的是 PowerShell 3.0 及以上版本，您可以简化函数参数的属性。布尔属性的缺省值都为 $true，所以这在 PowerShell 2.0 中是缺省代码： function Get-Sample { Param ( [Parameter(Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)] [string] $Name ) } 从 PowerShell 3.0 开始，它浓缩成： function Get-Sample { Param ( [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)] [string] $Name ) } 新的代码更精炼，但是无法在 PowerShell 2.0 中运行。 本文国际来源：Simplify Parameter Attributes","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建临时文件名","slug":"creating-temporary-filenames","date":"2015-10-15T03:00:00.000Z","updated":"2017-03-17T15:26:26.428Z","comments":true,"path":"2015/10/15/creating-temporary-filenames/","link":"","permalink":"http://blog.vichamp.com/2015/10/15/creating-temporary-filenames/","excerpt":"如果您只是需要创建一个临时文件名（而不是真的需要创建该文件），而且您希望控制文件的扩展名，以下是一个实现该需求的简单函数： $elements = @() $elements += [System.IO.Path]::GetTempPath() $elements += [System.Guid]::NewGuid() $elements += &apos;csv&apos; $randomPath = &apos;{0}{1}.{2}&apos; -f $elements $randomPath 您可以很容易地根据它创建您自己的函数： function New-TemporaryFileName($Extension=&apos;txt&apos;) { $elements = @() $elements += [System.IO.Path]::GetTempPath() $elements += [System.Guid]::NewGuid() $elements += $Extension.TrimStart(&apos;.&apos;) &apos;{0}{1}.{2}&apos; -f $elements } 这是该函数的使用方法： PS C:\\&gt; New-TemporaryFileName C:\\Users\\Tobias\\AppData\\Local\\Temp\\8d8e5001-2be8-469d-9bc8-e2e3324cce66.txt PS C:\\&gt; New-TemporaryFileName ps1 C:\\Users\\Tobias\\AppData\\Local\\Temp\\412c40df-e691-44c1-8c94-f7ce30bb4875.ps1 PS C:\\&gt; New-TemporaryFileName csv C:\\Users\\Tobias\\AppData\\Local\\Temp\\47b1a65f-2705-4926-8a72-21f05430f2c5.csv","text":"如果您只是需要创建一个临时文件名（而不是真的需要创建该文件），而且您希望控制文件的扩展名，以下是一个实现该需求的简单函数： $elements = @() $elements += [System.IO.Path]::GetTempPath() $elements += [System.Guid]::NewGuid() $elements += &apos;csv&apos; $randomPath = &apos;{0}{1}.{2}&apos; -f $elements $randomPath 您可以很容易地根据它创建您自己的函数： function New-TemporaryFileName($Extension=&apos;txt&apos;) { $elements = @() $elements += [System.IO.Path]::GetTempPath() $elements += [System.Guid]::NewGuid() $elements += $Extension.TrimStart(&apos;.&apos;) &apos;{0}{1}.{2}&apos; -f $elements } 这是该函数的使用方法： PS C:\\&gt; New-TemporaryFileName C:\\Users\\Tobias\\AppData\\Local\\Temp\\8d8e5001-2be8-469d-9bc8-e2e3324cce66.txt PS C:\\&gt; New-TemporaryFileName ps1 C:\\Users\\Tobias\\AppData\\Local\\Temp\\412c40df-e691-44c1-8c94-f7ce30bb4875.ps1 PS C:\\&gt; New-TemporaryFileName csv C:\\Users\\Tobias\\AppData\\Local\\Temp\\47b1a65f-2705-4926-8a72-21f05430f2c5.csv 本文国际来源：Creating Temporary File Names","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 为什么 GetTempFileName() 是有害的","slug":"why-gettempfilename-is-evil","date":"2015-10-14T03:00:00.000Z","updated":"2017-03-17T15:26:26.428Z","comments":true,"path":"2015/10/14/why-gettempfilename-is-evil/","link":"","permalink":"http://blog.vichamp.com/2015/10/14/why-gettempfilename-is-evil/","excerpt":"有些人可能会用 .NET 方法来试图生成一个随机的临时文件名： $path = [System.IO.Path]::GetTempFileName() $path 它确实可以用。不过它还做了些别的事情。它实际上用那个文件名创建了一个空白文件： PS C:\\&gt; Test-Path $path True 如果您没有清除临时文件，将会在创建了 65535 个临时文件之后得到一个异常。 在 PowerShell 5.0 中，New-TemporaryFile 做了相同的事情，但是它返回了一个文件，这样您可以立即确认确实创建了一个文件，而不是一个文件名。","text":"有些人可能会用 .NET 方法来试图生成一个随机的临时文件名： $path = [System.IO.Path]::GetTempFileName() $path 它确实可以用。不过它还做了些别的事情。它实际上用那个文件名创建了一个空白文件： PS C:\\&gt; Test-Path $path True 如果您没有清除临时文件，将会在创建了 65535 个临时文件之后得到一个异常。 在 PowerShell 5.0 中，New-TemporaryFile 做了相同的事情，但是它返回了一个文件，这样您可以立即确认确实创建了一个文件，而不是一个文件名。 本文国际来源：Why GetTempFileName() is Evil","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 删除别名","slug":"deleting-aliases1","date":"2015-10-13T03:00:00.000Z","updated":"2017-03-17T15:26:26.428Z","comments":true,"path":"2015/10/13/deleting-aliases1/","link":"","permalink":"http://blog.vichamp.com/2015/10/13/deleting-aliases1/","excerpt":"在 PowerShell 中创建新的别名很常见。但是如果您做错了什么，要怎么办？ PS C:\\&gt; Set-Alias -Name ping -Value notepad PS C:\\&gt; ping 127.0.0.1 当创建了一个别名之后，并没有 cmdlet 可以移除它。您必须得关闭 PowerShell 并打开一个新的 PowerShell 会话来“忘记”掉自定义的别名。 或者，您可以利用 alias: 虚拟驱动器，并且像移除文件一样移除别名： PS C:\\&gt; del alias:ping PS C:\\&gt; ping 127.0.0.1 Pinging 127.0.0.1 with 32 bytes of data: Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128 Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128 Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128 Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128 Ping statistics for 127.0.0.1: Packets: Sent = 4, Received = 4, Lost = 0 (0% loss), Approximate round trip times in milli-seconds: Minimum = 0ms, Maximum = 0ms, Average = 0ms PS C:\\&gt;","text":"在 PowerShell 中创建新的别名很常见。但是如果您做错了什么，要怎么办？ PS C:\\&gt; Set-Alias -Name ping -Value notepad PS C:\\&gt; ping 127.0.0.1 当创建了一个别名之后，并没有 cmdlet 可以移除它。您必须得关闭 PowerShell 并打开一个新的 PowerShell 会话来“忘记”掉自定义的别名。 或者，您可以利用 alias: 虚拟驱动器，并且像移除文件一样移除别名： PS C:\\&gt; del alias:ping PS C:\\&gt; ping 127.0.0.1 Pinging 127.0.0.1 with 32 bytes of data: Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128 Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128 Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128 Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128 Ping statistics for 127.0.0.1: Packets: Sent = 4, Received = 4, Lost = 0 (0% loss), Approximate round trip times in milli-seconds: Minimum = 0ms, Maximum = 0ms, Average = 0ms PS C:\\&gt; 本文国际来源：Deleting Aliases","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 快速创建编码的 PowerShell 命令","slug":"creating-encoded-powershell-commands-on-the-fly","date":"2015-10-12T03:00:00.000Z","updated":"2017-03-17T15:26:26.413Z","comments":true,"path":"2015/10/12/creating-encoded-powershell-commands-on-the-fly/","link":"","permalink":"http://blog.vichamp.com/2015/10/12/creating-encoded-powershell-commands-on-the-fly/","excerpt":"当在 PowerShell 控制台之外执行 PowerShell 代码时，您需要传递代码给 powershell.exe。要确保您的代码不与特殊字符冲突，命令可以编码后传给 powershell.exe。 一个最简单的将纯文本命令行转换为编码后的命令的方法如下： PS C:\\&gt; cmd /c echo powershell { Get-Service | Where-Object Status -eq Running } powershell -encodedCommand IABHAGUAdAAtAFMAZQByAHYAaQBjAGUAIAB8ACAAVwBoAGUAcgBlAC0ATwBiAGoAZQ BjAHQAIABTAHQAYQB0AHUAcwAgAC0AZQBxACAAUgB1AG4AbgBpAG4AZwAgAA== -inputFormat xml -outputFormat xml PS C:\\&gt; Here you’d find out that you can run the Get-Service | Where-Object statement as an encoded command like this:然后可以以这样的方式执行编码后的 Get-Service | Where-Object 语句。 powershell.exe -encodedCommand IABHAGUAdAAtAFMAZQByAHYAaQBjAGUAIAB8ACAAVwBoAGUAcgBlAC0ATwBiAGoAZQBjAHQAIABTAHQAYQB0AHUAcwAgAC0AZQBxACAAUgB1AG4AbgBpAG4AZwAgAA== 当您在 cmd.exe（或 PowerShell 控制台中）运行这段语句时，您能够得到所有运行中的服务。只需要移除 -inputFormat 和 -outputFormat 参数，并且移除所有换行符。编码后的命令是一个长长的字符串。","text":"当在 PowerShell 控制台之外执行 PowerShell 代码时，您需要传递代码给 powershell.exe。要确保您的代码不与特殊字符冲突，命令可以编码后传给 powershell.exe。 一个最简单的将纯文本命令行转换为编码后的命令的方法如下： PS C:\\&gt; cmd /c echo powershell { Get-Service | Where-Object Status -eq Running } powershell -encodedCommand IABHAGUAdAAtAFMAZQByAHYAaQBjAGUAIAB8ACAAVwBoAGUAcgBlAC0ATwBiAGoAZQ BjAHQAIABTAHQAYQB0AHUAcwAgAC0AZQBxACAAUgB1AG4AbgBpAG4AZwAgAA== -inputFormat xml -outputFormat xml PS C:\\&gt; Here you’d find out that you can run the Get-Service | Where-Object statement as an encoded command like this:然后可以以这样的方式执行编码后的 Get-Service | Where-Object 语句。 powershell.exe -encodedCommand IABHAGUAdAAtAFMAZQByAHYAaQBjAGUAIAB8ACAAVwBoAGUAcgBlAC0ATwBiAGoAZQBjAHQAIABTAHQAYQB0AHUAcwAgAC0AZQBxACAAUgB1AG4AbgBpAG4AZwAgAA== 当您在 cmd.exe（或 PowerShell 控制台中）运行这段语句时，您能够得到所有运行中的服务。只需要移除 -inputFormat 和 -outputFormat 参数，并且移除所有换行符。编码后的命令是一个长长的字符串。 本文国际来源：Creating Encoded PowerShell Commands on the Fly","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 为变量增加 ValidateRange","slug":"adding-validaterange-to-a-variable","date":"2015-10-09T03:00:00.000Z","updated":"2017-03-17T15:26:26.413Z","comments":true,"path":"2015/10/09/adding-validaterange-to-a-variable/","link":"","permalink":"http://blog.vichamp.com/2015/10/09/adding-validaterange-to-a-variable/","excerpt":"如果您希望为一个变量增加一个合法数值的范围，您可以向该变量添加一个 ValidateRange 属性，很像函数参数的工作方式。唯一的区别在，它手工作用于您期望的变量上： $test = 1 $variable = Get-Variable test $validateRange = New-Object -TypeName System.Management.Automation.ValidateRangeAttribute(1,100) $variable.Attributes.Add($validateRange) $test = 10 $test = 100 $test = 1000 变量 $test 现在只允许 1 到 100 的数值。当您试图赋一个该范围之外的值时，会得到一个异常。 PS C:\\&gt; $test = 101 The variable cannot be validated because the value 101 is not a valid value for the test variable. At line:1 char:1 + $test = 101 + ~~~~~~~~~~~ + CategoryInfo : MetadataError: (:) [], ValidationMetadataException + FullyQualifiedErrorId : ValidateSetFailure","text":"如果您希望为一个变量增加一个合法数值的范围，您可以向该变量添加一个 ValidateRange 属性，很像函数参数的工作方式。唯一的区别在，它手工作用于您期望的变量上： $test = 1 $variable = Get-Variable test $validateRange = New-Object -TypeName System.Management.Automation.ValidateRangeAttribute(1,100) $variable.Attributes.Add($validateRange) $test = 10 $test = 100 $test = 1000 变量 $test 现在只允许 1 到 100 的数值。当您试图赋一个该范围之外的值时，会得到一个异常。 PS C:\\&gt; $test = 101 The variable cannot be validated because the value 101 is not a valid value for the test variable. At line:1 char:1 + $test = 101 + ~~~~~~~~~~~ + CategoryInfo : MetadataError: (:) [], ValidationMetadataException + FullyQualifiedErrorId : ValidateSetFailure 本文国际来源：Adding ValidateRange to a Variable","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 为什么 $MaximumHistoryCount 容量有限","slug":"why-maximumhistorycount-has-a-limit","date":"2015-10-08T03:00:00.000Z","updated":"2017-03-17T15:26:26.397Z","comments":true,"path":"2015/10/08/why-maximumhistorycount-has-a-limit/","link":"","permalink":"http://blog.vichamp.com/2015/10/08/why-maximumhistorycount-has-a-limit/","excerpt":"如果您想增加最大命令历史的容量，您可能会遇到这样的限制： PS C:\\&gt; $MaximumHistoryCount = 100000 The variable cannot be validated because the value 100000 is not a valid value for the Maximum HistoryCount variable. 这里并没有提示合法的范围是多少。有意思的地方是这个变量的合法范围保存在哪。答案是：您可以查询这个变量的 ValidateRange 属性： $variable = Get-Variable MaximumHistoryCount $variable.Attributes $variable.Attributes.MinRange $variable.Attributes.MaxRange 但您遇到一个变量在原始数据类型之外有数值限制，您可能需要检查变量的属性来确认其中是否有验证器属性。","text":"如果您想增加最大命令历史的容量，您可能会遇到这样的限制： PS C:\\&gt; $MaximumHistoryCount = 100000 The variable cannot be validated because the value 100000 is not a valid value for the Maximum HistoryCount variable. 这里并没有提示合法的范围是多少。有意思的地方是这个变量的合法范围保存在哪。答案是：您可以查询这个变量的 ValidateRange 属性： $variable = Get-Variable MaximumHistoryCount $variable.Attributes $variable.Attributes.MinRange $variable.Attributes.MaxRange 但您遇到一个变量在原始数据类型之外有数值限制，您可能需要检查变量的属性来确认其中是否有验证器属性。 本文国际来源：Why $MaximumHistoryCount has a Limit","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 复制命令历史","slug":"copying-command-history-0","date":"2015-10-07T03:00:00.000Z","updated":"2017-03-17T15:26:26.397Z","comments":true,"path":"2015/10/07/copying-command-history-0/","link":"","permalink":"http://blog.vichamp.com/2015/10/07/copying-command-history-0/","excerpt":"您可以将整个命令历史拷贝到剪贴板中： (Get-History).CommandLine | clip.exe 该技术使用 PowerShell 3.0 带来的自动展开技术。若要在 PowerShell 2.0 中使用它，您需要像这样手工展开属性： Get-History | Select-Object -ExpandProperty commandline | clip.exe 要只拷贝最后五条命令，只需要为 Get-History 命令加上 -Count 参数即可： (Get-History -Count 5).CommandLine | clip.exe","text":"您可以将整个命令历史拷贝到剪贴板中： (Get-History).CommandLine | clip.exe 该技术使用 PowerShell 3.0 带来的自动展开技术。若要在 PowerShell 2.0 中使用它，您需要像这样手工展开属性： Get-History | Select-Object -ExpandProperty commandline | clip.exe 要只拷贝最后五条命令，只需要为 Get-History 命令加上 -Count 参数即可： (Get-History -Count 5).CommandLine | clip.exe 本文国际来源：Copying Command History","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 增加历史缓存","slug":"increase-history-cache","date":"2015-10-06T03:00:00.000Z","updated":"2017-03-17T15:26:26.381Z","comments":true,"path":"2015/10/06/increase-history-cache/","link":"","permalink":"http://blog.vichamp.com/2015/10/06/increase-history-cache/","excerpt":"当您在 PowerShell 会话中工作一段时间以后，命令历史可能十分有用。每个会话存储了您输入的所有命令，您可以按上下键浏览已输入的命令。 您甚至可以这样搜索历史缓存： PS C:\\&gt; #obje 键入一个注释符（# 号），然后跟上您所能回忆起的命令关键字，然后按下 TAB 键，每按一次 TAB 将会显示命令历史中匹配的一条命令（如果没有匹配成功，将不会显示）。 要限制命令历史的大小，请使用 $MaximumHistoryCount 变量。缺省值是 4096。 PS C:\\&gt; $MaximumHistoryCount 4096 PS C:\\&gt; $MaximumHistoryCount = 32KB-1 PS C:\\&gt; $MaximumHistoryCount 32767 PS C:\\&gt; 历史缓存最大允许的容量是 32KB-1。","text":"当您在 PowerShell 会话中工作一段时间以后，命令历史可能十分有用。每个会话存储了您输入的所有命令，您可以按上下键浏览已输入的命令。 您甚至可以这样搜索历史缓存： PS C:\\&gt; #obje 键入一个注释符（# 号），然后跟上您所能回忆起的命令关键字，然后按下 TAB 键，每按一次 TAB 将会显示命令历史中匹配的一条命令（如果没有匹配成功，将不会显示）。 要限制命令历史的大小，请使用 $MaximumHistoryCount 变量。缺省值是 4096。 PS C:\\&gt; $MaximumHistoryCount 4096 PS C:\\&gt; $MaximumHistoryCount = 32KB-1 PS C:\\&gt; $MaximumHistoryCount 32767 PS C:\\&gt; 历史缓存最大允许的容量是 32KB-1。 本文国际来源：Increase History Cache","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取最后启动时间","slug":"getting-last-bootup-time","date":"2015-10-05T03:00:00.000Z","updated":"2017-03-17T15:26:26.381Z","comments":true,"path":"2015/10/05/getting-last-bootup-time/","link":"","permalink":"http://blog.vichamp.com/2015/10/05/getting-last-bootup-time/","excerpt":"在 PowerShell 3.0 以上版本中，可以很容易地用 Get-CimInstance 从 WMI 中获取真实的 DateTime 类型信息。这段代码将告诉您系统上次启动的时间： #requires -Version 3 (Get-CimInstance -ClassName Win32_OperatingSystem).LastBootUpTime 在 PowerShell 2.0 中，您只能使用 Get-WmiObject，它是以 WMI 格式反馈数据的： (Get-WmiObject -Class Win32_OperatingSystem).LastBootUpTime 这里，您必须手工转换 WMI 格式： $object = Get-WmiObject -Class Win32_OperatingSystem $lastboot = $object.LastBootUpTime $object.ConvertToDateTime($lastboot) ConvertToDateTime() 转换函数实际上是一个附加的方法。在这个场景背后，是一个静态方法实现了以上工作： $object = Get-WmiObject -Class Win32_OperatingSystem $lastboot = $object.LastBootUpTime [System.Management.ManagementDateTimeConverter]::ToDateTime($lastboot)","text":"在 PowerShell 3.0 以上版本中，可以很容易地用 Get-CimInstance 从 WMI 中获取真实的 DateTime 类型信息。这段代码将告诉您系统上次启动的时间： #requires -Version 3 (Get-CimInstance -ClassName Win32_OperatingSystem).LastBootUpTime 在 PowerShell 2.0 中，您只能使用 Get-WmiObject，它是以 WMI 格式反馈数据的： (Get-WmiObject -Class Win32_OperatingSystem).LastBootUpTime 这里，您必须手工转换 WMI 格式： $object = Get-WmiObject -Class Win32_OperatingSystem $lastboot = $object.LastBootUpTime $object.ConvertToDateTime($lastboot) ConvertToDateTime() 转换函数实际上是一个附加的方法。在这个场景背后，是一个静态方法实现了以上工作： $object = Get-WmiObject -Class Win32_OperatingSystem $lastboot = $object.LastBootUpTime [System.Management.ManagementDateTimeConverter]::ToDateTime($lastboot) 本文国际来源：Getting Last Bootup Time","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 复制对象","slug":"cloning-objects-0","date":"2015-10-02T03:00:00.000Z","updated":"2017-03-17T15:26:26.381Z","comments":true,"path":"2015/10/02/cloning-objects-0/","link":"","permalink":"http://blog.vichamp.com/2015/10/02/cloning-objects-0/","excerpt":"在前一个技能中我们演示了 PowerShell 是通过引用存储对象的。如果您想创建一个浮板，您可能需要手工复制对象的所有属性。 以下是一个简单的克隆对象的方法： $object1 = @{Name=&apos;Weltner&apos;; ID=12 } $object2 = @{Name=&apos;Frank&apos;; ID=99 } $a = $object1, $object2 # clone entire object by serializing it back and forth: $b = $a | ConvertTo-Json -Depth 99 | ConvertFrom-Json $b[0].Name = &apos;changed&apos; $b[0].Name $a[0].Name 不过，请注意序列化的过程可能会改变复制的对象类型。 PS C:\\&gt; $a[0].GetType().FullName System.Collections.Hashtable PS C:\\&gt; $b[0].GetType().FullName System.Management.Automation.PSCustomObject PS C:\\&gt;","text":"在前一个技能中我们演示了 PowerShell 是通过引用存储对象的。如果您想创建一个浮板，您可能需要手工复制对象的所有属性。 以下是一个简单的克隆对象的方法： $object1 = @{Name=&apos;Weltner&apos;; ID=12 } $object2 = @{Name=&apos;Frank&apos;; ID=99 } $a = $object1, $object2 # clone entire object by serializing it back and forth: $b = $a | ConvertTo-Json -Depth 99 | ConvertFrom-Json $b[0].Name = &apos;changed&apos; $b[0].Name $a[0].Name 不过，请注意序列化的过程可能会改变复制的对象类型。 PS C:\\&gt; $a[0].GetType().FullName System.Collections.Hashtable PS C:\\&gt; $b[0].GetType().FullName System.Management.Automation.PSCustomObject PS C:\\&gt; 本文国际来源：Cloning Objects","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 复制数组（第 2 部分）","slug":"copying-arrays-part-2","date":"2015-10-01T03:00:00.000Z","updated":"2017-03-17T15:26:26.381Z","comments":true,"path":"2015/10/01/copying-arrays-part-2/","link":"","permalink":"http://blog.vichamp.com/2015/10/01/copying-arrays-part-2/","excerpt":"在前一个技能中我们解释了如何用 Clone() 方法安全地“克隆”一个数组。这将把一个数组的内容复制到一个新的数组。 然而，如果数组的元素是对象（不是数字或字符串等原始数据类型），数组存储了这些对象的内存地址，所以克隆方法虽然创建了一个新的数组，但是新的数组仍然引用了相同对象。请看： $object1 = @{Name=&apos;Weltner&apos;; ID=12 } $object2 = @{Name=&apos;Frank&apos;; ID=99 } $a = $object1, $object2 $b = $a.Clone() $b[0].Name = &apos;changed&apos; $b[0].Name $a[0].Name 虽然您克隆了数组 $a，但是新的数组 $b 仍然引用了相同的对象，对对象的更改会同时影响两个数组。只有对数组内容的更改是独立的： $object1 = @{Name=&apos;Weltner&apos;; ID=12 } $object2 = @{Name=&apos;Frank&apos;; ID=99 } $a = $object1, $object2 $b = $a.Clone() $b[0] = &apos;deleted&apos; $b[0] $a[0]","text":"在前一个技能中我们解释了如何用 Clone() 方法安全地“克隆”一个数组。这将把一个数组的内容复制到一个新的数组。 然而，如果数组的元素是对象（不是数字或字符串等原始数据类型），数组存储了这些对象的内存地址，所以克隆方法虽然创建了一个新的数组，但是新的数组仍然引用了相同对象。请看： $object1 = @{Name=&apos;Weltner&apos;; ID=12 } $object2 = @{Name=&apos;Frank&apos;; ID=99 } $a = $object1, $object2 $b = $a.Clone() $b[0].Name = &apos;changed&apos; $b[0].Name $a[0].Name 虽然您克隆了数组 $a，但是新的数组 $b 仍然引用了相同的对象，对对象的更改会同时影响两个数组。只有对数组内容的更改是独立的： $object1 = @{Name=&apos;Weltner&apos;; ID=12 } $object2 = @{Name=&apos;Frank&apos;; ID=99 } $a = $object1, $object2 $b = $a.Clone() $b[0] = &apos;deleted&apos; $b[0] $a[0] 本文国际来源：Copying Arrays (Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"小米路由器 mini 与 OpenWRT","slug":"miwifimini-with-OpenWRT","date":"2015-09-30T07:42:00.000Z","updated":"2017-03-17T15:26:26.378Z","comments":true,"path":"2015/09/30/miwifimini-with-OpenWRT/","link":"","permalink":"http://blog.vichamp.com/2015/09/30/miwifimini-with-OpenWRT/","excerpt":"","text":"今天拿到小米路由器 mini ，准备对它刷入 OpenWRT 固件。这类操作通常都有些坑，所以将过程记录如下： 初始化 难度 ★★☆☆☆ 陷阱 ★☆☆☆☆ 小米路由器 mini 开箱以后，按照内附的纸质说明书对它进行简单的初始化，使得电脑可以通过它上网。这个过程是面向普通消费者的，所以过程不再赘述。 初始化完成后，路由器 WEB 管理界面中可能会提示有可升级的固件，在此可以忽略，因为我们下一步可能对它进行降级。 在路由器的 USB 口中插入一个格式化为 FAT32 的空白 U 盘，容量在 1GB 以上即可，最好是带指示灯的，这样可以看得到它的读写状态。首次插入 U 盘的时候，小米路由器会向 U 盘里写入十来兆的数据，要等 U 盘指示灯停止闪烁以后再进行后续的断电、刷机等操作比较保险。 用小米路由器的手机 APP（扫盒子上的二维码下载）将路由器和小米账户绑定。这步是打开 SSH 的基础。 固件降级 难度 ★★☆☆☆ 陷阱 ★★★☆☆ 为了打开 SSH 功能，我们需要刷入小米路由 mini 的开发版固件。注意，我们不仅不能刷入最新版的固件，相反，要对已有的固件降级。因为经过一系列实验，发现若使用高版本的小米路由器 mini 固件，在后续打开 SSH 操作的时候，会遇到黄灯闪烁 3 秒后变成了红灯的问题。 请自行搜索 0.6.40 版的 miwifi_r1cm_all_ace8a_0.6.40.bin 并下载，这个版本亲测可以用。官网的MiWiFi成长日志提供的 0.8.x 和 0.7.x 版都无法打开 SSH。 然后在路由器的 WEB 控制台的路由设置中手动刷入上述 .bin 文件。按照提示等待 5-8 分钟，就可以再次进入路由器的 WEB 控制台了。可以在 WEB 控制台中确认降级成功。 打开 SSH 难度 ★★★☆☆ 陷阱 ★★☆☆☆ 打开 SSH 意味着失去保修。不过准备继续折腾的人早已做好放弃保修的准备了。 访问MiWiFi – 小米路由器官网，点击“开放/开启 SSH 工具/下载工具包”，并记下 root 密码。注意这将下载一个专属的 miwifi_ssh.bin 文件，同款不同机器是不通用的。 把下载下来的 miwifi_ssh.bin 复制到刚才的 U 盘中。断电，插入 U 盘，按住复位键，通电，在黄色指示灯闪烁的时候，放开复位键，等待….当指示灯变成 蓝色长亮的时候，说明我们获取到 root 权限并启动 SSH 服务了。 刷入 PandoraBox 难度 ★★★☆☆ 陷阱 ★★★☆☆ 访问 Index of /PandoraBox/Xiaomi-Mini-R1CM/，目前 stable 目录下没东西，只有 testing 目录下有东西，也就是只有测试版。 下载最新的 PandoraBox-ralink-mt7620-xiaomi-mini-squashfs-sysupgrade-r460-20150216.bin（还有个文件名不带 mt7620 字样的固件不知道是做什么的）。 用 XSHELL、SecureCRT、PUTTY 等 SSH 客户端，以及 WinSCP 文件传输器（以 SCP 协议）以前面记录的 root 密码登录 192.168.31.1。 用 WinSCP 把下载的 PandoraBox 固件上传到小米路由 mini 的 /tmp/ 目录下，顺便改个短点的名字 PandoraBox.bin。 在 SSH 客户端中执行以下命令开始刷入 PandoraBox 固件： mtd -r write /tmp/PandoraBox.bin firmware 注意，如果遇到 Could not open mtd device: firmware 提示，请按前面的步骤进行固件降级。 等路由重启后，可以搜索到信号PandoraBox_XXXX，没有密码，连上去后进入192.168.1.1，密码 admin，之后就能看到可爱的 OpenWRT 界面了。 刷 u-boot刷 u-boot 应该在刷 PandoraBox 步骤之前。刷 PandoraBox u-boot 不是必须的，但是刷了可以方便后续的上传固件，不用一直SS H 操作。 u-boot是一种普遍用于嵌入式系统中的Bootloader,Bootloader是在操作系统运行之前执行的一小段程序。他可以用来恢复小米路由器的固件，可以说只要刷了uboot，你的路由器基本上刷不死了。 小米 u-boot 的用法是将固件命名为 miwifi.bin，存在 FAT32 U 盘根目录中，插入路由器，按住 reset 键接通电源，待黄灯闪烁之后松开。 PandoraBox u-boot 的用法是将 PC 网卡配置成 192.168.1.2/255.255.255.0/192.168.1.1，按住 reset 键接通电源，待黄灯闪烁之后松开，用 PC 浏览器打开 http://192.168.1.1，即可通过上传 PandoraBox 的固件来刷。 注意，小米官方的 u-boot 和 PandoraBox 的不同。刷了 PandoraBox 的固件之后，不能通过 WEB 方式刷小米固件，但可以通过 WEB 方式刷小米 u-boot，然后通过小米 u-boot 可以刷小米固件。这样来实现从 PandoraBox 刷回原产小米固件。 主要攻略如下： 小米路由器mini折腾之刷不死uboot篇 - 老高的技术博客小米mini使用不死uboot刷宽带宝教程 - 交流讨论 - 宽带宝论坛 - Powered by Discuz! 参考 MiWiFi – 小米路由器官网 如果通过小米路由器来访问，实际上访问的可能是路由器内部的管理界面。 使用小米路由器mini刷pandorabox并使用ChinaDNS-C + dnsmasq + shadowsocks 实现透明翻墙 小米路由mini潘多拉+OpenWrt+stable版+完美解决软件源+Transmission+MultiWan+Python 【小米路由器mini刷机】mini刷潘多拉固件教程（固件已更新）_小米路由器_MIUI论坛","categories":[{"name":"embedded","slug":"embedded","permalink":"http://blog.vichamp.com/categories/embedded/"}],"tags":[{"name":"embedded","slug":"embedded","permalink":"http://blog.vichamp.com/tags/embedded/"},{"name":"linux","slug":"linux","permalink":"http://blog.vichamp.com/tags/linux/"}],"keywords":[{"name":"embedded","slug":"embedded","permalink":"http://blog.vichamp.com/categories/embedded/"}]},{"title":"PowerShell 技能连载 - 复制数组（第 1 部分）","slug":"copying-arrays-part-1","date":"2015-09-30T03:00:00.000Z","updated":"2017-03-17T15:26:26.371Z","comments":true,"path":"2015/09/30/copying-arrays-part-1/","link":"","permalink":"http://blog.vichamp.com/2015/09/30/copying-arrays-part-1/","excerpt":"当您复制变量内容时，您也可以只拷贝“引用”（内存地址），而不是内容。请看这个例子： $a = 1..10 $b = $a $b[0] = &apos;changed&apos; $b[0] $a[0] 虽然您改变了 $b，但 $a 也跟着改变。两个变量都引用了相同的内存地址，所以两者具有相同的内容。 要创建一个数组的全新拷贝，您需要先对它进行克隆： $a = 1..10 $b = $a.Clone() $b[0] = &apos;changed&apos; $b[0] $a[0]","text":"当您复制变量内容时，您也可以只拷贝“引用”（内存地址），而不是内容。请看这个例子： $a = 1..10 $b = $a $b[0] = &apos;changed&apos; $b[0] $a[0] 虽然您改变了 $b，但 $a 也跟着改变。两个变量都引用了相同的内存地址，所以两者具有相同的内容。 要创建一个数组的全新拷贝，您需要先对它进行克隆： $a = 1..10 $b = $a.Clone() $b[0] = &apos;changed&apos; $b[0] $a[0] 本文国际来源：Copying Arrays (Part 1)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用编码的脚本","slug":"using-encoded-scripts","date":"2015-09-29T03:00:00.000Z","updated":"2017-03-17T15:26:26.353Z","comments":true,"path":"2015/09/29/using-encoded-scripts/","link":"","permalink":"http://blog.vichamp.com/2015/09/29/using-encoded-scripts/","excerpt":"在 VBScript 中有编码的脚本。编码并不是隐藏脚本内容的安全方法，但它能使用户获取代码内容略微更难一点。 以下是一个传入 PowerShell 脚本并对它编码的函数： function ConvertTo-EncodedScript { param ( $Path, [Switch]$Open ) $Code = Get-Content -Path $Path -Raw $Bytes = [System.Text.Encoding]::Unicode.GetBytes($Code) $Base64 = [Convert]::ToBase64String($Bytes) $NewPath = [System.IO.Path]::ChangeExtension($Path, &apos;.pse1&apos;) $Base64 | Set-Content -Path $NewPath if ($Open) { notepad $NewPath } } 编码后的脚本将会以 .pse1 扩展名来保存（这是一个完全随意定义的文件扩展名，并不是微软定义的）。 要执行这段编码后的脚本，请运行这段命令（不能在 PowerShell ISE 中运行）： powershell -encodedcommand (Get-Content &apos;Z:\\pathtoscript\\scriptname.pse1&apos; -Raw) 请注意 PowerShell 最多支持大约 8000 个字符的编码命令。编码命令的本意是安全地将 PowerShell 代码传递给 powershell.exe，而不会被特殊字符打断命令行。","text":"在 VBScript 中有编码的脚本。编码并不是隐藏脚本内容的安全方法，但它能使用户获取代码内容略微更难一点。 以下是一个传入 PowerShell 脚本并对它编码的函数： function ConvertTo-EncodedScript { param ( $Path, [Switch]$Open ) $Code = Get-Content -Path $Path -Raw $Bytes = [System.Text.Encoding]::Unicode.GetBytes($Code) $Base64 = [Convert]::ToBase64String($Bytes) $NewPath = [System.IO.Path]::ChangeExtension($Path, &apos;.pse1&apos;) $Base64 | Set-Content -Path $NewPath if ($Open) { notepad $NewPath } } 编码后的脚本将会以 .pse1 扩展名来保存（这是一个完全随意定义的文件扩展名，并不是微软定义的）。 要执行这段编码后的脚本，请运行这段命令（不能在 PowerShell ISE 中运行）： powershell -encodedcommand (Get-Content &apos;Z:\\pathtoscript\\scriptname.pse1&apos; -Raw) 请注意 PowerShell 最多支持大约 8000 个字符的编码命令。编码命令的本意是安全地将 PowerShell 代码传递给 powershell.exe，而不会被特殊字符打断命令行。 本文国际来源：Using Encoded Scripts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 try..finally 在 PowerShell 关闭时执行代码","slug":"use-try-finally-to-execute-code-when-powershell-closes","date":"2015-09-28T03:00:00.000Z","updated":"2017-03-17T15:26:26.337Z","comments":true,"path":"2015/09/28/use-try-finally-to-execute-code-when-powershell-closes/","link":"","permalink":"http://blog.vichamp.com/2015/09/28/use-try-finally-to-execute-code-when-powershell-closes/","excerpt":"如果您需要在 PowerShell 退出之前执行一些代码，您可以像这样简单地使用 try..finally 代码块： try { # some code Start-Sleep -Seconds 20 } finally { # this gets executed even if the code in the try block throws an exception [Console]::Beep(4000,1000) } 这段代码模拟一段长时间运行的脚本。甚至您关闭 PowerShell 窗口时，在 finally 块中的代码也会在 PowerShell 停止之前执行。 当然这得当脚本确实在运行时才有效。","text":"如果您需要在 PowerShell 退出之前执行一些代码，您可以像这样简单地使用 try..finally 代码块： try { # some code Start-Sleep -Seconds 20 } finally { # this gets executed even if the code in the try block throws an exception [Console]::Beep(4000,1000) } 这段代码模拟一段长时间运行的脚本。甚至您关闭 PowerShell 窗口时，在 finally 块中的代码也会在 PowerShell 停止之前执行。 当然这得当脚本确实在运行时才有效。 本文国际来源：Use try…finally to Execute Code when PowerShell Closes","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用后台任务","slug":"using-background-jobs","date":"2015-09-25T03:00:00.000Z","updated":"2017-03-17T15:26:26.337Z","comments":true,"path":"2015/09/25/using-background-jobs/","link":"","permalink":"http://blog.vichamp.com/2015/09/25/using-background-jobs/","excerpt":"后台任务可以用来加速您的脚本。如果您的脚本有一系列可并发执行的独立的任务组成，那么就合适使用后台任务。 后台任务适用于这两种情况： 任务需要至少 3-4 秒执行时间。 任务并不会返回大量数据。 以下是一个基本的由 3 个任务组成的后台任务场景。如果依次执行，它们一共约耗费 23 秒时间。通过使用后台任务，它们只消耗 11 秒（由最长的单个任务时间决定）加上一些额外的上下文时间。 #requires -Version 2 # three things you want to do in parallel # for illustration, Start-Sleep is used # remove Start-Sleep and replace with real-world # tasks $task1 = { Start-Sleep -Seconds 4 dir $home } $task2 = { Start-Sleep -Seconds 8 Get-Service } $task3 = { Start-Sleep -Seconds 11 &apos;Hello Dude&apos; } $job1 = Start-Job -ScriptBlock $task1 $job2 = Start-Job -ScriptBlock $task2 $result3 = &amp; $task3 Wait-Job -Job $job1, $job2 $result1 = Receive-Job -Job $job1 $result2 = Receive-Job -Job $job2 Remove-Job $job1, $job2","text":"后台任务可以用来加速您的脚本。如果您的脚本有一系列可并发执行的独立的任务组成，那么就合适使用后台任务。 后台任务适用于这两种情况： 任务需要至少 3-4 秒执行时间。 任务并不会返回大量数据。 以下是一个基本的由 3 个任务组成的后台任务场景。如果依次执行，它们一共约耗费 23 秒时间。通过使用后台任务，它们只消耗 11 秒（由最长的单个任务时间决定）加上一些额外的上下文时间。 #requires -Version 2 # three things you want to do in parallel # for illustration, Start-Sleep is used # remove Start-Sleep and replace with real-world # tasks $task1 = { Start-Sleep -Seconds 4 dir $home } $task2 = { Start-Sleep -Seconds 8 Get-Service } $task3 = { Start-Sleep -Seconds 11 &apos;Hello Dude&apos; } $job1 = Start-Job -ScriptBlock $task1 $job2 = Start-Job -ScriptBlock $task2 $result3 = &amp; $task3 Wait-Job -Job $job1, $job2 $result1 = Receive-Job -Job $job1 $result2 = Receive-Job -Job $job2 Remove-Job $job1, $job2 本文国际来源：Using Background Jobs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 移除 Windows 10 应用","slug":"removing-windows-10-apps","date":"2015-09-24T03:00:00.000Z","updated":"2017-03-17T15:26:26.337Z","comments":true,"path":"2015/09/24/removing-windows-10-apps/","link":"","permalink":"http://blog.vichamp.com/2015/09/24/removing-windows-10-apps/","excerpt":"Windows 10 预装了一系列应用程序。幸运的是，您可以用 PowerShell 来移除您不想要的程序。当然，需要管理员权限。 要查看安装了哪些应用程序，请运行这段代码： Get-AppxPackage -User $env:USERNAME 这将列出所有用您自己的用户账户安装的应用程序。要移除应用程序，请使用 PackageFullName，并且将它传给 Remove-AppxPackage 命令。请在更改之前备份您的系统，而且风险自负。多数应用程序并不是必须的。","text":"Windows 10 预装了一系列应用程序。幸运的是，您可以用 PowerShell 来移除您不想要的程序。当然，需要管理员权限。 要查看安装了哪些应用程序，请运行这段代码： Get-AppxPackage -User $env:USERNAME 这将列出所有用您自己的用户账户安装的应用程序。要移除应用程序，请使用 PackageFullName，并且将它传给 Remove-AppxPackage 命令。请在更改之前备份您的系统，而且风险自负。多数应用程序并不是必须的。 本文国际来源：Removing Windows 10 Apps","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 修正远程发送者信息","slug":"fixing-remoting-sender-information","date":"2015-09-23T03:00:00.000Z","updated":"2017-03-17T15:26:26.322Z","comments":true,"path":"2015/09/23/fixing-remoting-sender-information/","link":"","permalink":"http://blog.vichamp.com/2015/09/23/fixing-remoting-sender-information/","excerpt":"如果您使用 Invoke-Command 来远程执行 PowerShell 代码，您可能会注意到 PowerShell 远程操作会添加一个新的 PSComputerName 属性用来表示数据的来源。 这段代码将获取名为 dc-01 的机器的进程列表。PSComputerName 属性指明了源计算机名。当您使用多于一台电脑时十分有用。 #requires -Version 2 $code = { Get-Process } Invoke-Command -ScriptBlock $code -ComputerName dc-01 然而，如果您将结果用管道输出到 Out-GridView，PSComputerName 属性消失了。 作为一个变通办法，当您将结果输出到 Select-Object 命令时，PSComputerName 属性将会在网格视图窗口中正确地显示。 #requires -Version 2 $code = { Get-Process | Select-Object -Property Name, ID, Handles, CPU } Invoke-Command -ScriptBlock $code -ComputerName dc-01 | Out-GridView","text":"如果您使用 Invoke-Command 来远程执行 PowerShell 代码，您可能会注意到 PowerShell 远程操作会添加一个新的 PSComputerName 属性用来表示数据的来源。 这段代码将获取名为 dc-01 的机器的进程列表。PSComputerName 属性指明了源计算机名。当您使用多于一台电脑时十分有用。 #requires -Version 2 $code = { Get-Process } Invoke-Command -ScriptBlock $code -ComputerName dc-01 然而，如果您将结果用管道输出到 Out-GridView，PSComputerName 属性消失了。 作为一个变通办法，当您将结果输出到 Select-Object 命令时，PSComputerName 属性将会在网格视图窗口中正确地显示。 #requires -Version 2 $code = { Get-Process | Select-Object -Property Name, ID, Handles, CPU } Invoke-Command -ScriptBlock $code -ComputerName dc-01 | Out-GridView 本文国际来源：Fixing Remoting Sender Information","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 设置新的 Windows 注册所有者","slug":"setting-new-windows-registered-owner","date":"2015-09-22T03:00:00.000Z","updated":"2017-03-17T15:26:26.322Z","comments":true,"path":"2015/09/22/setting-new-windows-registered-owner/","link":"","permalink":"http://blog.vichamp.com/2015/09/22/setting-new-windows-registered-owner/","excerpt":"这一小段代码将提示输入新的注册所有者名，然后将更新 Windows 注册表中的值。请注意需要管理员权限。 #requires -RunAsAdministrator $NewName = Read-Host -Prompt &apos;Enter New Registered Windows Owner&apos; Set-ItemProperty -Path &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&apos; -Name RegisteredOwner -Value $NewName -Type String 这也是一个更改 Windows 注册表的模板代码。","text":"这一小段代码将提示输入新的注册所有者名，然后将更新 Windows 注册表中的值。请注意需要管理员权限。 #requires -RunAsAdministrator $NewName = Read-Host -Prompt &apos;Enter New Registered Windows Owner&apos; Set-ItemProperty -Path &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&apos; -Name RegisteredOwner -Value $NewName -Type String 这也是一个更改 Windows 注册表的模板代码。 本文国际来源：Setting New Windows Registered Owner","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 下载文件","slug":"downloading-files","date":"2015-09-21T03:00:00.000Z","updated":"2017-03-17T15:26:26.320Z","comments":true,"path":"2015/09/21/downloading-files/","link":"","permalink":"http://blog.vichamp.com/2015/09/21/downloading-files/","excerpt":"Invoke-WebRequest 可以从 internet 下载文件。这个例子将下载一个 33MB 的 NASA 公开视频到您的计算机上，然后用您计算机上 WMV 视频文件的关联应用打开它： #requires -Version 3 $Video = &apos;http://s3.amazonaws.com/akamai.netstorage/HD_downloads/BEAMextract_final_revB.wmv&apos; $Destination = &quot;$env:temp\\nasavideo1.wmv&quot; Invoke-WebRequest -Uri $Video -OutFile $Destination -UseBasicParsing Invoke-Item -Path $Destination","text":"Invoke-WebRequest 可以从 internet 下载文件。这个例子将下载一个 33MB 的 NASA 公开视频到您的计算机上，然后用您计算机上 WMV 视频文件的关联应用打开它： #requires -Version 3 $Video = &apos;http://s3.amazonaws.com/akamai.netstorage/HD_downloads/BEAMextract_final_revB.wmv&apos; $Destination = &quot;$env:temp\\nasavideo1.wmv&quot; Invoke-WebRequest -Uri $Video -OutFile $Destination -UseBasicParsing Invoke-Item -Path $Destination 本文国际来源：Downloading Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将哈希表用作条件化的代码库","slug":"using-hash-table-as-conditional-code-repository","date":"2015-09-18T03:00:00.000Z","updated":"2017-03-17T15:26:26.315Z","comments":true,"path":"2015/09/18/using-hash-table-as-conditional-code-repository/","link":"","permalink":"http://blog.vichamp.com/2015/09/18/using-hash-table-as-conditional-code-repository/","excerpt":"脚本中平时经常需要检测一个文件夹是否存在，如果不存在则创建： #requires -Version 1 $path = &apos;c:\\testfolder&apos; $exists = Test-Path -Path $path if ($exists) { $null = New-Item -Path $path -ItemType Directory Write-Warning -Message &apos;Folder created&apos; } else { Write-Warning -Message &apos;Folder already present&apos; } 以下是一种很不常见的方法，以一种不同的概念实现相同的功能： #requires -Version 1 $Creator = @{ $true = { Write-Warning &apos;Folder already present&apos;} $false = {$null = New-Item -Path $Path -ItemType Directory Write-Warning &apos;Folder created&apos;} } $Path = &apos;c:\\testfolder2&apos; &amp; $Creator[(Test-Path $Path)] 实际上，这段脚本用了一个哈希表（$Creator)）来存储两个脚本块，而它的键是 $true 和 $false。 现在，根据文件夹存在与否，哈希表将返回合适的脚本块，接下来被 &amp;（调用）操作符执行。 哈希表用这种方式来模拟从句。","text":"脚本中平时经常需要检测一个文件夹是否存在，如果不存在则创建： #requires -Version 1 $path = &apos;c:\\testfolder&apos; $exists = Test-Path -Path $path if ($exists) { $null = New-Item -Path $path -ItemType Directory Write-Warning -Message &apos;Folder created&apos; } else { Write-Warning -Message &apos;Folder already present&apos; } 以下是一种很不常见的方法，以一种不同的概念实现相同的功能： #requires -Version 1 $Creator = @{ $true = { Write-Warning &apos;Folder already present&apos;} $false = {$null = New-Item -Path $Path -ItemType Directory Write-Warning &apos;Folder created&apos;} } $Path = &apos;c:\\testfolder2&apos; &amp; $Creator[(Test-Path $Path)] 实际上，这段脚本用了一个哈希表（$Creator)）来存储两个脚本块，而它的键是 $true 和 $false。 现在，根据文件夹存在与否，哈希表将返回合适的脚本块，接下来被 &amp;（调用）操作符执行。 哈希表用这种方式来模拟从句。 本文国际来源：Using Hash Table as Conditional Code Repository","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 为什么 Invoke-Expression 是邪恶的","slug":"why-invoke-expression-is-evil","date":"2015-09-17T03:00:00.000Z","updated":"2017-03-17T15:26:26.307Z","comments":true,"path":"2015/09/17/why-invoke-expression-is-evil/","link":"","permalink":"http://blog.vichamp.com/2015/09/17/why-invoke-expression-is-evil/","excerpt":"Invoke-Expression 接受任何字符串输入并将它视为 PowerShell 代码。通过这种方式，您可以动态地创建代码，并执行它。 Invoke-Expression 是一个非常危险的命令，因为不仅您可以创建动态的代码。恶意的脚本可以隐藏它的邪恶目的，例如通过 web 站点下载代码。 以下是一个安全并有趣的例子，演示了如何从下载到执行一段代码： #requires -Version 3 Invoke-Expression -Command (Invoke-WebRequest -Uri &apos;http://bit.ly/e0Mw9w&apos; -UseBasicParsing).Content 如果您不希望发生意外，这行代码可以帮您预览将会发生什么。请在 PowerShell ISE 中运行这段代码。它将显示从 internet 下载的 PowerShell 代码，而不是立即执行它： #requires -Version 3 $file = $psise.CurrentPowerShellTab.Files.Add() $file.Editor.text = (Invoke-WebRequest -Uri &apos;http://bit.ly/e0Mw9w&apos; -UseBasicParsing).Content","text":"Invoke-Expression 接受任何字符串输入并将它视为 PowerShell 代码。通过这种方式，您可以动态地创建代码，并执行它。 Invoke-Expression 是一个非常危险的命令，因为不仅您可以创建动态的代码。恶意的脚本可以隐藏它的邪恶目的，例如通过 web 站点下载代码。 以下是一个安全并有趣的例子，演示了如何从下载到执行一段代码： #requires -Version 3 Invoke-Expression -Command (Invoke-WebRequest -Uri &apos;http://bit.ly/e0Mw9w&apos; -UseBasicParsing).Content 如果您不希望发生意外，这行代码可以帮您预览将会发生什么。请在 PowerShell ISE 中运行这段代码。它将显示从 internet 下载的 PowerShell 代码，而不是立即执行它： #requires -Version 3 $file = $psise.CurrentPowerShellTab.Files.Add() $file.Editor.text = (Invoke-WebRequest -Uri &apos;http://bit.ly/e0Mw9w&apos; -UseBasicParsing).Content 本文国际来源：Why Invoke-Expression is Evil","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 访问网页内容","slug":"accessing-web-page-content","date":"2015-09-16T03:00:00.000Z","updated":"2017-03-17T15:26:26.305Z","comments":true,"path":"2015/09/16/accessing-web-page-content/","link":"","permalink":"http://blog.vichamp.com/2015/09/16/accessing-web-page-content/","excerpt":"从 PowerShell 3.0 开始，Invoke-WebRequest 命令可以轻松地下载网页内容。例如这个例子可以从 www.powertheshell.com 获取所有链接： #requires -Version 3 $url = &apos;http://www.powertheshell.com&apos; $page = Invoke-WebRequest -Uri $url $page.Links 您也可以用这种方式获取原始的 HTML 内容： #requires -Version 3 $url = &apos;http://www.powertheshell.com&apos; $page = Invoke-WebRequest -Uri $url $page.RawContent 当您用这种方法处理其它 URL 时，您可能偶尔会遇到弹出一个安全警告框，提示需要存储 cookie 的权限。要禁止这些对话框出现并静默执行命令，请使用 -UseBasicParsing 参数。","text":"从 PowerShell 3.0 开始，Invoke-WebRequest 命令可以轻松地下载网页内容。例如这个例子可以从 www.powertheshell.com 获取所有链接： #requires -Version 3 $url = &apos;http://www.powertheshell.com&apos; $page = Invoke-WebRequest -Uri $url $page.Links 您也可以用这种方式获取原始的 HTML 内容： #requires -Version 3 $url = &apos;http://www.powertheshell.com&apos; $page = Invoke-WebRequest -Uri $url $page.RawContent 当您用这种方法处理其它 URL 时，您可能偶尔会遇到弹出一个安全警告框，提示需要存储 cookie 的权限。要禁止这些对话框出现并静默执行命令，请使用 -UseBasicParsing 参数。 本文国际来源：Accessing Web Page Content","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 分析 svchost 进程","slug":"analyzing-svchost-processes","date":"2015-09-15T03:00:00.000Z","updated":"2017-03-17T15:26:26.300Z","comments":true,"path":"2015/09/15/analyzing-svchost-processes/","link":"","permalink":"http://blog.vichamp.com/2015/09/15/analyzing-svchost-processes/","excerpt":"有时候，您会在任务管理器或 Get-Process 输出中看到一系列名为“svchost”的进程。每个“svchost”进程中运行着一个或多个 Windows 服务。 要更好地理解这些进程后隐藏着哪些服务，您可以使用这样的代码： #requires -Version 2 # Hash table defines two keys: # Name and Expression # they can be used with Select-Object # to produce &quot;calculated&quot; properties $Service = @{ Name = &apos;Service&apos; Expression = { # if the process is &quot;svchost&quot;... if ($_.Name -eq &apos;svchost&apos;) { # ...find out the current process ID... $processID = $_.ID # ...and look up the services attached to it ($serviceList.$processID).Name -join &apos;, &apos; } } } # create a service lookup table with ProcessID as a key $serviceList = Get-WmiObject -Class Win32_Service | Group-Object -Property ProcessID -AsString -AsHashTable # get all running processes... Get-Process | # add the new calculated column defined in $Service... Select-Object -Property Name, ID, CPU, $Service | # and output results to a grid view Window Out-GridView 当您运行这段代码时，您会见到当前运行中的进程列表。当进程名是“svchost”时，您会在新的“Service”列中查看到服务名。","text":"有时候，您会在任务管理器或 Get-Process 输出中看到一系列名为“svchost”的进程。每个“svchost”进程中运行着一个或多个 Windows 服务。 要更好地理解这些进程后隐藏着哪些服务，您可以使用这样的代码： #requires -Version 2 # Hash table defines two keys: # Name and Expression # they can be used with Select-Object # to produce &quot;calculated&quot; properties $Service = @{ Name = &apos;Service&apos; Expression = { # if the process is &quot;svchost&quot;... if ($_.Name -eq &apos;svchost&apos;) { # ...find out the current process ID... $processID = $_.ID # ...and look up the services attached to it ($serviceList.$processID).Name -join &apos;, &apos; } } } # create a service lookup table with ProcessID as a key $serviceList = Get-WmiObject -Class Win32_Service | Group-Object -Property ProcessID -AsString -AsHashTable # get all running processes... Get-Process | # add the new calculated column defined in $Service... Select-Object -Property Name, ID, CPU, $Service | # and output results to a grid view Window Out-GridView 当您运行这段代码时，您会见到当前运行中的进程列表。当进程名是“svchost”时，您会在新的“Service”列中查看到服务名。 本文国际来源：Analyzing svchost Processes","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 ProcessID 定位服务","slug":"identifying-services-by-processid","date":"2015-09-14T03:00:00.000Z","updated":"2017-03-17T15:26:26.282Z","comments":true,"path":"2015/09/14/identifying-services-by-processid/","link":"","permalink":"http://blog.vichamp.com/2015/09/14/identifying-services-by-processid/","excerpt":"Group-Object 是一个创建查询表的很好的命令。如果您希望用进程 ID 来定位一个 Windows 服务，以下是实现方法： $serviceList = Get-WmiObject -Class Win32_Service | Group-Object -Property ProcessID -AsString -AsHashTable 一旦变量被赋值之后，只需要用进程 ID 作为属性即可： PS&gt; $serviceList.672 ExitCode : 0 Name : WSearch ProcessId : 672 StartMode : Auto State : Running Status : OK","text":"Group-Object 是一个创建查询表的很好的命令。如果您希望用进程 ID 来定位一个 Windows 服务，以下是实现方法： $serviceList = Get-WmiObject -Class Win32_Service | Group-Object -Property ProcessID -AsString -AsHashTable 一旦变量被赋值之后，只需要用进程 ID 作为属性即可： PS&gt; $serviceList.672 ExitCode : 0 Name : WSearch ProcessId : 672 StartMode : Auto State : Running Status : OK 本文国际来源：Identifying Services by ProcessID","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建真实的类","slug":"creating-real-classes","date":"2015-09-11T03:00:00.000Z","updated":"2017-03-17T15:26:26.282Z","comments":true,"path":"2015/09/11/creating-real-classes/","link":"","permalink":"http://blog.vichamp.com/2015/09/11/creating-real-classes/","excerpt":"PowerShell 5.0 开始引入了类的概念，不过您也可以在 PowerShell 的其它版本中使用自定义类。只需要用 C# 代码来定义真正的类，然后用 Add-Type 来编译这些类。 以下是一个创建一个名为“myClass”，包含三个属性的新类。PowerShell 接下来可以用 New-Object 命令创建对象。 $code = &apos; using System; public class myClass { public bool Enabled { get; set; } public string Name { get; set; } public DateTime Time { get; set; } } &apos; Add-Type -TypeDefinition $code $instance = New-Object -TypeName myClass $instance.Enabled = $true $instance.Time = Get-Date $instance.Name = $env:username $instance 为什么需要这么做呢？自定义的类可以包含来自多个来源的信息，而且您可以使用 C# 的各种复杂特性来定义您的类，包括方法、动态和静态成员等。 显然，拥有一些技术背景的开发人员对这种技术最感兴趣。","text":"PowerShell 5.0 开始引入了类的概念，不过您也可以在 PowerShell 的其它版本中使用自定义类。只需要用 C# 代码来定义真正的类，然后用 Add-Type 来编译这些类。 以下是一个创建一个名为“myClass”，包含三个属性的新类。PowerShell 接下来可以用 New-Object 命令创建对象。 $code = &apos; using System; public class myClass { public bool Enabled { get; set; } public string Name { get; set; } public DateTime Time { get; set; } } &apos; Add-Type -TypeDefinition $code $instance = New-Object -TypeName myClass $instance.Enabled = $true $instance.Time = Get-Date $instance.Name = $env:username $instance 为什么需要这么做呢？自定义的类可以包含来自多个来源的信息，而且您可以使用 C# 的各种复杂特性来定义您的类，包括方法、动态和静态成员等。 显然，拥有一些技术背景的开发人员对这种技术最感兴趣。 本文国际来源：Creating Real Classes","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 向 PowerShell ISE 添加测试宿主","slug":"adding-test-hosts-to-powershell-ise","date":"2015-09-10T03:00:00.000Z","updated":"2017-03-17T15:26:26.259Z","comments":true,"path":"2015/09/10/adding-test-hosts-to-powershell-ise/","link":"","permalink":"http://blog.vichamp.com/2015/09/10/adding-test-hosts-to-powershell-ise/","excerpt":"要在随 PowerShell 3.0 以上版本发行的 PowerShell ISE 中打开一个新的测试宿主，这是一个小小的辅助函数： #requires -Version 3 function New-PSHost { param ( [Parameter(Mandatory = $true)] $Name ) $newTab = $psise.PowerShellTabs.Add() $newTab.DisplayName = $Name } 当您运行该函数并且输入 New-PSHost 之后，您会收到一个输入名字的提示。请键入新的测试宿主的名字，并按下 ENTER 键，PowerShell ISE 将会在一个新的 PowerShell 标签页中打开一个新的 PowerShell 宿主，并且标签页以您起的名字命名。","text":"要在随 PowerShell 3.0 以上版本发行的 PowerShell ISE 中打开一个新的测试宿主，这是一个小小的辅助函数： #requires -Version 3 function New-PSHost { param ( [Parameter(Mandatory = $true)] $Name ) $newTab = $psise.PowerShellTabs.Add() $newTab.DisplayName = $Name } 当您运行该函数并且输入 New-PSHost 之后，您会收到一个输入名字的提示。请键入新的测试宿主的名字，并按下 ENTER 键，PowerShell ISE 将会在一个新的 PowerShell 标签页中打开一个新的 PowerShell 宿主，并且标签页以您起的名字命名。 本文国际来源：Adding Test Hosts to PowerShell ISE","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中使用 PowerShell Tabs","slug":"using-powershell-tabs-in-the-powershell-ise","date":"2015-09-09T03:00:00.000Z","updated":"2017-03-17T15:26:26.259Z","comments":true,"path":"2015/09/09/using-powershell-tabs-in-the-powershell-ise/","link":"","permalink":"http://blog.vichamp.com/2015/09/09/using-powershell-tabs-in-the-powershell-ise/","excerpt":"随着 PowerShell 3.0 及以上版本发行的 PowerShell ISE 实际上是一个多宿主。它可以容纳多个单独的 PowerShell 实例。 要添加一个新的 PowerShell 宿主，请按 CTRL + T。然后输入 Enter-PSSession，并按下 CTRL + SHIFT + R 就能创建一个连接到远程系统的新的 PowerShell 宿主。 每个新的 PowerShell 宿主界面在 PowerShell ISE 中体现为一个新的标签页，名字为“PowerShell1”、“PowerShell2”、“PowerShell3”等。 在 ISE 中多个独立的 PowerShell 宿主十分有用。例如，希望在一个干净的环境里测试 test-drive 代码。 如果您愿意的话，甚至可以对标签进行重命名，来更好地体现它所表示的内容： PS&gt; $psise.CurrentPowerShellTab.DisplayName = &apos;Testing&apos; 请注意只有在至少有 2 个以上 PowerShell 宿主时，才会显示 PowerShell 标签。您可能需要先按下 CTRL + T 才能够看到重命名的效果。","text":"随着 PowerShell 3.0 及以上版本发行的 PowerShell ISE 实际上是一个多宿主。它可以容纳多个单独的 PowerShell 实例。 要添加一个新的 PowerShell 宿主，请按 CTRL + T。然后输入 Enter-PSSession，并按下 CTRL + SHIFT + R 就能创建一个连接到远程系统的新的 PowerShell 宿主。 每个新的 PowerShell 宿主界面在 PowerShell ISE 中体现为一个新的标签页，名字为“PowerShell1”、“PowerShell2”、“PowerShell3”等。 在 ISE 中多个独立的 PowerShell 宿主十分有用。例如，希望在一个干净的环境里测试 test-drive 代码。 如果您愿意的话，甚至可以对标签进行重命名，来更好地体现它所表示的内容： PS&gt; $psise.CurrentPowerShellTab.DisplayName = &apos;Testing&apos; 请注意只有在至少有 2 个以上 PowerShell 宿主时，才会显示 PowerShell 标签。您可能需要先按下 CTRL + T 才能够看到重命名的效果。 本文国际来源：Using PowerShell Tabs in the PowerShell ISE","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 定义缺省参数","slug":"defining-default-parameters","date":"2015-09-08T03:00:00.000Z","updated":"2017-03-17T15:26:26.242Z","comments":true,"path":"2015/09/08/defining-default-parameters/","link":"","permalink":"http://blog.vichamp.com/2015/09/08/defining-default-parameters/","excerpt":"PowerShell 可以为任意参数定义缺省值，所以如果您总是需要传同一个缺省值给 Get-ChildItem 的 -Path 参数，那么可以这么做： PS&gt; $PSDefaultParameterValues[&apos;Get-ChildItem:Path&apos;] = &apos;C:\\$Recycle.Bin&apos; 当您运行 Get-ChildItem（或它的别名，例如 dir），并且没有传入 -Path 参数时，PowerShell 总是会使用 $PSDefaultParameterValues 变量中定义的值。 您也可以使用通配符。例如，如果您希望对所有 AD 命令的 -Server 参数设置缺省值，请试试这段代码： PS&gt; $PSDefaultParameterValues[&apos;*-AD*:Server&apos;] = &apos;dc-01&apos; $PSDefaultParameterValues 实际上是一个哈希表，所以您可以覆盖缺省值，或将当前定义的所有缺省值导出成列表： Name Value ---- ----- *-AD*:Server dc-01 Get-ChildItem:Path C:\\$Recycle.Bin 要清空所有缺省参数，请清除哈希表： PS&gt; $PSDefaultParameterValues.Clear()","text":"PowerShell 可以为任意参数定义缺省值，所以如果您总是需要传同一个缺省值给 Get-ChildItem 的 -Path 参数，那么可以这么做： PS&gt; $PSDefaultParameterValues[&apos;Get-ChildItem:Path&apos;] = &apos;C:\\$Recycle.Bin&apos; 当您运行 Get-ChildItem（或它的别名，例如 dir），并且没有传入 -Path 参数时，PowerShell 总是会使用 $PSDefaultParameterValues 变量中定义的值。 您也可以使用通配符。例如，如果您希望对所有 AD 命令的 -Server 参数设置缺省值，请试试这段代码： PS&gt; $PSDefaultParameterValues[&apos;*-AD*:Server&apos;] = &apos;dc-01&apos; $PSDefaultParameterValues 实际上是一个哈希表，所以您可以覆盖缺省值，或将当前定义的所有缺省值导出成列表： Name Value ---- ----- *-AD*:Server dc-01 Get-ChildItem:Path C:\\$Recycle.Bin 要清空所有缺省参数，请清除哈希表： PS&gt; $PSDefaultParameterValues.Clear() 本文国际来源：Defining Default Parameters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 输出的同时赋值","slug":"outputting-and-assigning-at-the-same-time","date":"2015-09-07T03:00:00.000Z","updated":"2017-03-17T15:26:26.242Z","comments":true,"path":"2015/09/07/outputting-and-assigning-at-the-same-time/","link":"","permalink":"http://blog.vichamp.com/2015/09/07/outputting-and-assigning-at-the-same-time/","excerpt":"如果您想将某个命令的结果赋给一个变量，并且同时输出结果，以下是两种实现方法： 您可以使用小括号： PS&gt; ($result = Get-Service) Status Name DisplayName ------ ---- ----------- Running AdobeARMservice Adobe Acrobat Update Service (...) 或者使用 OutVariable 通用参数： PS&gt; Get-Service -OutVariable result Status Name DisplayName ------ ---- ----------- Running AdobeARMservice Adobe Acrobat Update Service (...)","text":"如果您想将某个命令的结果赋给一个变量，并且同时输出结果，以下是两种实现方法： 您可以使用小括号： PS&gt; ($result = Get-Service) Status Name DisplayName ------ ---- ----------- Running AdobeARMservice Adobe Acrobat Update Service (...) 或者使用 OutVariable 通用参数： PS&gt; Get-Service -OutVariable result Status Name DisplayName ------ ---- ----------- Running AdobeARMservice Adobe Acrobat Update Service (...) 本文国际来源：Outputting and Assigning at the Same Time","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通用属性和可选的通用属性","slug":"common-parameters-and-optional-common-parameters","date":"2015-09-04T03:00:00.000Z","updated":"2017-03-17T15:26:26.242Z","comments":true,"path":"2015/09/04/common-parameters-and-optional-common-parameters/","link":"","permalink":"http://blog.vichamp.com/2015/09/04/common-parameters-and-optional-common-parameters/","excerpt":"cmdlet 和高级的 PowerShell 函数可以拥有自己的参数，但它们通常继承了通用的参数。 要查看通用参数的列表，请试试这段代码： PS&gt; [System.Management.Automation.Cmdlet]::CommonParameters Verbose Debug ErrorAction WarningAction ErrorVariable WarningVariable OutVariable OutBuffer PipelineVariable 结果视 PowerShell 的版本可能会有不同。在 PowerShell 5.0 中，增加了两个通用的参数。 有些 cmdlet 可能有额外的通用参数。要列出这些参数，请试试这段代码： PS&gt; [System.Management.Automation.Cmdlet]::OptionalCommonParameters WhatIf Confirm UseTransaction","text":"cmdlet 和高级的 PowerShell 函数可以拥有自己的参数，但它们通常继承了通用的参数。 要查看通用参数的列表，请试试这段代码： PS&gt; [System.Management.Automation.Cmdlet]::CommonParameters Verbose Debug ErrorAction WarningAction ErrorVariable WarningVariable OutVariable OutBuffer PipelineVariable 结果视 PowerShell 的版本可能会有不同。在 PowerShell 5.0 中，增加了两个通用的参数。 有些 cmdlet 可能有额外的通用参数。要列出这些参数，请试试这段代码： PS&gt; [System.Management.Automation.Cmdlet]::OptionalCommonParameters WhatIf Confirm UseTransaction 本文国际来源：Common Parameters and Optional Common Parameters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 逐行显示对象的属性","slug":"displaying-object-properties-one-per-line","date":"2015-09-03T03:00:00.000Z","updated":"2017-03-17T15:26:26.226Z","comments":true,"path":"2015/09/03/displaying-object-properties-one-per-line/","link":"","permalink":"http://blog.vichamp.com/2015/09/03/displaying-object-properties-one-per-line/","excerpt":"有些时候您可能需要查看某个对象中包含的数据。例如，如果您查询 PowerShell 的进程并将它显示在一个网格视图窗口中，您可以查看对象的内容： Get-Process -Id $pid | Out-GridView 但这样真的容易查看吗？这个对象显示在一行里，而且一个潜在的限制是网格视图窗口最多只能显示 30 列。由于所有信息都显示在一行里，您也无法搜索属性，因为总是整行被同时选中。 能否更友好地逐行显示对象属性呢？以下是实现方法： $object = Get-Process -Id $pid ($object | Get-Member -MemberType *Property).Name | ForEach-Object { New-Object PSObject -Property ([Ordered]@{Property=$_; Value=$object.$_ }) } | Out-GridView 现在，每个属性各显示在一行上，可以尽可能多地显示，而且可以根据内容搜索某个特定的属性。","text":"有些时候您可能需要查看某个对象中包含的数据。例如，如果您查询 PowerShell 的进程并将它显示在一个网格视图窗口中，您可以查看对象的内容： Get-Process -Id $pid | Out-GridView 但这样真的容易查看吗？这个对象显示在一行里，而且一个潜在的限制是网格视图窗口最多只能显示 30 列。由于所有信息都显示在一行里，您也无法搜索属性，因为总是整行被同时选中。 能否更友好地逐行显示对象属性呢？以下是实现方法： $object = Get-Process -Id $pid ($object | Get-Member -MemberType *Property).Name | ForEach-Object { New-Object PSObject -Property ([Ordered]@{Property=$_; Value=$object.$_ }) } | Out-GridView 现在，每个属性各显示在一行上，可以尽可能多地显示，而且可以根据内容搜索某个特定的属性。 本文国际来源：Displaying Object Properties One per Line","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 列出（并检查）PowerShell 用户配置","slug":"listing-and-checking-powershell-profiles","date":"2015-09-02T03:00:00.000Z","updated":"2017-03-17T15:26:26.226Z","comments":true,"path":"2015/09/02/listing-and-checking-powershell-profiles/","link":"","permalink":"http://blog.vichamp.com/2015/09/02/listing-and-checking-powershell-profiles/","excerpt":"用户配置脚本指的是当 PowerShell 启动时自动执行的 PowerShell 脚本。主用户配置脚本的路径可以通过 $profile 获得。 要获得所有可能的用户配置脚本路径，可以使用以下代码： #requires -Version 1 ($profile | Get-Member -MemberType NoteProperty).Name | ForEach-Object { $profile.$_ } 要检查您机器上的所有用户配置，请使用这段示例代码： #requires -Version 3 ($profile | Get-Member -MemberType NoteProperty).Name | ForEach-Object { $path = $profile.$_ New-Object PSObject -Property ([Ordered]@{Path=$Path; Exists=(Test-Path $Path) }) } 输出结果类似如下： Path Exists ---- ------ C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1 False C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\Microsoft.PowerShellISE_profile.ps1 False C:\\Users\\user09\\Documents\\WindowsPowerShell\\profile.ps1 True C:\\Users\\user09\\Documents\\WindowsPowerShell\\Microsoft.PowerShellISE_profile.ps1 True 这个例子有趣的地方是如何编程获取对象的属性。您可以使用 Get-Member 来查找某个对象的属性名。我们将在接下来的文章中介绍这个隐藏的技能。","text":"用户配置脚本指的是当 PowerShell 启动时自动执行的 PowerShell 脚本。主用户配置脚本的路径可以通过 $profile 获得。 要获得所有可能的用户配置脚本路径，可以使用以下代码： #requires -Version 1 ($profile | Get-Member -MemberType NoteProperty).Name | ForEach-Object { $profile.$_ } 要检查您机器上的所有用户配置，请使用这段示例代码： #requires -Version 3 ($profile | Get-Member -MemberType NoteProperty).Name | ForEach-Object { $path = $profile.$_ New-Object PSObject -Property ([Ordered]@{Path=$Path; Exists=(Test-Path $Path) }) } 输出结果类似如下： Path Exists ---- ------ C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1 False C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\Microsoft.PowerShellISE_profile.ps1 False C:\\Users\\user09\\Documents\\WindowsPowerShell\\profile.ps1 True C:\\Users\\user09\\Documents\\WindowsPowerShell\\Microsoft.PowerShellISE_profile.ps1 True 这个例子有趣的地方是如何编程获取对象的属性。您可以使用 Get-Member 来查找某个对象的属性名。我们将在接下来的文章中介绍这个隐藏的技能。 本文国际来源：Listing (and Checking) PowerShell Profiles","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 只用一行代码创建新对象","slug":"creating-new-objects-oneliner","date":"2015-09-01T15:00:00.000Z","updated":"2017-03-17T15:26:26.220Z","comments":true,"path":"2015/09/01/creating-new-objects-oneliner/","link":"","permalink":"http://blog.vichamp.com/2015/09/01/creating-new-objects-oneliner/","excerpt":"有些时候您可能需要创建自己的对象来存储一系列信息。以下这行简洁的单行代码演示了如何快速创建新的对象： #requires -Version 3 $Info = &apos;Test&apos; $SomeOtherInfo = 12 New-Object PSObject -Property ([Ordered]@{Location=$Info; Remark=$SomeOtherInfo }) 这段代码的执行后将创建包含 Location 和 Remark 两个属性的新对象。只需要重命名哈希表中的键名，即可改变对象的属性名。 Location Remark -------- ------ Test 12 请注意 [Ordered] 是 PowerShell 3.0 引入的，能够创建有序的哈希表。在 PowerShell 2.0 中，可以使用不带 [ordered] 的代码。不带它会导致新对象中的属性顺序是随机的。","text":"有些时候您可能需要创建自己的对象来存储一系列信息。以下这行简洁的单行代码演示了如何快速创建新的对象： #requires -Version 3 $Info = &apos;Test&apos; $SomeOtherInfo = 12 New-Object PSObject -Property ([Ordered]@{Location=$Info; Remark=$SomeOtherInfo }) 这段代码的执行后将创建包含 Location 和 Remark 两个属性的新对象。只需要重命名哈希表中的键名，即可改变对象的属性名。 Location Remark -------- ------ Test 12 请注意 [Ordered] 是 PowerShell 3.0 引入的，能够创建有序的哈希表。在 PowerShell 2.0 中，可以使用不带 [ordered] 的代码。不带它会导致新对象中的属性顺序是随机的。 本文国际来源：Creating New Objects - Oneliner","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"欢迎使用新版的PowerShell官网主页（转）","slug":"welcoming-the-new-home-of-powershell","date":"2015-08-31T22:55:00.000Z","updated":"2017-03-17T15:26:26.197Z","comments":true,"path":"2015/09/01/welcoming-the-new-home-of-powershell/","link":"","permalink":"http://blog.vichamp.com/2015/09/01/welcoming-the-new-home-of-powershell/","excerpt":"筹划了很久，一直想搭建一个独立的PowerShell主页，来展示我们分散在其它网站上面大量的PowerShell资源。比如PowerShell脚本库，博客，Connect，GitHub仓库和TechNet文档，显然PowerShell已经在很多地方立足了。 今天我们很荣幸的宣布新版的PowerShell主页正式上线。https://msdn.microsoft.com/en-us/powershell 我们很努力地为PowerShell建立了一个新版的主页。第一个发布版本给用户提供了一个集成了官方的PowerShell资源，内容，文档的统一门户。新版的Powershell主页让我们的在线品牌体验更现代化，它有一个简单的导航栏和一个响应式的，移动端友好的界面设计。我们计划让它成长为一个PowerShell社区相关的一站式商店。 在接下来的两周中，我们会对网站的某些方面稍加润色，同时添加一些额外的内容来展示我们社区生态系统中的亮点。我们会快速迭代，将会由微软PowerShell内部团队对网站进行直接维护。如果您有任何问题，建议和反馈，请（在原文下面）随时留下评论，或着关注我的tweet(@joeyaiello) 或着 Neema Saeedi (@neems)。 荔非苔注：截至本文发稿，对应的PowerShell中文主页依然是旧版。","text":"筹划了很久，一直想搭建一个独立的PowerShell主页，来展示我们分散在其它网站上面大量的PowerShell资源。比如PowerShell脚本库，博客，Connect，GitHub仓库和TechNet文档，显然PowerShell已经在很多地方立足了。 今天我们很荣幸的宣布新版的PowerShell主页正式上线。https://msdn.microsoft.com/en-us/powershell 我们很努力地为PowerShell建立了一个新版的主页。第一个发布版本给用户提供了一个集成了官方的PowerShell资源，内容，文档的统一门户。新版的Powershell主页让我们的在线品牌体验更现代化，它有一个简单的导航栏和一个响应式的，移动端友好的界面设计。我们计划让它成长为一个PowerShell社区相关的一站式商店。 在接下来的两周中，我们会对网站的某些方面稍加润色，同时添加一些额外的内容来展示我们社区生态系统中的亮点。我们会快速迭代，将会由微软PowerShell内部团队对网站进行直接维护。如果您有任何问题，建议和反馈，请（在原文下面）随时留下评论，或着关注我的tweet(@joeyaiello) 或着 Neema Saeedi (@neems)。 荔非苔注：截至本文发稿，对应的PowerShell中文主页依然是旧版。 原文作者：Joey Aiello（PowerShell项目经理）原文链接：Welcoming the new home of PowerShell中译链接：欢迎使用新版的PowerShell官网主页 - PowerShell 中文博客","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"Windows管理框架(WMF) 5.0 路线图（转）","slug":"windows-management-framework-wmf-v5-roadmap","date":"2015-08-31T22:53:00.000Z","updated":"2017-03-17T15:26:26.213Z","comments":true,"path":"2015/09/01/windows-management-framework-wmf-v5-roadmap/","link":"","permalink":"http://blog.vichamp.com/2015/09/01/windows-management-framework-wmf-v5-roadmap/","excerpt":"在接下来的几周之内（2015年8月）我们将会继续发布受支持的Windows 管理框架（WMF）5.0的后续“预览产品”，2015年第四个季度，您将能够下载到WMF5.0的RTM版本。 WMF 5.0的产品预览版和前几个版本的WMF5.0预览版相比，有如下不同: 微软会对它提供完整支持，一直到WMF RTM 50正式发布。提供完整支持意味着，将给客户遇到的任何妨碍性问题我们都会提供调查和应对方案，甚至必要的更新。 预览产品中所有功能都将会出现在最终产品中，在这个安装包中没有任何的实验性的功能。 您必须在安装这个预览版之前，卸载之前的所有预览版 不管是即将到来的完整支持版本的WMF 5.0（预览产品和正式版），我们都将会经常吸收我们WMF5.0预览版用户社区提供的反馈。所以还望您尽早部署WMF 5.0产品预览版，并且提前提供建议给我们，争取让我们的RTM版本更好。","text":"在接下来的几周之内（2015年8月）我们将会继续发布受支持的Windows 管理框架（WMF）5.0的后续“预览产品”，2015年第四个季度，您将能够下载到WMF5.0的RTM版本。 WMF 5.0的产品预览版和前几个版本的WMF5.0预览版相比，有如下不同: 微软会对它提供完整支持，一直到WMF RTM 50正式发布。提供完整支持意味着，将给客户遇到的任何妨碍性问题我们都会提供调查和应对方案，甚至必要的更新。 预览产品中所有功能都将会出现在最终产品中，在这个安装包中没有任何的实验性的功能。 您必须在安装这个预览版之前，卸载之前的所有预览版 不管是即将到来的完整支持版本的WMF 5.0（预览产品和正式版），我们都将会经常吸收我们WMF5.0预览版用户社区提供的反馈。所以还望您尽早部署WMF 5.0产品预览版，并且提前提供建议给我们，争取让我们的RTM版本更好。 原文作者：Hemant Mahawar [MSFT] （高级项目经理）原文链接：Windows Management Framework (WMF) 5.0 Roadmap中译链接：Windows管理框架(WMF) 5.0 路线图 - PowerShell 中文博客","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 映射网络驱动器（第 3 部分）","slug":"mapping-network-drives-part-3","date":"2015-08-31T03:00:00.000Z","updated":"2017-03-17T15:26:26.197Z","comments":true,"path":"2015/08/31/mapping-network-drives-part-3/","link":"","permalink":"http://blog.vichamp.com/2015/08/31/mapping-network-drives-part-3/","excerpt":"如果您从 VBScript 迁移到 PowerShell，您也许会记得 VBScript 如何映射网络驱动器。这个选项在 PowerShell 中仍然有效。 $helper = New-Object -ComObject WScript.Network $helper.MapNetworkDrive(&apos;O:&apos;,&apos;\\\\dc-01\\somefolder&apos;,$true) $helper.EnumNetworkDrives() Test-Path -Path O:\\ explorer.exe O:\\ Get-PSDrive -Name O $helper.RemoveNetworkDrive(&apos;O:&apos;, $true, $true) 如果您希望以不同的凭据登录，请使用这种方式： $helper.MapNetworkDrive(&apos;O:&apos;,&apos;\\\\dc-01\\somefolder&apos;,$true, &apos;training\\user02&apos;, &apos;topSecret&apos;)","text":"如果您从 VBScript 迁移到 PowerShell，您也许会记得 VBScript 如何映射网络驱动器。这个选项在 PowerShell 中仍然有效。 $helper = New-Object -ComObject WScript.Network $helper.MapNetworkDrive(&apos;O:&apos;,&apos;\\\\dc-01\\somefolder&apos;,$true) $helper.EnumNetworkDrives() Test-Path -Path O:\\ explorer.exe O:\\ Get-PSDrive -Name O $helper.RemoveNetworkDrive(&apos;O:&apos;, $true, $true) 如果您希望以不同的凭据登录，请使用这种方式： $helper.MapNetworkDrive(&apos;O:&apos;,&apos;\\\\dc-01\\somefolder&apos;,$true, &apos;training\\user02&apos;, &apos;topSecret&apos;) 本文国际来源：Mapping Network Drives (Part 3)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 映射网络驱动器（第 2 部分）","slug":"mapping-network-drives-part-2","date":"2015-08-28T03:00:00.000Z","updated":"2017-03-17T15:26:26.182Z","comments":true,"path":"2015/08/28/mapping-network-drives-part-2/","link":"","permalink":"http://blog.vichamp.com/2015/08/28/mapping-network-drives-part-2/","excerpt":"从 PowerShell 3.0 开始，您可以使用 New-PSDrive 命令来映射网络驱动器。它们也可以在文件管理器中显示。以下是一些示例代码： #requires -Version 3 New-PSDrive -Name N -PSProvider FileSystem -Root &apos;\\\\dc-01\\somefolder&apos; -Persist Test-Path -Path N:\\ explorer.exe N:\\ Get-PSDrive -Name N Remove-PSDrive -Name N -Force 如果您希望提供登录凭据，请在 New-PSDrive 命令后添加 -Credential 参数，并且以 domain\\username 的方式提交用户名。密码将会以安全的方式提示输入。","text":"从 PowerShell 3.0 开始，您可以使用 New-PSDrive 命令来映射网络驱动器。它们也可以在文件管理器中显示。以下是一些示例代码： #requires -Version 3 New-PSDrive -Name N -PSProvider FileSystem -Root &apos;\\\\dc-01\\somefolder&apos; -Persist Test-Path -Path N:\\ explorer.exe N:\\ Get-PSDrive -Name N Remove-PSDrive -Name N -Force 如果您希望提供登录凭据，请在 New-PSDrive 命令后添加 -Credential 参数，并且以 domain\\username 的方式提交用户名。密码将会以安全的方式提示输入。 本文国际来源：Mapping Network Drives (Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 映射网络驱动器（第 1 部分）","slug":"mapping-network-drives-part-1","date":"2015-08-27T03:00:00.000Z","updated":"2017-03-17T15:26:26.182Z","comments":true,"path":"2015/08/27/mapping-network-drives-part-1/","link":"","permalink":"http://blog.vichamp.com/2015/08/27/mapping-network-drives-part-1/","excerpt":"PowerShell 支持控制台命令，所以如果您需要映射一个网络驱动器，通常最可靠的方式是使用传统好用的 net.exe，类似这样： #requires -Version 1 net.exe use M: &apos;\\\\dc-01\\somefolder&apos; /PERSISTENT:YES Test-Path -Path M:\\ explorer.exe M:\\ 如果您忽略“/PERSISTENT:YES”参数，那么映射的驱动器将只是临时的，注销并登录后将不会自动重连。 请注意如果驱动器号 M: 已在使用中，将会收到一个错误。将 M: 换成一个星号，将自动使用下一个可用的驱动器号。 要提交登录凭据，请使用这种方法： net.exe use * &apos;\\\\dc-01\\somefolder&apos; /PERSISTENT:YES /USER:training\\user03 * 这将以 training\\user03 的身份登录，并使用下一个可用的驱动器号，并且交互式地询问密码。请注意这只能在普通的 PowerShell 控制台中使用。它不能在 PowerShell ISE 中使用，因为 PowerShell ISE 并没有一个真实的控制台，所以无法交互式地询问密码。 要提交密码，将用户名之后的星号替换为密码。这当然不是很好的实践，因为这将把密码透露给所有可以查看代码的人。","text":"PowerShell 支持控制台命令，所以如果您需要映射一个网络驱动器，通常最可靠的方式是使用传统好用的 net.exe，类似这样： #requires -Version 1 net.exe use M: &apos;\\\\dc-01\\somefolder&apos; /PERSISTENT:YES Test-Path -Path M:\\ explorer.exe M:\\ 如果您忽略“/PERSISTENT:YES”参数，那么映射的驱动器将只是临时的，注销并登录后将不会自动重连。 请注意如果驱动器号 M: 已在使用中，将会收到一个错误。将 M: 换成一个星号，将自动使用下一个可用的驱动器号。 要提交登录凭据，请使用这种方法： net.exe use * &apos;\\\\dc-01\\somefolder&apos; /PERSISTENT:YES /USER:training\\user03 * 这将以 training\\user03 的身份登录，并使用下一个可用的驱动器号，并且交互式地询问密码。请注意这只能在普通的 PowerShell 控制台中使用。它不能在 PowerShell ISE 中使用，因为 PowerShell ISE 并没有一个真实的控制台，所以无法交互式地询问密码。 要提交密码，将用户名之后的星号替换为密码。这当然不是很好的实践，因为这将把密码透露给所有可以查看代码的人。 本文国际来源：Mapping Network Drives (Part 1)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 指定执行超时","slug":"executing-with-timeout","date":"2015-08-26T03:00:00.000Z","updated":"2017-03-17T15:26:26.181Z","comments":true,"path":"2015/08/26/executing-with-timeout/","link":"","permalink":"http://blog.vichamp.com/2015/08/26/executing-with-timeout/","excerpt":"Start-Process 可以启动进程但是不支持超时。如果您需要在指定的超时时间后结束一个跑飞了的进程，您可以使用类似这样的方法： #requires -Version 2 $maximumRuntimeSeconds = 3 $process = Start-Process -FilePath powershell.exe -ArgumentList &apos;-Command Start-Sleep -Seconds 4&apos; -PassThru try { $process | Wait-Process -Timeout $maximumRuntimeSeconds -ErrorAction Stop Write-Warning -Message &apos;Process successfully completed within timeout.&apos; } catch { Write-Warning -Message &apos;Process exceeded timeout, will be killed now.&apos; $process | Stop-Process -Force } Wait-Process 用于等待进程执行。如果它没有在指定的超时之内结束，Wait-Process 将抛出一个异常。在相应的错误处理器中可以决定要如何处理。 在这个例子中，catch 代码块将结束进程。 这个例子的处理代码是启动第二个 PowerShell 实例，在新的实例中执行 Start-Sleep 命令来模拟某些长时间运行的任务。如果您将 Start-Sleep 的参数调整为短于 $maximumRuntimeSeconds 指定的值，那么操作将会在指定的超时值之内完成，而您的脚本将不会结束该进程。","text":"Start-Process 可以启动进程但是不支持超时。如果您需要在指定的超时时间后结束一个跑飞了的进程，您可以使用类似这样的方法： #requires -Version 2 $maximumRuntimeSeconds = 3 $process = Start-Process -FilePath powershell.exe -ArgumentList &apos;-Command Start-Sleep -Seconds 4&apos; -PassThru try { $process | Wait-Process -Timeout $maximumRuntimeSeconds -ErrorAction Stop Write-Warning -Message &apos;Process successfully completed within timeout.&apos; } catch { Write-Warning -Message &apos;Process exceeded timeout, will be killed now.&apos; $process | Stop-Process -Force } Wait-Process 用于等待进程执行。如果它没有在指定的超时之内结束，Wait-Process 将抛出一个异常。在相应的错误处理器中可以决定要如何处理。 在这个例子中，catch 代码块将结束进程。 这个例子的处理代码是启动第二个 PowerShell 实例，在新的实例中执行 Start-Sleep 命令来模拟某些长时间运行的任务。如果您将 Start-Sleep 的参数调整为短于 $maximumRuntimeSeconds 指定的值，那么操作将会在指定的超时值之内完成，而您的脚本将不会结束该进程。 本文国际来源：Executing with Timeout","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 以管理员身份执行指定的代码","slug":"executing-selected-code-as-admin","date":"2015-08-25T03:00:00.000Z","updated":"2017-03-17T15:26:26.160Z","comments":true,"path":"2015/08/25/executing-selected-code-as-admin/","link":"","permalink":"http://blog.vichamp.com/2015/08/25/executing-selected-code-as-admin/","excerpt":"如果您需要以管理员身份运行指定的脚本片段，您可以以管理员身份临时创建第二个 PowerShell 实例，然后在临时的实例中执行特权代码。 这是一段停止 Windows 更新服务的例子。当您以普通用户运行这段代码时，它将自动弹出提权的对话框，然后在一个新的管理员外壳中执行您的代码： #requires -Version 2 Start-Process -FilePath powershell.exe -Verb runas -ArgumentList &apos;Stop-Service -Name wuauserv&apos; -WindowStyle Minimized","text":"如果您需要以管理员身份运行指定的脚本片段，您可以以管理员身份临时创建第二个 PowerShell 实例，然后在临时的实例中执行特权代码。 这是一段停止 Windows 更新服务的例子。当您以普通用户运行这段代码时，它将自动弹出提权的对话框，然后在一个新的管理员外壳中执行您的代码： #requires -Version 2 Start-Process -FilePath powershell.exe -Verb runas -ArgumentList &apos;Stop-Service -Name wuauserv&apos; -WindowStyle Minimized 本文国际来源：Executing Selected Code as Admin","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找驱动器号","slug":"finding-drive-letters","date":"2015-08-24T03:00:00.000Z","updated":"2017-03-17T15:26:26.160Z","comments":true,"path":"2015/08/24/finding-drive-letters/","link":"","permalink":"http://blog.vichamp.com/2015/08/24/finding-drive-letters/","excerpt":"以下是一个查找保留驱动器号的简单函数： #requires -Version 3 function Get-DriveLetter { (Get-WmiObject -Class Win32_LogicalDisk).DeviceID } 要列出所有正在使用的驱动器号，请使用以下代码： PS&gt; Get-DriveLetter C: D: Y: Z: PS&gt; 要查看某个给定的驱动器号是否被保留，可以使用这段代码： PS&gt; $letters = Get-DriveLetter PS&gt; $letters -contains &apos;c:&apos; True PS&gt; $letters -contains &apos;f:&apos; False PS&gt;","text":"以下是一个查找保留驱动器号的简单函数： #requires -Version 3 function Get-DriveLetter { (Get-WmiObject -Class Win32_LogicalDisk).DeviceID } 要列出所有正在使用的驱动器号，请使用以下代码： PS&gt; Get-DriveLetter C: D: Y: Z: PS&gt; 要查看某个给定的驱动器号是否被保留，可以使用这段代码： PS&gt; $letters = Get-DriveLetter PS&gt; $letters -contains &apos;c:&apos; True PS&gt; $letters -contains &apos;f:&apos; False PS&gt; 本文国际来源：Finding Drive Letters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 快速设置多个环境变量","slug":"quickly-setting-multiple-environment-variables","date":"2015-08-21T03:00:00.000Z","updated":"2017-03-17T15:26:26.144Z","comments":true,"path":"2015/08/21/quickly-setting-multiple-environment-variables/","link":"","permalink":"http://blog.vichamp.com/2015/08/21/quickly-setting-multiple-environment-variables/","excerpt":"以下是一种快速（并且永久地）设置一系列环境变量的很棒的方法： $hashtable = @{ Name = &apos;Weltner&apos; ID = 12 Ort = &apos;Hannover&apos; Type = &apos;Notebook&apos; ABC = 123 } $hashtable.Keys | ForEach-Object { $Name = $_ $Value = $hashtable.$Name [Environment]::SetEnvironmentVariable($Name, $Value, &quot;User&quot;) } 只需要在一个哈希表中定义变量。该脚本将为每个键值对创建一个环境变量。将“User”替换为“Machine”，就可以创建系统级别的环境变量。不过这将需要管理员权限。 通过类似的方法，您也可以删除环境变量。只需要将空字符串赋值给哈希表中的值即可。","text":"以下是一种快速（并且永久地）设置一系列环境变量的很棒的方法： $hashtable = @{ Name = &apos;Weltner&apos; ID = 12 Ort = &apos;Hannover&apos; Type = &apos;Notebook&apos; ABC = 123 } $hashtable.Keys | ForEach-Object { $Name = $_ $Value = $hashtable.$Name [Environment]::SetEnvironmentVariable($Name, $Value, &quot;User&quot;) } 只需要在一个哈希表中定义变量。该脚本将为每个键值对创建一个环境变量。将“User”替换为“Machine”，就可以创建系统级别的环境变量。不过这将需要管理员权限。 通过类似的方法，您也可以删除环境变量。只需要将空字符串赋值给哈希表中的值即可。 本文国际来源：Quickly Setting Multiple Environment Variables","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 快速查找脚本","slug":"quickly-finding-scripts","date":"2015-08-20T03:00:00.000Z","updated":"2017-03-17T15:26:26.144Z","comments":true,"path":"2015/08/20/quickly-finding-scripts/","link":"","permalink":"http://blog.vichamp.com/2015/08/20/quickly-finding-scripts/","excerpt":"要在“我的文档”文件夹的任意位置中快速定位一个 PowerShell 脚本，请试试这个 Find-Script 函数： #requires -Version 3 function Find-Script { param ( [Parameter(Mandatory = $true)] $SearchPhrase, $Path = [Environment]::GetFolderPath(&apos;MyDocuments&apos;) ) Get-ChildItem -Path $Path -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue | Select-String -Pattern $SearchPhrase -List | Select-Object -Property Path, Line | Out-GridView -Title &quot;All Scripts containing $SearchPhrase&quot; -PassThru | ForEach-Object -Process { ise $_.Path } } 像这样运行： Find-Script &apos;childitem&apos; 这将返回一个在您的文档文件夹中包含搜索关键词的所有 PowerShell 脚本。当您在网格视图窗口中选择了某些脚本并点击确认按钮后，这些脚本将会自动由 PowerShell ISE 打开。 要设置一个不同的搜索跟路径，请使用 -Path 参数。通过这种方式，您可以很容易地在您的 USB 媒体或是网络路径中搜索。","text":"要在“我的文档”文件夹的任意位置中快速定位一个 PowerShell 脚本，请试试这个 Find-Script 函数： #requires -Version 3 function Find-Script { param ( [Parameter(Mandatory = $true)] $SearchPhrase, $Path = [Environment]::GetFolderPath(&apos;MyDocuments&apos;) ) Get-ChildItem -Path $Path -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue | Select-String -Pattern $SearchPhrase -List | Select-Object -Property Path, Line | Out-GridView -Title &quot;All Scripts containing $SearchPhrase&quot; -PassThru | ForEach-Object -Process { ise $_.Path } } 像这样运行： Find-Script &apos;childitem&apos; 这将返回一个在您的文档文件夹中包含搜索关键词的所有 PowerShell 脚本。当您在网格视图窗口中选择了某些脚本并点击确认按钮后，这些脚本将会自动由 PowerShell ISE 打开。 要设置一个不同的搜索跟路径，请使用 -Path 参数。通过这种方式，您可以很容易地在您的 USB 媒体或是网络路径中搜索。 本文国际来源：Quickly Finding Scripts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 隐藏变量内容","slug":"hiding-variable-content","date":"2015-08-19T03:00:00.000Z","updated":"2017-03-17T15:26:26.128Z","comments":true,"path":"2015/08/19/hiding-variable-content/","link":"","permalink":"http://blog.vichamp.com/2015/08/19/hiding-variable-content/","excerpt":"当您覆盖某个对象的 ToString() 方法时，您就可以控制这个对象的显示方式。而这个对象的内容并不会被改变： $a = 123 $a = $a | Add-Member -MemberType ScriptMethod -Name toString -Value { &apos;secret&apos;} -Force -PassThru $a $a -eq 123 $a.GetType().FullName 例如，当一个变量表示字节数的时候，您甚至可以在您的自定义的 ToString() 方法中获取原始的变量值，然后将它显示为 MB（兆字节）： $a = 2316782313 $a = $a | Add-Member -MemberType ScriptMethod -Name toString -Value { [Math]::Round($this / 1MB,1) } -Force -PassThru $a $a -eq 123 $a.GetType().FullName","text":"当您覆盖某个对象的 ToString() 方法时，您就可以控制这个对象的显示方式。而这个对象的内容并不会被改变： $a = 123 $a = $a | Add-Member -MemberType ScriptMethod -Name toString -Value { &apos;secret&apos;} -Force -PassThru $a $a -eq 123 $a.GetType().FullName 例如，当一个变量表示字节数的时候，您甚至可以在您的自定义的 ToString() 方法中获取原始的变量值，然后将它显示为 MB（兆字节）： $a = 2316782313 $a = $a | Add-Member -MemberType ScriptMethod -Name toString -Value { [Math]::Round($this / 1MB,1) } -Force -PassThru $a $a -eq 123 $a.GetType().FullName 本文国际来源：Hiding Variable Content","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 向对象增加额外信息","slug":"adding-additional-information-to-objects","date":"2015-08-18T03:00:00.000Z","updated":"2017-03-17T15:26:26.128Z","comments":true,"path":"2015/08/18/adding-additional-information-to-objects/","link":"","permalink":"http://blog.vichamp.com/2015/08/18/adding-additional-information-to-objects/","excerpt":"当您获取结果信息时，您可能会希望向结果对象添加一些额外的属性，这样待会儿就可以知道它们是从哪儿来的。 向复杂类型对象添加额外的信息和向简单数据类型添加额外的信息不同（在前一个技能中有介绍）。 Get-Process | Add-Member -MemberType NoteProperty -Name PC -Value $env:COMPUTERNAME -PassThru | Select-Object -Property Name, Company, Description, PC | Out-GridView 这段代码中 Get-Process 返回的进程均被添加了一个名为“PC”的额外属性，用来存放进程所在的计算机名。 要查看自定义属性，要么使用 Select-Object 并指定属性名，要么使用点号语法： $list = Get-Process | Add-Member -MemberType NoteProperty -Name PC -Value $env:COMPUTERNAME -PassThru $list | ForEach-Object { &apos;Process {0} on {1}&apos; -f $_.Name, $_.PC }","text":"当您获取结果信息时，您可能会希望向结果对象添加一些额外的属性，这样待会儿就可以知道它们是从哪儿来的。 向复杂类型对象添加额外的信息和向简单数据类型添加额外的信息不同（在前一个技能中有介绍）。 Get-Process | Add-Member -MemberType NoteProperty -Name PC -Value $env:COMPUTERNAME -PassThru | Select-Object -Property Name, Company, Description, PC | Out-GridView 这段代码中 Get-Process 返回的进程均被添加了一个名为“PC”的额外属性，用来存放进程所在的计算机名。 要查看自定义属性，要么使用 Select-Object 并指定属性名，要么使用点号语法： $list = Get-Process | Add-Member -MemberType NoteProperty -Name PC -Value $env:COMPUTERNAME -PassThru $list | ForEach-Object { &apos;Process {0} on {1}&apos; -f $_.Name, $_.PC } 本文国际来源：Adding Additional Information to Objects","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 向原始数据类型增加额外信息","slug":"appending-extra-information-to-primitive-data-types","date":"2015-08-17T03:00:00.000Z","updated":"2017-03-17T15:26:26.113Z","comments":true,"path":"2015/08/17/appending-extra-information-to-primitive-data-types/","link":"","permalink":"http://blog.vichamp.com/2015/08/17/appending-extra-information-to-primitive-data-types/","excerpt":"也许您希望对一个变量做标记并提供一些额外信息。在 PowerShell 中，可以使用 Add-Member 来向一个变量附加 NoteProperties 或 ScriptProperties。 一个 NoteProperty 包含一些静态信息，而当我们获取一个 ScriptProperty 的值时，将会运行一段代码。 请看如何对一个简单的字符串做操作： $a = &quot;some text&quot; $a = $a | Add-Member -MemberType NoteProperty -Name Origin -Value $env:computername -PassThru $a = $a | Add-Member -MemberType ScriptProperty -Name Time -Value { Get-Date } -PassThru $a $a.Origin $a.Time","text":"也许您希望对一个变量做标记并提供一些额外信息。在 PowerShell 中，可以使用 Add-Member 来向一个变量附加 NoteProperties 或 ScriptProperties。 一个 NoteProperty 包含一些静态信息，而当我们获取一个 ScriptProperty 的值时，将会运行一段代码。 请看如何对一个简单的字符串做操作： $a = &quot;some text&quot; $a = $a | Add-Member -MemberType NoteProperty -Name Origin -Value $env:computername -PassThru $a = $a | Add-Member -MemberType ScriptProperty -Name Time -Value { Get-Date } -PassThru $a $a.Origin $a.Time 本文国际来源：Appending Extra Information to Primitive Data Types","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 简单的 INI 文件替代","slug":"simple-replacement-for-ini-files","date":"2015-08-14T03:00:00.000Z","updated":"2017-03-17T15:26:26.113Z","comments":true,"path":"2015/08/14/simple-replacement-for-ini-files/","link":"","permalink":"http://blog.vichamp.com/2015/08/14/simple-replacement-for-ini-files/","excerpt":"如果您想将设置保存在您的脚本之外并将它们保存在一个独立的配置文件中，那么您可以使用各种数据格式。 INI 文件的并地支持并不充分，所以您得人工处理它们。JSON 和 XML 文件有处理器支持，但是文字内容太复杂，不容易被人类阅读。 If your config data can be expressed as key-value pairs like below, then we have an alternative:如果您的配置数据是类似这样的键值对，那么我们可以有别的选择： 123Name = &apos;Tom&apos;ID = 12Path = &apos;C:&apos; 将键值对保存为一个纯文本文件，然后使用这段代码来读取该文件： $hashtable = @{} $path = &apos;z:\\yourfilename.config&apos; $payload = Get-Content -Path $path | Where-Object { $_ -like &apos;*=*&apos; } | ForEach-Object { $infos = $_ -split &apos;=&apos; $key = $infos[0].Trim() $value = $infos[1].Trim() $hashtable.$key = $value } 结果是一个哈希表，您可以用这种方式轻松地读取各项的值： $hashtable.Name $hashtable.ID $hashtable.Path","text":"如果您想将设置保存在您的脚本之外并将它们保存在一个独立的配置文件中，那么您可以使用各种数据格式。 INI 文件的并地支持并不充分，所以您得人工处理它们。JSON 和 XML 文件有处理器支持，但是文字内容太复杂，不容易被人类阅读。 If your config data can be expressed as key-value pairs like below, then we have an alternative:如果您的配置数据是类似这样的键值对，那么我们可以有别的选择： 123Name = &apos;Tom&apos;ID = 12Path = &apos;C:&apos; 将键值对保存为一个纯文本文件，然后使用这段代码来读取该文件： $hashtable = @{} $path = &apos;z:\\yourfilename.config&apos; $payload = Get-Content -Path $path | Where-Object { $_ -like &apos;*=*&apos; } | ForEach-Object { $infos = $_ -split &apos;=&apos; $key = $infos[0].Trim() $value = $infos[1].Trim() $hashtable.$key = $value } 结果是一个哈希表，您可以用这种方式轻松地读取各项的值： $hashtable.Name $hashtable.ID $hashtable.Path 本文国际来源：Simple Replacement for INI Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"字幕整理脚本","slug":"Subtitle-Optimizer","date":"2015-08-13T10:53:47.000Z","updated":"2017-03-17T15:26:26.113Z","comments":true,"path":"2015/08/13/Subtitle-Optimizer/","link":"","permalink":"http://blog.vichamp.com/2015/08/13/Subtitle-Optimizer/","excerpt":"","text":"从看过的电影、美剧里学英语是一件很棒的事。因为你曾经被带入过那个场景，曾经和主角一同喜怒哀乐。如果能将电影里的中英文对白整理出来，对做笔记和搜索回顾将大有帮助。 我们可以从网上（例如射手网）下载视频的中英文字幕，需要是 .srt 格式的。它实际上是一个文本文件，内容类似如下： 12345678910111213141516171300:04:42,050 --&gt; 00:04:45,010&#123;\\an2&#125;&#123;\\pos(212,240)&#125;第三季 第一集1400:01:56,000 --&gt; 00:01:56,990爸Hey, Pop.1500:01:56,880 --&gt; 00:02:04,020&#123;\\an8&#125;凯文·安德伍德1600:01:59,750 --&gt; 00:02:01,510好久不见啊Been a while, hasn&apos;t it? 我们希望将它整理成这样的格式： 123456789第三季 第一集爸Hey, Pop.凯文·安德伍德好久不见啊Been a while, hasn&apos;t it? 这个任务可以用 PowerShell + 正则表达式轻松搞定。 12345678910111213141516if (!(Test-Path dst)) &#123; md dst | Out-Null&#125;Get-ChildItem src\\*.srt | ForEach-Object &#123; $srcFile = $_ Write-Output \"Processing $($srcFile.Name)\" $dstFile = (Join-Path 'dst' $srcFile.BaseName) + '.txt' Get-Content $srcFile | ForEach-Object &#123; $line = $_ if ($line -cmatch '\\A\\d+\\z') &#123; return &#125; if ($line -cmatch '\\d\\d:\\d\\d:\\d\\d,\\d\\d\\d --&gt; \\d\\d:\\d\\d:\\d\\d,\\d\\d\\d') &#123; return &#125; $line = $line -creplace '\\s*\\&#123;\\\\.*?\\&#125;\\s*', '' return $line &#125; | Out-File $dstFile&#125; 只需要将字幕源文件放在src目录下，运行脚本，就可以在dst目录下得到期望的文本文件。执行效果如下： 文件目录如下： 您也可以在这里下载完整的脚本。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"text","slug":"text","permalink":"http://blog.vichamp.com/tags/text/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 删除数组元素","slug":"remove-array-elements","date":"2015-08-13T03:00:00.000Z","updated":"2017-03-17T15:26:26.113Z","comments":true,"path":"2015/08/13/remove-array-elements/","link":"","permalink":"http://blog.vichamp.com/2015/08/13/remove-array-elements/","excerpt":"您曾经比较过两个数组吗？Compare-Object 可能有用。请试试这段代码： $array1 = 1..100 $array2 = 2,4,80,98 Compare-Object -ReferenceObject $array1 -DifferenceObject $array2 | Select-Object -ExpandProperty InputObject 执行的结果是 $array1 的内容减去 $array2 的内容。 要获取 $array1 和 $array2 中共有的元素，请使用以下方法： $array1 = 1..100 $array2 = 2,4,80,98, 112 Compare-Object -ReferenceObject $array1 -DifferenceObject $array2 -ExcludeDifferent -IncludeEqual | Select-Object -ExpandProperty InputObject","text":"您曾经比较过两个数组吗？Compare-Object 可能有用。请试试这段代码： $array1 = 1..100 $array2 = 2,4,80,98 Compare-Object -ReferenceObject $array1 -DifferenceObject $array2 | Select-Object -ExpandProperty InputObject 执行的结果是 $array1 的内容减去 $array2 的内容。 要获取 $array1 和 $array2 中共有的元素，请使用以下方法： $array1 = 1..100 $array2 = 2,4,80,98, 112 Compare-Object -ReferenceObject $array1 -DifferenceObject $array2 -ExcludeDifferent -IncludeEqual | Select-Object -ExpandProperty InputObject 本文国际来源：Remove Array Elements","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 快速获取 IP 地址","slug":"quickly-getting-ip-addresses","date":"2015-08-12T03:00:00.000Z","updated":"2017-03-17T15:26:26.097Z","comments":true,"path":"2015/08/12/quickly-getting-ip-addresses/","link":"","permalink":"http://blog.vichamp.com/2015/08/12/quickly-getting-ip-addresses/","excerpt":"您是否希望快速获取您的机器或是网络上的机器的 IP 地址列表？以下是实现方法： #requires -Version 3 $ComputerName = &apos;&apos; [System.Net.Dns]::GetHostAddresses($ComputerName).IPAddressToString 要只取 IPv4 地址，请使用这种方法： #requires -Version 1 $ComputerName = &apos;&apos; [System.Net.Dns]::GetHostAddresses($ComputerName) | Where-Object { $_.AddressFamily -eq &apos;InterNetwork&apos; } | Select-Object -ExpandProperty IPAddressToString 类似地，要获取 IPv6 地址，请改成这种方法： #requires -Version 1 $ComputerName = &apos;&apos; [System.Net.Dns]::GetHostAddresses($ComputerName) | Where-Object { $_.AddressFamily -eq &apos;InterNetworkV6&apos; } | Select-Object -ExpandProperty IPAddressToString","text":"您是否希望快速获取您的机器或是网络上的机器的 IP 地址列表？以下是实现方法： #requires -Version 3 $ComputerName = &apos;&apos; [System.Net.Dns]::GetHostAddresses($ComputerName).IPAddressToString 要只取 IPv4 地址，请使用这种方法： #requires -Version 1 $ComputerName = &apos;&apos; [System.Net.Dns]::GetHostAddresses($ComputerName) | Where-Object { $_.AddressFamily -eq &apos;InterNetwork&apos; } | Select-Object -ExpandProperty IPAddressToString 类似地，要获取 IPv6 地址，请改成这种方法： #requires -Version 1 $ComputerName = &apos;&apos; [System.Net.Dns]::GetHostAddresses($ComputerName) | Where-Object { $_.AddressFamily -eq &apos;InterNetworkV6&apos; } | Select-Object -ExpandProperty IPAddressToString 本文国际来源：Quickly Getting IP Addresses","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 截短文本","slug":"shortening-text","date":"2015-08-11T03:00:00.000Z","updated":"2017-03-17T15:26:26.081Z","comments":true,"path":"2015/08/11/shortening-text/","link":"","permalink":"http://blog.vichamp.com/2015/08/11/shortening-text/","excerpt":"假设您希望截掉一个字符串尾部的一些文字。以下是使用字符串操作的传统方法： $text = &quot;Some text&quot; $fromRight = 3 $text.Substring(0, $text.Length - $fromRight) 一个更强大的方法是使用 -replace 操作符结合正则表达式： $text = &quot;Some text&quot; $fromRight = 3 $text -replace &quot;.{$fromRight}$&quot; 这段代码将去掉文字尾部（$）之前 $fromRight 个任意字符（”.“）。 由于正则表达式十分灵活，所以您可以重新编辑它，只截去数字，且最多只截掉 5 个数字： $text1 = &quot;Some text with digits267686783&quot; $text2 = &quot;Some text with digits3&quot; $text1 -replace &quot;\\d{0,5}$&quot; $text2 -replace &quot;\\d{0,5}$&quot; 量词“{0,5}”告诉正则表达式引擎需要 0 到 5 个数字，引擎会尽可能多地选取。","text":"假设您希望截掉一个字符串尾部的一些文字。以下是使用字符串操作的传统方法： $text = &quot;Some text&quot; $fromRight = 3 $text.Substring(0, $text.Length - $fromRight) 一个更强大的方法是使用 -replace 操作符结合正则表达式： $text = &quot;Some text&quot; $fromRight = 3 $text -replace &quot;.{$fromRight}$&quot; 这段代码将去掉文字尾部（$）之前 $fromRight 个任意字符（”.“）。 由于正则表达式十分灵活，所以您可以重新编辑它，只截去数字，且最多只截掉 5 个数字： $text1 = &quot;Some text with digits267686783&quot; $text2 = &quot;Some text with digits3&quot; $text1 -replace &quot;\\d{0,5}$&quot; $text2 -replace &quot;\\d{0,5}$&quot; 量词“{0,5}”告诉正则表达式引擎需要 0 到 5 个数字，引擎会尽可能多地选取。 本文国际来源：Shortening Text","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 避免使用重定向符","slug":"avoid-using-redirection","date":"2015-08-10T03:00:00.000Z","updated":"2017-03-17T15:26:26.081Z","comments":true,"path":"2015/08/10/avoid-using-redirection/","link":"","permalink":"http://blog.vichamp.com/2015/08/10/avoid-using-redirection/","excerpt":"如果您还在使用旧的重定向操作符来将命令的结果输出到一个文件，那么您可以使用新的 PowerShell cmdlet 来代替。以下是原因： #requires -Version 2 $OutPath = &quot;$env:temp\\report.txt&quot; Get-EventLog -LogName System -EntryType Error, Warning -Newest 10 &gt; $OutPath notepad.exe $OutPath 这将产生一个文本文件，内容和控制台中显示的精确一致，但不会包含任何对象的特性。 下一个例子确保输出的文本一点也不会被截断，并且输出使用 UTF8 编码——这些参数都是简易重定向所不包含的： #requires -Version 2 $OutPath = &quot;$env:temp\\report.txt&quot; Get-EventLog -LogName System -EntryType Error, Warning -Newest 10 | Format-Table -AutoSize -Wrap | Out-File -FilePath $OutPath -Width 100 notepad.exe $OutPath","text":"如果您还在使用旧的重定向操作符来将命令的结果输出到一个文件，那么您可以使用新的 PowerShell cmdlet 来代替。以下是原因： #requires -Version 2 $OutPath = &quot;$env:temp\\report.txt&quot; Get-EventLog -LogName System -EntryType Error, Warning -Newest 10 &gt; $OutPath notepad.exe $OutPath 这将产生一个文本文件，内容和控制台中显示的精确一致，但不会包含任何对象的特性。 下一个例子确保输出的文本一点也不会被截断，并且输出使用 UTF8 编码——这些参数都是简易重定向所不包含的： #requires -Version 2 $OutPath = &quot;$env:temp\\report.txt&quot; Get-EventLog -LogName System -EntryType Error, Warning -Newest 10 | Format-Table -AutoSize -Wrap | Out-File -FilePath $OutPath -Width 100 notepad.exe $OutPath 本文国际来源：Avoid Using Redirection","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 解码 PowerShell 命令","slug":"encode-powershell-commands","date":"2015-08-07T03:00:00.000Z","updated":"2017-03-17T15:26:26.081Z","comments":true,"path":"2015/08/07/encode-powershell-commands/","link":"","permalink":"http://blog.vichamp.com/2015/08/07/encode-powershell-commands/","excerpt":"当您需要在一个独立的 powershell.exe 以一个 PowerShell 命令的方式执行代码时，并不十分安全。这要看您从哪儿调用 powershell.exe，您的代码参数可能被解析器修改，而且代码中的特殊字符可能会造成宿主混淆。 一个更健壮的传递命令方法是将它们编码并用解码命令提交。这只适用于短的代码。长度必须限制在 8000 字符左右以内。 $code = { Get-EventLog -LogName System -EntryType Error | Out-GridView } $Bytes = [System.Text.Encoding]::Unicode.GetBytes($code.ToString()) $Encoded = [Convert]::ToBase64String($Bytes) $args = &apos;-noprofile -encodedcommand &apos; + $Encoded Start-Process -FilePath powershell.exe -ArgumentList $args","text":"当您需要在一个独立的 powershell.exe 以一个 PowerShell 命令的方式执行代码时，并不十分安全。这要看您从哪儿调用 powershell.exe，您的代码参数可能被解析器修改，而且代码中的特殊字符可能会造成宿主混淆。 一个更健壮的传递命令方法是将它们编码并用解码命令提交。这只适用于短的代码。长度必须限制在 8000 字符左右以内。 $code = { Get-EventLog -LogName System -EntryType Error | Out-GridView } $Bytes = [System.Text.Encoding]::Unicode.GetBytes($code.ToString()) $Encoded = [Convert]::ToBase64String($Bytes) $args = &apos;-noprofile -encodedcommand &apos; + $Encoded Start-Process -FilePath powershell.exe -ArgumentList $args 本文国际来源：Encode PowerShell Commands","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 定义多行文本","slug":"define-multiline-text","date":"2015-08-06T03:00:00.000Z","updated":"2017-03-17T15:26:26.059Z","comments":true,"path":"2015/08/06/define-multiline-text/","link":"","permalink":"http://blog.vichamp.com/2015/08/06/define-multiline-text/","excerpt":"当您需要在 PowerShell 中定义多行文本时，通常可以这样使用 here-string： $text = @&quot; I am safe here I can even use &quot;quotes&quot; &quot;@ $text | Out-GridView 值得注意的重点是分隔符包含（不可见的）回车符。必须在开始标记后有一个，在结束标记前有一个。 一个很特殊的另一种用法是使用脚本块来代替： $text = { I am safe here I can even use &quot;quotes&quot; } $text.ToString() | Out-GridView 虽然代码颜色不同，并且需要将脚本块转为字符串。这种方法有一定局限性，因为脚本块是一段 PowerShell 代码，并且它会被解析器解析。所以您只能包裹一段不会造成解析器混淆的文本。 这个是个不合法的例子，将会造成语法错误，因为非闭合的双引号： $text = { I am safe here I can even use &quot;quotes } $text.ToString() | Out-GridView","text":"当您需要在 PowerShell 中定义多行文本时，通常可以这样使用 here-string： $text = @&quot; I am safe here I can even use &quot;quotes&quot; &quot;@ $text | Out-GridView 值得注意的重点是分隔符包含（不可见的）回车符。必须在开始标记后有一个，在结束标记前有一个。 一个很特殊的另一种用法是使用脚本块来代替： $text = { I am safe here I can even use &quot;quotes&quot; } $text.ToString() | Out-GridView 虽然代码颜色不同，并且需要将脚本块转为字符串。这种方法有一定局限性，因为脚本块是一段 PowerShell 代码，并且它会被解析器解析。所以您只能包裹一段不会造成解析器混淆的文本。 这个是个不合法的例子，将会造成语法错误，因为非闭合的双引号： $text = { I am safe here I can even use &quot;quotes } $text.ToString() | Out-GridView 本文国际来源：Define Multiline Text","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 当前脚本的路径","slug":"current-script-path","date":"2015-08-05T03:00:00.000Z","updated":"2017-03-17T15:26:26.044Z","comments":true,"path":"2015/08/05/current-script-path/","link":"","permalink":"http://blog.vichamp.com/2015/08/05/current-script-path/","excerpt":"在 PowerShell 1.0 和 2.0 中，您需要一堆奇怪的代码来获得当前脚本的位置： # make sure the script is saved and NOT &quot;Untitled&quot;! $invocation = (Get-Variable MyInvocation).Value $scriptPath = Split-Path $invocation.MyCommand.Path $scriptName = $invocation.MyCommand.Name $scriptPath $scriptName 只有将它放在脚本的根部，这段代码才能用。 从 PowerShell 3.0 开始，事情变得更简单了，并且这些特殊变量在您脚本的任意地方都可以用。 # make sure the script is saved and NOT &quot;Untitled&quot;! $ScriptName = Split-Path $PSCommandPath -Leaf $PSScriptRoot $PSCommandPath $ScriptName","text":"在 PowerShell 1.0 和 2.0 中，您需要一堆奇怪的代码来获得当前脚本的位置： # make sure the script is saved and NOT &quot;Untitled&quot;! $invocation = (Get-Variable MyInvocation).Value $scriptPath = Split-Path $invocation.MyCommand.Path $scriptName = $invocation.MyCommand.Name $scriptPath $scriptName 只有将它放在脚本的根部，这段代码才能用。 从 PowerShell 3.0 开始，事情变得更简单了，并且这些特殊变量在您脚本的任意地方都可以用。 # make sure the script is saved and NOT &quot;Untitled&quot;! $ScriptName = Split-Path $PSCommandPath -Leaf $PSScriptRoot $PSCommandPath $ScriptName 本文国际来源：Current Script Path","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 发现动态参数","slug":"discovering-dynamic-parameters","date":"2015-08-04T03:00:00.000Z","updated":"2017-03-17T15:26:26.028Z","comments":true,"path":"2015/08/04/discovering-dynamic-parameters/","link":"","permalink":"http://blog.vichamp.com/2015/08/04/discovering-dynamic-parameters/","excerpt":"在前一个技能中我们展示了如何查找暴露了动态参数的 cmdlet。现在让我们来探索什么事动态参数。这个 Get-CmdletDynamicParameter 函数将返回一个动态参数的列表和它们的缺省值： #requires -Version 2 function Get-CmdletDynamicParameter { param ( [Parameter(ValueFromPipeline = $true,Mandatory = $true)] [String] $CmdletName ) process { $command = Get-Command -Name $CmdletName -CommandType Cmdlet if ($command) { $cmdlet = New-Object -TypeName $command.ImplementingType.FullName if ($cmdlet -is [Management.Automation.IDynamicParameters]) { $flags = [Reflection.BindingFlags]&apos;Instance, Nonpublic&apos; $field = $ExecutionContext.GetType().GetField(&apos;_context&apos;, $flags) $context = $field.GetValue($ExecutionContext) $property = [Management.Automation.Cmdlet].GetProperty(&apos;Context&apos;, $flags) $property.SetValue($cmdlet, $context, $null) $cmdlet.GetDynamicParameters() } } } } Get-CmdletDynamicParameter -CmdletName Get-ChildItem 该函数使用一些黑客的办法来暴露动态参数，这种方法是受到 Dave Wyatt 的启发。请参见他的文章 https://davewyatt.wordpress.com/2014/09/01/proxy-functions-for-cmdlets-with-dynamic-parameters/。","text":"在前一个技能中我们展示了如何查找暴露了动态参数的 cmdlet。现在让我们来探索什么事动态参数。这个 Get-CmdletDynamicParameter 函数将返回一个动态参数的列表和它们的缺省值： #requires -Version 2 function Get-CmdletDynamicParameter { param ( [Parameter(ValueFromPipeline = $true,Mandatory = $true)] [String] $CmdletName ) process { $command = Get-Command -Name $CmdletName -CommandType Cmdlet if ($command) { $cmdlet = New-Object -TypeName $command.ImplementingType.FullName if ($cmdlet -is [Management.Automation.IDynamicParameters]) { $flags = [Reflection.BindingFlags]&apos;Instance, Nonpublic&apos; $field = $ExecutionContext.GetType().GetField(&apos;_context&apos;, $flags) $context = $field.GetValue($ExecutionContext) $property = [Management.Automation.Cmdlet].GetProperty(&apos;Context&apos;, $flags) $property.SetValue($cmdlet, $context, $null) $cmdlet.GetDynamicParameters() } } } } Get-CmdletDynamicParameter -CmdletName Get-ChildItem 该函数使用一些黑客的办法来暴露动态参数，这种方法是受到 Dave Wyatt 的启发。请参见他的文章 https://davewyatt.wordpress.com/2014/09/01/proxy-functions-for-cmdlets-with-dynamic-parameters/。 本文国际来源：Discovering Dynamic Parameters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找带动态参数的 cmdlet","slug":"finding-cmdlets-with-dynamic-parameters","date":"2015-08-03T03:00:00.000Z","updated":"2017-03-17T15:26:26.012Z","comments":true,"path":"2015/08/03/finding-cmdlets-with-dynamic-parameters/","link":"","permalink":"http://blog.vichamp.com/2015/08/03/finding-cmdlets-with-dynamic-parameters/","excerpt":"有些 cmdlet 暴露了动态参数。它们只在特定的环境下可用。例如 Get-ChildItem 只在当前的位置是文件系统路径（并且是 PowerShell 3.0 以上版本）时才暴露 -File 和 -Directory 参数。 要查找所有带动态参数的 cmdlet，请试试这段代码： #requires -Version 2 $cmdlets = Get-Command -CommandType Cmdlet $cmdlets.Count $loaded = $cmdlets | Where-Object { $_.ImplementingType } $loaded.Count $dynamic = $loaded | Where-Object { $cmdlet = New-Object -TypeName $_.ImplementingType.FullName $cmdlet -is [System.Management.Automation.IDynamicParameters] } $dynamic.Count $dynamic | Out-GridView 您将只会获得已加载并且包含动态参数的 cmdlet。","text":"有些 cmdlet 暴露了动态参数。它们只在特定的环境下可用。例如 Get-ChildItem 只在当前的位置是文件系统路径（并且是 PowerShell 3.0 以上版本）时才暴露 -File 和 -Directory 参数。 要查找所有带动态参数的 cmdlet，请试试这段代码： #requires -Version 2 $cmdlets = Get-Command -CommandType Cmdlet $cmdlets.Count $loaded = $cmdlets | Where-Object { $_.ImplementingType } $loaded.Count $dynamic = $loaded | Where-Object { $cmdlet = New-Object -TypeName $_.ImplementingType.FullName $cmdlet -is [System.Management.Automation.IDynamicParameters] } $dynamic.Count $dynamic | Out-GridView 您将只会获得已加载并且包含动态参数的 cmdlet。 本文国际来源：Finding Cmdlets with Dynamic Parameters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 改变 ISE 缩放比例","slug":"change-ise-zoom-level","date":"2015-07-31T03:00:00.000Z","updated":"2017-03-17T15:26:25.997Z","comments":true,"path":"2015/07/31/change-ise-zoom-level/","link":"","permalink":"http://blog.vichamp.com/2015/07/31/change-ise-zoom-level/","excerpt":"PowerShell ISE 的右下角有一个缩放滑竿，您也可以用 PowerShell 代码来控制它。 所以，您可以在 $profile 脚本中设置缺省值： $psise.Options.Zoom = 120 或者，可以写一些代码来戏弄您的同事： #requires -Version 2 $zoom = $psise.Options.Zoom # slide in for ($i = 20; $i -lt 200; $i++) { $psise.Options.Zoom = $i } # slide out for ($i = 199; $i -gt 20; $i--) { $psise.Options.Zoom = $i } # random whacky 1..10 | ForEach-Object { $psise.Options.Zoom = (Get-Random -Minimum 30 -Maximum 400) Start-Sleep -Milliseconds (Get-Random -Minimum 100 -Maximum 400) } $psise.Options.Zoom = $zoom","text":"PowerShell ISE 的右下角有一个缩放滑竿，您也可以用 PowerShell 代码来控制它。 所以，您可以在 $profile 脚本中设置缺省值： $psise.Options.Zoom = 120 或者，可以写一些代码来戏弄您的同事： #requires -Version 2 $zoom = $psise.Options.Zoom # slide in for ($i = 20; $i -lt 200; $i++) { $psise.Options.Zoom = $i } # slide out for ($i = 199; $i -gt 20; $i--) { $psise.Options.Zoom = $i } # random whacky 1..10 | ForEach-Object { $psise.Options.Zoom = (Get-Random -Minimum 30 -Maximum 400) Start-Sleep -Milliseconds (Get-Random -Minimum 100 -Maximum 400) } $psise.Options.Zoom = $zoom 本文国际来源：Change ISE Zoom Level","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在任意 Powershell 版本中解压 ZIP 文件","slug":"unzipping-zip-files-with-any-powershell-version","date":"2015-07-30T03:00:00.000Z","updated":"2017-03-17T15:26:25.997Z","comments":true,"path":"2015/07/30/unzipping-zip-files-with-any-powershell-version/","link":"","permalink":"http://blog.vichamp.com/2015/07/30/unzipping-zip-files-with-any-powershell-version/","excerpt":"如果您没有安装 PowerShell 5.0，并且没有安装 .NET Framework 4.5，以下是一个使用 Windows 原生功能解压 ZIP 文件的办法。 不过，如果您安装了资源管理器自定义的 ZIP 文件扩展，这个方法可能不能用。 $Source = &apos;C:\\somezipfile.zip&apos; $Destination = &apos;C:\\somefolder&apos; $ShowDestinationFolder = $true if ((Test-Path $Destination) -eq $false) { $null = mkdir $Destination } $shell = New-Object -ComObject Shell.Application $sourceFolder = $shell.NameSpace($Source) $destinationFolder = $shell.NameSpace($Destination) $DestinationFolder.CopyHere($sourceFolder.Items()) if ($ShowDestinationFolder) { explorer.exe $Destination } 这个方法的好处是在需要覆盖文件的时候，会弹出 shell 的对话框。这个方法也可以解压 CAB 文件。","text":"如果您没有安装 PowerShell 5.0，并且没有安装 .NET Framework 4.5，以下是一个使用 Windows 原生功能解压 ZIP 文件的办法。 不过，如果您安装了资源管理器自定义的 ZIP 文件扩展，这个方法可能不能用。 $Source = &apos;C:\\somezipfile.zip&apos; $Destination = &apos;C:\\somefolder&apos; $ShowDestinationFolder = $true if ((Test-Path $Destination) -eq $false) { $null = mkdir $Destination } $shell = New-Object -ComObject Shell.Application $sourceFolder = $shell.NameSpace($Source) $destinationFolder = $shell.NameSpace($Destination) $DestinationFolder.CopyHere($sourceFolder.Items()) if ($ShowDestinationFolder) { explorer.exe $Destination } 这个方法的好处是在需要覆盖文件的时候，会弹出 shell 的对话框。这个方法也可以解压 CAB 文件。 本文国际来源：Unzipping ZIP Files with any PowerShell Version","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 PowerShell 3.0 和 4.0 中解压 ZIP 文件","slug":"unzipping-zip-files-with-powershell-3-0-and-4-0","date":"2015-07-29T03:00:00.000Z","updated":"2017-03-17T15:26:25.997Z","comments":true,"path":"2015/07/29/unzipping-zip-files-with-powershell-3-0-and-4-0/","link":"","permalink":"http://blog.vichamp.com/2015/07/29/unzipping-zip-files-with-powershell-3-0-and-4-0/","excerpt":"PowerShell 5.0 中引入了 ZIP 文件支持，但是如果您安装了 .NET Framework 4.5 并且希望更多地控制解压的过程，请试试这个方法： #requires -Version 2 # .NET Framework 4.5 required! Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop $Source = &apos;C:\\somezipfile.zip&apos; $Destination = &apos;C:\\somefolder&apos; $Overwrite = $true $ShowDestinationFolder = $true if ((Test-Path $Destination) -eq $false) { $null = mkdir $Destination } $Content = [IO.Compression.ZipFile]::OpenRead($Source).Entries $Content | ForEach-Object -Process { $FilePath = Join-Path -Path $Destination -ChildPath $_ [IO.Compression.ZipFileExtensions]::ExtractToFile($_,$FilePath,$Overwrite) } if ($ShowDestinationFolder) { explorer.exe $Destination }","text":"PowerShell 5.0 中引入了 ZIP 文件支持，但是如果您安装了 .NET Framework 4.5 并且希望更多地控制解压的过程，请试试这个方法： #requires -Version 2 # .NET Framework 4.5 required! Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop $Source = &apos;C:\\somezipfile.zip&apos; $Destination = &apos;C:\\somefolder&apos; $Overwrite = $true $ShowDestinationFolder = $true if ((Test-Path $Destination) -eq $false) { $null = mkdir $Destination } $Content = [IO.Compression.ZipFile]::OpenRead($Source).Entries $Content | ForEach-Object -Process { $FilePath = Join-Path -Path $Destination -ChildPath $_ [IO.Compression.ZipFileExtensions]::ExtractToFile($_,$FilePath,$Overwrite) } if ($ShowDestinationFolder) { explorer.exe $Destination } 本文国际来源：Unzipping ZIP Files with PowerShell 3.0 and 4.0","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 解压 ZIP 文件","slug":"unzipping-zip-files","date":"2015-07-28T03:00:00.000Z","updated":"2017-03-17T15:26:25.981Z","comments":true,"path":"2015/07/28/unzipping-zip-files/","link":"","permalink":"http://blog.vichamp.com/2015/07/28/unzipping-zip-files/","excerpt":"在 PowerShell 5.0 中，有一个新的 cmdlet 可以解压 ZIP 文件： #requires -Version 5 $Source = &apos;C:\\somezipfile.zip&apos; $Destination = &apos;C:\\somefolder&apos; $Overwrite = $true $ShowDestinationFolder = $true Expand-Archive -Path $Source -DestinationPath $Destination -Force:$Overwrite if ($ShowDestinationFolder) { explorer.exe $Destination }","text":"在 PowerShell 5.0 中，有一个新的 cmdlet 可以解压 ZIP 文件： #requires -Version 5 $Source = &apos;C:\\somezipfile.zip&apos; $Destination = &apos;C:\\somefolder&apos; $Overwrite = $true $ShowDestinationFolder = $true Expand-Archive -Path $Source -DestinationPath $Destination -Force:$Overwrite if ($ShowDestinationFolder) { explorer.exe $Destination } 本文国际来源：Unzipping ZIP Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找打开了 PowerShell 远程操作功能的计算机","slug":"finding-computers-with-powershell-remoting","date":"2015-07-27T03:00:00.000Z","updated":"2017-03-17T15:26:25.981Z","comments":true,"path":"2015/07/27/finding-computers-with-powershell-remoting/","link":"","permalink":"http://blog.vichamp.com/2015/07/27/finding-computers-with-powershell-remoting/","excerpt":"在前一个技能中我们演示了如何如何测试一台计算机的端口。在安装了 Microsoft 免费的 RSAT 工具之后，您可以查询您的 Active Directory，并获取所有计算机用户的列表，或指定范围内的所有计算机账户（例如用 -SearchBase 限制在一个特定的 OU 中搜索）。 下一步，您可以使用该端口来测试这些计算机是否在线，以及 PowerShell 远程操作端口 5985 是否打开： #requires -Version 1 -Modules ActiveDirectory function Test-Port { Param([string]$ComputerName,$port = 5985,$timeout = 1000) try { $tcpclient = New-Object -TypeName system.Net.Sockets.TcpClient $iar = $tcpclient.BeginConnect($ComputerName,$port,$null,$null) $wait = $iar.AsyncWaitHandle.WaitOne($timeout,$false) if(!$wait) { $tcpclient.Close() return $false } else { # Close the connection and report the error if there is one $null = $tcpclient.EndConnect($iar) $tcpclient.Close() return $true } } catch { $false } } Get-ADComputer -Filter * | Select-Object -ExpandProperty dnsHostName | ForEach-Object { Write-Progress -Activity &apos;Testing Port&apos; -Status $_ } | Where-Object -FilterScript { Test-Port -ComputerName $_ }","text":"在前一个技能中我们演示了如何如何测试一台计算机的端口。在安装了 Microsoft 免费的 RSAT 工具之后，您可以查询您的 Active Directory，并获取所有计算机用户的列表，或指定范围内的所有计算机账户（例如用 -SearchBase 限制在一个特定的 OU 中搜索）。 下一步，您可以使用该端口来测试这些计算机是否在线，以及 PowerShell 远程操作端口 5985 是否打开： #requires -Version 1 -Modules ActiveDirectory function Test-Port { Param([string]$ComputerName,$port = 5985,$timeout = 1000) try { $tcpclient = New-Object -TypeName system.Net.Sockets.TcpClient $iar = $tcpclient.BeginConnect($ComputerName,$port,$null,$null) $wait = $iar.AsyncWaitHandle.WaitOne($timeout,$false) if(!$wait) { $tcpclient.Close() return $false } else { # Close the connection and report the error if there is one $null = $tcpclient.EndConnect($iar) $tcpclient.Close() return $true } } catch { $false } } Get-ADComputer -Filter * | Select-Object -ExpandProperty dnsHostName | ForEach-Object { Write-Progress -Activity &apos;Testing Port&apos; -Status $_ } | Where-Object -FilterScript { Test-Port -ComputerName $_ } 本文国际来源：Finding Computers with PowerShell Remoting","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 测试一个网络端口","slug":"testing-a-network-port","date":"2015-07-24T03:00:00.000Z","updated":"2017-03-17T15:26:25.981Z","comments":true,"path":"2015/07/24/testing-a-network-port/","link":"","permalink":"http://blog.vichamp.com/2015/07/24/testing-a-network-port/","excerpt":"这个 Test-Port 的测试函数可以通过一个网络端口测试一台远程的机器。它传入一个远程机器名（或 IP 地址），以及可选的端口号和和超时值。 缺省端口号是 5985，改端口用于 PowerShell 远程操作。缺省的超时值是 1000ms（1 秒）。 #requires -Version 1 function Test-Port { Param([string]$ComputerName,$port = 5985,$timeout = 1000) try { $tcpclient = New-Object -TypeName system.Net.Sockets.TcpClient $iar = $tcpclient.BeginConnect($ComputerName,$port,$null,$null) $wait = $iar.AsyncWaitHandle.WaitOne($timeout,$false) if(!$wait) { $tcpclient.Close() return $false } else { # Close the connection and report the error if there is one $null = $tcpclient.EndConnect($iar) $tcpclient.Close() return $true } } catch { $false } } 所以如果您希望知道一台远程计算机是否启用了 PowerShell 远程操作，您只需要运行： PS&gt; Test-Port -ComputerName TestServer False 由于缺省的超时值是 1 秒，您最多等待 1 秒就能等到响应。","text":"这个 Test-Port 的测试函数可以通过一个网络端口测试一台远程的机器。它传入一个远程机器名（或 IP 地址），以及可选的端口号和和超时值。 缺省端口号是 5985，改端口用于 PowerShell 远程操作。缺省的超时值是 1000ms（1 秒）。 #requires -Version 1 function Test-Port { Param([string]$ComputerName,$port = 5985,$timeout = 1000) try { $tcpclient = New-Object -TypeName system.Net.Sockets.TcpClient $iar = $tcpclient.BeginConnect($ComputerName,$port,$null,$null) $wait = $iar.AsyncWaitHandle.WaitOne($timeout,$false) if(!$wait) { $tcpclient.Close() return $false } else { # Close the connection and report the error if there is one $null = $tcpclient.EndConnect($iar) $tcpclient.Close() return $true } } catch { $false } } 所以如果您希望知道一台远程计算机是否启用了 PowerShell 远程操作，您只需要运行： PS&gt; Test-Port -ComputerName TestServer False 由于缺省的超时值是 1 秒，您最多等待 1 秒就能等到响应。 本文国际来源：Testing a Network Port","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找登录的用户","slug":"finding-logged-on-users","date":"2015-07-23T03:00:00.000Z","updated":"2017-03-17T15:26:25.976Z","comments":true,"path":"2015/07/23/finding-logged-on-users/","link":"","permalink":"http://blog.vichamp.com/2015/07/23/finding-logged-on-users/","excerpt":"在前一个技能里我们介绍了如何查找物理上登录的用户。在这个技能中您将学习到如何列出当前登录到本地系统的所有用户。这包括了通过 RDP 及其它方式连上的用户： #requires -Version 1 function Get-LoggedOnUserSession { param ( $ComputerName, $Credential ) Get-WmiObject -Class Win32_LogonSession @PSBoundParameters | ForEach-Object { $_.GetRelated(&apos;Win32_UserAccount&apos;) | Select-Object -ExpandProperty Caption } | Sort-Object -Unique } 执行 Get-LoggedOnUserSession 命令将得到当前登录到机器上的所有用户。如指定了 -Credential（域名\\用户名）参数，可以访问远程机器。","text":"在前一个技能里我们介绍了如何查找物理上登录的用户。在这个技能中您将学习到如何列出当前登录到本地系统的所有用户。这包括了通过 RDP 及其它方式连上的用户： #requires -Version 1 function Get-LoggedOnUserSession { param ( $ComputerName, $Credential ) Get-WmiObject -Class Win32_LogonSession @PSBoundParameters | ForEach-Object { $_.GetRelated(&apos;Win32_UserAccount&apos;) | Select-Object -ExpandProperty Caption } | Sort-Object -Unique } 执行 Get-LoggedOnUserSession 命令将得到当前登录到机器上的所有用户。如指定了 -Credential（域名\\用户名）参数，可以访问远程机器。 本文国际来源：Finding Logged On Users","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找物理登录的用户","slug":"find-physically-logged-on-user","date":"2015-07-22T03:00:00.000Z","updated":"2017-03-17T15:26:25.959Z","comments":true,"path":"2015/07/22/find-physically-logged-on-user/","link":"","permalink":"http://blog.vichamp.com/2015/07/22/find-physically-logged-on-user/","excerpt":"一台机器上只能有一个物理登录的用户。物理登录的用户意味着正坐在机器旁边的那个用户。 这个 PowerShell 函数能返回本地或远程系统物理登录的用户。要访问远程系统，您可能需要远程系统的本地管理员权限，并且确保防火墙已配置成允许连接。 #requires -Version 1 function Get-LoggedOnUser { param ( $ComputerName, $Credential ) Get-WmiObject -Class Win32_ComputerSystem @PSBoundParameters | Select-Object -ExpandProperty UserName } 运行 Get-LoggedOnUser 命令后能够获得本机上物理登录的用户名。指定 -ComputerName（或者 -Credential）参数可以获得远程机器上物理登录的用户名。","text":"一台机器上只能有一个物理登录的用户。物理登录的用户意味着正坐在机器旁边的那个用户。 这个 PowerShell 函数能返回本地或远程系统物理登录的用户。要访问远程系统，您可能需要远程系统的本地管理员权限，并且确保防火墙已配置成允许连接。 #requires -Version 1 function Get-LoggedOnUser { param ( $ComputerName, $Credential ) Get-WmiObject -Class Win32_ComputerSystem @PSBoundParameters | Select-Object -ExpandProperty UserName } 运行 Get-LoggedOnUser 命令后能够获得本机上物理登录的用户名。指定 -ComputerName（或者 -Credential）参数可以获得远程机器上物理登录的用户名。 本文国际来源：Find Physically Logged On User","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通过连接字符串访问 SQL 数据库","slug":"accessing-an-sql-database-with-a-connection-string","date":"2015-07-21T03:00:00.000Z","updated":"2017-03-17T15:26:25.943Z","comments":true,"path":"2015/07/21/accessing-an-sql-database-with-a-connection-string/","link":"","permalink":"http://blog.vichamp.com/2015/07/21/accessing-an-sql-database-with-a-connection-string/","excerpt":"在前一个技能中我们揭示了如何创建一个 SQL Server 的连接字符串。无论您用什么方式创建了这个字符串——假设您已拥有了一个合法的数据库连接字符串，这个例子将演示如何对数据库执行 SQL 命令。 #requires -Version 2 # make sure this is a valid connection string to your database # see www.connectionstrings.com for reference $connectionString = &apos;Provider=SQLOLEDB.1;Password=.topSecret!;Persist Security Info=True;User ID=sa;Initial Catalog=test;Data Source=myDBServer\\SQLEXPRESS2012&apos; # make sure this is valid SQL for your database # so in this case, make sure there is a table called &quot;test&quot; $sql = &apos;select * from test&apos; $db = New-Object -ComObject ADODB.Connection $db.Open($connectionString) $rs = $db.Execute($sql) $results = While ($rs.EOF -eq $false) { $CustomObject = New-Object -TypeName PSObject $rs.Fields | ForEach-Object -Process { $CustomObject | Add-Member -MemberType NoteProperty -Name $_.Name -Value $_.Value } $CustomObject $rs.MoveNext() } $results | Out-GridView","text":"在前一个技能中我们揭示了如何创建一个 SQL Server 的连接字符串。无论您用什么方式创建了这个字符串——假设您已拥有了一个合法的数据库连接字符串，这个例子将演示如何对数据库执行 SQL 命令。 #requires -Version 2 # make sure this is a valid connection string to your database # see www.connectionstrings.com for reference $connectionString = &apos;Provider=SQLOLEDB.1;Password=.topSecret!;Persist Security Info=True;User ID=sa;Initial Catalog=test;Data Source=myDBServer\\SQLEXPRESS2012&apos; # make sure this is valid SQL for your database # so in this case, make sure there is a table called &quot;test&quot; $sql = &apos;select * from test&apos; $db = New-Object -ComObject ADODB.Connection $db.Open($connectionString) $rs = $db.Execute($sql) $results = While ($rs.EOF -eq $false) { $CustomObject = New-Object -TypeName PSObject $rs.Fields | ForEach-Object -Process { $CustomObject | Add-Member -MemberType NoteProperty -Name $_.Name -Value $_.Value } $CustomObject $rs.MoveNext() } $results | Out-GridView 本文国际来源：Accessing an SQL Database with a Connection String","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取 SQL Server 连接字符串","slug":"getting-sql-server-connection-string","date":"2015-07-20T03:00:00.000Z","updated":"2017-03-17T15:26:25.928Z","comments":true,"path":"2015/07/20/getting-sql-server-connection-string/","link":"","permalink":"http://blog.vichamp.com/2015/07/20/getting-sql-server-connection-string/","excerpt":"如果您希望用 PowerShell 访问 SQL Server，您需要一个连接字符串。连接字符串包含了访问 SQL Server 实例所需的所有信息。 通常，要正确地组织一个连接字符串并不容易。以下是一个帮您实现这个目的的 Get-ConnectionString 函数： #requires -Version 2 function Get-ConnectionString { $Path = Join-Path -Path $env:TEMP -ChildPath &apos;dummy.udl&apos; $null = New-Item -Path $Path -ItemType File -Force $CommandArg = &quot;&quot;&quot;$env:CommonProgramFiles\\System\\OLE DB\\oledb32.dll&quot;&quot;,OpenDSLFile &quot; + $Path Start-Process -FilePath Rundll32.exe -ArgumentList $CommandArg -Wait $ConnectionString = Get-Content -Path $Path | Select-Object -Last 1 $ConnectionString | clip.exe Write-Warning -Message &apos;Connection String is also available from clipboard&apos; $ConnectionString } 当您运行 Get-ConnectionString 时，PowerShell 会打开一个对话框，您可以提交和测试连接的情况。当您关闭对话框窗口时，PowerShell 将返回由 UI 对话框创建的连接字符串。","text":"如果您希望用 PowerShell 访问 SQL Server，您需要一个连接字符串。连接字符串包含了访问 SQL Server 实例所需的所有信息。 通常，要正确地组织一个连接字符串并不容易。以下是一个帮您实现这个目的的 Get-ConnectionString 函数： #requires -Version 2 function Get-ConnectionString { $Path = Join-Path -Path $env:TEMP -ChildPath &apos;dummy.udl&apos; $null = New-Item -Path $Path -ItemType File -Force $CommandArg = &quot;&quot;&quot;$env:CommonProgramFiles\\System\\OLE DB\\oledb32.dll&quot;&quot;,OpenDSLFile &quot; + $Path Start-Process -FilePath Rundll32.exe -ArgumentList $CommandArg -Wait $ConnectionString = Get-Content -Path $Path | Select-Object -Last 1 $ConnectionString | clip.exe Write-Warning -Message &apos;Connection String is also available from clipboard&apos; $ConnectionString } 当您运行 Get-ConnectionString 时，PowerShell 会打开一个对话框，您可以提交和测试连接的情况。当您关闭对话框窗口时，PowerShell 将返回由 UI 对话框创建的连接字符串。 本文国际来源：Getting SQL Server Connection String","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 更新 Active Directory 中的办公电话号码","slug":"updating-your-office-phone-number-in-active-directory","date":"2015-07-17T03:00:00.000Z","updated":"2017-03-17T15:26:25.928Z","comments":true,"path":"2015/07/17/updating-your-office-phone-number-in-active-directory/","link":"","permalink":"http://blog.vichamp.com/2015/07/17/updating-your-office-phone-number-in-active-directory/","excerpt":"如果您安装了微软免费提供的 RSAT 工具，您可以使用 PowerShell 来更新您 AD 用户账户中存储的信息，例如您的办公电话号码。 您是否有权限提交变更的信息取决于您的企业安全设置，但缺省情况下您可以修改许多（您自己账户的）信息而不需要管理员权限。 这个例子演示了用 PowerShell 脚本提示输入一个新的办公电话号码然后更新到 Active Directory 中： #requires -Version 1 -Modules ActiveDirectory $phoneNumber = Read-Host -Prompt &apos;Your new office phone number&apos; $user = $env:USERNAME Set-ADUser -Identity $user -OfficePhone $phoneNumber","text":"如果您安装了微软免费提供的 RSAT 工具，您可以使用 PowerShell 来更新您 AD 用户账户中存储的信息，例如您的办公电话号码。 您是否有权限提交变更的信息取决于您的企业安全设置，但缺省情况下您可以修改许多（您自己账户的）信息而不需要管理员权限。 这个例子演示了用 PowerShell 脚本提示输入一个新的办公电话号码然后更新到 Active Directory 中： #requires -Version 1 -Modules ActiveDirectory $phoneNumber = Read-Host -Prompt &apos;Your new office phone number&apos; $user = $env:USERNAME Set-ADUser -Identity $user -OfficePhone $phoneNumber 本文国际来源：Updating Your Office Phone Number in Active Directory","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 向 AD 对象增加自定义属性","slug":"adding-custom-attributes-to-ad-objects","date":"2015-07-16T03:00:00.000Z","updated":"2017-03-17T15:26:25.928Z","comments":true,"path":"2015/07/16/adding-custom-attributes-to-ad-objects/","link":"","permalink":"http://blog.vichamp.com/2015/07/16/adding-custom-attributes-to-ad-objects/","excerpt":"如果您想向一个 AD 对象增加自定义属性，只需要用一个哈希表，然后增加期望的属性名和属性值。然后用 Set-ADUser（在随微软免费的 RSAT 工具发布的 ActiveDirectory 模块中）。 这个例子将想当前的用户账户增加两个扩展属性（请确保不要破坏基础环境的属性！请使用测试环境来学习）： #requires -Version 1 -Modules ActiveDirectory # create an empty hash table $custom = @{} # add the attribute names and values $custom.ExtensionAttribute3 = 12 $custom.ExtensionAttribute4 = &apos;Hello&apos; # assign the attributes to your current user object $user = $env:USERNAME Set-ADUser -Identity $user -Add $custom 选择正确的参数很重要。用 -Add 参数向属性增加新的值；用 -Remove 移除一个已有的值；用 -Replace 将属性替换为一个新的值。","text":"如果您想向一个 AD 对象增加自定义属性，只需要用一个哈希表，然后增加期望的属性名和属性值。然后用 Set-ADUser（在随微软免费的 RSAT 工具发布的 ActiveDirectory 模块中）。 这个例子将想当前的用户账户增加两个扩展属性（请确保不要破坏基础环境的属性！请使用测试环境来学习）： #requires -Version 1 -Modules ActiveDirectory # create an empty hash table $custom = @{} # add the attribute names and values $custom.ExtensionAttribute3 = 12 $custom.ExtensionAttribute4 = &apos;Hello&apos; # assign the attributes to your current user object $user = $env:USERNAME Set-ADUser -Identity $user -Add $custom 选择正确的参数很重要。用 -Add 参数向属性增加新的值；用 -Remove 移除一个已有的值；用 -Replace 将属性替换为一个新的值。 本文国际来源：Adding Custom Attributes to AD Objects","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 复制 Active Directory 安全设置","slug":"cloning-active-directory-security-settings","date":"2015-07-15T03:00:00.000Z","updated":"2017-03-17T15:26:25.912Z","comments":true,"path":"2015/07/15/cloning-active-directory-security-settings/","link":"","permalink":"http://blog.vichamp.com/2015/07/15/cloning-active-directory-security-settings/","excerpt":"当您向一个 AD 对象增加委派权限（例如允许一个用户管理一个组织对象的成员）时，实际上是调用了该 AD 对象的改变安全设置方法。 AD 安全描述符有可能非常复杂。复制 AD 安全信息却非常简单。所以如果您希望将相同的安全设置复制到另一个 AD 对象，您可以从一个对象读取已有的安全设置，然后将它们复制到另一个对象上。 这段脚本演示了如何从一个 OU 读取安全设置，并且将它复制到另一个 OU。这需要随 ActiveDirectory 模块发布的 ActiveDirectory 提供器。这个模块是微软免费的 RSAT 工具的一部分，需事先安装。 #requires -Version 2 -Modules ActiveDirectory Import-Module -Name ActiveDirectory # read AD security from NewOU1 $sd = Get-Acl -Path &apos;AD:\\OU=NewOU1,DC=powershell,DC=local&apos; # assign security to NewOU2 Set-Acl -Path &apos;AD:\\OU=NewOU2,DC=powershell,DC=local&apos; -AclObject $sd","text":"当您向一个 AD 对象增加委派权限（例如允许一个用户管理一个组织对象的成员）时，实际上是调用了该 AD 对象的改变安全设置方法。 AD 安全描述符有可能非常复杂。复制 AD 安全信息却非常简单。所以如果您希望将相同的安全设置复制到另一个 AD 对象，您可以从一个对象读取已有的安全设置，然后将它们复制到另一个对象上。 这段脚本演示了如何从一个 OU 读取安全设置，并且将它复制到另一个 OU。这需要随 ActiveDirectory 模块发布的 ActiveDirectory 提供器。这个模块是微软免费的 RSAT 工具的一部分，需事先安装。 #requires -Version 2 -Modules ActiveDirectory Import-Module -Name ActiveDirectory # read AD security from NewOU1 $sd = Get-Acl -Path &apos;AD:\\OU=NewOU1,DC=powershell,DC=local&apos; # assign security to NewOU2 Set-Acl -Path &apos;AD:\\OU=NewOU2,DC=powershell,DC=local&apos; -AclObject $sd 本文国际来源：Cloning Active Directory Security Settings","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将命令历史保存到文件","slug":"get-command-history-as-file","date":"2015-07-14T03:00:00.000Z","updated":"2017-03-17T15:26:25.912Z","comments":true,"path":"2015/07/14/get-command-history-as-file/","link":"","permalink":"http://blog.vichamp.com/2015/07/14/get-command-history-as-file/","excerpt":"随着 PowerShell 3.0 及以上脚本发布的 PowerShell ISE 内置编辑器可以支持定制，并且可以增加自己的菜单项。 当您运行以下代码时，您会发现在“附加工具”菜单中会多出一个“Get Command History”子菜单，也可以通过 ALT + C 组合键激活该功能。 这个命令将返回当前的命令行历史（您在当前 ISE 会话中交互式键入的命令）并且将它们拷贝到一个新的 PowerShell 文件中。通过这种方式，可以很轻松地保存互操作的历史。您甚至可以通过这种方式自动创建 PowerShell 脚本：只需要删掉不能用的代码行，只留下能产生预期结果的代码行。 #requires -Version 3 $code = { $text = Get-History | Select-Object -ExpandProperty CommandLine | Out-String $file = $psise.CurrentPowerShellTab.Files.Add() $file.Editor.Text = $text } $psise.CurrentPowerShellTab.AddOnsMenu.Submenus.Add(&apos;Get Command History&apos;, $code, &apos;ALT+C&apos;)","text":"随着 PowerShell 3.0 及以上脚本发布的 PowerShell ISE 内置编辑器可以支持定制，并且可以增加自己的菜单项。 当您运行以下代码时，您会发现在“附加工具”菜单中会多出一个“Get Command History”子菜单，也可以通过 ALT + C 组合键激活该功能。 这个命令将返回当前的命令行历史（您在当前 ISE 会话中交互式键入的命令）并且将它们拷贝到一个新的 PowerShell 文件中。通过这种方式，可以很轻松地保存互操作的历史。您甚至可以通过这种方式自动创建 PowerShell 脚本：只需要删掉不能用的代码行，只留下能产生预期结果的代码行。 #requires -Version 3 $code = { $text = Get-History | Select-Object -ExpandProperty CommandLine | Out-String $file = $psise.CurrentPowerShellTab.Files.Add() $file.Editor.Text = $text } $psise.CurrentPowerShellTab.AddOnsMenu.Submenus.Add(&apos;Get Command History&apos;, $code, &apos;ALT+C&apos;) 本文国际来源：Get Command History as File","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 简单的 AD 组管理","slug":"simple-ad-group-management","date":"2015-07-13T03:00:00.000Z","updated":"2017-03-17T15:26:25.912Z","comments":true,"path":"2015/07/13/simple-ad-group-management/","link":"","permalink":"http://blog.vichamp.com/2015/07/13/simple-ad-group-management/","excerpt":"假设您已下载安装了微软免费的 RSAT 工具，那么管理 AD 组合组成员会相当轻松。以下几行代码演示了如何入门： #requires -Version 1 -Modules ActiveDirectory # create new AD group New-ADGroup -DisplayName PowerShellGurus -GroupScope DomainLocal -Name PSGurus # get group Get-ADGroup -Identity PSGurus -Credential $cred -Server 172.16.14.53 # select users by some criteria $newMembers = Get-ADUser -Filter &apos;Name -like &quot;User*&quot;&apos; # add them to new AD group Add-ADGroupMember -Identity &apos;PSGurus&apos; -Members $newMembers # list members of group Get-ADGroupMember -Identity PSGurus","text":"假设您已下载安装了微软免费的 RSAT 工具，那么管理 AD 组合组成员会相当轻松。以下几行代码演示了如何入门： #requires -Version 1 -Modules ActiveDirectory # create new AD group New-ADGroup -DisplayName PowerShellGurus -GroupScope DomainLocal -Name PSGurus # get group Get-ADGroup -Identity PSGurus -Credential $cred -Server 172.16.14.53 # select users by some criteria $newMembers = Get-ADUser -Filter &apos;Name -like &quot;User*&quot;&apos; # add them to new AD group Add-ADGroupMember -Identity &apos;PSGurus&apos; -Members $newMembers # list members of group Get-ADGroupMember -Identity PSGurus 本文国际来源：Simple AD Group Management","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 PowerShell 的帮助","slug":"using-powershell-help","date":"2015-07-10T03:00:00.000Z","updated":"2017-03-17T15:26:25.896Z","comments":true,"path":"2015/07/10/using-powershell-help/","link":"","permalink":"http://blog.vichamp.com/2015/07/10/using-powershell-help/","excerpt":"要查看完整的 PowerShell 帮助，您首先需要从 Internet 下载帮助信息。只需要以管理员权限打开一个 PowerShell 控制台执行以下代码： PS&gt; Start-Process -FilePath powershell.exe -Verb runas 下一步，下载 PowerShell 帮助： PS&gt; Update-Help -UICulture en-us -Force 请注意：PowerShell 帮助只有英语的版本。这是为什么要指定 -UICulture 确保请求下载英文帮助文件的原因。 当帮助文件安装完后，在 PowerShell 4.0 及以上版本就可以使用了。您可以显示一个命令的完整帮助，或只是显示示例代码： PS&gt; Get-Help -Name Get-Random -ShowWindow PS&gt; Get-Help -Name Get-Random -Examples NAME Get-Random SYNOPSIS Gets a random number, or selects objects randomly from a collection. -------------------------- EXAMPLE 1 -------------------------- PS C:\\&gt;Get-Random 3951433 This command gets a random integer between 0 (zero) and Int32.MaxValue. -------------------------- EXAMPLE 2 -------------------------- PS C:\\&gt;Get-Random -Maximum 100 47 This command gets a random integer between 0 (zero) and 99. ... 在 PowerShell 3.0 中，如果您并不是使用英语，您需要手动将帮助文件从 en-US 文件夹复制到您语言对应的文件夹中： #requires -RunAsAdministrator #requires -Version 3 $locale = $host.CurrentUICulture.Name if ($locale -eq &apos;en-us&apos;) { Write-Warning &apos;You are using the English locale, all is good.&apos; } else { Copy-Item -Path &quot;$pshome\\en-us\\*&quot; -Destination &quot;$pshome\\$locale\\&quot; -Recurse -ErrorAction SilentlyContinue -Verbose Write-Host &quot;Help updated in $locale locale&quot; } 当帮助文件复制到您语言对应的文件夹中后，您就可以在非英语系统中使用英语的帮助文件了。","text":"要查看完整的 PowerShell 帮助，您首先需要从 Internet 下载帮助信息。只需要以管理员权限打开一个 PowerShell 控制台执行以下代码： PS&gt; Start-Process -FilePath powershell.exe -Verb runas 下一步，下载 PowerShell 帮助： PS&gt; Update-Help -UICulture en-us -Force 请注意：PowerShell 帮助只有英语的版本。这是为什么要指定 -UICulture 确保请求下载英文帮助文件的原因。 当帮助文件安装完后，在 PowerShell 4.0 及以上版本就可以使用了。您可以显示一个命令的完整帮助，或只是显示示例代码： PS&gt; Get-Help -Name Get-Random -ShowWindow PS&gt; Get-Help -Name Get-Random -Examples NAME Get-Random SYNOPSIS Gets a random number, or selects objects randomly from a collection. -------------------------- EXAMPLE 1 -------------------------- PS C:\\&gt;Get-Random 3951433 This command gets a random integer between 0 (zero) and Int32.MaxValue. -------------------------- EXAMPLE 2 -------------------------- PS C:\\&gt;Get-Random -Maximum 100 47 This command gets a random integer between 0 (zero) and 99. ... 在 PowerShell 3.0 中，如果您并不是使用英语，您需要手动将帮助文件从 en-US 文件夹复制到您语言对应的文件夹中： #requires -RunAsAdministrator #requires -Version 3 $locale = $host.CurrentUICulture.Name if ($locale -eq &apos;en-us&apos;) { Write-Warning &apos;You are using the English locale, all is good.&apos; } else { Copy-Item -Path &quot;$pshome\\en-us\\*&quot; -Destination &quot;$pshome\\$locale\\&quot; -Recurse -ErrorAction SilentlyContinue -Verbose Write-Host &quot;Help updated in $locale locale&quot; } 当帮助文件复制到您语言对应的文件夹中后，您就可以在非英语系统中使用英语的帮助文件了。 本文国际来源：Using PowerShell Help","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 设置 AD 账号的过期时间","slug":"setting-ad-account-expiration-date","date":"2015-07-08T20:00:00.000Z","updated":"2017-03-17T15:26:25.881Z","comments":true,"path":"2015/07/09/setting-ad-account-expiration-date/","link":"","permalink":"http://blog.vichamp.com/2015/07/09/setting-ad-account-expiration-date/","excerpt":"要安全地使用临时的 AD 账号，例如给客户或是顾问使用，请记得设置一个失效日期。 以下示例代码演示了如何设置今天起 20 之后过期： #requires -Version 1 -Modules ActiveDirectory # SAMAccount name $user = &apos;user12&apos; # days when to expire $Days = 20 # expiration date is today plus the number of days $expirationDate = (Get-Date).AddDays($Days) Set-ADUser -Identity $user -AccountExpirationDate $expirationDate 请注意这段代码需要随 RSAT 免费工具发布的 Active Directory 模块。 如果您的计算机并没有连接到 AD，但是您拥有一个合法的 AD 账号，您可以用这种方法手动连接到 AD： #requires -Version 1 -Modules ActiveDirectory # Name or IP of DC $ServerName = &apos;10.10.12.110&apos; # Logon credentials $Credential = Get-Credential # SAMAccount name $user = &apos;user12&apos; # days when to expire $Days = 20 # expiration date is today plus the number of days $expirationDate = (Get-Date).AddDays($Days) Set-ADUser -Identity $user -AccountExpirationDate $expirationDate -Server $ServerName -Credential $Credential","text":"要安全地使用临时的 AD 账号，例如给客户或是顾问使用，请记得设置一个失效日期。 以下示例代码演示了如何设置今天起 20 之后过期： #requires -Version 1 -Modules ActiveDirectory # SAMAccount name $user = &apos;user12&apos; # days when to expire $Days = 20 # expiration date is today plus the number of days $expirationDate = (Get-Date).AddDays($Days) Set-ADUser -Identity $user -AccountExpirationDate $expirationDate 请注意这段代码需要随 RSAT 免费工具发布的 Active Directory 模块。 如果您的计算机并没有连接到 AD，但是您拥有一个合法的 AD 账号，您可以用这种方法手动连接到 AD： #requires -Version 1 -Modules ActiveDirectory # Name or IP of DC $ServerName = &apos;10.10.12.110&apos; # Logon credentials $Credential = Get-Credential # SAMAccount name $user = &apos;user12&apos; # days when to expire $Days = 20 # expiration date is today plus the number of days $expirationDate = (Get-Date).AddDays($Days) Set-ADUser -Identity $user -AccountExpirationDate $expirationDate -Server $ServerName -Credential $Credential 本文国际来源：Setting AD Account Expiration Date","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 批量删除 AD 的防意外删除保护","slug":"bulk-remove-protection-for-accidental-deletion-in-ad","date":"2015-07-08T03:00:00.000Z","updated":"2017-03-17T15:26:25.881Z","comments":true,"path":"2015/07/08/bulk-remove-protection-for-accidental-deletion-in-ad/","link":"","permalink":"http://blog.vichamp.com/2015/07/08/bulk-remove-protection-for-accidental-deletion-in-ad/","excerpt":"缺省情况下，AD 对象是受保护防止意外删除的。要移除一个指定的范围内所有对象（例如某个机构之下）的这种保护，请试试这段代码： #requires -Version 1 -Modules ActiveDirectory Get-ADObject -Filter * -SearchBase &apos;OU=TestOU,DC=Vision,DC=local&quot;&apos; | ForEach-Object -Process { Set-ADObject -ProtectedFromAccidentalDeletion $false -Identity $_ } 注意：这段代码需要免费的 RSAT 工具所带的 ActiveDirectory 模块。","text":"缺省情况下，AD 对象是受保护防止意外删除的。要移除一个指定的范围内所有对象（例如某个机构之下）的这种保护，请试试这段代码： #requires -Version 1 -Modules ActiveDirectory Get-ADObject -Filter * -SearchBase &apos;OU=TestOU,DC=Vision,DC=local&quot;&apos; | ForEach-Object -Process { Set-ADObject -ProtectedFromAccidentalDeletion $false -Identity $_ } 注意：这段代码需要免费的 RSAT 工具所带的 ActiveDirectory 模块。 本文国际来源：Bulk-Remove Protection for Accidental Deletion in AD","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - AD 操作自动化入门","slug":"first-steps-automating-ad","date":"2015-07-06T20:00:00.000Z","updated":"2017-03-17T15:26:25.859Z","comments":true,"path":"2015/07/07/first-steps-automating-ad/","link":"","permalink":"http://blog.vichamp.com/2015/07/07/first-steps-automating-ad/","excerpt":"当 Microsoft 下载的免费的 RSAT 工具包含了 ActiveDirectory 模块。它带有一系列管理 Active Directory 账户的命令。 假设您已经连入了一个 Active Directory 环境，您可以使用以下示例代码来熟悉这些新命令： # find your own user account by SAMAccountName Get-ADUser -Identity $env:USERNAME # find user account by DN Get-ADUser -Identity &apos;CN=TWeltner,OU=Users,OU=Hannover,OU=Trainees,DC=powershell,DC=local&apos; # find your own user account and return all available attributes Get-ADUser -Identity $env:USERNAME -Properties * # find your own user account and change attributes Get-ADUser -Identity $env:USERNAME | Set-ADUser -Description &apos;My account&apos; # find all user accounts where the SAMAccount name starts with &quot;T&quot; Get-ADUser -Filter &apos;SAMAccountName -like &quot;T*&quot;&apos; # find user account &quot;ThomasP&quot; and use different logon details for AD # logon details for your AD $cred = Get-Credential $IPDC = &apos;10.10.11.2&apos; Get-ADUser -Identity ThomasP -Credential $cred -Server $IPDC # find all groups and output results to gridview Get-ADGroup -Filter * | Out-GridView # find all groups below a given search root Get-ADGroup -Filter * -SearchBase &apos;OU=test,DC=powershell,DC=local&apos; # get all members of a group Get-ADGroupMember -Identity &apos;Domain Admins&apos; # create new user account named &quot;Tom&quot; # define password $secret = &apos;Initial$$00&apos; | ConvertTo-SecureString -AsPlainText -Force $secret = Read-Host -Prompt &apos;Password&apos; -AsSecureString New-ADUser -Name Tom -SamAccountName Tom -ChangePasswordAtLogon $true -AccountPassword $secret -Enabled $true # delete user account &quot;Tom&quot; Remove-ADUser -Identity Tom -Confirm:$false # create an organizational unit named &quot;NewOU1&quot; in powershell.local New-ADOrganizationalUnit -Name &apos;NewOU1&apos; -Path &apos;DC=powershell,DC=local&apos; # all user accounts not used within last 180 days $FileTime = (Get-Date).AddDays(-180).ToFileTime() $ageLimit = &quot;(lastLogontimestamp&lt;=$FileTime)&quot; Get-ADUser -LDAPFilter $ageLimit","text":"当 Microsoft 下载的免费的 RSAT 工具包含了 ActiveDirectory 模块。它带有一系列管理 Active Directory 账户的命令。 假设您已经连入了一个 Active Directory 环境，您可以使用以下示例代码来熟悉这些新命令： # find your own user account by SAMAccountName Get-ADUser -Identity $env:USERNAME # find user account by DN Get-ADUser -Identity &apos;CN=TWeltner,OU=Users,OU=Hannover,OU=Trainees,DC=powershell,DC=local&apos; # find your own user account and return all available attributes Get-ADUser -Identity $env:USERNAME -Properties * # find your own user account and change attributes Get-ADUser -Identity $env:USERNAME | Set-ADUser -Description &apos;My account&apos; # find all user accounts where the SAMAccount name starts with &quot;T&quot; Get-ADUser -Filter &apos;SAMAccountName -like &quot;T*&quot;&apos; # find user account &quot;ThomasP&quot; and use different logon details for AD # logon details for your AD $cred = Get-Credential $IPDC = &apos;10.10.11.2&apos; Get-ADUser -Identity ThomasP -Credential $cred -Server $IPDC # find all groups and output results to gridview Get-ADGroup -Filter * | Out-GridView # find all groups below a given search root Get-ADGroup -Filter * -SearchBase &apos;OU=test,DC=powershell,DC=local&apos; # get all members of a group Get-ADGroupMember -Identity &apos;Domain Admins&apos; # create new user account named &quot;Tom&quot; # define password $secret = &apos;Initial$$00&apos; | ConvertTo-SecureString -AsPlainText -Force $secret = Read-Host -Prompt &apos;Password&apos; -AsSecureString New-ADUser -Name Tom -SamAccountName Tom -ChangePasswordAtLogon $true -AccountPassword $secret -Enabled $true # delete user account &quot;Tom&quot; Remove-ADUser -Identity Tom -Confirm:$false # create an organizational unit named &quot;NewOU1&quot; in powershell.local New-ADOrganizationalUnit -Name &apos;NewOU1&apos; -Path &apos;DC=powershell,DC=local&apos; # all user accounts not used within last 180 days $FileTime = (Get-Date).AddDays(-180).ToFileTime() $ageLimit = &quot;(lastLogontimestamp&lt;=$FileTime)&quot; Get-ADUser -LDAPFilter $ageLimit 本文国际来源：First Steps Automating AD","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 设置本地 Administrator 账号的密码","slug":"changing-local-administrator-account-password","date":"2015-07-06T03:00:00.000Z","updated":"2017-03-17T15:26:25.859Z","comments":true,"path":"2015/07/06/changing-local-administrator-account-password/","link":"","permalink":"http://blog.vichamp.com/2015/07/06/changing-local-administrator-account-password/","excerpt":"要操作本地用户账号并设置一个新密码，您可以使用底层的 WinNT: 命名空间。 请注意，您需要管理员权限来设置新密码。 这个脚本可以为本地 Administrator 账号设置密码： #requires -Version 1 $Password = &apos;P@ssw0rd&apos; $admin = [adsi](&quot;WinNT://$env:computername/administrator, user&quot;) $admin.psbase.invoke(&apos;SetPassword&apos;, $Password)","text":"要操作本地用户账号并设置一个新密码，您可以使用底层的 WinNT: 命名空间。 请注意，您需要管理员权限来设置新密码。 这个脚本可以为本地 Administrator 账号设置密码： #requires -Version 1 $Password = &apos;P@ssw0rd&apos; $admin = [adsi](&quot;WinNT://$env:computername/administrator, user&quot;) $admin.psbase.invoke(&apos;SetPassword&apos;, $Password) 本文国际来源：Changing Local Administrator Account Password","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"常见的乱码","slug":"Common-Messy-Code","date":"2015-07-04T12:55:31.000Z","updated":"2017-03-17T15:26:25.859Z","comments":true,"path":"2015/07/04/Common-Messy-Code/","link":"","permalink":"http://blog.vichamp.com/2015/07/04/Common-Messy-Code/","excerpt":"","text":"这是一个程序员段子，实际上是几种常见的乱码： 手持两把锟斤拷， 口中疾呼烫烫烫。 脚踏千朵屯屯屯， 笑看万物锘锘锘。 锟斤拷的来历Unicode和老编码体系的转化过程中，肯定有一些字，用Unicode是没法表示的，Unicode官方用了一个占位符来表示这些文字，这就是：U+FFFD REPLACEMENT CHARACTER。 那么U+FFFD的UTF-8编码出来，恰好是 ‘\\xef\\xbf\\xbd’。如果这个’\\xef\\xbf\\xbd’，重复多次，例如 ‘\\xef\\xbf\\xbd\\xef\\xbf\\xbd’，然后放到GBK/CP936/GB2312/GB18030的环境中显示的话，一个汉字2个字节，最终的结果就是：锟斤拷——锟(0xEFBF)，斤（0xBDEF），拷（0xBFBD） 烫烫烫的来历在windows平台下，ms的编译器（也就是vc带的那个）在 Debug 模式下，会把未初始化的栈内存全部填成 0xcc，用字符串来看就是”烫烫烫烫烫烫烫”，也就是说出现了烫烫烫，赶紧检查初始化吧。。。 屯屯屯的来历同上，未初始化的堆内存全部填成0xcd，字符串看就是“屯屯屯屯屯屯屯屯”。 锘的来历微软在 UTF-8 文件头部加上了 EF BB BF BOM 标记。在不支持 BOM 的环境下对其进行 UTF-8 解码得到“锘”字。","categories":[{"name":"program","slug":"program","permalink":"http://blog.vichamp.com/categories/program/"}],"tags":[{"name":"encoding","slug":"encoding","permalink":"http://blog.vichamp.com/tags/encoding/"}],"keywords":[{"name":"program","slug":"program","permalink":"http://blog.vichamp.com/categories/program/"}]},{"title":"PowerShell 技能连载 - 加密文本","slug":"encrypting-text","date":"2015-07-02T20:00:00.000Z","updated":"2017-03-17T15:26:25.843Z","comments":true,"path":"2015/07/03/encrypting-text/","link":"","permalink":"http://blog.vichamp.com/2015/07/03/encrypting-text/","excerpt":"有很多办法可以加密文本。以下是一个未使用“密钥”的方法，所谓的密钥实际上是您的用户标识符加上机器名。 当您使用 ConvertTo-TextEncrypted 命令加密文本时，结果只能由同一个人在同一台机器上使用 ConvertFrom-TextEncrypted 命令来解密： #requires -Version 2 function ConvertTo-TextEncrypted { param([Parameter(ValueFromPipeline = $true)]$Text) process { $Text | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString } } function ConvertFrom-TextEncrypted { param([Parameter(ValueFromPipeline = $true)]$Text) process { $SecureString = $Text | ConvertTo-SecureString $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString) [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) } } 要测试效果，请先使用这行代码： PS&gt; &quot;Hello World&quot; | ConvertTo-TextEncrypted | ConvertFrom-TextEncrypted Hello World 下一步，得到相同的密文，然后将它保存到一个文件中： $Path = &quot;$env:temp\\secret.txt&quot; &apos;Hello World&apos; | ConvertTo-TextEncrypted | Set-Content -Path $Path 现在，使用这行代码来读取加密的文件，然后对它进行解密： $Path = &quot;$env:temp\\secret.txt&quot; Get-Content -Path $Path | ConvertFrom-TextEncrypted 请注意两个脚本都不包含密码。而实际的密码正是你的用户标识符。当另一个人，或是您在另一台机器上试图解开文件中的密文，将会失败。 这个方法可以用来安全地保存个人密码，这样您就不用每天都输入了。","text":"有很多办法可以加密文本。以下是一个未使用“密钥”的方法，所谓的密钥实际上是您的用户标识符加上机器名。 当您使用 ConvertTo-TextEncrypted 命令加密文本时，结果只能由同一个人在同一台机器上使用 ConvertFrom-TextEncrypted 命令来解密： #requires -Version 2 function ConvertTo-TextEncrypted { param([Parameter(ValueFromPipeline = $true)]$Text) process { $Text | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString } } function ConvertFrom-TextEncrypted { param([Parameter(ValueFromPipeline = $true)]$Text) process { $SecureString = $Text | ConvertTo-SecureString $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString) [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) } } 要测试效果，请先使用这行代码： PS&gt; &quot;Hello World&quot; | ConvertTo-TextEncrypted | ConvertFrom-TextEncrypted Hello World 下一步，得到相同的密文，然后将它保存到一个文件中： $Path = &quot;$env:temp\\secret.txt&quot; &apos;Hello World&apos; | ConvertTo-TextEncrypted | Set-Content -Path $Path 现在，使用这行代码来读取加密的文件，然后对它进行解密： $Path = &quot;$env:temp\\secret.txt&quot; Get-Content -Path $Path | ConvertFrom-TextEncrypted 请注意两个脚本都不包含密码。而实际的密码正是你的用户标识符。当另一个人，或是您在另一台机器上试图解开文件中的密文，将会失败。 这个方法可以用来安全地保存个人密码，这样您就不用每天都输入了。 本文国际来源：Encrypting Text","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将过期的日志存档","slug":"moving-outdated-log-files-to-archive","date":"2015-07-02T03:00:00.000Z","updated":"2017-03-17T15:26:25.843Z","comments":true,"path":"2015/07/02/moving-outdated-log-files-to-archive/","link":"","permalink":"http://blog.vichamp.com/2015/07/02/moving-outdated-log-files-to-archive/","excerpt":"有时，你会需要在文件超过一定的日期之后将它们移动到一个存档文件夹。 这个例子演示了如何检测过期文件的基本策略，以及如何将它们移动到存档文件夹： #requires -Version 1 # how old (in days) would obsolete files be $Days = 14 # where to look for obsolete files $Path = $env:windir $Filter = &apos;*.log&apos; # where to move obsolete files $DestinationPath = &apos;c:\\archive&apos; # make sure destination folder exists $destinationExists = Test-Path -Path $DestinationPath if (!$destinationExists) { $null = New-Item -Path $DestinationPath -ItemType Directory } $cutoffDate = (Get-Date).AddDays(-$Days) Get-ChildItem -Path $Path -Filter $Filter -Recurse -ErrorAction SilentlyContinue | Where-Object -FilterScript { $_.LastWriteTime -lt $cutoffDate } | Move-Item -Destination c:\\archive -WhatIf 这个示例脚本在 Windows 文件夹和它的子文件夹中查找所有扩展名为 *.log 的日志文件。所有超过 14 天（在过去 14 天内没有修改过）的日志文件将被移动到 c:\\archive 目录中。如果该文件夹不存在，则会自动创建。 请注意这只是一个示例脚本。您可能需要管理员权限才能确实将文件移出 Windows 文件夹。","text":"有时，你会需要在文件超过一定的日期之后将它们移动到一个存档文件夹。 这个例子演示了如何检测过期文件的基本策略，以及如何将它们移动到存档文件夹： #requires -Version 1 # how old (in days) would obsolete files be $Days = 14 # where to look for obsolete files $Path = $env:windir $Filter = &apos;*.log&apos; # where to move obsolete files $DestinationPath = &apos;c:\\archive&apos; # make sure destination folder exists $destinationExists = Test-Path -Path $DestinationPath if (!$destinationExists) { $null = New-Item -Path $DestinationPath -ItemType Directory } $cutoffDate = (Get-Date).AddDays(-$Days) Get-ChildItem -Path $Path -Filter $Filter -Recurse -ErrorAction SilentlyContinue | Where-Object -FilterScript { $_.LastWriteTime -lt $cutoffDate } | Move-Item -Destination c:\\archive -WhatIf 这个示例脚本在 Windows 文件夹和它的子文件夹中查找所有扩展名为 *.log 的日志文件。所有超过 14 天（在过去 14 天内没有修改过）的日志文件将被移动到 c:\\archive 目录中。如果该文件夹不存在，则会自动创建。 请注意这只是一个示例脚本。您可能需要管理员权限才能确实将文件移出 Windows 文件夹。 本文国际来源：Moving Outdated Log Files to Archive","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建友好的“结束进程”应用程序","slug":"create-benign-task-kill-application","date":"2015-07-01T03:00:00.000Z","updated":"2017-03-17T15:26:25.827Z","comments":true,"path":"2015/07/01/create-benign-task-kill-application/","link":"","permalink":"http://blog.vichamp.com/2015/07/01/create-benign-task-kill-application/","excerpt":"在前一个技能中，我们展示了如何选择应用程序并且立即结束它们。所有未保存的数据将会丢失。 这是一个更复杂的实现。它可以列出所有的应用程序，您可以选择希望结束的应用程序（按住 CTRL 键选择多个应用程序）。 该脚本接下来尝试向选中的应用程序发送“关闭窗口”消息。用户将有机会保存未保存的数据。用户也可以取消“关闭窗口”消息。 This is why the script waits for 15 seconds, and then checks whether the requested applications actually ended. If not, these applications are killed immediately (remove –WhatIf to actually kill them):这是为什么该脚本等待 15 秒，然后确认请求的应用程序是否确实已结束的原因。如果指定的尚未结束，则此时立即结束（移除 -WhatIf 可以真正结束它们）： #requires -Version 3 $list = Get-Process | Where-Object -FilterScript { $_.MainWindowHandle -ne 0 } | Select-Object -Property Name, Description, MainWindowTitle, Company, ID | Out-GridView -Title &apos;Choose Application to Kill&apos; -PassThru # try and close peacefully $list.ID | ForEach-Object -Process { $process = Get-Process -Id $_ $null = $process.CloseMainWindow() } # give user 15 seconds to respond Start-Sleep -Seconds 15 # check to see if selected programs closed, and if not, kill # them anyway (remove -WhatIf to actually kill them) $list.ID | ForEach-Object -Process { Get-Process -Id $_ -ErrorAction SilentlyContinue } | Where-Object -FilterScript { $_.hasExited -eq $false } | Stop-Process -WhatIf","text":"在前一个技能中，我们展示了如何选择应用程序并且立即结束它们。所有未保存的数据将会丢失。 这是一个更复杂的实现。它可以列出所有的应用程序，您可以选择希望结束的应用程序（按住 CTRL 键选择多个应用程序）。 该脚本接下来尝试向选中的应用程序发送“关闭窗口”消息。用户将有机会保存未保存的数据。用户也可以取消“关闭窗口”消息。 This is why the script waits for 15 seconds, and then checks whether the requested applications actually ended. If not, these applications are killed immediately (remove –WhatIf to actually kill them):这是为什么该脚本等待 15 秒，然后确认请求的应用程序是否确实已结束的原因。如果指定的尚未结束，则此时立即结束（移除 -WhatIf 可以真正结束它们）： #requires -Version 3 $list = Get-Process | Where-Object -FilterScript { $_.MainWindowHandle -ne 0 } | Select-Object -Property Name, Description, MainWindowTitle, Company, ID | Out-GridView -Title &apos;Choose Application to Kill&apos; -PassThru # try and close peacefully $list.ID | ForEach-Object -Process { $process = Get-Process -Id $_ $null = $process.CloseMainWindow() } # give user 15 seconds to respond Start-Sleep -Seconds 15 # check to see if selected programs closed, and if not, kill # them anyway (remove -WhatIf to actually kill them) $list.ID | ForEach-Object -Process { Get-Process -Id $_ -ErrorAction SilentlyContinue } | Where-Object -FilterScript { $_.hasExited -eq $false } | Stop-Process -WhatIf 本文国际来源：Create Benign “Task Kill” Application","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建“结束进程”应用","slug":"create-task-kill-application","date":"2015-06-30T03:00:00.000Z","updated":"2017-03-17T15:26:25.827Z","comments":true,"path":"2015/06/30/create-task-kill-application/","link":"","permalink":"http://blog.vichamp.com/2015/06/30/create-task-kill-application/","excerpt":"只需要通过一个管道命令，PowerShell 就能够打开一个包含正在运行的程序列表。您可以选择列表中的一个或多个进程（按住 CTRL 键选择多余一个条目），然后 PowerShell 可以结束选中的程序。 Get-Process | Where-Object { $_.MainWindowHandle -ne 0 } | Select-Object -Property Name, Description, MainWindowTitle, Company, ID | Out-GridView -Title &apos;Choose Application to Kill&apos; -PassThru | Stop-Process -WhatIf 请注意代码中使用了 -WhatIf 来模拟结束进程。如果您希望真的结束进程，那么移除 -WhatIf 代码。 结束程序会导致选中的应用程序立即停止。所有未保存的数据都会丢失。","text":"只需要通过一个管道命令，PowerShell 就能够打开一个包含正在运行的程序列表。您可以选择列表中的一个或多个进程（按住 CTRL 键选择多余一个条目），然后 PowerShell 可以结束选中的程序。 Get-Process | Where-Object { $_.MainWindowHandle -ne 0 } | Select-Object -Property Name, Description, MainWindowTitle, Company, ID | Out-GridView -Title &apos;Choose Application to Kill&apos; -PassThru | Stop-Process -WhatIf 请注意代码中使用了 -WhatIf 来模拟结束进程。如果您希望真的结束进程，那么移除 -WhatIf 代码。 结束程序会导致选中的应用程序立即停止。所有未保存的数据都会丢失。 本文国际来源：Create “Task Kill” Application","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 打开网页","slug":"open-web-page","date":"2015-06-29T03:00:00.000Z","updated":"2017-03-17T15:26:25.812Z","comments":true,"path":"2015/06/29/open-web-page/","link":"","permalink":"http://blog.vichamp.com/2015/06/29/open-web-page/","excerpt":"要快速地在 Internet Explorer 中打开新的网页，您可以像这样定义一个名为 Show-WebPage 的新函数： #requires -Version 2 function Show-WebPage { param ( [Parameter(Mandatory = $true, HelpMessage = &apos;URL to open&apos;)] $URL ) Start-Process -FilePath iexplore.exe -ArgumentList $URL } 当您运行这段脚本并执行 Show-WebPage 时，该命令将询问您要打开的 URL。您也可以通过 Show-WebPage 的参数提交 URL。 请注意该函数使用了 Start-Process 命令来启动您指定的浏览器。如果您将这行代码改为： Start-Process -FilePath $URL 那么将会使用您的缺省浏览器来打开该 URL。","text":"要快速地在 Internet Explorer 中打开新的网页，您可以像这样定义一个名为 Show-WebPage 的新函数： #requires -Version 2 function Show-WebPage { param ( [Parameter(Mandatory = $true, HelpMessage = &apos;URL to open&apos;)] $URL ) Start-Process -FilePath iexplore.exe -ArgumentList $URL } 当您运行这段脚本并执行 Show-WebPage 时，该命令将询问您要打开的 URL。您也可以通过 Show-WebPage 的参数提交 URL。 请注意该函数使用了 Start-Process 命令来启动您指定的浏览器。如果您将这行代码改为： Start-Process -FilePath $URL 那么将会使用您的缺省浏览器来打开该 URL。 本文国际来源：Open Web Page","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取 Active Directory 用户名","slug":"getting-active-directory-user-name","date":"2015-06-26T03:00:00.000Z","updated":"2017-03-17T15:26:25.812Z","comments":true,"path":"2015/06/26/getting-active-directory-user-name/","link":"","permalink":"http://blog.vichamp.com/2015/06/26/getting-active-directory-user-name/","excerpt":"以下是一个在 Active Directory 中快速当前用户并且获取账户信息，例如显示名称的方法： ([adsisearcher]&quot;(samaccountname=$env:USERNAME)&quot;).FindOne().Properties[&apos;displayname&apos;]","text":"以下是一个在 Active Directory 中快速当前用户并且获取账户信息，例如显示名称的方法： ([adsisearcher]&quot;(samaccountname=$env:USERNAME)&quot;).FindOne().Properties[&apos;displayname&apos;] 本文国际来源：Getting Active Directory User Name","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将“列出所有变量”功能加入 PowerShell","slug":"adding-quot-list-all-variables-quot-to-powershell-ise","date":"2015-06-25T03:00:00.000Z","updated":"2017-03-17T15:26:25.796Z","comments":true,"path":"2015/06/25/adding-quot-list-all-variables-quot-to-powershell-ise/","link":"","permalink":"http://blog.vichamp.com/2015/06/25/adding-quot-list-all-variables-quot-to-powershell-ise/","excerpt":"在前一个技能中我们展示了一个可以显示 PowerShell ISE 中所有打开的脚本的所有变量名的脚本。 以下是一个改造，能够在 PowerShell ISE 的“附加工具”菜单中新增一个“List Variables”命令： $code = { $psise.CurrentPowerShellTab.Files | ForEach-Object { $errors = $null [System.Management.Automation.PSParser]::Tokenize($_.Editor.Text, [ref]$errors) | Where-Object { $_.Type -eq &apos;Variable&apos;} | Select-Object -Property Content | Add-Member -MemberType NoteProperty -Name Script -Value $_.DisplayName -PassThru } | Sort-Object -Property Content, Script -Unique | Out-GridView -Title &apos;Variables in use&apos; -PassThru } $psise.CurrentPowerShellTab.AddOnsMenu.Submenus.Add(&apos;List Variables&apos;, $code, &apos;ALT+V&apos;) 当您运行这段代码后，您可以按下 ALT+V 打开一个网格窗口显示所有打开的脚本中用到的变量。","text":"在前一个技能中我们展示了一个可以显示 PowerShell ISE 中所有打开的脚本的所有变量名的脚本。 以下是一个改造，能够在 PowerShell ISE 的“附加工具”菜单中新增一个“List Variables”命令： $code = { $psise.CurrentPowerShellTab.Files | ForEach-Object { $errors = $null [System.Management.Automation.PSParser]::Tokenize($_.Editor.Text, [ref]$errors) | Where-Object { $_.Type -eq &apos;Variable&apos;} | Select-Object -Property Content | Add-Member -MemberType NoteProperty -Name Script -Value $_.DisplayName -PassThru } | Sort-Object -Property Content, Script -Unique | Out-GridView -Title &apos;Variables in use&apos; -PassThru } $psise.CurrentPowerShellTab.AddOnsMenu.Submenus.Add(&apos;List Variables&apos;, $code, &apos;ALT+V&apos;) 当您运行这段代码后，您可以按下 ALT+V 打开一个网格窗口显示所有打开的脚本中用到的变量。 本文国际来源：Adding “List All Variables” to PowerShell ISE","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 列出所有脚本中的所有变量","slug":"listing-all-variables-in-all-scripts","date":"2015-06-24T03:00:00.000Z","updated":"2017-03-17T15:26:25.796Z","comments":true,"path":"2015/06/24/listing-all-variables-in-all-scripts/","link":"","permalink":"http://blog.vichamp.com/2015/06/24/listing-all-variables-in-all-scripts/","excerpt":"是否希望列出 PowerShell ISE 中打开的所有文件中的变量清单？ 以下是一段能够创建这样清单的代码： $psise.CurrentPowerShellTab.Files | ForEach-Object { $errors = $null [System.Management.Automation.PSParser]::Tokenize($_.Editor.Text, [ref]$errors) | Where-Object { $_.Type -eq &apos;Variable&apos;} | Select-Object -Property Content | Add-Member -MemberType NoteProperty -Name Script -Value $_.DisplayName -PassThru } | Sort-Object -Property Content, Script -Unique","text":"是否希望列出 PowerShell ISE 中打开的所有文件中的变量清单？ 以下是一段能够创建这样清单的代码： $psise.CurrentPowerShellTab.Files | ForEach-Object { $errors = $null [System.Management.Automation.PSParser]::Tokenize($_.Editor.Text, [ref]$errors) | Where-Object { $_.Type -eq &apos;Variable&apos;} | Select-Object -Property Content | Add-Member -MemberType NoteProperty -Name Script -Value $_.DisplayName -PassThru } | Sort-Object -Property Content, Script -Unique 本文国际来源：Listing All Variables in All Scripts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 快捷循环","slug":"quick-loop","date":"2015-06-23T03:00:00.000Z","updated":"2017-03-17T15:26:25.781Z","comments":true,"path":"2015/06/23/quick-loop/","link":"","permalink":"http://blog.vichamp.com/2015/06/23/quick-loop/","excerpt":"适用于 PowerShell 4.0 及以上版本 PowerShell 中有一系列循环的语法。以下是一些 PowerShell 4.0 中循环执行代码的不太常见的方法。这个例子将播放一段频率不断提高的声音（请确保打开了扬声器）： (1..100).Foreach{[Console]::Beep($_ * 100, 300)} 在 PowerShell 4.0 及以上版本，数组拥有了 Where() 和 ForEach() 方法。您可以像这样写一个过滤器： @(Get-Service).Where({$_.Status -eq &apos;Running&apos;}) PowerShell 的语法糖能让您省略这些语句中的大括号： @(Get-Service).Where{$_.Status -eq &apos;Running&apos;} 请注意该方法是针对数组的。相对于传统的管道方法，这种方法速度更快，但是内存消耗更大。","text":"适用于 PowerShell 4.0 及以上版本 PowerShell 中有一系列循环的语法。以下是一些 PowerShell 4.0 中循环执行代码的不太常见的方法。这个例子将播放一段频率不断提高的声音（请确保打开了扬声器）： (1..100).Foreach{[Console]::Beep($_ * 100, 300)} 在 PowerShell 4.0 及以上版本，数组拥有了 Where() 和 ForEach() 方法。您可以像这样写一个过滤器： @(Get-Service).Where({$_.Status -eq &apos;Running&apos;}) PowerShell 的语法糖能让您省略这些语句中的大括号： @(Get-Service).Where{$_.Status -eq &apos;Running&apos;} 请注意该方法是针对数组的。相对于传统的管道方法，这种方法速度更快，但是内存消耗更大。 本文国际来源：Quick Loop","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 分析（所有）事件日志源","slug":"analyzing-all-event-log-entries","date":"2015-06-22T03:00:00.000Z","updated":"2017-03-17T15:26:25.781Z","comments":true,"path":"2015/06/22/analyzing-all-event-log-entries/","link":"","permalink":"http://blog.vichamp.com/2015/06/22/analyzing-all-event-log-entries/","excerpt":"您也许知道 Get-EventLog 命令。该命令能从一个指定的系统日志中读取所有条目： Get-EventLog -LogName System 然而，Get-EventLog 一次只能查询一个事件日志源。所以如果您希望在所有事件日志源中查找所有错误信息，您需要创建一个循环，并且需要知道事件日志名字。 以下是一个单行的查询所有事件日志的简单技巧： Get-EventLog -List | Select-Object -ExpandProperty Entries -ErrorAction SilentlyContinue | Where-Object { $_.EntryType -eq &apos;Error&apos; }","text":"您也许知道 Get-EventLog 命令。该命令能从一个指定的系统日志中读取所有条目： Get-EventLog -LogName System 然而，Get-EventLog 一次只能查询一个事件日志源。所以如果您希望在所有事件日志源中查找所有错误信息，您需要创建一个循环，并且需要知道事件日志名字。 以下是一个单行的查询所有事件日志的简单技巧： Get-EventLog -List | Select-Object -ExpandProperty Entries -ErrorAction SilentlyContinue | Where-Object { $_.EntryType -eq &apos;Error&apos; } 本文国际来源：Analyzing (All) Event Log Entries","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找最重要的错误系统日志","slug":"finding-the-most-important-event-log-error-sources","date":"2015-06-19T03:00:00.000Z","updated":"2017-03-17T15:26:25.781Z","comments":true,"path":"2015/06/19/finding-the-most-important-event-log-error-sources/","link":"","permalink":"http://blog.vichamp.com/2015/06/19/finding-the-most-important-event-log-error-sources/","excerpt":"如果您没有充裕的时间来调查您系统日志中出现频率最高的错误来源，请试试这行代码： Get-EventLog -LogName System -EntryType Error, Warning | Group-Object -Property Source | Sort-Object -Property Count -Descending 当您找到导致一系列错误（或警告）的源头时，这行代码可以显示错误的细节： # change this variable to the name of the source you want # to explore: $source = &apos;Schannel&apos; Get-EventLog -LogName System -Source $source | Out-GridView","text":"如果您没有充裕的时间来调查您系统日志中出现频率最高的错误来源，请试试这行代码： Get-EventLog -LogName System -EntryType Error, Warning | Group-Object -Property Source | Sort-Object -Property Count -Descending 当您找到导致一系列错误（或警告）的源头时，这行代码可以显示错误的细节： # change this variable to the name of the source you want # to explore: $source = &apos;Schannel&apos; Get-EventLog -LogName System -Source $source | Out-GridView 本文国际来源：Finding the Most Important Event Log Error Sources","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 刷新新挂载的磁盘","slug":"refresh-newly-mounted-disks","date":"2015-06-18T03:00:00.000Z","updated":"2017-03-17T15:26:25.778Z","comments":true,"path":"2015/06/18/refresh-newly-mounted-disks/","link":"","permalink":"http://blog.vichamp.com/2015/06/18/refresh-newly-mounted-disks/","excerpt":"如果您的脚本刚刚挂载了一个新的驱动器，PowerShell 可能无法立即存取它（例如通过 Get-ChildItem），因为 Powerell 尚未更新它的驱动器列表。 要更新 PowerShell 驱动器列表，请用这行代码： $null = Get-PSDrive","text":"如果您的脚本刚刚挂载了一个新的驱动器，PowerShell 可能无法立即存取它（例如通过 Get-ChildItem），因为 Powerell 尚未更新它的驱动器列表。 要更新 PowerShell 驱动器列表，请用这行代码： $null = Get-PSDrive 本文国际来源：Refresh Newly Mounted Disks","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从 PSSnapin 中加载 cmdlet","slug":"load-cmdlets-from-pssnapins","date":"2015-06-17T03:00:00.000Z","updated":"2017-03-17T15:26:25.758Z","comments":true,"path":"2015/06/17/load-cmdlets-from-pssnapins/","link":"","permalink":"http://blog.vichamp.com/2015/06/17/load-cmdlets-from-pssnapins/","excerpt":"近期多数 cmdlet 都是包装在模块中。模块是从 PowerShell 2.0 开始引入的概念。它们的主要好处是可以复制粘贴部署（不需要安装）以及模块自动加载（当您需要时，PowerShell 将自动加载模块）。 有一些 cmdlet 还是用 PowerShell snap-in (PSSnapin) 的方式包装，而不是采用模块的方式包装。PSSnapin 是从 PowerShell 1.0 就开始引入的。PSSnapin 需要安装才能使用。而且由于它们是注册在 HKEY_LOCAL_MACHINE 中，所以它们安装时往往需要管理员权限。 要列出所有可用的 PSSnapin，请运行这行代码： Get-PSSnapin -Registered 与模块相对，PSSnapin 需要先手动加载，才能使用其中的 cmdlet。这行代码将会加载所有可用的 PSSnapin： Get-PSSnapin -Registered | Add-PSSnapin -Verbose","text":"近期多数 cmdlet 都是包装在模块中。模块是从 PowerShell 2.0 开始引入的概念。它们的主要好处是可以复制粘贴部署（不需要安装）以及模块自动加载（当您需要时，PowerShell 将自动加载模块）。 有一些 cmdlet 还是用 PowerShell snap-in (PSSnapin) 的方式包装，而不是采用模块的方式包装。PSSnapin 是从 PowerShell 1.0 就开始引入的。PSSnapin 需要安装才能使用。而且由于它们是注册在 HKEY_LOCAL_MACHINE 中，所以它们安装时往往需要管理员权限。 要列出所有可用的 PSSnapin，请运行这行代码： Get-PSSnapin -Registered 与模块相对，PSSnapin 需要先手动加载，才能使用其中的 cmdlet。这行代码将会加载所有可用的 PSSnapin： Get-PSSnapin -Registered | Add-PSSnapin -Verbose 本文国际来源：Load Cmdlets from PSSnapins","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 加载 PowerShell 模块","slug":"loading-powershell-modules","date":"2015-06-16T03:00:00.000Z","updated":"2017-03-17T15:26:25.758Z","comments":true,"path":"2015/06/16/loading-powershell-modules/","link":"","permalink":"http://blog.vichamp.com/2015/06/16/loading-powershell-modules/","excerpt":"所有的 cmdlet 都位于模块或是 snap-in 中。要查看当前加载了哪些模块，请使用 Get-Module 命令。 在 PowerShell 3.0 或更高版本中，当您运行多数模块中的 cmdlet 时，它们都将被隐式地导入。这种聪明的机制实现了“按需加载”的效果，所以在多数情况下不需要手动加载模块，或是显式地手动加载所有模块。 要关闭自动加载，请使用这行代码： $PSModuleAutoLoadingPreference = &apos;none&apos; 请注意当您这么做的时候，您有责任加载所有需要的模块。 如果您希望加载所有可用的模块，请使用 Import-Module 命令。 这将读取您整个系统中所有可用的模块： Get-Module -ListAvailable | Import-Module -Verbose","text":"所有的 cmdlet 都位于模块或是 snap-in 中。要查看当前加载了哪些模块，请使用 Get-Module 命令。 在 PowerShell 3.0 或更高版本中，当您运行多数模块中的 cmdlet 时，它们都将被隐式地导入。这种聪明的机制实现了“按需加载”的效果，所以在多数情况下不需要手动加载模块，或是显式地手动加载所有模块。 要关闭自动加载，请使用这行代码： $PSModuleAutoLoadingPreference = &apos;none&apos; 请注意当您这么做的时候，您有责任加载所有需要的模块。 如果您希望加载所有可用的模块，请使用 Import-Module 命令。 这将读取您整个系统中所有可用的模块： Get-Module -ListAvailable | Import-Module -Verbose 本文国际来源：Loading PowerShell Modules","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 如何查找包含指定参数的命令","slug":"how-to-find-commands-that-have-the-specified-parameter","date":"2015-06-15T03:00:00.000Z","updated":"2017-03-17T15:26:25.743Z","comments":true,"path":"2015/06/15/how-to-find-commands-that-have-the-specified-parameter/","link":"","permalink":"http://blog.vichamp.com/2015/06/15/how-to-find-commands-that-have-the-specified-parameter/","excerpt":"Get-Command 是当您需要查找某个命令来完成一件事情时的主要工具。 您可以这样搜索动词和/或名词： # find all cmdlets/functions that stop things Get-Command -Verb Stop # find all cmdlets/functions that affect services Get-Command -Noun Service 从 PowerShell 3.0 开始，Get-Command 还可以根据一个给定的参数查找 cmdlet 或函数： # new in PS3 and better # find all cmdlets/functions with a -ComputerName parameter Get-Command -ParameterName ComputerName 请注意 Get-Command 是在已加载的 cmdlet/函数中搜索。请确保在搜索前已导入了所需的模块。","text":"Get-Command 是当您需要查找某个命令来完成一件事情时的主要工具。 您可以这样搜索动词和/或名词： # find all cmdlets/functions that stop things Get-Command -Verb Stop # find all cmdlets/functions that affect services Get-Command -Noun Service 从 PowerShell 3.0 开始，Get-Command 还可以根据一个给定的参数查找 cmdlet 或函数： # new in PS3 and better # find all cmdlets/functions with a -ComputerName parameter Get-Command -ParameterName ComputerName 请注意 Get-Command 是在已加载的 cmdlet/函数中搜索。请确保在搜索前已导入了所需的模块。 本文国际来源：How to find Commands that have the Specified Parameter","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取 CPU 核心和处理器信息","slug":"get-cpu-cores-and-processor-information","date":"2015-06-12T03:00:00.000Z","updated":"2017-03-17T15:26:25.743Z","comments":true,"path":"2015/06/12/get-cpu-cores-and-processor-information/","link":"","permalink":"http://blog.vichamp.com/2015/06/12/get-cpu-cores-and-processor-information/","excerpt":"通过一行 WMI 代码，就可以查看您的 CPU 详情： PS&gt; Get-WmiObject -Class Win32_Processor | Select-Object -Property Name, Number* Name NumberOfCores NumberOfLogicalProcessors ---- ------------- ------------------------- Intel(R) Core(TM) i7-26... 2 4","text":"通过一行 WMI 代码，就可以查看您的 CPU 详情： PS&gt; Get-WmiObject -Class Win32_Processor | Select-Object -Property Name, Number* Name NumberOfCores NumberOfLogicalProcessors ---- ------------- ------------------------- Intel(R) Core(TM) i7-26... 2 4 本文国际来源：Get CPU Cores and Processor Information","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 安装 Windows 功能","slug":"installing-windows-features","date":"2015-06-11T03:00:00.000Z","updated":"2017-03-17T15:26:25.743Z","comments":true,"path":"2015/06/11/installing-windows-features/","link":"","permalink":"http://blog.vichamp.com/2015/06/11/installing-windows-features/","excerpt":"在服务器中，Powershell 可以通过 Install-WindowsFeature 命令安装 Windows 功能。 若您将 Install-WindowsFeature 返回的结果保存下来，则可以用 Get-WindowsFeature 查看安装的状态： # install features on server and save result in $result Install-WindowsFeature -Name AD-Domain-Services, DNS -IncludeManagementTools -OutVariable result -Verbose # view the result of your change Get-WindowsFeature -Name $result.FeatureResult.Name","text":"在服务器中，Powershell 可以通过 Install-WindowsFeature 命令安装 Windows 功能。 若您将 Install-WindowsFeature 返回的结果保存下来，则可以用 Get-WindowsFeature 查看安装的状态： # install features on server and save result in $result Install-WindowsFeature -Name AD-Domain-Services, DNS -IncludeManagementTools -OutVariable result -Verbose # view the result of your change Get-WindowsFeature -Name $result.FeatureResult.Name 本文国际来源：Installing Windows Features","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建动态脚本块","slug":"create-dynamic-script-blocks","date":"2015-06-10T03:00:00.000Z","updated":"2017-03-17T15:26:25.743Z","comments":true,"path":"2015/06/10/create-dynamic-script-blocks/","link":"","permalink":"http://blog.vichamp.com/2015/06/10/create-dynamic-script-blocks/","excerpt":"脚本块是一段可执行的 PowerShell 代码。您通常可以将语句包裹在大括号中创建脚本块。 若要在脚本中动态创建脚本块，以下是将一个字符串转换为脚本块的方法。 $scriptblock = [ScriptBlock]::Create(&apos;notepad&apos;) 通过这种方法，您的代码首先以字符串的形式创建代码，然后将字符串转换为脚本块，然后将脚本块传递给您需要的 cmdlet（例如 Invoke-Command）： PS&gt; Invoke-Command -ScriptBlock &apos;notepad&apos; Cannot convert the &quot;notepad&quot; value of type &quot;System.String&quot; to type &quot;System.Management.Automation.ScriptBlock&quot;. (raised by: Invoke-Command) PS&gt; Invoke-Command -ScriptBlock ([ScriptBlock]::Create(&apos;notepad&apos;))","text":"脚本块是一段可执行的 PowerShell 代码。您通常可以将语句包裹在大括号中创建脚本块。 若要在脚本中动态创建脚本块，以下是将一个字符串转换为脚本块的方法。 $scriptblock = [ScriptBlock]::Create(&apos;notepad&apos;) 通过这种方法，您的代码首先以字符串的形式创建代码，然后将字符串转换为脚本块，然后将脚本块传递给您需要的 cmdlet（例如 Invoke-Command）： PS&gt; Invoke-Command -ScriptBlock &apos;notepad&apos; Cannot convert the &quot;notepad&quot; value of type &quot;System.String&quot; to type &quot;System.Management.Automation.ScriptBlock&quot;. (raised by: Invoke-Command) PS&gt; Invoke-Command -ScriptBlock ([ScriptBlock]::Create(&apos;notepad&apos;)) 本文国际来源：Create Dynamic Script Blocks","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理 NTFS 权限继承","slug":"manage-ntfs-permission-inheritance","date":"2015-06-09T03:00:00.000Z","updated":"2017-03-17T15:26:25.727Z","comments":true,"path":"2015/06/09/manage-ntfs-permission-inheritance/","link":"","permalink":"http://blog.vichamp.com/2015/06/09/manage-ntfs-permission-inheritance/","excerpt":"缺省情况下，文件和文件夹从它们的父节点继承权限。要停用继承，并且只保留显式权限，请做以下两件事情：增加你需要显式权限，然后禁止继承。 这个示例代码创建了一个名为“PermissionNoInheritance”的文件夹，然后为当前用户赋予读权限，为管理员组赋予完整权限，并且禁止继承。 # create folder $Path = &apos;c:\\PermissionNoInheritance&apos; $null = New-Item -Path $Path -ItemType Directory -ErrorAction SilentlyContinue # get current permissions $acl = Get-Acl -Path $path # add a new permission for current user $permission = $env:username, &apos;Read,Modify&apos;, &apos;ContainerInherit, ObjectInherit&apos;, &apos;None&apos;, &apos;Allow&apos; $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # add a new permission for Administrators $permission = &apos;Administrators&apos;, &apos;FullControl&apos;, &apos;ContainerInherit, ObjectInherit&apos;, &apos;None&apos;, &apos;Allow&apos; $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # disable inheritance $acl.SetAccessRuleProtection($true, $false) # set new permissions $acl | Set-Acl -Path $path","text":"缺省情况下，文件和文件夹从它们的父节点继承权限。要停用继承，并且只保留显式权限，请做以下两件事情：增加你需要显式权限，然后禁止继承。 这个示例代码创建了一个名为“PermissionNoInheritance”的文件夹，然后为当前用户赋予读权限，为管理员组赋予完整权限，并且禁止继承。 # create folder $Path = &apos;c:\\PermissionNoInheritance&apos; $null = New-Item -Path $Path -ItemType Directory -ErrorAction SilentlyContinue # get current permissions $acl = Get-Acl -Path $path # add a new permission for current user $permission = $env:username, &apos;Read,Modify&apos;, &apos;ContainerInherit, ObjectInherit&apos;, &apos;None&apos;, &apos;Allow&apos; $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # add a new permission for Administrators $permission = &apos;Administrators&apos;, &apos;FullControl&apos;, &apos;ContainerInherit, ObjectInherit&apos;, &apos;None&apos;, &apos;Allow&apos; $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # disable inheritance $acl.SetAccessRuleProtection($true, $false) # set new permissions $acl | Set-Acl -Path $path 本文国际来源：Manage NTFS Permission Inheritance","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 移除非继承的 NTFS 权限","slug":"removing-explicit-ntfs-permissions","date":"2015-06-08T03:00:00.000Z","updated":"2017-03-17T15:26:25.727Z","comments":true,"path":"2015/06/08/removing-explicit-ntfs-permissions/","link":"","permalink":"http://blog.vichamp.com/2015/06/08/removing-explicit-ntfs-permissions/","excerpt":"在前一个例子中，我们演示了如何向已有的文件夹添加新的 NTFS 权限。如果您希望重置权限并且移除所有之前所有非继承的 NTFS 权限，以下是示例代码： # make sure this folder exists $Path = &apos;c:\\sampleFolderNTFS&apos; # get explicit permissions $acl = Get-Acl -Path $path $acl.Access | Where-Object { $_.isInherited -eq $false } | # ...and remove them ForEach-Object { $acl.RemoveAccessRuleAll($_) } # set new permissions $acl | Set-Acl -Path $path","text":"在前一个例子中，我们演示了如何向已有的文件夹添加新的 NTFS 权限。如果您希望重置权限并且移除所有之前所有非继承的 NTFS 权限，以下是示例代码： # make sure this folder exists $Path = &apos;c:\\sampleFolderNTFS&apos; # get explicit permissions $acl = Get-Acl -Path $path $acl.Access | Where-Object { $_.isInherited -eq $false } | # ...and remove them ForEach-Object { $acl.RemoveAccessRuleAll($_) } # set new permissions $acl | Set-Acl -Path $path 本文国际来源：Removing Explicit NTFS Permissions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取非继承的 NTFS 权限","slug":"getting-explicit-ntfs-permissions","date":"2015-06-05T03:00:00.000Z","updated":"2017-03-17T15:26:25.712Z","comments":true,"path":"2015/06/05/getting-explicit-ntfs-permissions/","link":"","permalink":"http://blog.vichamp.com/2015/06/05/getting-explicit-ntfs-permissions/","excerpt":"要查看某个文件或者文件夹被直接赋予了哪些 NTFS 权限，请注意“isInherited”属性。这段代码将创建一个名为“sampleFolderNTFS”的新文件夹，并且列出所有非继承的 NTFS 权限。当您创建该文件夹时，它只拥有继承的权限，所以您查看非继承权限的时候获得不到任何结果： $Path = &apos;c:\\sampleFolderNTFS&apos; # create new folder $null = New-Item -Path $Path -ItemType Directory -ErrorAction SilentlyContinue # get permissions $acl = Get-Acl -Path $path $acl.Access | Where-Object { $_.isInherited -eq $false } 当您增加了非继承权限时，这段代码将会产生结果。这是通过 PowerShell 增加非继承权限的方法。它将针对当前用户添加读、写、修改权限： $acl = Get-Acl -Path $path # add a new permission $permission = $env:username, &apos;Read,Write,Modify&apos;, &apos;ContainerInherit, ObjectInherit&apos;, &apos;None&apos;, &apos;Allow&apos; $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # set new permissions $acl | Set-Acl -Path $path","text":"要查看某个文件或者文件夹被直接赋予了哪些 NTFS 权限，请注意“isInherited”属性。这段代码将创建一个名为“sampleFolderNTFS”的新文件夹，并且列出所有非继承的 NTFS 权限。当您创建该文件夹时，它只拥有继承的权限，所以您查看非继承权限的时候获得不到任何结果： $Path = &apos;c:\\sampleFolderNTFS&apos; # create new folder $null = New-Item -Path $Path -ItemType Directory -ErrorAction SilentlyContinue # get permissions $acl = Get-Acl -Path $path $acl.Access | Where-Object { $_.isInherited -eq $false } 当您增加了非继承权限时，这段代码将会产生结果。这是通过 PowerShell 增加非继承权限的方法。它将针对当前用户添加读、写、修改权限： $acl = Get-Acl -Path $path # add a new permission $permission = $env:username, &apos;Read,Write,Modify&apos;, &apos;ContainerInherit, ObjectInherit&apos;, &apos;None&apos;, &apos;Allow&apos; $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # set new permissions $acl | Set-Acl -Path $path 本文国际来源：Getting Explicit NTFS Permissions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理 NTFS 权限","slug":"managing-ntfs-permissions","date":"2015-06-04T03:00:00.000Z","updated":"2017-03-17T15:26:25.712Z","comments":true,"path":"2015/06/04/managing-ntfs-permissions/","link":"","permalink":"http://blog.vichamp.com/2015/06/04/managing-ntfs-permissions/","excerpt":"在前一个技能中我们演示了如何向一个文件夹增加 NTFS 权限。要查看可以设置哪些权限，看以下示例： PS&gt; [System.Enum]::GetNames([System.Security.AccessControl.FileSystemRights]) ListDirectory ReadData WriteData CreateFiles CreateDirectories AppendData ReadExtendedAttributes WriteExtendedAttributes Traverse ExecuteFile DeleteSubdirectoriesAndFiles ReadAttributes WriteAttributes Write Delete ReadPermissions Read ReadAndExecute Modify ChangePermissions TakeOwnership Synchronize FullControl 假设您已创建了一个名为“protectedfolder”的文件夹： $Path = &apos;c:\\protectedFolder&apos; # create new folder $null = New-Item -Path $Path -ItemType Directory 要为“Tobias”用户（请将用户名替换为您系统中实际存在的用户名）增加文件系统权限，请运行这段代码： # get permissions $acl = Get-Acl -Path $path # add a new permission $permission = &apos;Tobias&apos;, &apos;Read,Write,Modify&apos;, &apos;ContainerInherit, ObjectInherit&apos;, &apos;None&apos;, &apos;Allow&apos; $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # set new permissions $acl | Set-Acl -Path $path","text":"在前一个技能中我们演示了如何向一个文件夹增加 NTFS 权限。要查看可以设置哪些权限，看以下示例： PS&gt; [System.Enum]::GetNames([System.Security.AccessControl.FileSystemRights]) ListDirectory ReadData WriteData CreateFiles CreateDirectories AppendData ReadExtendedAttributes WriteExtendedAttributes Traverse ExecuteFile DeleteSubdirectoriesAndFiles ReadAttributes WriteAttributes Write Delete ReadPermissions Read ReadAndExecute Modify ChangePermissions TakeOwnership Synchronize FullControl 假设您已创建了一个名为“protectedfolder”的文件夹： $Path = &apos;c:\\protectedFolder&apos; # create new folder $null = New-Item -Path $Path -ItemType Directory 要为“Tobias”用户（请将用户名替换为您系统中实际存在的用户名）增加文件系统权限，请运行这段代码： # get permissions $acl = Get-Acl -Path $path # add a new permission $permission = &apos;Tobias&apos;, &apos;Read,Write,Modify&apos;, &apos;ContainerInherit, ObjectInherit&apos;, &apos;None&apos;, &apos;Allow&apos; $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # set new permissions $acl | Set-Acl -Path $path 本文国际来源：Managing NTFS Permissions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建一个包含 NTFS 权限的文件夹","slug":"create-folder-with-ntfs-permissions","date":"2015-06-03T03:00:00.000Z","updated":"2017-03-17T15:26:25.696Z","comments":true,"path":"2015/06/03/create-folder-with-ntfs-permissions/","link":"","permalink":"http://blog.vichamp.com/2015/06/03/create-folder-with-ntfs-permissions/","excerpt":"您常常会需要创建一个文件夹并且为它设置 NTFS 权限。 这是一个简单的创建新文件夹并演示如何向已有权限中增加新的权限的示例代码： $Path = &apos;c:\\protectedFolder&apos; # create new folder $null = New-Item -Path $Path -ItemType Directory # get permissions $acl = Get-Acl -Path $path # add a new permission $permission = &apos;Everyone&apos;, &apos;FullControl&apos;, &apos;ContainerInherit, ObjectInherit&apos;, &apos;None&apos;, &apos;Allow&apos; $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # add another new permission # WARNING: Replace username &quot;Tobias&quot; with the user name or group that you want to grant permissions $permission = &apos;Tobias&apos;, &apos;FullControl&apos;, &apos;ContainerInherit, ObjectInherit&apos;, &apos;None&apos;, &apos;Allow&apos; $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # set new permissions $acl | Set-Acl -Path $path","text":"您常常会需要创建一个文件夹并且为它设置 NTFS 权限。 这是一个简单的创建新文件夹并演示如何向已有权限中增加新的权限的示例代码： $Path = &apos;c:\\protectedFolder&apos; # create new folder $null = New-Item -Path $Path -ItemType Directory # get permissions $acl = Get-Acl -Path $path # add a new permission $permission = &apos;Everyone&apos;, &apos;FullControl&apos;, &apos;ContainerInherit, ObjectInherit&apos;, &apos;None&apos;, &apos;Allow&apos; $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # add another new permission # WARNING: Replace username &quot;Tobias&quot; with the user name or group that you want to grant permissions $permission = &apos;Tobias&apos;, &apos;FullControl&apos;, &apos;ContainerInherit, ObjectInherit&apos;, &apos;None&apos;, &apos;Allow&apos; $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # set new permissions $acl | Set-Acl -Path $path 本文国际来源：Create Folder with NTFS Permissions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 分割超长代码行","slug":"splitting-long-lines","date":"2015-06-02T03:00:00.000Z","updated":"2017-03-17T15:26:25.696Z","comments":true,"path":"2015/06/02/splitting-long-lines/","link":"","permalink":"http://blog.vichamp.com/2015/06/02/splitting-long-lines/","excerpt":"为了提高可读性，您可以将超长的 PowerShell 代码行拆分成多行。 Get-Service | Where-Object { $_.Status -eq &apos;Running&apos; } Get-Service | Where-Object { $_.Status -eq &apos;Running&apos; } 在管道符之后，您可以加入一个换行。您也可以安全地在一个左大括号之后、右大括号之前加入一个换行： Get-Service | Where-Object { $_.Status -eq &apos;Running&apos; } 如果您需要在其它地方换行，那么请在换行之前加入一个反引号： Get-Service | Where-Object ` { $_.Status -eq &apos;Running&apos; }","text":"为了提高可读性，您可以将超长的 PowerShell 代码行拆分成多行。 Get-Service | Where-Object { $_.Status -eq &apos;Running&apos; } Get-Service | Where-Object { $_.Status -eq &apos;Running&apos; } 在管道符之后，您可以加入一个换行。您也可以安全地在一个左大括号之后、右大括号之前加入一个换行： Get-Service | Where-Object { $_.Status -eq &apos;Running&apos; } 如果您需要在其它地方换行，那么请在换行之前加入一个反引号： Get-Service | Where-Object ` { $_.Status -eq &apos;Running&apos; } 本文国际来源：Splitting Long Lines","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 显示函数参数","slug":"prompting-for-function-parameters","date":"2015-06-01T03:00:00.000Z","updated":"2017-03-17T15:26:25.680Z","comments":true,"path":"2015/06/01/prompting-for-function-parameters/","link":"","permalink":"http://blog.vichamp.com/2015/06/01/prompting-for-function-parameters/","excerpt":"通过一个简单的技巧，您可以创建一个对话框窗口来帮助用户提供您写的函数的所需要参数。 只需要使用 $PSBoundParameters 来判定用户是否传入了参数。如果用户未传入参数，那么请运行 Show-Command 并传入您的函数名，然后返回您的函数，其它什么也不用做。 Show-Command 自动解决剩下的部分：它会显示一个包括所有函数参数的对话框，当用户点击“运行”时，它将以提交的参数运行该函数。 function Show-PromptInfo { param ( [string] $Name, [int] $ID ) if ($PSBoundParameters.Count -eq 0) { Show-Command -Name Show-PromptInfo return } &quot;Your name is $name, and the id is $id.&quot; } 当您执行 Show-PromptInfo 函数时传入了正确的参数，则将立即执行该函数的内容。 PS&gt; Show-PromptInfo -Name weltner -ID 12 Your name is weltner, and the id is 12. PS&gt; Show-PromptInfo &lt;# Dialog opens, then runs the function with submitted parameters#&gt; 当您执行该函数时没有传入任何参数，则将弹出一个对话框，提示您交互式地输入参数。","text":"通过一个简单的技巧，您可以创建一个对话框窗口来帮助用户提供您写的函数的所需要参数。 只需要使用 $PSBoundParameters 来判定用户是否传入了参数。如果用户未传入参数，那么请运行 Show-Command 并传入您的函数名，然后返回您的函数，其它什么也不用做。 Show-Command 自动解决剩下的部分：它会显示一个包括所有函数参数的对话框，当用户点击“运行”时，它将以提交的参数运行该函数。 function Show-PromptInfo { param ( [string] $Name, [int] $ID ) if ($PSBoundParameters.Count -eq 0) { Show-Command -Name Show-PromptInfo return } &quot;Your name is $name, and the id is $id.&quot; } 当您执行 Show-PromptInfo 函数时传入了正确的参数，则将立即执行该函数的内容。 PS&gt; Show-PromptInfo -Name weltner -ID 12 Your name is weltner, and the id is 12. PS&gt; Show-PromptInfo &lt;# Dialog opens, then runs the function with submitted parameters#&gt; 当您执行该函数时没有传入任何参数，则将弹出一个对话框，提示您交互式地输入参数。 本文国际来源：Prompting for Function Parameters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 PowerShell 的帮助窗口作为通用输出","slug":"using-powershell-s-help-window-for-general-output","date":"2015-05-29T03:00:00.000Z","updated":"2017-03-17T15:26:25.680Z","comments":true,"path":"2015/05/29/using-powershell-s-help-window-for-general-output/","link":"","permalink":"http://blog.vichamp.com/2015/05/29/using-powershell-s-help-window-for-general-output/","excerpt":"要显示文本信息，您当然可以启动 noteapd.exe，并且用编辑器来显示文本。不过，在编辑器中显示文本并不是一个好主意，如果您不希望文本被改变。 PowerShell 给我们带来了一个很棒的窗体，用来显示一小段或者中等长度的文本：内置的帮助窗口。 通过一些调整，该窗口可以重新编程，显示任意的文本信息。而且，您可以使用内置的全文搜索功能在您的文本中导航，甚至可以根据你的喜好设置前景色和背景色。 只需要将任意的文本通过管道传递给 Out-Window，并且根据需要可选地指定颜色、搜索词和标题。以下是 Out-Window 函数： function Out-Window { param ( [String] $Title = &apos;PowerShell Output&apos;, [String] $FindText = &apos;&apos;, [String] $ForegroundColor = &apos;Black&apos;, [String] $BackgroundColor = &apos;White&apos; ) # take all pipeline input: $allData = @($Input) if ($allData.Count -gt 0) { # open window in new thread to keep PS responsive $code = { param($textToDisplay, $FindText, $Title, $ForegroundColor, $BackgroundColor) $dialog = (New-Object –TypeName Microsoft.Management.UI.HelpWindow($textToDisplay)) $dialog.Title = $Title $type = $dialog.GetType() $field = $type.GetField(&apos;Settings&apos;, &apos;NonPublic,Instance&apos;) $button = $field.GetValue($dialog) $button.Visibility = &apos;Collapsed&apos; $dialog.Show() $dialog.Hide() $field = $type.GetField(&apos;Find&apos;, &apos;NonPublic,Instance&apos;) $textbox = $field.GetValue($dialog) $textbox.Text = $FindText $field = $type.GetField(&apos;HelpText&apos;, &apos;NonPublic,Instance&apos;) $RTB = $field.GetValue($dialog) $RTB.Background = $BackgroundColor $RTB.Foreground = $ForegroundColor $method = $type.GetMethod(&apos;MoveToNextMatch&apos;, [System.Reflection.BindingFlags]&apos;NonPublic,Instance&apos;) $method.Invoke($dialog, @($true)) $dialog.ShowDialog() } $ps = [PowerShell]::Create() $newRunspace = [RunSpaceFactory]::CreateRunspace() $newRunspace.ApartmentState = &apos;STA&apos; $newRunspace.Open() $ps.Runspace = $newRunspace $null = $ps.AddScript($code).AddArgument(($allData | Format-Table -AutoSize -Wrap | Out-String -Width 100)).AddArgument($FindText).AddArgument($Title).AddArgument($ForegroundColor).AddArgument($BackgroundColor) $null = $ps.BeginInvoke() } } 调用的示例如下： Get-Content C:\\Windows\\windowsupdate.log | # limit to first 100 lines (help window is not designed to work with huge texts) Select-Object -First 100 | Out-Window -Find Success -Title &apos;My Output&apos; -Background Blue -Foreground White 请记住两件事： 帮助窗口并不是设计为显示大量文本的。请确保使用该方法显示不超过几 KB 的文本。 这只是试验性的代码。它并没有清除 PowerShell 用来显示窗体所创建的线程。当您关闭该线程时，该 PowerShell 线程将保持在后台运行，直到您关闭 PowerShell。我们需要为帮助窗口关闭事件增加一个事件处理器。该事件处理器可以清理该 PowerShell 线程。","text":"要显示文本信息，您当然可以启动 noteapd.exe，并且用编辑器来显示文本。不过，在编辑器中显示文本并不是一个好主意，如果您不希望文本被改变。 PowerShell 给我们带来了一个很棒的窗体，用来显示一小段或者中等长度的文本：内置的帮助窗口。 通过一些调整，该窗口可以重新编程，显示任意的文本信息。而且，您可以使用内置的全文搜索功能在您的文本中导航，甚至可以根据你的喜好设置前景色和背景色。 只需要将任意的文本通过管道传递给 Out-Window，并且根据需要可选地指定颜色、搜索词和标题。以下是 Out-Window 函数： function Out-Window { param ( [String] $Title = &apos;PowerShell Output&apos;, [String] $FindText = &apos;&apos;, [String] $ForegroundColor = &apos;Black&apos;, [String] $BackgroundColor = &apos;White&apos; ) # take all pipeline input: $allData = @($Input) if ($allData.Count -gt 0) { # open window in new thread to keep PS responsive $code = { param($textToDisplay, $FindText, $Title, $ForegroundColor, $BackgroundColor) $dialog = (New-Object –TypeName Microsoft.Management.UI.HelpWindow($textToDisplay)) $dialog.Title = $Title $type = $dialog.GetType() $field = $type.GetField(&apos;Settings&apos;, &apos;NonPublic,Instance&apos;) $button = $field.GetValue($dialog) $button.Visibility = &apos;Collapsed&apos; $dialog.Show() $dialog.Hide() $field = $type.GetField(&apos;Find&apos;, &apos;NonPublic,Instance&apos;) $textbox = $field.GetValue($dialog) $textbox.Text = $FindText $field = $type.GetField(&apos;HelpText&apos;, &apos;NonPublic,Instance&apos;) $RTB = $field.GetValue($dialog) $RTB.Background = $BackgroundColor $RTB.Foreground = $ForegroundColor $method = $type.GetMethod(&apos;MoveToNextMatch&apos;, [System.Reflection.BindingFlags]&apos;NonPublic,Instance&apos;) $method.Invoke($dialog, @($true)) $dialog.ShowDialog() } $ps = [PowerShell]::Create() $newRunspace = [RunSpaceFactory]::CreateRunspace() $newRunspace.ApartmentState = &apos;STA&apos; $newRunspace.Open() $ps.Runspace = $newRunspace $null = $ps.AddScript($code).AddArgument(($allData | Format-Table -AutoSize -Wrap | Out-String -Width 100)).AddArgument($FindText).AddArgument($Title).AddArgument($ForegroundColor).AddArgument($BackgroundColor) $null = $ps.BeginInvoke() } } 调用的示例如下： Get-Content C:\\Windows\\windowsupdate.log | # limit to first 100 lines (help window is not designed to work with huge texts) Select-Object -First 100 | Out-Window -Find Success -Title &apos;My Output&apos; -Background Blue -Foreground White 请记住两件事： 帮助窗口并不是设计为显示大量文本的。请确保使用该方法显示不超过几 KB 的文本。 这只是试验性的代码。它并没有清除 PowerShell 用来显示窗体所创建的线程。当您关闭该线程时，该 PowerShell 线程将保持在后台运行，直到您关闭 PowerShell。我们需要为帮助窗口关闭事件增加一个事件处理器。该事件处理器可以清理该 PowerShell 线程。 本文国际来源：Using PowerShell’s Help Window for General Output","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在后台播放声音","slug":"playing-sound-in-the-background","date":"2015-05-28T03:00:00.000Z","updated":"2017-03-17T15:26:25.680Z","comments":true,"path":"2015/05/28/playing-sound-in-the-background/","link":"","permalink":"http://blog.vichamp.com/2015/05/28/playing-sound-in-the-background/","excerpt":"如果您的脚本执行起来需要较长时间，您可能会希望播放一段系统声音文件。以下是一个实现该功能的示例代码： # find first available WAV file in Windows $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it $player = New-Object Media.SoundPlayer $WAVPath try { $player.PlayLooping() &apos;Doing something...&apos; 1..100 | ForEach-Object { Write-Progress -Activity &apos;Doing Something. Hang in&apos; -Status $_ -PercentComplete $_ Start-Sleep -MilliSeconds (Get-Random -Minimum 300 -Maximum 1300) } } finally { $player.Stop() } 这段示例代码使用 Windows 文件夹中找到的第一个 WAV 文件，然后在脚本的执行期间播放它。您当然也可以指定其它 WAV 文件的路径。","text":"如果您的脚本执行起来需要较长时间，您可能会希望播放一段系统声音文件。以下是一个实现该功能的示例代码： # find first available WAV file in Windows $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it $player = New-Object Media.SoundPlayer $WAVPath try { $player.PlayLooping() &apos;Doing something...&apos; 1..100 | ForEach-Object { Write-Progress -Activity &apos;Doing Something. Hang in&apos; -Status $_ -PercentComplete $_ Start-Sleep -MilliSeconds (Get-Random -Minimum 300 -Maximum 1300) } } finally { $player.Stop() } 这段示例代码使用 Windows 文件夹中找到的第一个 WAV 文件，然后在脚本的执行期间播放它。您当然也可以指定其它 WAV 文件的路径。 本文国际来源：Playing Sound in the Background","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找可执行程序","slug":"finding-executable","date":"2015-05-27T03:00:00.000Z","updated":"2017-03-17T15:26:25.660Z","comments":true,"path":"2015/05/27/finding-executable/","link":"","permalink":"http://blog.vichamp.com/2015/05/27/finding-executable/","excerpt":"许多文件扩展名都被关联为可执行程序。您可以使用 Invoke-Item 来打开一个可执行的文件。 然而，查找哪些文件扩展名是可执行程序却不是那么简单。您可以读取 Windows 注册表，然后自己查找这些值。如果您采用这种方法，请注意 32/64 位的问题。 另外一个方法是使用 Windows API。以下示例代码演示了它是如何工作的。如果您使用了这种方法，您可以将重活交给操作系统做。付出的代价是一堆调用内部 API 函数的 C# 代码。 $Source = @&quot; using System; using System.Text; using System.Runtime.InteropServices; public class Win32API { [DllImport(&quot;shell32.dll&quot;, EntryPoint=&quot;FindExecutable&quot;)] public static extern long FindExecutableA(string lpFile, string lpDirectory, StringBuilder lpResult); public static string FindExecutable(string pv_strFilename) { StringBuilder objResultBuffer = new StringBuilder(1024); long lngResult = 0; lngResult = FindExecutableA(pv_strFilename, string.Empty, objResultBuffer); if(lngResult &gt;= 32) { return objResultBuffer.ToString(); } return string.Format(&quot;Error: ({0})&quot;, lngResult); } } &quot;@ Add-Type -TypeDefinition $Source -ErrorAction SilentlyContinue $FullName = &apos;c:\\Windows\\windowsupdate.log&apos; $Executable = [Win32API]::FindExecutable($FullName) &quot;$FullName will be launched by $Executable&quot; 一个已知的限制是 FindExecutable() 的使用前提是该文件必须存在。您无法只通过文件扩展名来断定是否为一个可执行文件。","text":"许多文件扩展名都被关联为可执行程序。您可以使用 Invoke-Item 来打开一个可执行的文件。 然而，查找哪些文件扩展名是可执行程序却不是那么简单。您可以读取 Windows 注册表，然后自己查找这些值。如果您采用这种方法，请注意 32/64 位的问题。 另外一个方法是使用 Windows API。以下示例代码演示了它是如何工作的。如果您使用了这种方法，您可以将重活交给操作系统做。付出的代价是一堆调用内部 API 函数的 C# 代码。 $Source = @&quot; using System; using System.Text; using System.Runtime.InteropServices; public class Win32API { [DllImport(&quot;shell32.dll&quot;, EntryPoint=&quot;FindExecutable&quot;)] public static extern long FindExecutableA(string lpFile, string lpDirectory, StringBuilder lpResult); public static string FindExecutable(string pv_strFilename) { StringBuilder objResultBuffer = new StringBuilder(1024); long lngResult = 0; lngResult = FindExecutableA(pv_strFilename, string.Empty, objResultBuffer); if(lngResult &gt;= 32) { return objResultBuffer.ToString(); } return string.Format(&quot;Error: ({0})&quot;, lngResult); } } &quot;@ Add-Type -TypeDefinition $Source -ErrorAction SilentlyContinue $FullName = &apos;c:\\Windows\\windowsupdate.log&apos; $Executable = [Win32API]::FindExecutable($FullName) &quot;$FullName will be launched by $Executable&quot; 一个已知的限制是 FindExecutable() 的使用前提是该文件必须存在。您无法只通过文件扩展名来断定是否为一个可执行文件。 本文国际来源：Finding Executable","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 根据大写字符分割文本","slug":"splitting-text-at-uppercase-letters","date":"2015-05-26T03:00:00.000Z","updated":"2017-03-17T15:26:25.660Z","comments":true,"path":"2015/05/26/splitting-text-at-uppercase-letters/","link":"","permalink":"http://blog.vichamp.com/2015/05/26/splitting-text-at-uppercase-letters/","excerpt":"要在一段文本的每个大写字符出分割这段文本，而不用提供一个大写字符的列表，请试试这个例子： $text = &apos;MapNetworkDriveWithCredential&apos; [Char[]]$raw = foreach ($character in $text.ToCharArray()) { if ([Char]::IsUpper($character)) { &apos; &apos; } $character } $newtext = (-join $raw).Trim() $newtext","text":"要在一段文本的每个大写字符出分割这段文本，而不用提供一个大写字符的列表，请试试这个例子： $text = &apos;MapNetworkDriveWithCredential&apos; [Char[]]$raw = foreach ($character in $text.ToCharArray()) { if ([Char]::IsUpper($character)) { &apos; &apos; } $character } $newtext = (-join $raw).Trim() $newtext 本文国际来源：Splitting Text at Uppercase Letters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找大写字符","slug":"finding-uppercase-characters","date":"2015-05-25T03:00:00.000Z","updated":"2017-03-17T15:26:25.660Z","comments":true,"path":"2015/05/25/finding-uppercase-characters/","link":"","permalink":"http://blog.vichamp.com/2015/05/25/finding-uppercase-characters/","excerpt":"如果您希望查找大写字符，那么可以使用正则表达式。然而，您也可以提供一个大写字符的列表作为对比使用。一个更灵活的办法是使用 .NET 的 IsUpper() 函数。 以下是一段示例代码：它逐字符扫描一段文本，然后返回首个大写字符的位置： $text = &apos;here is some text with Uppercase letters&apos; $c = 0 $position = foreach ($character in $text.ToCharArray()) { $c++ if ([Char]::IsUpper($character)) { $c break } } if ($position -eq $null) { &apos;No uppercase characters detected.&apos; } else { &quot;First uppercase character at position $position&quot; $text.Substring(0, $position) + &quot;&lt;&lt;&lt;&quot; + $text.Substring($position) } 执行的结果类似这样： PS C:\\&gt; First uppercase character at position 24 here is some text with U&lt;&lt;&lt;ppercase letters","text":"如果您希望查找大写字符，那么可以使用正则表达式。然而，您也可以提供一个大写字符的列表作为对比使用。一个更灵活的办法是使用 .NET 的 IsUpper() 函数。 以下是一段示例代码：它逐字符扫描一段文本，然后返回首个大写字符的位置： $text = &apos;here is some text with Uppercase letters&apos; $c = 0 $position = foreach ($character in $text.ToCharArray()) { $c++ if ([Char]::IsUpper($character)) { $c break } } if ($position -eq $null) { &apos;No uppercase characters detected.&apos; } else { &quot;First uppercase character at position $position&quot; $text.Substring(0, $position) + &quot;&lt;&lt;&lt;&quot; + $text.Substring($position) } 执行的结果类似这样： PS C:\\&gt; First uppercase character at position 24 here is some text with U&lt;&lt;&lt;ppercase letters 本文国际来源：Finding Uppercase Characters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在控制台输出中使用绿色的复选标记","slug":"using-green-checkmarks-in-console-output","date":"2015-05-22T03:00:00.000Z","updated":"2017-03-17T15:26:25.645Z","comments":true,"path":"2015/05/22/using-green-checkmarks-in-console-output/","link":"","permalink":"http://blog.vichamp.com/2015/05/22/using-green-checkmarks-in-console-output/","excerpt":"在前一个技能中您已见到了如何使 PowerShell 控制台支持 TrueType 字体中所有可用的字符。您只需要将字符代码转换为“Char”类型即可。 以下是一个更高级的示例代码，使用了 splatting 技术将一个绿色的复选标记插入您的控制台输出中： $greenCheck = @{ Object = [Char]8730 ForegroundColor = &apos;Green&apos; NoNewLine = $true } Write-Host &quot;Status check... &quot; -NoNewline Start-Sleep -Seconds 1 Write-Host @greenCheck Write-Host &quot; (Done)&quot; 这样当您需要一个绿色的复选标记时，使用这行代码： Write-Host @greenCheck 如果该复选标记并没有显示出来，请确保您的控制台字体设置成了 TrueType 字体，例如“Consolas”。您可以点击控制台标题栏左上角的图标，并选择“属性”来设置字体。","text":"在前一个技能中您已见到了如何使 PowerShell 控制台支持 TrueType 字体中所有可用的字符。您只需要将字符代码转换为“Char”类型即可。 以下是一个更高级的示例代码，使用了 splatting 技术将一个绿色的复选标记插入您的控制台输出中： $greenCheck = @{ Object = [Char]8730 ForegroundColor = &apos;Green&apos; NoNewLine = $true } Write-Host &quot;Status check... &quot; -NoNewline Start-Sleep -Seconds 1 Write-Host @greenCheck Write-Host &quot; (Done)&quot; 这样当您需要一个绿色的复选标记时，使用这行代码： Write-Host @greenCheck 如果该复选标记并没有显示出来，请确保您的控制台字体设置成了 TrueType 字体，例如“Consolas”。您可以点击控制台标题栏左上角的图标，并选择“属性”来设置字体。 本文国际来源：Using Green Checkmarks in Console Output","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在控制台输出中使用符号","slug":"using-symbols-in-console-output","date":"2015-05-21T03:00:00.000Z","updated":"2017-03-17T15:26:25.645Z","comments":true,"path":"2015/05/21/using-symbols-in-console-output/","link":"","permalink":"http://blog.vichamp.com/2015/05/21/using-symbols-in-console-output/","excerpt":"您知道吗，控制台输出内容可以包括特殊字符，例如复选标记？您所需要做的只是将控制台设成 TrueType 字体，例如“Consolas”。 要显示特殊字体，请使用十进制或十六进制字符代码，例如： [Char]8730 [Char]0x25BA 或者执行内置的“CharacterMap”程序以您选择的控制台字体选择另一个特殊字符。 以下是一个让您在 PowerShell 控制台中得到更复杂提示的示例代码： function prompt { $specialChar1 = [Char]0x25ba Write-Host &apos;PS &apos; -NoNewline Write-Host $specialChar1 -ForegroundColor Green -NoNewline &apos; &apos; $host.UI.RawUI.WindowTitle = Get-Location } 请注意“prompt”函数必须返回至少一个字符，否则 PowerShell 将使用它的默认提示信息。这是为什么该函数用一个空格作为返回值，并且使用 Write-Host 作为彩色输出的原因。","text":"您知道吗，控制台输出内容可以包括特殊字符，例如复选标记？您所需要做的只是将控制台设成 TrueType 字体，例如“Consolas”。 要显示特殊字体，请使用十进制或十六进制字符代码，例如： [Char]8730 [Char]0x25BA 或者执行内置的“CharacterMap”程序以您选择的控制台字体选择另一个特殊字符。 以下是一个让您在 PowerShell 控制台中得到更复杂提示的示例代码： function prompt { $specialChar1 = [Char]0x25ba Write-Host &apos;PS &apos; -NoNewline Write-Host $specialChar1 -ForegroundColor Green -NoNewline &apos; &apos; $host.UI.RawUI.WindowTitle = Get-Location } 请注意“prompt”函数必须返回至少一个字符，否则 PowerShell 将使用它的默认提示信息。这是为什么该函数用一个空格作为返回值，并且使用 Write-Host 作为彩色输出的原因。 本文国际来源：Using Symbols in Console Output","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 测试嵌套深度","slug":"test-nested-depth","date":"2015-05-20T03:00:00.000Z","updated":"2017-03-17T15:26:25.629Z","comments":true,"path":"2015/05/20/test-nested-depth/","link":"","permalink":"http://blog.vichamp.com/2015/05/20/test-nested-depth/","excerpt":"当您调用一个函数时，PowerShell 会增加嵌套的深度。当一个函数调用另一个函数，或是一段脚本时，将进一步增加嵌套的深度。以下是一个能够告诉您当前代码嵌套深度的函数： function Test-NestLevel { $i = 1 $ok = $true do { try { $test = Get-Variable -Name Host -Scope $i } catch { $ok = $false } $i++ } While ($ok) $i } 当您设计递归（调用自身的函数）函数时，这种方法十分有用。 以下是使用该技术的示例代码： function Test-Diving { param($Depth) if ($Depth -gt 10) { return } &quot;Diving deeper to $Depth meters...&quot; $currentDepth = Test-NestLevel &quot;calculated depth: $currentDepth&quot; Test-Diving -depth ($Depth+1) } Test-Diving -depth 1 当您运行 Test-Diving 时，该函数将调用自身，直到达到 10 米深。该函数使用一个参数来控制嵌套深度，而 Test-NestLevel 的执行结果将返回相同的数字。 请注意它们的区别：Test-NestLevel 返回所有（绝对的）嵌套级别，而参数告诉您函数调用自己的次数。如果 Test-Diving 包含在其它函数中，那么绝对的级别和相对的级别将会不同： PS C:\\&gt; Test-Diving -Depth 1 diving deeper to 1 meters... calculated depth: 1 diving deeper to 2 meters... calculated depth: 2 diving deeper to 3 meters... calculated depth: 3 diving deeper to 4 meters... calculated depth: 4 diving deeper to 5 meters... calculated depth: 5 diving deeper to 6 meters... calculated depth: 6 diving deeper to 7 meters... calculated depth: 7 diving deeper to 8 meters... calculated depth: 8 diving deeper to 9 meters... calculated depth: 9 diving deeper to 10 meters... calculated depth: 10 PS C:\\&gt; &amp; { Test-Diving -Depth 1 } diving deeper to 1 meters... calculated depth: 2 diving deeper to 2 meters... calculated depth: 3 diving deeper to 3 meters... calculated depth: 4 diving deeper to 4 meters... calculated depth: 5 diving deeper to 5 meters... calculated depth: 6 diving deeper to 6 meters... calculated depth: 7 diving deeper to 7 meters... calculated depth: 8 diving deeper to 8 meters... calculated depth: 9 diving deeper to 9 meters... calculated depth: 10 diving deeper to 10 meters... calculated depth: 11 PS C:\\&gt; Test-NestLevel 总是从当前的代码中返回嵌套的级别到全局作用域。","text":"当您调用一个函数时，PowerShell 会增加嵌套的深度。当一个函数调用另一个函数，或是一段脚本时，将进一步增加嵌套的深度。以下是一个能够告诉您当前代码嵌套深度的函数： function Test-NestLevel { $i = 1 $ok = $true do { try { $test = Get-Variable -Name Host -Scope $i } catch { $ok = $false } $i++ } While ($ok) $i } 当您设计递归（调用自身的函数）函数时，这种方法十分有用。 以下是使用该技术的示例代码： function Test-Diving { param($Depth) if ($Depth -gt 10) { return } &quot;Diving deeper to $Depth meters...&quot; $currentDepth = Test-NestLevel &quot;calculated depth: $currentDepth&quot; Test-Diving -depth ($Depth+1) } Test-Diving -depth 1 当您运行 Test-Diving 时，该函数将调用自身，直到达到 10 米深。该函数使用一个参数来控制嵌套深度，而 Test-NestLevel 的执行结果将返回相同的数字。 请注意它们的区别：Test-NestLevel 返回所有（绝对的）嵌套级别，而参数告诉您函数调用自己的次数。如果 Test-Diving 包含在其它函数中，那么绝对的级别和相对的级别将会不同： PS C:\\&gt; Test-Diving -Depth 1 diving deeper to 1 meters... calculated depth: 1 diving deeper to 2 meters... calculated depth: 2 diving deeper to 3 meters... calculated depth: 3 diving deeper to 4 meters... calculated depth: 4 diving deeper to 5 meters... calculated depth: 5 diving deeper to 6 meters... calculated depth: 6 diving deeper to 7 meters... calculated depth: 7 diving deeper to 8 meters... calculated depth: 8 diving deeper to 9 meters... calculated depth: 9 diving deeper to 10 meters... calculated depth: 10 PS C:\\&gt; &amp; { Test-Diving -Depth 1 } diving deeper to 1 meters... calculated depth: 2 diving deeper to 2 meters... calculated depth: 3 diving deeper to 3 meters... calculated depth: 4 diving deeper to 4 meters... calculated depth: 5 diving deeper to 5 meters... calculated depth: 6 diving deeper to 6 meters... calculated depth: 7 diving deeper to 7 meters... calculated depth: 8 diving deeper to 8 meters... calculated depth: 9 diving deeper to 9 meters... calculated depth: 10 diving deeper to 10 meters... calculated depth: 11 PS C:\\&gt; Test-NestLevel 总是从当前的代码中返回嵌套的级别到全局作用域。 本文国际来源：Test Nested Depth","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 跳出管道","slug":"aborting-pipeline","date":"2015-05-19T03:00:00.000Z","updated":"2017-03-17T15:26:25.629Z","comments":true,"path":"2015/05/19/aborting-pipeline/","link":"","permalink":"http://blog.vichamp.com/2015/05/19/aborting-pipeline/","excerpt":"有些时候您可能希望当某些条件满足时跳出一个管道。 以下是一种实现该功能的创新方法。它适用于 PowerShell 2.0 以及更高版本。 以下是一段示例代码： filter Stop-Pipeline { param ( [scriptblock] $condition = {$true} ) if (&amp; $condition) { continue } $_ } do { Get-ChildItem c:\\Windows -Recurse -ErrorAction SilentlyContinue | Stop-Pipeline { ($_.FullName.ToCharArray() -eq &apos;\\&apos;).Count -gt 3 } } while ($false) 该管道方法递归扫描 Windows 文件夹。代码中有一个名为 Stop-Pipeline 的新命令。您可以将一个脚本块传给它，如果该脚本块的执行结果为 $true，该管道将会退出。 在这个例子中，您可以控制递归的深度。当路径中包含三个反斜杠（\\）时，管道将会停止。将数字“3”改为更大的值可以在更深的文件夹中递归。 这个技巧的使用前提是管道需要放置在一个“do”循环中。因为 Stop-Pipeline 主要的功能是当条件满足时执行“Continue”语句，使 do 循环提前退出。 这听起来不太方便不过它工作得很优雅。以下是一个简单的改动。它将运行一个管道最多不超过 10 秒： $start = Get-Date $MaxSeconds = 10 do { Get-ChildItem c:\\Windows -Recurse -ErrorAction SilentlyContinue | Stop-Pipeline { ((Get-Date) - $start).TotalSeconds -gt $MaxSeconds } } while ($false) 如果您希望保存管道的结果而不是输出它们，只需要在“do”语句之前放置一个变量。 $result = do { Get-Chil...","text":"有些时候您可能希望当某些条件满足时跳出一个管道。 以下是一种实现该功能的创新方法。它适用于 PowerShell 2.0 以及更高版本。 以下是一段示例代码： filter Stop-Pipeline { param ( [scriptblock] $condition = {$true} ) if (&amp; $condition) { continue } $_ } do { Get-ChildItem c:\\Windows -Recurse -ErrorAction SilentlyContinue | Stop-Pipeline { ($_.FullName.ToCharArray() -eq &apos;\\&apos;).Count -gt 3 } } while ($false) 该管道方法递归扫描 Windows 文件夹。代码中有一个名为 Stop-Pipeline 的新命令。您可以将一个脚本块传给它，如果该脚本块的执行结果为 $true，该管道将会退出。 在这个例子中，您可以控制递归的深度。当路径中包含三个反斜杠（\\）时，管道将会停止。将数字“3”改为更大的值可以在更深的文件夹中递归。 这个技巧的使用前提是管道需要放置在一个“do”循环中。因为 Stop-Pipeline 主要的功能是当条件满足时执行“Continue”语句，使 do 循环提前退出。 这听起来不太方便不过它工作得很优雅。以下是一个简单的改动。它将运行一个管道最多不超过 10 秒： $start = Get-Date $MaxSeconds = 10 do { Get-ChildItem c:\\Windows -Recurse -ErrorAction SilentlyContinue | Stop-Pipeline { ((Get-Date) - $start).TotalSeconds -gt $MaxSeconds } } while ($false) 如果您希望保存管道的结果而不是输出它们，只需要在“do”语句之前放置一个变量。 $result = do { Get-Chil... 本文国际来源：Aborting Pipeline","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - “Continue” 和标签","slug":"quot-continue-quot-and-labels","date":"2015-05-18T03:00:00.000Z","updated":"2017-03-17T15:26:25.613Z","comments":true,"path":"2015/05/18/quot-continue-quot-and-labels/","link":"","permalink":"http://blog.vichamp.com/2015/05/18/quot-continue-quot-and-labels/","excerpt":"当您在循环中使用“Continue”语句时，您可以跳过循环中剩下的语句，然后继续下一次循环。“Break”的工作原理与之相似，不过它不仅结束循环而且将跳过所有剩下的循环。 这引出一个问题：当您使用嵌套的循环时，这些语句影响了哪层循环？缺省情况下，“Continue”针对的是内层的循环，但是通过使用标签，您可以使“Continue”和“Break”指向外层循环。 :outer Foreach ($element in (1..10)) { for ($x = 1000; $x -lt 1500; $x += 100) { &quot;Frequency $x Hz&quot; [Console]::Beep($x, 500) continue outer Write-Host &apos;I am never seen unless you change the code...&apos; } } 由于这段示例代码的 continue 是针对外层循环的，所以您将见到（以及听到）10 次 1000Hz 的输出。 当您移除“Continue”之后的“outer”标签时，您会听到频率递增的蜂鸣，并且 Write-Host 语句不再被跳过。","text":"当您在循环中使用“Continue”语句时，您可以跳过循环中剩下的语句，然后继续下一次循环。“Break”的工作原理与之相似，不过它不仅结束循环而且将跳过所有剩下的循环。 这引出一个问题：当您使用嵌套的循环时，这些语句影响了哪层循环？缺省情况下，“Continue”针对的是内层的循环，但是通过使用标签，您可以使“Continue”和“Break”指向外层循环。 :outer Foreach ($element in (1..10)) { for ($x = 1000; $x -lt 1500; $x += 100) { &quot;Frequency $x Hz&quot; [Console]::Beep($x, 500) continue outer Write-Host &apos;I am never seen unless you change the code...&apos; } } 由于这段示例代码的 continue 是针对外层循环的，所以您将见到（以及听到）10 次 1000Hz 的输出。 当您移除“Continue”之后的“outer”标签时，您会听到频率递增的蜂鸣，并且 Write-Host 语句不再被跳过。 本文国际来源：“Continue” and Labels","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取内存消耗值","slug":"get-memory-consumption","date":"2015-05-15T03:00:00.000Z","updated":"2017-03-17T15:26:25.598Z","comments":true,"path":"2015/05/15/get-memory-consumption/","link":"","permalink":"http://blog.vichamp.com/2015/05/15/get-memory-consumption/","excerpt":"要了解某个脚本占用内存的大约值，或是当您将结果存入变量时 PowerShell 写入多少内存，以下是一个辅助函数： #requires -Version 2 $script:last_memory_usage_byte = 0 function Get-MemoryUsage { $memusagebyte = [System.GC]::GetTotalMemory(&apos;forcefullcollection&apos;) $memusageMB = $memusagebyte / 1MB $diffbytes = $memusagebyte - $script:last_memory_usage_byte $difftext = &apos;&apos; $sign = &apos;&apos; if ( $script:last_memory_usage_byte -ne 0 ) { if ( $diffbytes -ge 0 ) { $sign = &apos;+&apos; } $difftext = &quot;, $sign$diffbytes&quot; } Write-Host -Object (&apos;Memory usage: {0:n1} MB ({1:n0} Bytes{2})&apos; -f $memusageMB, $memusagebyte, $difftext) # save last value in script global variable $script:last_memory_usage_byte = $memusagebyte } 您可以在任意时候运行 Get-MemoryUsage，它将返回当前的内存消耗以及和上一次调用之间的变化量。 关键点在于使用垃圾收集器：它是负责清理内存，但是平时并不是立即清理内存。要粗略计算内存消耗时，需要调用垃圾收集器立即释放所有无用的内存，然后报告当前占用的内存。","text":"要了解某个脚本占用内存的大约值，或是当您将结果存入变量时 PowerShell 写入多少内存，以下是一个辅助函数： #requires -Version 2 $script:last_memory_usage_byte = 0 function Get-MemoryUsage { $memusagebyte = [System.GC]::GetTotalMemory(&apos;forcefullcollection&apos;) $memusageMB = $memusagebyte / 1MB $diffbytes = $memusagebyte - $script:last_memory_usage_byte $difftext = &apos;&apos; $sign = &apos;&apos; if ( $script:last_memory_usage_byte -ne 0 ) { if ( $diffbytes -ge 0 ) { $sign = &apos;+&apos; } $difftext = &quot;, $sign$diffbytes&quot; } Write-Host -Object (&apos;Memory usage: {0:n1} MB ({1:n0} Bytes{2})&apos; -f $memusageMB, $memusagebyte, $difftext) # save last value in script global variable $script:last_memory_usage_byte = $memusagebyte } 您可以在任意时候运行 Get-MemoryUsage，它将返回当前的内存消耗以及和上一次调用之间的变化量。 关键点在于使用垃圾收集器：它是负责清理内存，但是平时并不是立即清理内存。要粗略计算内存消耗时，需要调用垃圾收集器立即释放所有无用的内存，然后报告当前占用的内存。 本文国际来源：Get Memory Consumption","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用闭包将变量保持在脚本块内","slug":"use-closures-to-lock-variables-to-script-blocks","date":"2015-05-14T03:00:00.000Z","updated":"2017-03-17T15:26:25.598Z","comments":true,"path":"2015/05/14/use-closures-to-lock-variables-to-script-blocks/","link":"","permalink":"http://blog.vichamp.com/2015/05/14/use-closures-to-lock-variables-to-script-blocks/","excerpt":"当您使用脚本块中的变量时，运行脚本块时变量会被求值。 要将变量内容保持住，您可以创建一个新的“闭包”。当创建一个闭包之后，该脚本块持有该变量的值，该值为创建闭包时刻的值。 $info = 1 $code = { $info } $code = $code.GetNewClosure() $info = 2 &amp; $code 如果不使用闭包，该脚本块将显示“2”，因为执行时 $info 的值为 2。通过闭包的作用，该脚本块内包含的值为创建闭包时赋予 $info 的值。","text":"当您使用脚本块中的变量时，运行脚本块时变量会被求值。 要将变量内容保持住，您可以创建一个新的“闭包”。当创建一个闭包之后，该脚本块持有该变量的值，该值为创建闭包时刻的值。 $info = 1 $code = { $info } $code = $code.GetNewClosure() $info = 2 &amp; $code 如果不使用闭包，该脚本块将显示“2”，因为执行时 $info 的值为 2。通过闭包的作用，该脚本块内包含的值为创建闭包时赋予 $info 的值。 本文国际来源：Use Closures to Lock Variables to Script Blocks","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 互斥参数 (2)","slug":"mutually-exclusive-parameters-part-2","date":"2015-05-13T03:00:00.000Z","updated":"2017-03-17T15:26:25.598Z","comments":true,"path":"2015/05/13/mutually-exclusive-parameters-part-2/","link":"","permalink":"http://blog.vichamp.com/2015/05/13/mutually-exclusive-parameters-part-2/","excerpt":"PowerShell 函数中的互斥参数使用“ParameterSetName”属性将参数指定到不同的参数集上（或是参数组上）。 很少人知道可以为一个参数指定多个参数集名。通过这种方法，某个参数可以在一个场景中为可选，但在另外一个场景中为必选。 function Test-ParameterSet { [CmdletBinding(DefaultParameterSetName=&apos;NonCredential&apos;)] param ( $id, [Parameter(ParameterSetName=&apos;LocalOnly&apos;, Mandatory=$false)] $LocalAction, [Parameter(ParameterSetName=&apos;Credential&apos;, Mandatory=$true)] [Parameter(ParameterSetName=&apos;NonCredential&apos;, Mandatory=$false)] $ComputerName, [Parameter(ParameterSetName=&apos;Credential&apos;, Mandatory=$false)] $Credential ) $PSCmdlet.ParameterSetName $PSBoundParameters if ($PSBoundParameters.ContainsKey(&apos;ComputerName&apos;)) { Write-Warning &apos;Remote Call!&apos; } } Test-ParameterSet 函数显示了如何实现该功能：当“NonCredential”参数集有效时 -ComputerName 是可选的。如果用户使用了 -Credential 参数，那么 -ComputerName 变成了必选的。而如果用户使用了 -LocalAction 参数，那么 -ComputerName 和 -Credential 都变为不可用的了。","text":"PowerShell 函数中的互斥参数使用“ParameterSetName”属性将参数指定到不同的参数集上（或是参数组上）。 很少人知道可以为一个参数指定多个参数集名。通过这种方法，某个参数可以在一个场景中为可选，但在另外一个场景中为必选。 function Test-ParameterSet { [CmdletBinding(DefaultParameterSetName=&apos;NonCredential&apos;)] param ( $id, [Parameter(ParameterSetName=&apos;LocalOnly&apos;, Mandatory=$false)] $LocalAction, [Parameter(ParameterSetName=&apos;Credential&apos;, Mandatory=$true)] [Parameter(ParameterSetName=&apos;NonCredential&apos;, Mandatory=$false)] $ComputerName, [Parameter(ParameterSetName=&apos;Credential&apos;, Mandatory=$false)] $Credential ) $PSCmdlet.ParameterSetName $PSBoundParameters if ($PSBoundParameters.ContainsKey(&apos;ComputerName&apos;)) { Write-Warning &apos;Remote Call!&apos; } } Test-ParameterSet 函数显示了如何实现该功能：当“NonCredential”参数集有效时 -ComputerName 是可选的。如果用户使用了 -Credential 参数，那么 -ComputerName 变成了必选的。而如果用户使用了 -LocalAction 参数，那么 -ComputerName 和 -Credential 都变为不可用的了。 本文国际来源：Mutually Exclusive Parameters (Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 互斥参数 (1)","slug":"mutual-exclusive-parameters","date":"2015-05-12T03:00:00.000Z","updated":"2017-03-17T15:26:25.594Z","comments":true,"path":"2015/05/12/mutual-exclusive-parameters/","link":"","permalink":"http://blog.vichamp.com/2015/05/12/mutual-exclusive-parameters/","excerpt":"有些时候，PowerShell 的函数参数必须是互斥的：用户只能用这类参数多个中的一个，而不能同时使用。 要创建互斥参数，请将他们指定到不同的参数集中，并且确保定义了一个缺省的参数集（当 PowerShell 无法自动选择正确的参数集时使用）： function Test-ParameterSet { [CmdletBinding(DefaultParameterSetName=&apos;number&apos;)] param ( [int] [Parameter(ParameterSetName=&apos;number&apos;, Position=0)] $id, [string] [Parameter(ParameterSetName=&apos;text&apos;, Position=0)] $name ) $PSCmdlet.ParameterSetName $PSBoundParameters } Test-ParameterSet 函数有两个参数：-id 和 -name。用户只能指定一个参数，而不能同时指定两个参数。这个例子也演示了如何知道用户选择了哪个参数集。","text":"有些时候，PowerShell 的函数参数必须是互斥的：用户只能用这类参数多个中的一个，而不能同时使用。 要创建互斥参数，请将他们指定到不同的参数集中，并且确保定义了一个缺省的参数集（当 PowerShell 无法自动选择正确的参数集时使用）： function Test-ParameterSet { [CmdletBinding(DefaultParameterSetName=&apos;number&apos;)] param ( [int] [Parameter(ParameterSetName=&apos;number&apos;, Position=0)] $id, [string] [Parameter(ParameterSetName=&apos;text&apos;, Position=0)] $name ) $PSCmdlet.ParameterSetName $PSBoundParameters } Test-ParameterSet 函数有两个参数：-id 和 -name。用户只能指定一个参数，而不能同时指定两个参数。这个例子也演示了如何知道用户选择了哪个参数集。 本文国际来源：Mutual Exclusive Parameters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 解析 PowerShell 脚本","slug":"parsing-powershell-scripts","date":"2015-05-11T03:00:00.000Z","updated":"2017-03-17T15:26:25.586Z","comments":true,"path":"2015/05/11/parsing-powershell-scripts/","link":"","permalink":"http://blog.vichamp.com/2015/05/11/parsing-powershell-scripts/","excerpt":"如果您希望为 PowerShell 脚本语法着色，例如用 HTML 将它们格式化，以下是一个起步示例： 这个例子将读取当前 ISE 编辑器中显示的脚本，然后调用 PowerShell 解析器返回所有 token 的信息。 $content = $psise.CurrentFile.Editor.Text $token = $null $errors = $null $token = [System.Management.Automation.PSParser]::Tokenize($content, [ref]$errors) $token | Out-GridView 您可以简单地使用 Get-Content 来读取任何脚本中的内容。读取到的结果是一个由 token 对象组成的数组。它们包含了语法元素类型，以及起止位置。 该信息是格式化 PowerShell 代码所需要的。您可以为 token 类型指定颜色，并为 PowerShell 代码创建自己的文档。","text":"如果您希望为 PowerShell 脚本语法着色，例如用 HTML 将它们格式化，以下是一个起步示例： 这个例子将读取当前 ISE 编辑器中显示的脚本，然后调用 PowerShell 解析器返回所有 token 的信息。 $content = $psise.CurrentFile.Editor.Text $token = $null $errors = $null $token = [System.Management.Automation.PSParser]::Tokenize($content, [ref]$errors) $token | Out-GridView 您可以简单地使用 Get-Content 来读取任何脚本中的内容。读取到的结果是一个由 token 对象组成的数组。它们包含了语法元素类型，以及起止位置。 该信息是格式化 PowerShell 代码所需要的。您可以为 token 类型指定颜色，并为 PowerShell 代码创建自己的文档。 本文国际来源：Parsing PowerShell Scripts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 跳出管道","slug":"aborting-the-pipeline","date":"2015-05-08T03:00:00.000Z","updated":"2017-03-17T15:26:25.582Z","comments":true,"path":"2015/05/08/aborting-the-pipeline/","link":"","permalink":"http://blog.vichamp.com/2015/05/08/aborting-the-pipeline/","excerpt":"如果您事先知道期望从管道中得到多少个对象，您可以用 Select-Object 命令来停止上游的 cmdlet 执行。这样可以节约很多时间。 这个例子试着在 Windows 文件夹中查找 explorer.exe 的第一个实例。由于 Select-Object 语句的作用，一旦找到第一个实例，管道就结束了。如果没有这个语句，即便已经查找到所需的数据，Get-ChildItem 也会不断地递归扫描 Windows 文件夹。 #requires -Version 3 Get-ChildItem -Path c:\\Windows -Recurse -Filter explorer.exe -ErrorAction SilentlyContinue | Select-Object -First 1 请注意只有在 PowerShell 3.0 以上版本中，Select-Object 才具有中断上游 cmdlet 的能力。在早期的版本中，您仍然会获得前 x 个元素，但是上游的 cmdlet 会得不到“已经获得足够的数据”通知而一直持续执行。","text":"如果您事先知道期望从管道中得到多少个对象，您可以用 Select-Object 命令来停止上游的 cmdlet 执行。这样可以节约很多时间。 这个例子试着在 Windows 文件夹中查找 explorer.exe 的第一个实例。由于 Select-Object 语句的作用，一旦找到第一个实例，管道就结束了。如果没有这个语句，即便已经查找到所需的数据，Get-ChildItem 也会不断地递归扫描 Windows 文件夹。 #requires -Version 3 Get-ChildItem -Path c:\\Windows -Recurse -Filter explorer.exe -ErrorAction SilentlyContinue | Select-Object -First 1 请注意只有在 PowerShell 3.0 以上版本中，Select-Object 才具有中断上游 cmdlet 的能力。在早期的版本中，您仍然会获得前 x 个元素，但是上游的 cmdlet 会得不到“已经获得足够的数据”通知而一直持续执行。 本文国际来源：Aborting the Pipeline","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 向管道传递一个数组","slug":"passing-arrays-to-pipeline","date":"2015-05-07T03:00:00.000Z","updated":"2017-03-17T15:26:25.579Z","comments":true,"path":"2015/05/07/passing-arrays-to-pipeline/","link":"","permalink":"http://blog.vichamp.com/2015/05/07/passing-arrays-to-pipeline/","excerpt":"如果一个函数返回多于一个值，PowerShell 会将它们封装为一个数组。然而如果您通过管道将它传递至另一个函数，该管道会自动地将数组“解封”，并且一次处理一个数组元素。 如果您需要原原本本地处理一个数组而不希望解封，那么请将返回值封装在另一个数组中。通过这种方式，管道会将外层的数组解封并处理内层的数组。 以下代码演示了这个技能： #requires -Version 1 function Test-ArrayAsReturnValue1 { param($count) $array = 1..$count return $array } function Test-ArrayAsReturnValue2 { param($count) $array = 1..$count return ,$array } &apos;Result 1:&apos; Test-ArrayAsReturnValue1 -count 10 | ForEach-Object -Process { $_.GetType().FullName } &apos;Result 2:&apos; Test-ArrayAsReturnValue2 -count 10 | ForEach-Object -Process { $_.GetType().FullName } 当您运行这段代码时，第一个例子将返回数组中的元素。第二个例子将会把整个数组传递给循环。 PS C:\\&gt; Result 1: System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 Result 2: System.Object[]","text":"如果一个函数返回多于一个值，PowerShell 会将它们封装为一个数组。然而如果您通过管道将它传递至另一个函数，该管道会自动地将数组“解封”，并且一次处理一个数组元素。 如果您需要原原本本地处理一个数组而不希望解封，那么请将返回值封装在另一个数组中。通过这种方式，管道会将外层的数组解封并处理内层的数组。 以下代码演示了这个技能： #requires -Version 1 function Test-ArrayAsReturnValue1 { param($count) $array = 1..$count return $array } function Test-ArrayAsReturnValue2 { param($count) $array = 1..$count return ,$array } &apos;Result 1:&apos; Test-ArrayAsReturnValue1 -count 10 | ForEach-Object -Process { $_.GetType().FullName } &apos;Result 2:&apos; Test-ArrayAsReturnValue2 -count 10 | ForEach-Object -Process { $_.GetType().FullName } 当您运行这段代码时，第一个例子将返回数组中的元素。第二个例子将会把整个数组传递给循环。 PS C:\\&gt; Result 1: System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 Result 2: System.Object[] 本文国际来源：Passing Arrays to Pipeline","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 面向管理员的免费 PowerShell 模块","slug":"free-powershell-module-for-admins","date":"2015-05-06T03:00:00.000Z","updated":"2017-03-17T15:26:25.575Z","comments":true,"path":"2015/05/06/free-powershell-module-for-admins/","link":"","permalink":"http://blog.vichamp.com/2015/05/06/free-powershell-module-for-admins/","excerpt":"上个技能中我们收到一个反馈，推荐使用一个名为“Carbon”的免费 PowerShell 模块，其中包含了一大堆有用的 PowerShell 函数。 其中一个是 Get-IPAddress，它能返回您计算机的所有 IP 地址。您可以在这儿找到和下载该模块：http://get-carbon.org/。 请始终记着：从外部资源中下载 PowerShell 代码要记得检查一遍代码，确保是您所需要的内容。","text":"上个技能中我们收到一个反馈，推荐使用一个名为“Carbon”的免费 PowerShell 模块，其中包含了一大堆有用的 PowerShell 函数。 其中一个是 Get-IPAddress，它能返回您计算机的所有 IP 地址。您可以在这儿找到和下载该模块：http://get-carbon.org/。 请始终记着：从外部资源中下载 PowerShell 代码要记得检查一遍代码，确保是您所需要的内容。 本文国际来源：Free PowerShell Module for Admins","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将 CSV 转换为 Excel 文件","slug":"converting-csv-to-excel-file","date":"2015-05-05T03:00:00.000Z","updated":"2017-03-17T15:26:25.567Z","comments":true,"path":"2015/05/05/converting-csv-to-excel-file/","link":"","permalink":"http://blog.vichamp.com/2015/05/05/converting-csv-to-excel-file/","excerpt":"PowerShell 可以用 Export-Csv 很容易创建 CSV 文件。如果您的系统中安装了 Microsoft Excel，PowerShell 可以调用 Excel 将一个 CSV 文件转换为一个 XLSX Excel 文件。 以下是一段示例代码。它使用 Get-Process 来获取一些数据，然后将数据写入一个 CSV 文件。Export-Csv 使用 -UseCulture 来确保 CSV 文件使用您所安装的 Excel 期望的分隔符。 $FileName = &quot;$env:temp\\Report&quot; # create some CSV data Get-Process | Export-Csv -UseCulture -Path &quot;$FileName.csv&quot; -NoTypeInformation -Encoding UTF8 # load into Excel $excel = New-Object -ComObject Excel.Application $excel.Visible = $true $excel.Workbooks.Open(&quot;$FileName.csv&quot;).SaveAs(&quot;$FileName.xlsx&quot;,51) $excel.Quit() explorer.exe &quot;/Select,$FileName.xlsx&quot; 下一步，Excel 打开该 CSV 文件，然后将数据保存为一个 XLSX 文件。 它工作得很好，不过可能会遇到一个类似这样的异常： PS&gt; $excel.Workbooks.Open(&quot;$FileName.csv&quot;) Exception calling &quot;Open&quot; with &quot;1&quot; argument(s): &quot;Old format or invalid type library. (Exception from HRESULT: 0x80028018 (TYPE_E_INVDATAREAD))&quot; At line:1 char:1 + $excel.Workbooks.Open(&quot;$FileName.csv&quot;) + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [], MethodInvocationException + FullyQualifiedErrorId : ComMethodTargetInvocation 这是一个长期已知的问题。当您的 Excel 语言和您的 Windows 操作系统不一致时可能会碰到。当您的 Windows 操作系统使用一个本地化的 MUI 包时，也许根本不会遇到这个问题。 要解决这个问题，您可以临时改变该线程的语言文化设置来适应您的 Excel 版本： $FileName = &quot;$env:temp\\Report&quot; # create some CSV data Get-Process | Export-Csv -Path &quot;$FileName.csv&quot; -NoTypeInformation -Encoding UTF8 # load into Excel $excel = New-Object -ComObject Excel.Application $excel.Visible = $true # change thread culture [System.Threading.Thread]::CurrentThread.CurrentCulture = &apos;en-US&apos; $excel.Workbooks.Open(&quot;$FileName.csv&quot;).SaveAs(&quot;$FileName.xlsx&quot;,51) $excel.Quit() explorer.exe &quot;/Select,$FileName.xlsx&quot; 这也会带来另外一个问题：当您以 en-US 语言文化设置运行 Excel 的 Open() 方法时，它不再需要 CSV 文件使用您的本地化分隔符。现在它需要的是一个以半角逗号分隔的文件，所以第二个脚本去掉了 -UseCulture 设置。","text":"PowerShell 可以用 Export-Csv 很容易创建 CSV 文件。如果您的系统中安装了 Microsoft Excel，PowerShell 可以调用 Excel 将一个 CSV 文件转换为一个 XLSX Excel 文件。 以下是一段示例代码。它使用 Get-Process 来获取一些数据，然后将数据写入一个 CSV 文件。Export-Csv 使用 -UseCulture 来确保 CSV 文件使用您所安装的 Excel 期望的分隔符。 $FileName = &quot;$env:temp\\Report&quot; # create some CSV data Get-Process | Export-Csv -UseCulture -Path &quot;$FileName.csv&quot; -NoTypeInformation -Encoding UTF8 # load into Excel $excel = New-Object -ComObject Excel.Application $excel.Visible = $true $excel.Workbooks.Open(&quot;$FileName.csv&quot;).SaveAs(&quot;$FileName.xlsx&quot;,51) $excel.Quit() explorer.exe &quot;/Select,$FileName.xlsx&quot; 下一步，Excel 打开该 CSV 文件，然后将数据保存为一个 XLSX 文件。 它工作得很好，不过可能会遇到一个类似这样的异常： PS&gt; $excel.Workbooks.Open(&quot;$FileName.csv&quot;) Exception calling &quot;Open&quot; with &quot;1&quot; argument(s): &quot;Old format or invalid type library. (Exception from HRESULT: 0x80028018 (TYPE_E_INVDATAREAD))&quot; At line:1 char:1 + $excel.Workbooks.Open(&quot;$FileName.csv&quot;) + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [], MethodInvocationException + FullyQualifiedErrorId : ComMethodTargetInvocation 这是一个长期已知的问题。当您的 Excel 语言和您的 Windows 操作系统不一致时可能会碰到。当您的 Windows 操作系统使用一个本地化的 MUI 包时，也许根本不会遇到这个问题。 要解决这个问题，您可以临时改变该线程的语言文化设置来适应您的 Excel 版本： $FileName = &quot;$env:temp\\Report&quot; # create some CSV data Get-Process | Export-Csv -Path &quot;$FileName.csv&quot; -NoTypeInformation -Encoding UTF8 # load into Excel $excel = New-Object -ComObject Excel.Application $excel.Visible = $true # change thread culture [System.Threading.Thread]::CurrentThread.CurrentCulture = &apos;en-US&apos; $excel.Workbooks.Open(&quot;$FileName.csv&quot;).SaveAs(&quot;$FileName.xlsx&quot;,51) $excel.Quit() explorer.exe &quot;/Select,$FileName.xlsx&quot; 这也会带来另外一个问题：当您以 en-US 语言文化设置运行 Excel 的 Open() 方法时，它不再需要 CSV 文件使用您的本地化分隔符。现在它需要的是一个以半角逗号分隔的文件，所以第二个脚本去掉了 -UseCulture 设置。 本文国际来源：Converting CSV to Excel File","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 谁在使用网络资源？","slug":"who-is-accessing-network-resources","date":"2015-05-04T03:00:00.000Z","updated":"2017-03-17T15:26:25.560Z","comments":true,"path":"2015/05/04/who-is-accessing-network-resources/","link":"","permalink":"http://blog.vichamp.com/2015/05/04/who-is-accessing-network-resources/","excerpt":"假设您拥有管理员权限，您可以使用一个简单的 WMI 类来检测某人是否正在通过网络访问您的资源： PS&gt; Get-WmiObject -Class Win32_ServerConnection | Select-Object -Property ComputerName, ConnectionID, UserName, ShareName 这个操作也可以远程执行：只需要为 Get-WmiObject 命令增加 -ComputerName 参数即可查看谁在访问该远程计算机上的共享资源。需要拥有目标计算机的管理员权限才可以进行远程操作。","text":"假设您拥有管理员权限，您可以使用一个简单的 WMI 类来检测某人是否正在通过网络访问您的资源： PS&gt; Get-WmiObject -Class Win32_ServerConnection | Select-Object -Property ComputerName, ConnectionID, UserName, ShareName 这个操作也可以远程执行：只需要为 Get-WmiObject 命令增加 -ComputerName 参数即可查看谁在访问该远程计算机上的共享资源。需要拥有目标计算机的管理员权限才可以进行远程操作。 本文国际来源：Who is Accessing Network Resources?","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 禁止更新后自动重启","slug":"disable-automatic-reboot-after-update","date":"2015-05-01T03:00:00.000Z","updated":"2017-03-17T15:26:25.557Z","comments":true,"path":"2015/05/01/disable-automatic-reboot-after-update/","link":"","permalink":"http://blog.vichamp.com/2015/05/01/disable-automatic-reboot-after-update/","excerpt":"您是否厌烦了 Windows 安装了一些更新后导致的非计划中的重启？ 和其它情况类似，您可以通过组策略控制重启，而且多数组策略设置只是注册表键而已。以下是一个通过设置注册表键来实现控制安装更新后的重启设置的示例脚本： $code = { $key = &apos;HKLM:\\Software\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU&apos; $name = &apos;NoAutoRebootWithLoggedOnUsers&apos; $type = &apos;DWord&apos; $value = 1 if (!(Test-Path -Path $key)) { $null = New-Item -Path $key -Force } Set-ItemProperty -Path $key -Name $name -Value $value -Type $type } Start-Process -FilePath powershell.exe -ArgumentList $code -Verb runas -WorkingDirectory c:\\ 请注意该脚本如何操作注册表：它实际上是通过另一个 PowerShell 实例间接执行的。第二个实例是通过 Start-Process 启动的，而“-Verb Runas”确保了以管理员身份运行这段代码。 如果您当前没有管理员权限，那么会弹出提升权限的对话框供您选择使用管理员权限，或是如果您的账户没有管理员权限的时候要求您选择一个有权限的账户。","text":"您是否厌烦了 Windows 安装了一些更新后导致的非计划中的重启？ 和其它情况类似，您可以通过组策略控制重启，而且多数组策略设置只是注册表键而已。以下是一个通过设置注册表键来实现控制安装更新后的重启设置的示例脚本： $code = { $key = &apos;HKLM:\\Software\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU&apos; $name = &apos;NoAutoRebootWithLoggedOnUsers&apos; $type = &apos;DWord&apos; $value = 1 if (!(Test-Path -Path $key)) { $null = New-Item -Path $key -Force } Set-ItemProperty -Path $key -Name $name -Value $value -Type $type } Start-Process -FilePath powershell.exe -ArgumentList $code -Verb runas -WorkingDirectory c:\\ 请注意该脚本如何操作注册表：它实际上是通过另一个 PowerShell 实例间接执行的。第二个实例是通过 Start-Process 启动的，而“-Verb Runas”确保了以管理员身份运行这段代码。 如果您当前没有管理员权限，那么会弹出提升权限的对话框供您选择使用管理员权限，或是如果您的账户没有管理员权限的时候要求您选择一个有权限的账户。 本文国际来源：Disable Automatic Reboot After Update","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 移除空白（和换行）","slug":"removing-whitespace-and-line-breaks","date":"2015-04-30T03:00:00.000Z","updated":"2017-03-17T15:26:25.553Z","comments":true,"path":"2015/04/30/removing-whitespace-and-line-breaks/","link":"","permalink":"http://blog.vichamp.com/2015/04/30/removing-whitespace-and-line-breaks/","excerpt":"您也许知道每个 string 对象都有个 Trim() 方法可以删除该字符串开头和结尾的空白： $text = &apos; Hello &apos; $text.Trim() 一个鲜为人知的事实是，Trim() 也会删掉开头和结尾的换行： $text = &apos; Hello &apos; $text.Trim() 如果您需要，您可以控制 Trim() 函数吃掉的字符。 这个例子删除空格、点号、减号和换行： $text = &apos; ... Hello ...--- &apos; $text.Trim(&quot; .-`t`n`r&quot;)","text":"您也许知道每个 string 对象都有个 Trim() 方法可以删除该字符串开头和结尾的空白： $text = &apos; Hello &apos; $text.Trim() 一个鲜为人知的事实是，Trim() 也会删掉开头和结尾的换行： $text = &apos; Hello &apos; $text.Trim() 如果您需要，您可以控制 Trim() 函数吃掉的字符。 这个例子删除空格、点号、减号和换行： $text = &apos; ... Hello ...--- &apos; $text.Trim(&quot; .-`t`n`r&quot;) 本文国际来源：Removing Whitespace (and Line Breaks)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从 PowerShell 脚本中接收错误返回值","slug":"receiving-error-level-from-powershell-script","date":"2015-04-29T03:00:00.000Z","updated":"2017-03-17T15:26:25.546Z","comments":true,"path":"2015/04/29/receiving-error-level-from-powershell-script/","link":"","permalink":"http://blog.vichamp.com/2015/04/29/receiving-error-level-from-powershell-script/","excerpt":"以下是一个演示 PowerShell 如何返回一个数值型状态码给调用者的简单脚本： $exitcode = 123 $p = Start-Process -FilePath powershell -ArgumentList &quot;-command get-process; exit $exitcode&quot; -PassThru Wait-Process -Id $p.Id &apos;External Script ended with exit code &apos; + $p.ExitCode 如果您在 PowerShell 中直接调用该脚本（不使用 Start-Process），那么数值型返回值会被赋给 $LASTEXITCODE： $exitcode = 199 powershell.exe &quot;get-process; exit $exitcode&quot; &apos;External Script ended with exit code &apos; + $LASTEXITCODE 如果您从一个批处理文件或是 VBScript 中运行一段 PowerShell 脚本，该数值型返回值将会赋给 %ERRORLEVEL% 环境变量，好比 PowerShell 是一个控制台应用程序一样——实际上 powershell.exe 确实是。","text":"以下是一个演示 PowerShell 如何返回一个数值型状态码给调用者的简单脚本： $exitcode = 123 $p = Start-Process -FilePath powershell -ArgumentList &quot;-command get-process; exit $exitcode&quot; -PassThru Wait-Process -Id $p.Id &apos;External Script ended with exit code &apos; + $p.ExitCode 如果您在 PowerShell 中直接调用该脚本（不使用 Start-Process），那么数值型返回值会被赋给 $LASTEXITCODE： $exitcode = 199 powershell.exe &quot;get-process; exit $exitcode&quot; &apos;External Script ended with exit code &apos; + $LASTEXITCODE 如果您从一个批处理文件或是 VBScript 中运行一段 PowerShell 脚本，该数值型返回值将会赋给 %ERRORLEVEL% 环境变量，好比 PowerShell 是一个控制台应用程序一样——实际上 powershell.exe 确实是。 本文国际来源：Receiving Error Level from PowerShell Script","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 为什么“exit”将会关掉 PowerShell","slug":"why-quot-exit-quot-can-kill-powershell","date":"2015-04-28T03:00:00.000Z","updated":"2017-03-17T15:26:25.537Z","comments":true,"path":"2015/04/28/why-quot-exit-quot-can-kill-powershell/","link":"","permalink":"http://blog.vichamp.com/2015/04/28/why-quot-exit-quot-can-kill-powershell/","excerpt":"某些时候，我们会误会“exit”语句的工作方式。以下是一个例子： function abc { &apos;Start&apos; exit 100 &apos;Done&apos; } abc 当您运行这个脚本时，abc 函数会被调用，然后退出。您会见到“Start”提示，但见不到“Done”提示，并且 $LASTEXITCODE 变量的值为 100。但这是实际情况吗？ 当您在交互式的 PowerShell 控制台以交互式的方式运行 abc 方式时，该函数仍然退出了，不过这次，PowerShell 也被关闭了。为什么呢？ “Exit”在调用者作用域中退出代码。当您运行一个脚本时，该脚本退出后 PowerShell 仍然继续运行。当您以交互式的方式执行该函数时，交互式的 PowerShell 作为全局作用域退出了，而且由于不存在更高层的作用域了，所以 PowerShell 关闭了。 要更明显一点体现这个观点，我们在上述示例脚本中增加一点内容： function abc { &apos;Start&apos; exit 100 &apos;Done&apos; } &apos;Function starts&apos; abc &apos;Function ends&apos; 如您所发现的，“exit”实际上并不是退出 abc 函数，而是退出整个脚本。所以您既见不到“Done”字样也见不到“Function ends”字样。 所以请慎用“exit”语句！它只能用在退出一个脚本并将控制权交还给调用者的时候。","text":"某些时候，我们会误会“exit”语句的工作方式。以下是一个例子： function abc { &apos;Start&apos; exit 100 &apos;Done&apos; } abc 当您运行这个脚本时，abc 函数会被调用，然后退出。您会见到“Start”提示，但见不到“Done”提示，并且 $LASTEXITCODE 变量的值为 100。但这是实际情况吗？ 当您在交互式的 PowerShell 控制台以交互式的方式运行 abc 方式时，该函数仍然退出了，不过这次，PowerShell 也被关闭了。为什么呢？ “Exit”在调用者作用域中退出代码。当您运行一个脚本时，该脚本退出后 PowerShell 仍然继续运行。当您以交互式的方式执行该函数时，交互式的 PowerShell 作为全局作用域退出了，而且由于不存在更高层的作用域了，所以 PowerShell 关闭了。 要更明显一点体现这个观点，我们在上述示例脚本中增加一点内容： function abc { &apos;Start&apos; exit 100 &apos;Done&apos; } &apos;Function starts&apos; abc &apos;Function ends&apos; 如您所发现的，“exit”实际上并不是退出 abc 函数，而是退出整个脚本。所以您既见不到“Done”字样也见不到“Function ends”字样。 所以请慎用“exit”语句！它只能用在退出一个脚本并将控制权交还给调用者的时候。 本文国际来源：Why “exit” can kill PowerShell","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 理解 break、continue、return 和 exit 语句","slug":"understanding-break-continue-return-and-exit","date":"2015-04-27T03:00:00.000Z","updated":"2017-03-17T15:26:25.535Z","comments":true,"path":"2015/04/27/understanding-break-continue-return-and-exit/","link":"","permalink":"http://blog.vichamp.com/2015/04/27/understanding-break-continue-return-and-exit/","excerpt":"您是否十分熟悉“break”、“continue”、“return”和“exit”的用法？这些是十分有用的语言概念，以下是一个演示它们不同之处的测试函数： &apos;Starting&apos; function Test-Function { $fishtank = 1..10 Foreach ($fish in $fishtank) { if ($fish -eq 7) { break # &lt;- abort loop #continue # &lt;- skip just this iteration, but continue loop #return # &lt;- abort code, and continue in caller scope #exit # &lt;- abort code at caller scope } &quot;fishing fish #$fish&quot; } &apos;Done.&apos; } Test-Function &apos;Script done!&apos; 只需要去掉某个关键词的注释并运行脚本，就可以观察循环的执行结果。","text":"您是否十分熟悉“break”、“continue”、“return”和“exit”的用法？这些是十分有用的语言概念，以下是一个演示它们不同之处的测试函数： &apos;Starting&apos; function Test-Function { $fishtank = 1..10 Foreach ($fish in $fishtank) { if ($fish -eq 7) { break # &lt;- abort loop #continue # &lt;- skip just this iteration, but continue loop #return # &lt;- abort code, and continue in caller scope #exit # &lt;- abort code at caller scope } &quot;fishing fish #$fish&quot; } &apos;Done.&apos; } Test-Function &apos;Script done!&apos; 只需要去掉某个关键词的注释并运行脚本，就可以观察循环的执行结果。 本文国际来源：Understanding break, continue, return, and exit","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检测危险的 NTFS 权限","slug":"identifying-risky-ntfs-permissions","date":"2015-04-24T03:00:00.000Z","updated":"2017-03-17T15:26:25.524Z","comments":true,"path":"2015/04/24/identifying-risky-ntfs-permissions/","link":"","permalink":"http://blog.vichamp.com/2015/04/24/identifying-risky-ntfs-permissions/","excerpt":"以下是一个查找潜在危险的 NTFS 权限的快速简单的方法。这段脚本检测所有 $pathsToCheck 的文件夹并且汇报错有具有 $dangerousBitMask 中定义的文件系统标志的安全存取控制项（译者注：也就是“路径”）。 在这个例子中，该脚本从您的 %PATH% 环境变量中得到所有查找到的路径。这些路径是高风险的，需要用 NTFS 权限来保护，只能由 Administrators 和 system 拥有写权限。 软件安装程序常常将它们自身加入环境变量而没有正确地保护它们所加入的文件夹权限。这将增加安全风险。以下脚本将检查这些地方并找出哪些有潜在危险的 NTFS 存取权限供您做决定。 # list of paths to check for dangerous NTFS permissions $pathsToCheck = $env:Path -split &apos;;&apos; # these are the bits to watch for # if *any* one of these is set, the folder is reported $dangerousBitsMask = &apos;011010000000101010110&apos; $dangerousBits = [Convert]::ToInt64($dangerousBitsMask, 2) # check all paths... $pathsToCheck | ForEach-Object { $path = $_ # ...get NTFS security descriptor... $acl = Get-Acl -Path $path # ...check for any &quot;dangerous&quot; access right $acl.Access | Where-Object { $_.AccessControlType -eq &apos;Allow&apos; } | Where-Object { ($_.FileSystemRights -band $dangerousBits) -ne 0 } | ForEach-Object { # ...append path information, and display filesystem rights as bitmask $ace = $_ $bitmask = (&apos;0&apos; * 64) + [Convert]::toString([int]$ace.FileSystemRights, 2) $bitmask = $bitmask.Substring($bitmask.length - 64) $ace | Add-Member -MemberType NoteProperty -Name Path -Value $path -PassThru | Add-Member -MemberType NoteProperty -Name Rights -Value $bitmask -PassThru } } | Sort-Object -Property IdentityReference | Select-Object -Property IdentityReference, Path, Rights, FileSystemRights | Out-GridView","text":"以下是一个查找潜在危险的 NTFS 权限的快速简单的方法。这段脚本检测所有 $pathsToCheck 的文件夹并且汇报错有具有 $dangerousBitMask 中定义的文件系统标志的安全存取控制项（译者注：也就是“路径”）。 在这个例子中，该脚本从您的 %PATH% 环境变量中得到所有查找到的路径。这些路径是高风险的，需要用 NTFS 权限来保护，只能由 Administrators 和 system 拥有写权限。 软件安装程序常常将它们自身加入环境变量而没有正确地保护它们所加入的文件夹权限。这将增加安全风险。以下脚本将检查这些地方并找出哪些有潜在危险的 NTFS 存取权限供您做决定。 # list of paths to check for dangerous NTFS permissions $pathsToCheck = $env:Path -split &apos;;&apos; # these are the bits to watch for # if *any* one of these is set, the folder is reported $dangerousBitsMask = &apos;011010000000101010110&apos; $dangerousBits = [Convert]::ToInt64($dangerousBitsMask, 2) # check all paths... $pathsToCheck | ForEach-Object { $path = $_ # ...get NTFS security descriptor... $acl = Get-Acl -Path $path # ...check for any &quot;dangerous&quot; access right $acl.Access | Where-Object { $_.AccessControlType -eq &apos;Allow&apos; } | Where-Object { ($_.FileSystemRights -band $dangerousBits) -ne 0 } | ForEach-Object { # ...append path information, and display filesystem rights as bitmask $ace = $_ $bitmask = (&apos;0&apos; * 64) + [Convert]::toString([int]$ace.FileSystemRights, 2) $bitmask = $bitmask.Substring($bitmask.length - 64) $ace | Add-Member -MemberType NoteProperty -Name Path -Value $path -PassThru | Add-Member -MemberType NoteProperty -Name Rights -Value $bitmask -PassThru } } | Sort-Object -Property IdentityReference | Select-Object -Property IdentityReference, Path, Rights, FileSystemRights | Out-GridView 本文国际来源：Identifying Risky NTFS Permissions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取 IP 地址的地理信息","slug":"get-ip-address-geolocation","date":"2015-04-23T03:00:00.000Z","updated":"2017-03-17T15:26:25.517Z","comments":true,"path":"2015/04/23/get-ip-address-geolocation/","link":"","permalink":"http://blog.vichamp.com/2015/04/23/get-ip-address-geolocation/","excerpt":"您希望知道某个公网 IP 地址位于什么地方吗？假设您有 Internet 连接，您可以查询公共信息服务来获得。 这个例子将获取某个 IP 地址的地理信息。请确认您将示例 IP 地址替换为了实际存在的公网 IP 地址。请打开类似 https://www.whatismyip.com/ 这样的网站来查看您自己的 IP 地址。如果您使用的是一个内网 IP 地址，该 WEB 服务将无法准确地报告地理信息数据。 #requires -Version 3 $ipaddress = &apos;93.212.237.11&apos; $infoService = &quot;http://freegeoip.net/xml/$ipaddress&quot; $geoip = Invoke-RestMethod -Method Get -URI $infoService $geoip.Response","text":"您希望知道某个公网 IP 地址位于什么地方吗？假设您有 Internet 连接，您可以查询公共信息服务来获得。 这个例子将获取某个 IP 地址的地理信息。请确认您将示例 IP 地址替换为了实际存在的公网 IP 地址。请打开类似 https://www.whatismyip.com/ 这样的网站来查看您自己的 IP 地址。如果您使用的是一个内网 IP 地址，该 WEB 服务将无法准确地报告地理信息数据。 #requires -Version 3 $ipaddress = &apos;93.212.237.11&apos; $infoService = &quot;http://freegeoip.net/xml/$ipaddress&quot; $geoip = Invoke-RestMethod -Method Get -URI $infoService $geoip.Response 本文国际来源：Get IP Address Geolocation","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取当前 IP 地址","slug":"get-current-ip-address","date":"2015-04-22T03:00:00.000Z","updated":"2017-03-17T15:26:25.513Z","comments":true,"path":"2015/04/22/get-current-ip-address/","link":"","permalink":"http://blog.vichamp.com/2015/04/22/get-current-ip-address/","excerpt":"以下是一段您计算机绑定的所有 IP 地址的代码： #requires -Version 1 $ipaddress = [System.Net.DNS]::GetHostByName($null) Foreach ($ip in $ipaddress.AddressList) { $ip.IPAddressToString } 如果您将 $null 替换为主机名（例如“server123”），就可以获取对应计算机绑定的 IP 地址。 如果您只需要获取 IPv4 地址，请试试这段代码： #requires -Version 1 $ipaddress = [System.Net.DNS]::GetHostByName($null) foreach($ip in $ipaddress.AddressList) { if ($ip.AddressFamily -eq &apos;InterNetwork&apos;) { $ip.IPAddressToString } }","text":"以下是一段您计算机绑定的所有 IP 地址的代码： #requires -Version 1 $ipaddress = [System.Net.DNS]::GetHostByName($null) Foreach ($ip in $ipaddress.AddressList) { $ip.IPAddressToString } 如果您将 $null 替换为主机名（例如“server123”），就可以获取对应计算机绑定的 IP 地址。 如果您只需要获取 IPv4 地址，请试试这段代码： #requires -Version 1 $ipaddress = [System.Net.DNS]::GetHostByName($null) foreach($ip in $ipaddress.AddressList) { if ($ip.AddressFamily -eq &apos;InterNetwork&apos;) { $ip.IPAddressToString } } 本文国际来源：Get Current IP Address","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 验证域凭据","slug":"validating-domain-credentials","date":"2015-04-21T03:00:00.000Z","updated":"2017-03-17T15:26:25.503Z","comments":true,"path":"2015/04/21/validating-domain-credentials/","link":"","permalink":"http://blog.vichamp.com/2015/04/21/validating-domain-credentials/","excerpt":"要通过当前的域验证凭据（用户名和密码），您可以使用这段代码： #requires -Version 1 $username = &apos;test\\user&apos; $password = &apos;topSecret&apos; $root = &quot;LDAP://&quot; + ([ADSI]&quot;&quot;).distinguishedName $Domain = New-Object System.DirectoryServices.DirectoryEntry($root, $username, $password) if ($Domain.Name -eq $null) { Write-Warning &apos;Credentials incorrect, or computer is not a domain member.&apos; } else { Write-Host &apos;Credentials accepted.&apos; } 总的来说，该脚本首先确认当前域名，然后用提供的凭据来获取根元素。 如果该操作成功完成，说明凭据时合法的。如果失败，说明凭据是无效的，或者该计算机根本没有加入域。","text":"要通过当前的域验证凭据（用户名和密码），您可以使用这段代码： #requires -Version 1 $username = &apos;test\\user&apos; $password = &apos;topSecret&apos; $root = &quot;LDAP://&quot; + ([ADSI]&quot;&quot;).distinguishedName $Domain = New-Object System.DirectoryServices.DirectoryEntry($root, $username, $password) if ($Domain.Name -eq $null) { Write-Warning &apos;Credentials incorrect, or computer is not a domain member.&apos; } else { Write-Host &apos;Credentials accepted.&apos; } 总的来说，该脚本首先确认当前域名，然后用提供的凭据来获取根元素。 如果该操作成功完成，说明凭据时合法的。如果失败，说明凭据是无效的，或者该计算机根本没有加入域。 本文国际来源：Validating Domain Credentials","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 安全使用 UNC 路径","slug":"safely-use-unc-paths","date":"2015-04-20T03:00:00.000Z","updated":"2017-03-17T15:26:25.496Z","comments":true,"path":"2015/04/20/safely-use-unc-paths/","link":"","permalink":"http://blog.vichamp.com/2015/04/20/safely-use-unc-paths/","excerpt":"当您在 PowerShell 中使用 UNC 路径时，您的脚本可能会中断。由于 UNC 路径没有驱动器号，所以 PowerShell 将会在当前目录下查找，并且使用当前路径对应的 PSProvider。 所以如果您的当前目录不是一个文件路径（例如是一个注册表驱动器），那么您的 UNC 路径将会被解释成一个注册表路径。 要安全地使用路径，请一定在 UNC 路径前面加上正确的提供器名称： # UNC-Paths have no drive letter # so PowerShell uses the current directory instead to find the PSProvider # for UNC paths, to be safe, always add the provider name manually $exists = Test-Path -Path &apos;FileSystem::\\\\server12\\fileshare&apos; $exists","text":"当您在 PowerShell 中使用 UNC 路径时，您的脚本可能会中断。由于 UNC 路径没有驱动器号，所以 PowerShell 将会在当前目录下查找，并且使用当前路径对应的 PSProvider。 所以如果您的当前目录不是一个文件路径（例如是一个注册表驱动器），那么您的 UNC 路径将会被解释成一个注册表路径。 要安全地使用路径，请一定在 UNC 路径前面加上正确的提供器名称： # UNC-Paths have no drive letter # so PowerShell uses the current directory instead to find the PSProvider # for UNC paths, to be safe, always add the provider name manually $exists = Test-Path -Path &apos;FileSystem::\\\\server12\\fileshare&apos; $exists 本文国际来源：Safely Use UNC Paths","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 Splatting 技术","slug":"using-splatting","date":"2015-04-17T03:00:00.000Z","updated":"2017-03-17T15:26:25.494Z","comments":true,"path":"2015/04/17/using-splatting/","link":"","permalink":"http://blog.vichamp.com/2015/04/17/using-splatting/","excerpt":"通过 splatting 技术，您可以调用 cmdlet，并可以控制提交的参数。 要实现该目标，先向一个哈希表插入参数和值，然后将哈希表传给 cmdlet。这种方法适用于任意 cmdlet。 以下是一个例子： # classic: Get-ChildItem -Path c:\\windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue # Splatting $params = @{} $params.Path = &apos;c:\\windows&apos; $params.Filter = &apos;*.ps1&apos; $params.Recurse = $true $params.ErrorAction = &apos;SilentlyContinue&apos; Get-ChildItem @params","text":"通过 splatting 技术，您可以调用 cmdlet，并可以控制提交的参数。 要实现该目标，先向一个哈希表插入参数和值，然后将哈希表传给 cmdlet。这种方法适用于任意 cmdlet。 以下是一个例子： # classic: Get-ChildItem -Path c:\\windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue # Splatting $params = @{} $params.Path = &apos;c:\\windows&apos; $params.Filter = &apos;*.ps1&apos; $params.Recurse = $true $params.ErrorAction = &apos;SilentlyContinue&apos; Get-ChildItem @params 本文国际来源：Using Splatting","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 读取 RSS 频道","slug":"reading-rss-feeds","date":"2015-04-16T03:00:00.000Z","updated":"2017-03-17T15:26:25.490Z","comments":true,"path":"2015/04/16/reading-rss-feeds/","link":"","permalink":"http://blog.vichamp.com/2015/04/16/reading-rss-feeds/","excerpt":"我们可以通过 XML 对象来读取 RSS 频道信息，然而 XML 对象不支持代理服务器。 这个例子用 Invoke-WebRequest 通过代理服务器来获取 RSS 数据（如果忽略 -Proxy 参数则直接获取），然后将结果转换为 XML。 #requires -Version 3 $url = &apos;http://blogs.msdn.com/b/powershell/rss.aspx&apos; $page = Invoke-WebRequest -Uri $url &lt;#-Proxy &apos;http://proxy...:8080&apos; -ProxyUseDefaultCredentials#&gt; $content = $page.Content $xml = [XML]$content $xml.rss.channel.item | Out-GridView 这段代码将显示 PowerShell 团队博客数据。","text":"我们可以通过 XML 对象来读取 RSS 频道信息，然而 XML 对象不支持代理服务器。 这个例子用 Invoke-WebRequest 通过代理服务器来获取 RSS 数据（如果忽略 -Proxy 参数则直接获取），然后将结果转换为 XML。 #requires -Version 3 $url = &apos;http://blogs.msdn.com/b/powershell/rss.aspx&apos; $page = Invoke-WebRequest -Uri $url &lt;#-Proxy &apos;http://proxy...:8080&apos; -ProxyUseDefaultCredentials#&gt; $content = $page.Content $xml = [XML]$content $xml.rss.channel.item | Out-GridView 这段代码将显示 PowerShell 团队博客数据。 本文国际来源：Reading RSS Feeds","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 读取注册表键值和值类型","slug":"getting-registry-values-and-value-types","date":"2015-04-15T03:00:00.000Z","updated":"2017-03-17T15:26:25.483Z","comments":true,"path":"2015/04/15/getting-registry-values-and-value-types/","link":"","permalink":"http://blog.vichamp.com/2015/04/15/getting-registry-values-and-value-types/","excerpt":"Get-ItemProperty 可以方便地读取注册表键值，但是无法获得注册表键值的数据类型。 Get-ItemProperty -Path &apos;HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion&apos; 以下是通过 .NET 方法的另一种实现，可以获得所有的信息： PS&gt; Get-RegistryValue &apos;HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion&apos; Name Type Value ---- ---- ----- CurrentVersion String 6.1 CurrentBuild String 7601 SoftwareType String System CurrentType String Multiprocessor Free InstallDate DWord 1326015519 RegisteredOrganization String RegisteredOwner String Tobias SystemRoot String C:\\Windows InstallationType String Client EditionID String Ultimate ProductName String Windows 7 Ultimate ProductId String 0042xxx657 DigitalProductId Binary {164, 0, 0, 0...} DigitalProductId4 Binary {248, 4, 0, 0...} CurrentBuildNumber String 7601 BuildLab String 7601.win7sp1_gdr.150202-1526 BuildLabEx String 7601.18741.amd64fre.win7sp1_gdr.150202-1526 BuildGUID String f974f16b-3e62-4136-a6fb-64fccddecde3 CSDBuildNumber String 1130 PathName String C:\\Windows 我们需要开发一个 Get-RegistryValue 函数来实现该功能。请注意该函数可传入任意合法的注册表键，并且不需要使用 PowerShell 驱动器号。 function Get-RegistryValue { param ( [Parameter(Mandatory = $true)] $RegistryKey ) $key = Get-Item -Path &quot;Registry::$RegistryKey&quot; $key.GetValueNames() | ForEach-Object { $name = $_ $rv = 1 | Select-Object -Property Name, Type, Value $rv.Name = $name $rv.Type = $key.GetValueKind($name) $rv.Value = $key.GetValue($name) $rv } }","text":"Get-ItemProperty 可以方便地读取注册表键值，但是无法获得注册表键值的数据类型。 Get-ItemProperty -Path &apos;HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion&apos; 以下是通过 .NET 方法的另一种实现，可以获得所有的信息： PS&gt; Get-RegistryValue &apos;HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion&apos; Name Type Value ---- ---- ----- CurrentVersion String 6.1 CurrentBuild String 7601 SoftwareType String System CurrentType String Multiprocessor Free InstallDate DWord 1326015519 RegisteredOrganization String RegisteredOwner String Tobias SystemRoot String C:\\Windows InstallationType String Client EditionID String Ultimate ProductName String Windows 7 Ultimate ProductId String 0042xxx657 DigitalProductId Binary {164, 0, 0, 0...} DigitalProductId4 Binary {248, 4, 0, 0...} CurrentBuildNumber String 7601 BuildLab String 7601.win7sp1_gdr.150202-1526 BuildLabEx String 7601.18741.amd64fre.win7sp1_gdr.150202-1526 BuildGUID String f974f16b-3e62-4136-a6fb-64fccddecde3 CSDBuildNumber String 1130 PathName String C:\\Windows 我们需要开发一个 Get-RegistryValue 函数来实现该功能。请注意该函数可传入任意合法的注册表键，并且不需要使用 PowerShell 驱动器号。 function Get-RegistryValue { param ( [Parameter(Mandatory = $true)] $RegistryKey ) $key = Get-Item -Path &quot;Registry::$RegistryKey&quot; $key.GetValueNames() | ForEach-Object { $name = $_ $rv = 1 | Select-Object -Property Name, Type, Value $rv.Name = $name $rv.Type = $key.GetValueKind($name) $rv.Value = $key.GetValue($name) $rv } } 本文国际来源：Getting Registry Values and Value Types","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找电视剧信息","slug":"finding-information-about-tv-series","date":"2015-04-14T03:00:00.000Z","updated":"2017-03-17T15:26:25.473Z","comments":true,"path":"2015/04/14/finding-information-about-tv-series/","link":"","permalink":"http://blog.vichamp.com/2015/04/14/finding-information-about-tv-series/","excerpt":"PowerShell 可以查询基于 XML 内容的网站，以下是一个查询电影数据库的例子： 只需要输入您感兴趣的电视剧名称即可。如果您不能直接访问 Internet，可以用 -Proxy 参数指定代理服务器。 #requires -Version 3 $name = &apos;stargate&apos; $url = &quot;http://thetvdb.com/api/GetSeries.php?seriesname=$name&amp;language=en&quot; $page = Invoke-WebRequest -Uri $url &lt;#-Proxy &apos;http://proxy....:8080&apos; -ProxyUseDefaultCredentials#&gt; $content = $page.Content $xml = [XML]$content $xml.Data.Series | Out-GridView","text":"PowerShell 可以查询基于 XML 内容的网站，以下是一个查询电影数据库的例子： 只需要输入您感兴趣的电视剧名称即可。如果您不能直接访问 Internet，可以用 -Proxy 参数指定代理服务器。 #requires -Version 3 $name = &apos;stargate&apos; $url = &quot;http://thetvdb.com/api/GetSeries.php?seriesname=$name&amp;language=en&quot; $page = Invoke-WebRequest -Uri $url &lt;#-Proxy &apos;http://proxy....:8080&apos; -ProxyUseDefaultCredentials#&gt; $content = $page.Content $xml = [XML]$content $xml.Data.Series | Out-GridView 本文国际来源：Finding Information about TV Series","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"ionic 问答","slug":"ionic-qa","date":"2015-04-14T02:51:44.000Z","updated":"2017-03-17T15:26:25.474Z","comments":true,"path":"2015/04/14/ionic-qa/","link":"","permalink":"http://blog.vichamp.com/2015/04/14/ionic-qa/","excerpt":"","text":"Q: 使用 CSS 还是 ion- 指令A: Ion vs div directives - Ionic CSS 优势： 性能 DOM 干净 ion- 指令优势： 功能更强，例如 ion-list 的 show-reorder 等 API 结论：只是要样式，用 CSS；需要增强的 API 功能，用 ion- 指令。","categories":[{"name":"ionic","slug":"ionic","permalink":"http://blog.vichamp.com/categories/ionic/"}],"tags":[{"name":"ionic","slug":"ionic","permalink":"http://blog.vichamp.com/tags/ionic/"},{"name":"front-end","slug":"front-end","permalink":"http://blog.vichamp.com/tags/front-end/"}],"keywords":[{"name":"ionic","slug":"ionic","permalink":"http://blog.vichamp.com/categories/ionic/"}]},{"title":"PowerShell 技能连载 - 比较文件夹内容","slug":"comparing-folder-content","date":"2015-04-13T03:00:00.000Z","updated":"2017-03-17T15:26:25.456Z","comments":true,"path":"2015/04/13/comparing-folder-content/","link":"","permalink":"http://blog.vichamp.com/2015/04/13/comparing-folder-content/","excerpt":"要快速比较文件夹内容并且找出只在一个文件夹中存在的文件，请试试以下代码： $list1 = Get-ChildItem c:\\Windows\\system32 | Sort-Object -Property Name $list2 = Get-ChildItem \\\\server12\\c$\\windows\\system32 | Sort-Object -Property Name Compare-Object -ReferenceObject $list1 -DifferenceObject $list2 -Property Name | Sort-Object -Property Name 该代码属两个文件夹列表，一个来自本机，另一个来自远程计算机。接下来 Compare-Object 命令会挑出只在一个文件夹中存在的文件。","text":"要快速比较文件夹内容并且找出只在一个文件夹中存在的文件，请试试以下代码： $list1 = Get-ChildItem c:\\Windows\\system32 | Sort-Object -Property Name $list2 = Get-ChildItem \\\\server12\\c$\\windows\\system32 | Sort-Object -Property Name Compare-Object -ReferenceObject $list1 -DifferenceObject $list2 -Property Name | Sort-Object -Property Name 该代码属两个文件夹列表，一个来自本机，另一个来自远程计算机。接下来 Compare-Object 命令会挑出只在一个文件夹中存在的文件。 本文国际来源：Comparing Folder Content","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 批量重命名文件","slug":"bulk-re-naming-files","date":"2015-04-10T03:00:00.000Z","updated":"2017-03-17T15:26:25.453Z","comments":true,"path":"2015/04/10/bulk-re-naming-files/","link":"","permalink":"http://blog.vichamp.com/2015/04/10/bulk-re-naming-files/","excerpt":"假设您有一整个文件夹的图片文件，并希望它们的名字标准化。 这个脚本演示了如何批量重命名图片文件： $i = 0 Get-ChildItem -Path c:\\pictures -Filter *.jpg | ForEach-Object { $extension = $_.Extension $newName = &apos;pic_{0:d6}{1}&apos; -f $i, $extension $i++ Rename-Item -Path $_.FullName -NewName $newName } 文件夹中所有的 JPG 文件都被重命名了。新的文件名是“pic_”加上四位数字。 您可以很容易地修改脚本来重命名其它类型的文件，或是使用其它文件名模板。","text":"假设您有一整个文件夹的图片文件，并希望它们的名字标准化。 这个脚本演示了如何批量重命名图片文件： $i = 0 Get-ChildItem -Path c:\\pictures -Filter *.jpg | ForEach-Object { $extension = $_.Extension $newName = &apos;pic_{0:d6}{1}&apos; -f $i, $extension $i++ Rename-Item -Path $_.FullName -NewName $newName } 文件夹中所有的 JPG 文件都被重命名了。新的文件名是“pic_”加上四位数字。 您可以很容易地修改脚本来重命名其它类型的文件，或是使用其它文件名模板。 本文国际来源：Bulk Renaming Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 对密码加密","slug":"encoded-passwords","date":"2015-04-09T03:00:00.000Z","updated":"2017-03-17T15:26:25.450Z","comments":true,"path":"2015/04/09/encoded-passwords/","link":"","permalink":"http://blog.vichamp.com/2015/04/09/encoded-passwords/","excerpt":"如果您确实需要在脚本中保存一个凭据对象，以下是将一个安全字符串转换为加密文本的方法： $password = Read-Host -Prompt &apos;Enter Password&apos; -AsSecureString $encrypted = $password | ConvertFrom-SecureString $encrypted | clip.exe $encrypted 当运行这段代码时，会要求您输入密码。接下来密码会被转换为一系列字符并存入剪贴板中。加密的密钥是您的身份标识加上您的机器标识，所以只能用相同机器的相同用户对密码解密。 下一步，用这段代码可以将您的密码密文转换为凭据对象： $secret = &apos;01000000d08c9ddf0115d1118c7a00c04fc297eb01000000d4a6c6bfcbbb75418de6e9672d85e73600...996f8365c8c82ea61f94927d3e3b14000000c6aecec683717376f0fb18519f326f6ac9cd89dc&apos; $username = &apos;test\\user&apos; $password = $secret | ConvertTo-SecureString $credential = New-Object -TypeName System.Management.Automation.PSCredential($username, $password) # example call Start-Process notepad -Credential $credential -WorkingDirectory c:\\ 将加密的密码字符串写入脚本中，然后使用指定的用户名来验证身份。 现在，$cred 中保存的凭据对象可以在任何支持 -Credential 参数的 cmdlet 或函数中使用了。","text":"如果您确实需要在脚本中保存一个凭据对象，以下是将一个安全字符串转换为加密文本的方法： $password = Read-Host -Prompt &apos;Enter Password&apos; -AsSecureString $encrypted = $password | ConvertFrom-SecureString $encrypted | clip.exe $encrypted 当运行这段代码时，会要求您输入密码。接下来密码会被转换为一系列字符并存入剪贴板中。加密的密钥是您的身份标识加上您的机器标识，所以只能用相同机器的相同用户对密码解密。 下一步，用这段代码可以将您的密码密文转换为凭据对象： $secret = &apos;01000000d08c9ddf0115d1118c7a00c04fc297eb01000000d4a6c6bfcbbb75418de6e9672d85e73600...996f8365c8c82ea61f94927d3e3b14000000c6aecec683717376f0fb18519f326f6ac9cd89dc&apos; $username = &apos;test\\user&apos; $password = $secret | ConvertTo-SecureString $credential = New-Object -TypeName System.Management.Automation.PSCredential($username, $password) # example call Start-Process notepad -Credential $credential -WorkingDirectory c:\\ 将加密的密码字符串写入脚本中，然后使用指定的用户名来验证身份。 现在，$cred 中保存的凭据对象可以在任何支持 -Credential 参数的 cmdlet 或函数中使用了。 本文国际来源：Encoded Passwords","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找所有活动的驱动器号","slug":"find-all-active-drive-letters","date":"2015-04-08T03:00:00.000Z","updated":"2017-03-17T15:26:25.443Z","comments":true,"path":"2015/04/08/find-all-active-drive-letters/","link":"","permalink":"http://blog.vichamp.com/2015/04/08/find-all-active-drive-letters/","excerpt":"要快速地获取所有驱动器号，请使用以下代码： #requires -Version 1 [Environment]::GetLogicalDrives() 执行结果是所有活动的驱动器号： PS&gt; C:\\ D:\\ E:\\ F:\\ G:\\","text":"要快速地获取所有驱动器号，请使用以下代码： #requires -Version 1 [Environment]::GetLogicalDrives() 执行结果是所有活动的驱动器号： PS&gt; C:\\ D:\\ E:\\ F:\\ G:\\ 本文国际来源：Find All Active Drive Letters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用口令对文本信息加密","slug":"encrypting-text-information-using-passphrase","date":"2015-04-07T03:00:00.000Z","updated":"2017-03-17T15:26:25.435Z","comments":true,"path":"2015/04/07/encrypting-text-information-using-passphrase/","link":"","permalink":"http://blog.vichamp.com/2015/04/07/encrypting-text-information-using-passphrase/","excerpt":"适用于 PowerShell 3.0 及以上版本 在前一个技能中，我们介绍了如何使用 Windows 注册表中的 Windows 产品序列号来加密文本信息。 如果您觉得这种方式不够安全，那么可以使用自己指定的密钥来加密。以下例子演示了如何使用密码作为加密密钥： $Path = &quot;$env:temp\\secret.txt&quot; $Secret = &apos;Hello World!&apos; $Passphrase = &apos;Some secret key&apos; $key = [Byte[]]($Passphrase.PadRight(24).Substring(0,24).ToCharArray()) $Secret | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString -Key $key | Out-File -FilePath $Path notepad $Path 要解密一段密文，您需要知道对应的密码： $Passphrase = Read-Host &apos;Enter the secret pass phrase&apos; $Path = &quot;$env:temp\\secret.txt&quot; $key = [Byte[]]($Passphrase.PadRight(24).Substring(0,24).ToCharArray()) try { $decryptedTextSecureString = Get-Content -Path $Path -Raw | ConvertTo-SecureString -Key $key -ErrorAction Stop $cred = New-Object -TypeName System.Management.Automation.PSCredential(&apos;dummy&apos;, $decryptedTextSecureString) $decryptedText = $cred.GetNetworkCredential().Password } catch { $decryptedText = &apos;(wrong key)&apos; } &quot;The decrypted secret text: $decryptedText&quot;","text":"适用于 PowerShell 3.0 及以上版本 在前一个技能中，我们介绍了如何使用 Windows 注册表中的 Windows 产品序列号来加密文本信息。 如果您觉得这种方式不够安全，那么可以使用自己指定的密钥来加密。以下例子演示了如何使用密码作为加密密钥： $Path = &quot;$env:temp\\secret.txt&quot; $Secret = &apos;Hello World!&apos; $Passphrase = &apos;Some secret key&apos; $key = [Byte[]]($Passphrase.PadRight(24).Substring(0,24).ToCharArray()) $Secret | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString -Key $key | Out-File -FilePath $Path notepad $Path 要解密一段密文，您需要知道对应的密码： $Passphrase = Read-Host &apos;Enter the secret pass phrase&apos; $Path = &quot;$env:temp\\secret.txt&quot; $key = [Byte[]]($Passphrase.PadRight(24).Substring(0,24).ToCharArray()) try { $decryptedTextSecureString = Get-Content -Path $Path -Raw | ConvertTo-SecureString -Key $key -ErrorAction Stop $cred = New-Object -TypeName System.Management.Automation.PSCredential(&apos;dummy&apos;, $decryptedTextSecureString) $decryptedText = $cred.GetNetworkCredential().Password } catch { $decryptedText = &apos;(wrong key)&apos; } &quot;The decrypted secret text: $decryptedText&quot; 本文国际来源：Encrypting Text Information Using Passphrase","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 Windows 加密信息","slug":"encrypting-information-with-windows-productid","date":"2015-04-06T03:00:00.000Z","updated":"2017-03-17T15:26:25.432Z","comments":true,"path":"2015/04/06/encrypting-information-with-windows-productid/","link":"","permalink":"http://blog.vichamp.com/2015/04/06/encrypting-information-with-windows-productid/","excerpt":"适用于 PowerShell 3.0 及以上版本 要存储机密信息，您可以使用 SecureString 对象将其保存到磁盘上。PowerShell 自动使用用户账户作为密钥，所以只有保存该信息的用户可以读取它。 如果您希望该机密信息不绑定到特定的用户，而是绑定到某台机器，您可以使用 Windows 产品序列号作为密钥。请注意这并不是特别安全，因为密钥在 Windows 注册表中时公开可见的。它还有个使用前提是 Windows 是使用合法产品序列号安装的。 以下这段代码接受任意文本信息，然后用 Windows 产品序列号对它进行加密并保存到磁盘上： $Path = &quot;$env:temp\\secret.txt&quot; $Secret = &apos;Hello World!&apos; $regKey = Get-ItemProperty &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&apos; -Name DigitalProductID $encryptionKey = $regKey.DigitalProductID $Secret | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString -Key ($encryptionKey[0..23]) | Out-File -FilePath $Path notepad $Path 这是对加密的文本进行解密的代码： $Path = &quot;$env:temp\\secret.txt&quot; $regKey = Get-ItemProperty &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&apos; -Name DigitalProductID $encryptionKey = $regKey.DigitalProductID $decryptedTextSecureString = Get-Content -Path $Path -Raw | ConvertTo-SecureString -Key ($secureKey[0..23]) $cred = New-Object -TypeName System.Management.Automation.PSCredential(&apos;dummy&apos;, $decryptedTextSecureString) $decryptedText = $cred.GetNetworkCredential().Password &quot;The decrypted secret text: $decryptedText&quot; 请注意如何 PSCredential 对象来对密文进行解密并还原出明文的。","text":"适用于 PowerShell 3.0 及以上版本 要存储机密信息，您可以使用 SecureString 对象将其保存到磁盘上。PowerShell 自动使用用户账户作为密钥，所以只有保存该信息的用户可以读取它。 如果您希望该机密信息不绑定到特定的用户，而是绑定到某台机器，您可以使用 Windows 产品序列号作为密钥。请注意这并不是特别安全，因为密钥在 Windows 注册表中时公开可见的。它还有个使用前提是 Windows 是使用合法产品序列号安装的。 以下这段代码接受任意文本信息，然后用 Windows 产品序列号对它进行加密并保存到磁盘上： $Path = &quot;$env:temp\\secret.txt&quot; $Secret = &apos;Hello World!&apos; $regKey = Get-ItemProperty &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&apos; -Name DigitalProductID $encryptionKey = $regKey.DigitalProductID $Secret | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString -Key ($encryptionKey[0..23]) | Out-File -FilePath $Path notepad $Path 这是对加密的文本进行解密的代码： $Path = &quot;$env:temp\\secret.txt&quot; $regKey = Get-ItemProperty &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&apos; -Name DigitalProductID $encryptionKey = $regKey.DigitalProductID $decryptedTextSecureString = Get-Content -Path $Path -Raw | ConvertTo-SecureString -Key ($secureKey[0..23]) $cred = New-Object -TypeName System.Management.Automation.PSCredential(&apos;dummy&apos;, $decryptedTextSecureString) $decryptedText = $cred.GetNetworkCredential().Password &quot;The decrypted secret text: $decryptedText&quot; 请注意如何 PSCredential 对象来对密文进行解密并还原出明文的。 本文国际来源：Encrypting Information with Windows ProductID","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找 Exchange 邮箱","slug":"finding-exchange-mailboxes","date":"2015-04-03T03:00:00.000Z","updated":"2017-03-17T15:26:25.428Z","comments":true,"path":"2015/04/03/finding-exchange-mailboxes/","link":"","permalink":"http://blog.vichamp.com/2015/04/03/finding-exchange-mailboxes/","excerpt":"适用于 Microsoft Exchange 2013 要查看邮箱的个数，只需要使用 Exchange cmdlet 并且用 Measure-Object 来统计结果： Get-Mailbox –ResultSize Unlimited | Measure-Object | Select-Object -ExpandProperty Count 类似地，要查看所有共享的邮箱，使用这段代码： Get-Mailbox –ResultSize Unlimited -RecipientTypeDetails SharedMailbox | Measure-Object | Select-Object -ExpandProperty Count 若要只查看用户邮箱，需要稍微调整一下： Get-Mailbox –ResultSize Unlimited -RecipientTypeDetails UserMailbox | Measure-Object | Select-Object -ExpandProperty Count","text":"适用于 Microsoft Exchange 2013 要查看邮箱的个数，只需要使用 Exchange cmdlet 并且用 Measure-Object 来统计结果： Get-Mailbox –ResultSize Unlimited | Measure-Object | Select-Object -ExpandProperty Count 类似地，要查看所有共享的邮箱，使用这段代码： Get-Mailbox –ResultSize Unlimited -RecipientTypeDetails SharedMailbox | Measure-Object | Select-Object -ExpandProperty Count 若要只查看用户邮箱，需要稍微调整一下： Get-Mailbox –ResultSize Unlimited -RecipientTypeDetails UserMailbox | Measure-Object | Select-Object -ExpandProperty Count 本文国际来源：Finding Exchange Mailboxes","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 智能参数验证","slug":"clever-parameter-validation","date":"2015-04-02T03:00:00.000Z","updated":"2017-03-17T15:26:25.425Z","comments":true,"path":"2015/04/02/clever-parameter-validation/","link":"","permalink":"http://blog.vichamp.com/2015/04/02/clever-parameter-validation/","excerpt":"适用于 PowerShell 2.0 及以上版本 当您用 PowerShell 创建带参数的函数时，请明确地告知 PowerShell 该参数的类型。 这是一个简单的例子，您需要输入一个星期数： function Get-Weekday { param ( $Weekday ) &quot;You chose $Weekday&quot; } 用户可以传入任何东西，不仅是正常的星期数： PS&gt; Get-Weekday -Weekday NoWeekday You chose NoWeekday 有些时候，您可能会看到用正则表达式实现的验证器： function Get-Weekday { param ( [ValidatePattern(&apos;Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday&apos;)] $Weekday ) &quot;You chose $Weekday&quot; } 现在，用户的输入被限定在了这些模式中，如果输入的值不符合正则表达式的模式，PowerShell 将会抛出一个异常。然而，错误信息并不是很有用，并且用户输入的时候并不能享受到智能提示的便利。 一个更好的方法是使用验证集合： function Get-Weekday { param ( [ValidateSet(&apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;, &apos;Sunday&apos;)] $Weekday ) &quot;You chose $Weekday&quot; } 现在，用户只能输入您允许的值，并且用户在 PowerShell ISE 中输入的时候会获得智能提示信息，显示允许输入的值。 如果您了解您期望值对应的 .NET 的枚举类型，那么可以更简单地将该类型绑定到参数上： function Get-Weekday { param ( [System.DayOfWeek] $Weekday ) &quot;You chose $Weekday&quot; }","text":"适用于 PowerShell 2.0 及以上版本 当您用 PowerShell 创建带参数的函数时，请明确地告知 PowerShell 该参数的类型。 这是一个简单的例子，您需要输入一个星期数： function Get-Weekday { param ( $Weekday ) &quot;You chose $Weekday&quot; } 用户可以传入任何东西，不仅是正常的星期数： PS&gt; Get-Weekday -Weekday NoWeekday You chose NoWeekday 有些时候，您可能会看到用正则表达式实现的验证器： function Get-Weekday { param ( [ValidatePattern(&apos;Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday&apos;)] $Weekday ) &quot;You chose $Weekday&quot; } 现在，用户的输入被限定在了这些模式中，如果输入的值不符合正则表达式的模式，PowerShell 将会抛出一个异常。然而，错误信息并不是很有用，并且用户输入的时候并不能享受到智能提示的便利。 一个更好的方法是使用验证集合： function Get-Weekday { param ( [ValidateSet(&apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;, &apos;Sunday&apos;)] $Weekday ) &quot;You chose $Weekday&quot; } 现在，用户只能输入您允许的值，并且用户在 PowerShell ISE 中输入的时候会获得智能提示信息，显示允许输入的值。 如果您了解您期望值对应的 .NET 的枚举类型，那么可以更简单地将该类型绑定到参数上： function Get-Weekday { param ( [System.DayOfWeek] $Weekday ) &quot;You chose $Weekday&quot; } 本文国际来源：Clever Parameter Validation","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 发现高影响级别 cmdlet","slug":"discovering-high-impact-cmdlets","date":"2015-04-01T03:00:00.000Z","updated":"2017-03-17T15:26:25.416Z","comments":true,"path":"2015/04/01/discovering-high-impact-cmdlets/","link":"","permalink":"http://blog.vichamp.com/2015/04/01/discovering-high-impact-cmdlets/","excerpt":"适用于 PowerShell 所有版本 cmdlet 可以定义它们的影响力有多大。通常，那些会对系统造成不可恢复影响的 cmdlet 的“影响级别”设置为“高”。 当您运行这样一个 cmdlet 时，PowerShell 将会弹出一个确认对话框，防止您不小心误操作。确认对话框也能防止您在无人值守的情况下运行这些 cmdlet。 要查看 cmdlet 的“影响级别”为多高，可以用这段代码输出该信息： Get-Command -CommandType Cmdlet | ForEach-Object { $type = $_.ImplementingType if ($type -ne $null) { $type.GetCustomAttributes($true) | Where-Object { $_.VerbName -ne $null } | Select-Object @{Name=&apos;Name&apos;; Expression={&apos;{0}-{1}&apos; -f $_.VerbName, $_.NounName}}, ConfirmImpact } } | Sort-Object ConfirmImpact -Descending 要只查看影响级别为“高”的 cmdlet，只需要加一个过滤器： Get-Command -CommandType Cmdlet | ForEach-Object { $type = $_.ImplementingType if ($type -ne $null) { $type.GetCustomAttributes($true) | Where-Object { $_.VerbName -ne $null } | Select-Object @{Name=&apos;Name&apos;; Expression={&apos;{0}-{1}&apos; -f $_.VerbName, $_.NounName}}, ConfirmImpact } } | Sort-Object ConfirmImpact -Descending | Where-Object { $_.ConfirmImpact -eq &apos;High&apos; } 要以无人值守的方式运行这些 cmdlet 并且不让自动提示框出现，请加上 -Confirm:$False 参数。","text":"适用于 PowerShell 所有版本 cmdlet 可以定义它们的影响力有多大。通常，那些会对系统造成不可恢复影响的 cmdlet 的“影响级别”设置为“高”。 当您运行这样一个 cmdlet 时，PowerShell 将会弹出一个确认对话框，防止您不小心误操作。确认对话框也能防止您在无人值守的情况下运行这些 cmdlet。 要查看 cmdlet 的“影响级别”为多高，可以用这段代码输出该信息： Get-Command -CommandType Cmdlet | ForEach-Object { $type = $_.ImplementingType if ($type -ne $null) { $type.GetCustomAttributes($true) | Where-Object { $_.VerbName -ne $null } | Select-Object @{Name=&apos;Name&apos;; Expression={&apos;{0}-{1}&apos; -f $_.VerbName, $_.NounName}}, ConfirmImpact } } | Sort-Object ConfirmImpact -Descending 要只查看影响级别为“高”的 cmdlet，只需要加一个过滤器： Get-Command -CommandType Cmdlet | ForEach-Object { $type = $_.ImplementingType if ($type -ne $null) { $type.GetCustomAttributes($true) | Where-Object { $_.VerbName -ne $null } | Select-Object @{Name=&apos;Name&apos;; Expression={&apos;{0}-{1}&apos; -f $_.VerbName, $_.NounName}}, ConfirmImpact } } | Sort-Object ConfirmImpact -Descending | Where-Object { $_.ConfirmImpact -eq &apos;High&apos; } 要以无人值守的方式运行这些 cmdlet 并且不让自动提示框出现，请加上 -Confirm:$False 参数。 本文国际来源：Discovering High Impact Cmdlets","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - ISE 自动完成技巧","slug":"ise-auto-completion-trick","date":"2015-03-31T03:00:00.000Z","updated":"2017-03-17T15:26:25.413Z","comments":true,"path":"2015/03/31/ise-auto-completion-trick/","link":"","permalink":"http://blog.vichamp.com/2015/03/31/ise-auto-completion-trick/","excerpt":"适用于 PowerShell 3.0 ISE 及以上版本 当您希望选择某个 cmdlet 返回的信息时，通常使用的是 Select-Object： Get-Process | Select-Object -Property Name, Company, Description 然而，您需要手工键入希望显示的属性名。当您键入“-Property”之后并不会弹出智能提示。 一个不为人知的技巧是按下 CTRL+SPACE 来手动显示智能提示菜单。如您所见，PowerShell 会开心地提供所有属性的列表，前提是上一级的 cmdlet 定义了输出的类型。 要选择多余一个属性，在键入逗号之后，再次按下 CTRL+SPACE 即可。","text":"适用于 PowerShell 3.0 ISE 及以上版本 当您希望选择某个 cmdlet 返回的信息时，通常使用的是 Select-Object： Get-Process | Select-Object -Property Name, Company, Description 然而，您需要手工键入希望显示的属性名。当您键入“-Property”之后并不会弹出智能提示。 一个不为人知的技巧是按下 CTRL+SPACE 来手动显示智能提示菜单。如您所见，PowerShell 会开心地提供所有属性的列表，前提是上一级的 cmdlet 定义了输出的类型。 要选择多余一个属性，在键入逗号之后，再次按下 CTRL+SPACE 即可。 本文国际来源：ISE Auto-Completion Trick","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 访问非 Microsoft LDAP 服务","slug":"accessing-non-microsoft-ldap-servers","date":"2015-03-30T03:00:00.000Z","updated":"2017-03-17T15:26:25.410Z","comments":true,"path":"2015/03/30/accessing-non-microsoft-ldap-servers/","link":"","permalink":"http://blog.vichamp.com/2015/03/30/accessing-non-microsoft-ldap-servers/","excerpt":"适用于 PowerShell 所有版本 Microsoft 和 Dell 提供了一些 Active Directory 的免费 cmdlet，分别是 RSAT 工具和 Quest 的一部分。它们使访问域控制器变得更简单。 要访问一个非 Microsoft 的 LDAP 服务器，由于没有现成的 cmdlet，所以可以使用 .NET 框架的功能。 以下是一些示例代码，演示了如何连接这种 LDAP 服务器，提交 LDAP 查询，并且获取信息。 该脚本假设 LDAP 服务器架设在 192.168.1.1 的 389 端口，是“mycompany.com”域的一部分，有一个名为“SomeGroup”的工作组。该脚本列出该工作组的用户账户： $LDAPDirectoryService = &apos;192.168.1.1:389&apos; $DomainDN = &apos;dc=mycompany,dc=com&apos; $LDAPFilter = &apos;(&amp;(cn=SomeGroup))&apos; $null = [System.Reflection.Assembly]::LoadWithPartialName(&apos;System.DirectoryServices.Protocols&apos;) $null = [System.Reflection.Assembly]::LoadWithPartialName(&apos;System.Net&apos;) $LDAPServer = New-Object System.DirectoryServices.Protocols.LdapConnection $LDAPDirectoryService $LDAPServer.AuthType = [System.DirectoryServices.Protocols.AuthType]::Anonymous $LDAPServer.SessionOptions.ProtocolVersion = 3 $LDAPServer.SessionOptions.SecureSocketLayer =$false $Scope = [System.DirectoryServices.Protocols.SearchScope]::Subtree $AttributeList = @(&apos;*&apos;) $SearchRequest = New-Object System.DirectoryServices.Protocols.SearchRequest -ArgumentList $DomainDN,$LDAPFilter,$Scope,$AttributeList $groups = $LDAPServer.SendRequest($SearchRequest) foreach ($group in $groups.Entries) { $users=$group.attributes[&apos;memberUid&apos;].GetValues(&apos;string&apos;) foreach ($user in $users) { Write-Host $user } }","text":"适用于 PowerShell 所有版本 Microsoft 和 Dell 提供了一些 Active Directory 的免费 cmdlet，分别是 RSAT 工具和 Quest 的一部分。它们使访问域控制器变得更简单。 要访问一个非 Microsoft 的 LDAP 服务器，由于没有现成的 cmdlet，所以可以使用 .NET 框架的功能。 以下是一些示例代码，演示了如何连接这种 LDAP 服务器，提交 LDAP 查询，并且获取信息。 该脚本假设 LDAP 服务器架设在 192.168.1.1 的 389 端口，是“mycompany.com”域的一部分，有一个名为“SomeGroup”的工作组。该脚本列出该工作组的用户账户： $LDAPDirectoryService = &apos;192.168.1.1:389&apos; $DomainDN = &apos;dc=mycompany,dc=com&apos; $LDAPFilter = &apos;(&amp;(cn=SomeGroup))&apos; $null = [System.Reflection.Assembly]::LoadWithPartialName(&apos;System.DirectoryServices.Protocols&apos;) $null = [System.Reflection.Assembly]::LoadWithPartialName(&apos;System.Net&apos;) $LDAPServer = New-Object System.DirectoryServices.Protocols.LdapConnection $LDAPDirectoryService $LDAPServer.AuthType = [System.DirectoryServices.Protocols.AuthType]::Anonymous $LDAPServer.SessionOptions.ProtocolVersion = 3 $LDAPServer.SessionOptions.SecureSocketLayer =$false $Scope = [System.DirectoryServices.Protocols.SearchScope]::Subtree $AttributeList = @(&apos;*&apos;) $SearchRequest = New-Object System.DirectoryServices.Protocols.SearchRequest -ArgumentList $DomainDN,$LDAPFilter,$Scope,$AttributeList $groups = $LDAPServer.SendRequest($SearchRequest) foreach ($group in $groups.Entries) { $users=$group.attributes[&apos;memberUid&apos;].GetValues(&apos;string&apos;) foreach ($user in $users) { Write-Host $user } } 本文国际来源：Accessing Non-Microsoft LDAP Servers","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找只读型和常量型变量","slug":"finding-read-only-and-constant-variables","date":"2015-03-27T03:00:00.000Z","updated":"2017-03-17T15:26:25.402Z","comments":true,"path":"2015/03/27/finding-read-only-and-constant-variables/","link":"","permalink":"http://blog.vichamp.com/2015/03/27/finding-read-only-and-constant-variables/","excerpt":"适用于 PowerShell 所有版本 有些变量是受保护且不可改变的。要查这些变量，请看如下代码： Get-Variable | Where-Object { $_.Options -like &apos;*Constant*&apos; -or $_.Options -like &apos;*ReadOnly*&apos; } | Select-Object -Property Name, Options, Description 执行的结果类似这样： Name Options Description ---- ------- ----------- ? ReadOnly, AllScope Status des letzten Befehls ConsoleFileName ReadOnly, AllScope Name der aktuellen Kons... Error Constant ExecutionContext Constant, AllScope Die für Cmdlets verfügb... false Constant, AllScope Boolean False HOME ReadOnly, AllScope Ordner mit dem Profil d... Host Constant, AllScope Ein Verweis auf den Hos... PID Constant, AllScope Aktuelle Prozess-ID PSCulture ReadOnly, AllScope Die Kultur der aktuelle... PSHOME Constant, AllScope Der übergeordnete Ordne... psISE Constant PSUICulture ReadOnly, AllScope Die Benutzeroberflächen... psUnsupportedConsoleAppl... Constant PSVersionTable Constant, AllScope Versionsinformationen f... ShellId Constant, AllScope &quot;ShellID&quot; gibt die aktu... true Constant, AllScope Boolean True 有意思的地方是如何用 Where-Object 来过滤这些变量。这段代码使用了字符串对比和 -like。这是因为变量选项是各种标志，并且标志可以组合使用。通过使用 -like 和占位符，您可以基本安全地用您希望的标志来过滤，即便设置了其它标志。","text":"适用于 PowerShell 所有版本 有些变量是受保护且不可改变的。要查这些变量，请看如下代码： Get-Variable | Where-Object { $_.Options -like &apos;*Constant*&apos; -or $_.Options -like &apos;*ReadOnly*&apos; } | Select-Object -Property Name, Options, Description 执行的结果类似这样： Name Options Description ---- ------- ----------- ? ReadOnly, AllScope Status des letzten Befehls ConsoleFileName ReadOnly, AllScope Name der aktuellen Kons... Error Constant ExecutionContext Constant, AllScope Die für Cmdlets verfügb... false Constant, AllScope Boolean False HOME ReadOnly, AllScope Ordner mit dem Profil d... Host Constant, AllScope Ein Verweis auf den Hos... PID Constant, AllScope Aktuelle Prozess-ID PSCulture ReadOnly, AllScope Die Kultur der aktuelle... PSHOME Constant, AllScope Der übergeordnete Ordne... psISE Constant PSUICulture ReadOnly, AllScope Die Benutzeroberflächen... psUnsupportedConsoleAppl... Constant PSVersionTable Constant, AllScope Versionsinformationen f... ShellId Constant, AllScope &quot;ShellID&quot; gibt die aktu... true Constant, AllScope Boolean True 有意思的地方是如何用 Where-Object 来过滤这些变量。这段代码使用了字符串对比和 -like。这是因为变量选项是各种标志，并且标志可以组合使用。通过使用 -like 和占位符，您可以基本安全地用您希望的标志来过滤，即便设置了其它标志。 本文国际来源：Finding Read-Only and Constant Variables","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 只读及强类型变量","slug":"read-only-and-strongly-typed-variables","date":"2015-03-26T03:00:00.000Z","updated":"2017-03-17T15:26:25.399Z","comments":true,"path":"2015/03/26/read-only-and-strongly-typed-variables/","link":"","permalink":"http://blog.vichamp.com/2015/03/26/read-only-and-strongly-typed-variables/","excerpt":"适用于 PowerShell 所有版本 要让 PowerShell 脚本更鲁棒，您可以针对脚本变量编写一系列约束条件。 这么做的效果是，PowerShell 将会为您监控这些约束条件，并且如果某些条件不满足，将抛出错误。 第一个约束条件是传入的数据类型必须和期望的相符。将数据类型放在方括号中，然后将它放在变量前面。这将会使一个通用类型的变量转换为一个强类型的变量。 PS&gt; $profile.AllUsersAllHosts C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1 PS&gt; [int]$ID = 12 PS&gt; $ID = 17 PS&gt; $ID = &apos;19&apos; PS&gt; $ID = &apos;wrong&apos; Cannot convert type &quot;string&quot;... 请看 $ID 变量是如何成为一个只能存储 Integer 数据的变量。望您将一个非 Integer 值，（例如 ‘19’）传入时，它将自动转换成 Integer 类型。如果无法转换（例如 ‘wrong’），PowerShell 将会抛出一个错误。 下一个约束条件是“只读”状态。如果您确信某个变量在脚本的某一部分中不可被更改，请将它保住为只读。任何试图改变该变量的操作都会触发一个 PowerShell 异常： PS&gt; $a = 1 PS&gt; $a = 100 PS&gt; Set-Variable a -Option ReadOnly PS&gt; $a 100 PS&gt; $a = 200 Cannot overwrite variable. PS&gt; Set-Variable a -Option None -Force PS&gt; $a = 212 请注意写保护如何打开和关闭。要将写保护关闭，只需要将变量开关设为“None”，并且别忘了 -Force 开关。 如您所见，“ReadOnly”选项是一个软保护开关。您可以控制它开和关。在前一个技能中，您学到了“Constant”选项。Constant 的意思如它们的名字：常量。和“ReadOnly”不同，常量无法变回可写状态。","text":"适用于 PowerShell 所有版本 要让 PowerShell 脚本更鲁棒，您可以针对脚本变量编写一系列约束条件。 这么做的效果是，PowerShell 将会为您监控这些约束条件，并且如果某些条件不满足，将抛出错误。 第一个约束条件是传入的数据类型必须和期望的相符。将数据类型放在方括号中，然后将它放在变量前面。这将会使一个通用类型的变量转换为一个强类型的变量。 PS&gt; $profile.AllUsersAllHosts C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1 PS&gt; [int]$ID = 12 PS&gt; $ID = 17 PS&gt; $ID = &apos;19&apos; PS&gt; $ID = &apos;wrong&apos; Cannot convert type &quot;string&quot;... 请看 $ID 变量是如何成为一个只能存储 Integer 数据的变量。望您将一个非 Integer 值，（例如 ‘19’）传入时，它将自动转换成 Integer 类型。如果无法转换（例如 ‘wrong’），PowerShell 将会抛出一个错误。 下一个约束条件是“只读”状态。如果您确信某个变量在脚本的某一部分中不可被更改，请将它保住为只读。任何试图改变该变量的操作都会触发一个 PowerShell 异常： PS&gt; $a = 1 PS&gt; $a = 100 PS&gt; Set-Variable a -Option ReadOnly PS&gt; $a 100 PS&gt; $a = 200 Cannot overwrite variable. PS&gt; Set-Variable a -Option None -Force PS&gt; $a = 212 请注意写保护如何打开和关闭。要将写保护关闭，只需要将变量开关设为“None”，并且别忘了 -Force 开关。 如您所见，“ReadOnly”选项是一个软保护开关。您可以控制它开和关。在前一个技能中，您学到了“Constant”选项。Constant 的意思如它们的名字：常量。和“ReadOnly”不同，常量无法变回可写状态。 本文国际来源：Read-Only and Strongly Typed Variables","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"git 学习路线","slug":"Guideline-to-Learn-git","date":"2015-03-25T07:54:00.000Z","updated":"2017-03-17T15:26:23.289Z","comments":true,"path":"2015/03/25/Guideline-to-Learn-git/","link":"","permalink":"http://blog.vichamp.com/2015/03/25/Guideline-to-Learn-git/","excerpt":"Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。","text":"Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。 链接 Git - git 官网 Git for Windows - Windows 版的 git 命令行客户端 Git Client smartGit - 跨平台的图形化 git 客户端，可免费非商业使用。 教程 Git教程 - 廖雪峰的官方网站 git命令和smartgit使用介绍 《Git详解》系列 Git详解之一 Git起步 Git详解之二 Git基础 Git详解之三 Git分支 Git详解之四 服务器上的Git Git详解之五 分布式Git Git详解之六 Git工具 Git详解之七 自定义Git Git详解之八 Git与其他系统 Git详解之九 Git内部原理 《Git Step by Step》系列 Git Step by Step – (1) Git 简介 Git Step by Step – (2) 本地Repo Git Step by Step – (3) Git对象模型 Git Step by Step – (4) 探索.git目录 Git Step by Step – (5) Git分支(branch) Git Step by Step – (6) Git远程仓库 Git Step by Step – (7) Git远程仓库（续） Git Step by Step – (8) Git的merge和rebase gitflow 介绍一个成功的 Git 分支模型 http://nvie.com/files/Git-branching-model.pdf","categories":[{"name":"git","slug":"git","permalink":"http://blog.vichamp.com/categories/git/"}],"tags":[{"name":"learning","slug":"learning","permalink":"http://blog.vichamp.com/tags/learning/"},{"name":"guideline","slug":"guideline","permalink":"http://blog.vichamp.com/tags/guideline/"},{"name":"git","slug":"git","permalink":"http://blog.vichamp.com/tags/git/"},{"name":"scm","slug":"scm","permalink":"http://blog.vichamp.com/tags/scm/"}],"keywords":[{"name":"git","slug":"git","permalink":"http://blog.vichamp.com/categories/git/"}]},{"title":"PowerShell 技能连载 - 使用常量","slug":"using-constants","date":"2015-03-25T03:00:00.000Z","updated":"2017-03-17T15:26:25.390Z","comments":true,"path":"2015/03/25/using-constants/","link":"","permalink":"http://blog.vichamp.com/2015/03/25/using-constants/","excerpt":"适用于 PowerShell 所有版本 PowerShell 中的变量是不稳定的。您可以覆盖或是删除它们——除非创建常量。 常量只能在还不存在该常量的时候创建。这行代码创建了一个名为“connotChange”，值为 1 的常量。 New-Variable -Name cannotChange -Value 1 -Option Constant 在 PowerShell 运行期间，无法删除这个变量。该变量被绑定到当前的 PowerShell 会话。常量可以用在您不希望改变的敏感信息上。 您可以在您的主配置文件路径上定义常量，例如： PS&gt; $profile.AllUsersAllHosts C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1 如果该文件存在，PowerShell 将会在任何实例启动之前先执行它。如果您在此定义了常量——例如您的公司名、重要的服务器列表等——该信息将在所有 PowerShell 宿主内有效，而且无法被覆盖。","text":"适用于 PowerShell 所有版本 PowerShell 中的变量是不稳定的。您可以覆盖或是删除它们——除非创建常量。 常量只能在还不存在该常量的时候创建。这行代码创建了一个名为“connotChange”，值为 1 的常量。 New-Variable -Name cannotChange -Value 1 -Option Constant 在 PowerShell 运行期间，无法删除这个变量。该变量被绑定到当前的 PowerShell 会话。常量可以用在您不希望改变的敏感信息上。 您可以在您的主配置文件路径上定义常量，例如： PS&gt; $profile.AllUsersAllHosts C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1 如果该文件存在，PowerShell 将会在任何实例启动之前先执行它。如果您在此定义了常量——例如您的公司名、重要的服务器列表等——该信息将在所有 PowerShell 宿主内有效，而且无法被覆盖。 本文国际来源：Using Constants","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在脚本中包含资源","slug":"including-resources-with-your-scripts","date":"2015-03-24T03:00:00.000Z","updated":"2017-03-17T15:26:25.380Z","comments":true,"path":"2015/03/24/including-resources-with-your-scripts/","link":"","permalink":"http://blog.vichamp.com/2015/03/24/including-resources-with-your-scripts/","excerpt":"适用于 PowerShell 3.0 及以上版本 如果您的脚本需要额外的资源，比如说服务器名列表，图片文件，或是其它内容，那么请确保您的脚本可随处使用。 千万别使用绝对路径来定位资源文件。应使用 PowerShell 3.0 开始提供的 $PSScriptRoot（在 PowerShell 2.0 中，$PSScriptRoot 只能在模块中使用）。 $picture = &quot;$PSScriptRoot\\Resources\\picture.png&quot; Test-Path -Path $picture $data = &quot;$PSScriptRoot\\Resources\\somedata.txt&quot; Get-Content -Path $data $PSScriptRoot 总是指向脚本所在的目录（所以如果脚本尚未保存或是以交互式查询该变量，得到的结果是空）。","text":"适用于 PowerShell 3.0 及以上版本 如果您的脚本需要额外的资源，比如说服务器名列表，图片文件，或是其它内容，那么请确保您的脚本可随处使用。 千万别使用绝对路径来定位资源文件。应使用 PowerShell 3.0 开始提供的 $PSScriptRoot（在 PowerShell 2.0 中，$PSScriptRoot 只能在模块中使用）。 $picture = &quot;$PSScriptRoot\\Resources\\picture.png&quot; Test-Path -Path $picture $data = &quot;$PSScriptRoot\\Resources\\somedata.txt&quot; Get-Content -Path $data $PSScriptRoot 总是指向脚本所在的目录（所以如果脚本尚未保存或是以交互式查询该变量，得到的结果是空）。 本文国际来源：Including Resources with Your Scripts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中使用“more”","slug":"using-more-in-the-powershell-ise","date":"2015-03-23T03:00:00.000Z","updated":"2017-03-17T15:26:25.374Z","comments":true,"path":"2015/03/23/using-more-in-the-powershell-ise/","link":"","permalink":"http://blog.vichamp.com/2015/03/23/using-more-in-the-powershell-ise/","excerpt":"适用于 PowerShell ISE 在 PowerShell 控制台中，您可以将命令通过管道输出到旧式的“more.com”命令中，或者更高级一些的 Out-Host -Paging 中。这将分页显示数据，每按一个键翻一页： PS&gt; Get-Process | more PS&gt; Get-Process | Out-Host -Paging 在 PowerShell ISE 中，这些都不支持。这是因为 ISE 没有控制台，所以没有“可见的行数”概念，只有一个无限的文本缓冲区。 要避免大量的结果刷屏问题，只需要自己创建一个兼容 ISE 的“more”命令： function Out-More { param ( $Lines = 10, [Parameter(ValueFromPipeline=$true)] $InputObject ) begin { $counter = 0 } process { $counter++ if ($counter -ge $Lines) { $counter = 0 Write-Host &apos;Press ENTER to continue&apos; -ForegroundColor Yellow Read-Host } $InputObject } } 将您的结果通过管道输出到 Out-More，命令，并使用 -Lines 来指定接收到多少行以后暂停： PS&gt; Get-Process | Out-More -Lines 4 Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 100 9 1436 1592 51 6896 adb 307 42 22332 12940 123 1424 AllShareFrameworkDMS 42 4 1396 1284 19 1404 AllShareFrameworkManagerDMS Press ENTER to continue 81 7 1004 724 43 1388 armsvc 202 25 50376 55320 234 8,06 13720 chrome 1131 65 68672 93892 361 116,73 13964 chrome 199 24 53008 52700 225 5,56 14768 chrome Press ENTER to continue 248 26 31348 44984 239 44,31 15404 chrome 173 20 23756 25540 179 1,27 16492 chrome 190 22 36316 39208 207 2,81 16508 chrome 184 23 41800 44212 223 1,77 17244 chrome Press ENTER to continue","text":"适用于 PowerShell ISE 在 PowerShell 控制台中，您可以将命令通过管道输出到旧式的“more.com”命令中，或者更高级一些的 Out-Host -Paging 中。这将分页显示数据，每按一个键翻一页： PS&gt; Get-Process | more PS&gt; Get-Process | Out-Host -Paging 在 PowerShell ISE 中，这些都不支持。这是因为 ISE 没有控制台，所以没有“可见的行数”概念，只有一个无限的文本缓冲区。 要避免大量的结果刷屏问题，只需要自己创建一个兼容 ISE 的“more”命令： function Out-More { param ( $Lines = 10, [Parameter(ValueFromPipeline=$true)] $InputObject ) begin { $counter = 0 } process { $counter++ if ($counter -ge $Lines) { $counter = 0 Write-Host &apos;Press ENTER to continue&apos; -ForegroundColor Yellow Read-Host } $InputObject } } 将您的结果通过管道输出到 Out-More，命令，并使用 -Lines 来指定接收到多少行以后暂停： PS&gt; Get-Process | Out-More -Lines 4 Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 100 9 1436 1592 51 6896 adb 307 42 22332 12940 123 1424 AllShareFrameworkDMS 42 4 1396 1284 19 1404 AllShareFrameworkManagerDMS Press ENTER to continue 81 7 1004 724 43 1388 armsvc 202 25 50376 55320 234 8,06 13720 chrome 1131 65 68672 93892 361 116,73 13964 chrome 199 24 53008 52700 225 5,56 14768 chrome Press ENTER to continue 248 26 31348 44984 239 44,31 15404 chrome 173 20 23756 25540 179 1,27 16492 chrome 190 22 36316 39208 207 2,81 16508 chrome 184 23 41800 44212 223 1,77 17244 chrome Press ENTER to continue 本文国际来源：Using “more” in the PowerShell ISE","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从注册表中读取用户配置文件","slug":"read-user-profiles-from-registry","date":"2015-03-20T03:00:00.000Z","updated":"2017-03-17T15:26:25.371Z","comments":true,"path":"2015/03/20/read-user-profiles-from-registry/","link":"","permalink":"http://blog.vichamp.com/2015/03/20/read-user-profiles-from-registry/","excerpt":"适用于 PowerShell 所有版本 要查看哪个用户在您的机器上拥有（本地）配置文件，以及配置文件位于什么位置，请使用这段代码： $path = &apos;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\*&apos; Get-ItemProperty -Path $path | Select-Object -Property PSChildName, ProfileImagePath 它将自动枚举配置文件列表中的所有键，并返回用户 SID 和配置文件的路径： PSChildName ProfileImagePath ----------- ---------------- S-1-5-18 C:\\WINDOWS\\system32\\config\\systemprofile S-1-5-19 C:\\Windows\\ServiceProfiles\\LocalService S-1-5-20 C:\\Windows\\ServiceProfiles\\NetworkSer... S-1-5-21-1907506615-3936657230-268413... C:\\Users\\Tobias S-1-5-80-3880006512-4290199581-164872... C:\\Users\\MSSQL$SQLEXPRESS","text":"适用于 PowerShell 所有版本 要查看哪个用户在您的机器上拥有（本地）配置文件，以及配置文件位于什么位置，请使用这段代码： $path = &apos;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\*&apos; Get-ItemProperty -Path $path | Select-Object -Property PSChildName, ProfileImagePath 它将自动枚举配置文件列表中的所有键，并返回用户 SID 和配置文件的路径： PSChildName ProfileImagePath ----------- ---------------- S-1-5-18 C:\\WINDOWS\\system32\\config\\systemprofile S-1-5-19 C:\\Windows\\ServiceProfiles\\LocalService S-1-5-20 C:\\Windows\\ServiceProfiles\\NetworkSer... S-1-5-21-1907506615-3936657230-268413... C:\\Users\\Tobias S-1-5-80-3880006512-4290199581-164872... C:\\Users\\MSSQL$SQLEXPRESS 本文国际来源：Read User Profiles from Registry","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从注册表中读取文件扩展名关联（第二部分）","slug":"reading-associated-file-extensions-from-registry-part-2","date":"2015-03-19T03:00:00.000Z","updated":"2017-03-17T15:26:25.363Z","comments":true,"path":"2015/03/19/reading-associated-file-extensions-from-registry-part-2/","link":"","permalink":"http://blog.vichamp.com/2015/03/19/reading-associated-file-extensions-from-registry-part-2/","excerpt":"适用于 PowerShell 所有版本 在前一个技能里您已学到了如何用单行代码读取多个注册表键。在第二部分中，请试试这段单行代码： $lookup = Get-ItemProperty Registry::HKCR\\.[a-f]?? | Select-Object -Property PSChildName, &apos;(default)&apos;, ContentType, PerceivedType | Group-Object -Property PSChildName -AsHashTable -AsString 这段代码读取注册表 HKCR 中所有以点开头，接下来是三个字母，并且第一个字母必须是 a-f 的键——它的作用是读取所有以 a-f 开头，并且必须是 3 个字符的文件扩展名。 另外，结果通过管道输出到 Group-Object，并且“PSChildName”属性被用作哈希表的键名。 PSChildName 总是返回注册表的键名，在这个例子中代表的是文件的扩展名。 当您运行这行代码时，您可以查询任何已注册的文件扩展名： PS&gt; $lookup.&apos;.avi&apos; PSChildName (default) ContentType PerceivedType ----------- --------- ----------- ------------- .avi WMP11.AssocFile.AVI video PS&gt; $lookup.&apos;.fon&apos; PSChildName (default) ContentType PerceivedType ----------- --------- ----------- ------------- .fon fonfile 请注意这行代码限制了只包括 a-f 开头、三个字母的扩展名。要获取所有的文件扩展名，请使用这个路径： Registry::HKCR\\.*","text":"适用于 PowerShell 所有版本 在前一个技能里您已学到了如何用单行代码读取多个注册表键。在第二部分中，请试试这段单行代码： $lookup = Get-ItemProperty Registry::HKCR\\.[a-f]?? | Select-Object -Property PSChildName, &apos;(default)&apos;, ContentType, PerceivedType | Group-Object -Property PSChildName -AsHashTable -AsString 这段代码读取注册表 HKCR 中所有以点开头，接下来是三个字母，并且第一个字母必须是 a-f 的键——它的作用是读取所有以 a-f 开头，并且必须是 3 个字符的文件扩展名。 另外，结果通过管道输出到 Group-Object，并且“PSChildName”属性被用作哈希表的键名。 PSChildName 总是返回注册表的键名，在这个例子中代表的是文件的扩展名。 当您运行这行代码时，您可以查询任何已注册的文件扩展名： PS&gt; $lookup.&apos;.avi&apos; PSChildName (default) ContentType PerceivedType ----------- --------- ----------- ------------- .avi WMP11.AssocFile.AVI video PS&gt; $lookup.&apos;.fon&apos; PSChildName (default) ContentType PerceivedType ----------- --------- ----------- ------------- .fon fonfile 请注意这行代码限制了只包括 a-f 开头、三个字母的扩展名。要获取所有的文件扩展名，请使用这个路径： Registry::HKCR\\.* 本文国际来源：Reading Associated File Extensions from Registry (Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从注册表中读取文件扩展名关联（第一部分）","slug":"reading-associated-file-extensions-from-registry","date":"2015-03-18T03:00:00.000Z","updated":"2017-03-17T15:26:25.360Z","comments":true,"path":"2015/03/18/reading-associated-file-extensions-from-registry/","link":"","permalink":"http://blog.vichamp.com/2015/03/18/reading-associated-file-extensions-from-registry/","excerpt":"适用于 PowerShell 所有版本 PowerShell 代码可以写得十分紧凑。以下是一个从 Windows 注册表中读取所有文件扩展名关联的单行代码： Get-ItemProperty Registry::HKCR\\.* | Select-Object -Property PSChildName, &apos;(default)&apos;, ContentType, PerceivedType 请注意这些技巧：Get-ItemProperty 使用了名为“Registry::”的 provider，而不是 PowerShell 提供的注册表驱动器。通过这种方式，您可以使用默认的注册表路径，并且可以存取类似 _HKEY_CLASSES_ROOT_ 这样没有驱动器的 hive。 请注意 Select-Object 如何选择获取注册表值。这里有两个特殊的名字：“(default)”总是代表缺省的注册表值，并且“PSChildName”总是代表当前读取的注册表键名。 由于路径名中的“*”符，该命令将自动读取 HKCR 路径中以点开头的所有键。","text":"适用于 PowerShell 所有版本 PowerShell 代码可以写得十分紧凑。以下是一个从 Windows 注册表中读取所有文件扩展名关联的单行代码： Get-ItemProperty Registry::HKCR\\.* | Select-Object -Property PSChildName, &apos;(default)&apos;, ContentType, PerceivedType 请注意这些技巧：Get-ItemProperty 使用了名为“Registry::”的 provider，而不是 PowerShell 提供的注册表驱动器。通过这种方式，您可以使用默认的注册表路径，并且可以存取类似 _HKEY_CLASSES_ROOT_ 这样没有驱动器的 hive。 请注意 Select-Object 如何选择获取注册表值。这里有两个特殊的名字：“(default)”总是代表缺省的注册表值，并且“PSChildName”总是代表当前读取的注册表键名。 由于路径名中的“*”符，该命令将自动读取 HKCR 路径中以点开头的所有键。 本文国际来源：Reading Associated File Extensions from Registry","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 根据类型对数据排序","slug":"sort-things-with-type","date":"2015-03-17T03:00:00.000Z","updated":"2017-03-17T15:26:25.354Z","comments":true,"path":"2015/03/17/sort-things-with-type/","link":"","permalink":"http://blog.vichamp.com/2015/03/17/sort-things-with-type/","excerpt":"适用于 PowerShell 所有版本 Sort-Object 是一站式的排序解决方案。如果要对简单数据类型排序，只需要将它通过管道传递给 Sort-Object。如果要对复杂数据类型排序，则需要指定排序所使用的属性： # sorting primitive data 1,5,2,1,6,3,12,6 | Sort-Object -Unique # sorting object data Get-ChildItem -Path c:\\windows | Sort-Object –Property name 由于对象的天生原因，PowerShell 自动选择排序的算法。但如果您需要更多的控制呢？ 只需要传入一个代码块。在代码块中，$_ 代表需要排序的对象。您可以将它转型为任何期望的类型： # sorting string as numbers &apos;1&apos;,&apos;5&apos;,&apos;3a&apos;,&apos;12&apos;,&apos;6&apos; | Sort-Object -Property { $_ -as [int] } # sorting IPv4 addresses as versions &apos;1.2.3.4&apos;, &apos;10.1.2.3&apos;, &apos;100.4.2.1&apos;, &apos;2.3.4.5&apos;, &apos;9.10.11.12&apos; | Sort-Object -Property { [version] $_ }","text":"适用于 PowerShell 所有版本 Sort-Object 是一站式的排序解决方案。如果要对简单数据类型排序，只需要将它通过管道传递给 Sort-Object。如果要对复杂数据类型排序，则需要指定排序所使用的属性： # sorting primitive data 1,5,2,1,6,3,12,6 | Sort-Object -Unique # sorting object data Get-ChildItem -Path c:\\windows | Sort-Object –Property name 由于对象的天生原因，PowerShell 自动选择排序的算法。但如果您需要更多的控制呢？ 只需要传入一个代码块。在代码块中，$_ 代表需要排序的对象。您可以将它转型为任何期望的类型： # sorting string as numbers &apos;1&apos;,&apos;5&apos;,&apos;3a&apos;,&apos;12&apos;,&apos;6&apos; | Sort-Object -Property { $_ -as [int] } # sorting IPv4 addresses as versions &apos;1.2.3.4&apos;, &apos;10.1.2.3&apos;, &apos;100.4.2.1&apos;, &apos;2.3.4.5&apos;, &apos;9.10.11.12&apos; | Sort-Object -Property { [version] $_ } 本文国际来源：Sort Things with Type","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 PowerShell 打开网页","slug":"opening-webpages-from-powershell","date":"2015-03-16T03:00:00.000Z","updated":"2017-03-17T15:26:25.345Z","comments":true,"path":"2015/03/16/opening-webpages-from-powershell/","link":"","permalink":"http://blog.vichamp.com/2015/03/16/opening-webpages-from-powershell/","excerpt":"适用于 PowerShell 所有版本 假设您希望每天开始时，就用浏览器打开您最喜欢的网站。PowerShell 可以简单地实现这个需求。不过，这要看您是否喜欢自动打开网页。 使用 Start-Process 的时候，您可以通过参数指定选用哪个浏览器，以及提交的 URL 地址： # starts with a specific browser Start-Process -FilePath iexplore -ArgumentList www.powershellmagazine.com 这将在 Internet Explorer 中打开网站，而不是选用缺省的浏览器设置。 不过，它总是打开一个新的浏览器实例。请看另一种实现方式： # starts with default browser and adds to open browser Start-Process -FilePath www.tagesschau.de 这段代码中，我们将一个 URL 当做一个“可执行程序”，Windows 就会使用缺省的浏览器。如果缺省浏览器已经打开了，将在其中打开一个新的标签页，而不是打开一个新的浏览器窗口。 要让 PowerShell 在启动时自动打开网页，请确保 $profile 指向的文件路径存在。下一步，打开该脚本，并添加启动命令。","text":"适用于 PowerShell 所有版本 假设您希望每天开始时，就用浏览器打开您最喜欢的网站。PowerShell 可以简单地实现这个需求。不过，这要看您是否喜欢自动打开网页。 使用 Start-Process 的时候，您可以通过参数指定选用哪个浏览器，以及提交的 URL 地址： # starts with a specific browser Start-Process -FilePath iexplore -ArgumentList www.powershellmagazine.com 这将在 Internet Explorer 中打开网站，而不是选用缺省的浏览器设置。 不过，它总是打开一个新的浏览器实例。请看另一种实现方式： # starts with default browser and adds to open browser Start-Process -FilePath www.tagesschau.de 这段代码中，我们将一个 URL 当做一个“可执行程序”，Windows 就会使用缺省的浏览器。如果缺省浏览器已经打开了，将在其中打开一个新的标签页，而不是打开一个新的浏览器窗口。 要让 PowerShell 在启动时自动打开网页，请确保 $profile 指向的文件路径存在。下一步，打开该脚本，并添加启动命令。 本文国际来源：Opening Webpages from PowerShell","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检查网站的响应（和执行时间）","slug":"measuring-website-response-and-execution-times","date":"2015-03-13T03:00:00.000Z","updated":"2017-03-17T15:26:25.342Z","comments":true,"path":"2015/03/13/measuring-website-response-and-execution-times/","link":"","permalink":"http://blog.vichamp.com/2015/03/13/measuring-website-response-and-execution-times/","excerpt":"适用于 PowerShell 3.0 及以上版本 有些时候了解一个命令的执行时间是十分重要的。例如，要监控网站的响应时间，您可以使用 Invoke-WebRequest。用 Measure-Command 来测量执行的耗时。 $url = &apos;http://www.powershell.com&apos; # track execution time: $timeTaken = Measure-Command -Expression { $site = Invoke-WebRequest -Uri $url } $milliseconds = $timeTaken.TotalMilliseconds $milliseconds = [Math]::Round($milliseconds, 1) &quot;This took $milliseconds ms to execute&quot; 它返回一个 TimeSapn 对象，该对象包含了一个 “TotalMilliseconds“ 属性。使用 “Math“ 类提供的 Round() 方法将结果四舍五入。在这例子中，毫秒值被精确到小数点后 1 位。","text":"适用于 PowerShell 3.0 及以上版本 有些时候了解一个命令的执行时间是十分重要的。例如，要监控网站的响应时间，您可以使用 Invoke-WebRequest。用 Measure-Command 来测量执行的耗时。 $url = &apos;http://www.powershell.com&apos; # track execution time: $timeTaken = Measure-Command -Expression { $site = Invoke-WebRequest -Uri $url } $milliseconds = $timeTaken.TotalMilliseconds $milliseconds = [Math]::Round($milliseconds, 1) &quot;This took $milliseconds ms to execute&quot; 它返回一个 TimeSapn 对象，该对象包含了一个 “TotalMilliseconds“ 属性。使用 “Math“ 类提供的 Round() 方法将结果四舍五入。在这例子中，毫秒值被精确到小数点后 1 位。 本文国际来源：Measuring Website Response (and Execution Times)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 展开对象数据结构","slug":"unfolding-object-data-structure","date":"2015-03-12T03:00:00.000Z","updated":"2017-03-17T15:26:25.334Z","comments":true,"path":"2015/03/12/unfolding-object-data-structure/","link":"","permalink":"http://blog.vichamp.com/2015/03/12/unfolding-object-data-structure/","excerpt":"适用于 PowerShell 3.0 及以上版本 对象有可能包含嵌套的属性，您所关心的数据可能在一个对象中的“某个地方”。 要显示某个对象的所有属性和展开后的子属性，可将它转换为 JSON。这能很好地以文本的方式展现嵌套的属性。 这个例子获取当前的 PowerShell 进程，然后将它转化为 JSON，然后将文本输出到剪贴板。然后就可以将内容粘贴到任意的文本编辑器： Get-Process -Id $pid | ConvertTo-Json | clip.exe 要控制递归的深度，请使用 ConvertTo-Json 命令的 -Depth 参数。缺省值是 2（所以最多显示 2 层递归深度的内容）。","text":"适用于 PowerShell 3.0 及以上版本 对象有可能包含嵌套的属性，您所关心的数据可能在一个对象中的“某个地方”。 要显示某个对象的所有属性和展开后的子属性，可将它转换为 JSON。这能很好地以文本的方式展现嵌套的属性。 这个例子获取当前的 PowerShell 进程，然后将它转化为 JSON，然后将文本输出到剪贴板。然后就可以将内容粘贴到任意的文本编辑器： Get-Process -Id $pid | ConvertTo-Json | clip.exe 要控制递归的深度，请使用 ConvertTo-Json 命令的 -Depth 参数。缺省值是 2（所以最多显示 2 层递归深度的内容）。 本文国际来源：Unfolding Object Data Structure","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"Node.js 学习路线","slug":"Node-js-Guideline","date":"2015-03-11T03:30:33.000Z","updated":"2017-03-17T15:26:25.315Z","comments":true,"path":"2015/03/11/Node-js-Guideline/","link":"","permalink":"http://blog.vichamp.com/2015/03/11/Node-js-Guideline/","excerpt":"","text":"Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台， 用来方便地搭建快速的易于扩展的网络应用。Node.js 借助事件驱动，非阻塞 I/O 模型变得轻量和高效，非常适合运行在分布式设备的数据密集型的实时应用。 V8 引擎执行 JavaScript 的速度非常快，性能非常好。Node 对一些特殊用例进行了优化，提供了替代的 API，使得 V8 在非浏览器环境下运行得更好。 Node 是 一个 JavasSript 运行环境 (runtime)。实际上它是对 Google V8 引擎进行了封装。V8 引擎执行JavaScript 的速度非常快，性能非常好。Node 对一些特殊用例进行了优化，提供了替代的 API，使得 V8 在非浏览器环境下运行得更好。 网站 官方网站：Node.js 中文社区：CNode：Node.js专业中文社区 技巧 快速搭建 Node.js 开发环境以及加速 npm - CNode","categories":[{"name":"node.js","slug":"node-js","permalink":"http://blog.vichamp.com/categories/node-js/"}],"tags":[{"name":"guideline","slug":"guideline","permalink":"http://blog.vichamp.com/tags/guideline/"},{"name":"node.js","slug":"node-js","permalink":"http://blog.vichamp.com/tags/node-js/"}],"keywords":[{"name":"node.js","slug":"node-js","permalink":"http://blog.vichamp.com/categories/node-js/"}]},{"title":"PowerShell 技能连载 - 禁止确认信息","slug":"suppress-confirmation","date":"2015-03-11T03:00:00.000Z","updated":"2017-03-17T15:26:25.323Z","comments":true,"path":"2015/03/11/suppress-confirmation/","link":"","permalink":"http://blog.vichamp.com/2015/03/11/suppress-confirmation/","excerpt":"适用于 PowerShell 所有版本 某些 cmdlet（例如 Remove-ADGroupMember）会自动提示确认信息。这在无人值守的脚本中会有问题。 要禁用这些不需要的确认对话框，请显式将 -Confirm 开关参数设置为 false： Remove-ADGroupMember -Identity &apos;Domain Admins&apos; -Members user12 -Confirm:$false 或者，您可以修改安全级别。PowerShell 将会自动读取该设置。这行代码将所有 cmdlet 的自动确认关闭： $ConfirmPreference = &apos;None&apos; 请注意两个技能都只对缺省的确认对话框有效。如果一个 cmdlet 以 PowerShell 确认框架之外的方式提示确认，您需要参阅 cmdlet 的文档来查找如何禁止它的方法。","text":"适用于 PowerShell 所有版本 某些 cmdlet（例如 Remove-ADGroupMember）会自动提示确认信息。这在无人值守的脚本中会有问题。 要禁用这些不需要的确认对话框，请显式将 -Confirm 开关参数设置为 false： Remove-ADGroupMember -Identity &apos;Domain Admins&apos; -Members user12 -Confirm:$false 或者，您可以修改安全级别。PowerShell 将会自动读取该设置。这行代码将所有 cmdlet 的自动确认关闭： $ConfirmPreference = &apos;None&apos; 请注意两个技能都只对缺省的确认对话框有效。如果一个 cmdlet 以 PowerShell 确认框架之外的方式提示确认，您需要参阅 cmdlet 的文档来查找如何禁止它的方法。 本文国际来源：Suppress Confirmation","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 随时获取 cmdlet 的帮助","slug":"getting-cmdlet-help-no-matter-what","date":"2015-03-10T03:00:00.000Z","updated":"2017-03-17T15:26:25.305Z","comments":true,"path":"2015/03/10/getting-cmdlet-help-no-matter-what/","link":"","permalink":"http://blog.vichamp.com/2015/03/10/getting-cmdlet-help-no-matter-what/","excerpt":"适用于 PowerShell 3.0 及以上版本 从 PowerShell 3.0 开始，帮助文件不在随着 PowerShell 发布。相反，您需要通过 Update-Help 来下载它们，并且由于帮助文件是存储在（受保护的）PowerShell 文件夹中，所以一个普通用户无法实现该操作。 将来您需要某个 cmdlet 的帮助时，只需要直接使用在线版即可。以下代码将通过浏览器访问 Get-Process 的在线帮助（假设您有 Internet 连接）： PS&gt; help Get-Process -Online 安装了帮助文件之后，在 PowerShell ISE 中获得帮助变得更容易了：只需要点击任何 cmdlet 名称，然后按 F1 键。 如果仔细观察，会发现当按下 F1 时，实际上是帮您输入了帮助命令。所以如果需要同样的操作方便性，但是显示的是在线的帮助，您以实现一个类似这样的函数： function Get-Help($Name) { Get-Help $Name -Online } 然而，这可能会导致死循环，因为新创建的 Get-Help 会在内部调用自己。要让它正常工作，您需要您的函数内部是采用类似这样的方式调用原始的 Get-Help cmdlet： function Get-Help($Name) { Microsoft.PowerShell.Core\\Get-Help $Name -Online } 当您运行这个函数是，您可以点击 PowerShell ISE 中的任意 cmdlet 名称，然后按 F1 键，就能够访问该 cmdlet 的在线解释——忽略您本机安装的帮助文件。","text":"适用于 PowerShell 3.0 及以上版本 从 PowerShell 3.0 开始，帮助文件不在随着 PowerShell 发布。相反，您需要通过 Update-Help 来下载它们，并且由于帮助文件是存储在（受保护的）PowerShell 文件夹中，所以一个普通用户无法实现该操作。 将来您需要某个 cmdlet 的帮助时，只需要直接使用在线版即可。以下代码将通过浏览器访问 Get-Process 的在线帮助（假设您有 Internet 连接）： PS&gt; help Get-Process -Online 安装了帮助文件之后，在 PowerShell ISE 中获得帮助变得更容易了：只需要点击任何 cmdlet 名称，然后按 F1 键。 如果仔细观察，会发现当按下 F1 时，实际上是帮您输入了帮助命令。所以如果需要同样的操作方便性，但是显示的是在线的帮助，您以实现一个类似这样的函数： function Get-Help($Name) { Get-Help $Name -Online } 然而，这可能会导致死循环，因为新创建的 Get-Help 会在内部调用自己。要让它正常工作，您需要您的函数内部是采用类似这样的方式调用原始的 Get-Help cmdlet： function Get-Help($Name) { Microsoft.PowerShell.Core\\Get-Help $Name -Online } 当您运行这个函数是，您可以点击 PowerShell ISE 中的任意 cmdlet 名称，然后按 F1 键，就能够访问该 cmdlet 的在线解释——忽略您本机安装的帮助文件。 本文国际来源：Getting Cmdlet Help No Matter What","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检测 Wi-Fi 适配器和电源","slug":"examining-wi-fi-adapters-and-power-management","date":"2015-03-09T03:00:00.000Z","updated":"2017-03-17T15:26:25.303Z","comments":true,"path":"2015/03/09/examining-wi-fi-adapters-and-power-management/","link":"","permalink":"http://blog.vichamp.com/2015/03/09/examining-wi-fi-adapters-and-power-management/","excerpt":"适用于 Windows 8.1/Server 2012 R2 Windows 8.1 和 Server 2012 R2 带来了一系列好用的网卡管理 cmdlet。例如当您希望调查 Wi-Fi 连接问题时，或是检查为什么 Wake-On-LAN 功能未能唤醒机器时，检查网卡电源管理设置就十分有意思了。 现在是小菜一碟了： PS&gt; Get-NetAdapter Name InterfaceDescription ifIndex Status ---- -------------------- ------- ----- Bluetooth-Netzwerkverb... Bluetooth-Gerät (PAN) 7 Di... WiFi Intel(R) Wireless-N 7260 3 Up PS&gt; Get-NetAdapter -Name WiFi Name InterfaceDescription ifIndex Status ---- -------------------- ------- ----- WiFi Intel(R) Wireless-N 7260 3 Up 只要您知道网卡的名称，那么查询它电源管理设置的方法是： PS&gt; Get-NetAdapter -Name WiFi | Get-NetAdapterPowerManagement InterfaceDescription : Intel(R) Wireless-N 7260 Name : WiFi ArpOffload : Enabled NSOffload : Enabled RsnRekeyOffload : Enabled D0PacketCoalescing : Enabled SelectiveSuspend : Unsupported DeviceSleepOnDisconnect : Disabled WakeOnMagicPacket : Enabled WakeOnPattern : Enabled 请注意您需要管理员权限来查看电源管理设置，否则会得到一个误导性的错误信息，提示设备工作不正常。","text":"适用于 Windows 8.1/Server 2012 R2 Windows 8.1 和 Server 2012 R2 带来了一系列好用的网卡管理 cmdlet。例如当您希望调查 Wi-Fi 连接问题时，或是检查为什么 Wake-On-LAN 功能未能唤醒机器时，检查网卡电源管理设置就十分有意思了。 现在是小菜一碟了： PS&gt; Get-NetAdapter Name InterfaceDescription ifIndex Status ---- -------------------- ------- ----- Bluetooth-Netzwerkverb... Bluetooth-Gerät (PAN) 7 Di... WiFi Intel(R) Wireless-N 7260 3 Up PS&gt; Get-NetAdapter -Name WiFi Name InterfaceDescription ifIndex Status ---- -------------------- ------- ----- WiFi Intel(R) Wireless-N 7260 3 Up 只要您知道网卡的名称，那么查询它电源管理设置的方法是： PS&gt; Get-NetAdapter -Name WiFi | Get-NetAdapterPowerManagement InterfaceDescription : Intel(R) Wireless-N 7260 Name : WiFi ArpOffload : Enabled NSOffload : Enabled RsnRekeyOffload : Enabled D0PacketCoalescing : Enabled SelectiveSuspend : Unsupported DeviceSleepOnDisconnect : Disabled WakeOnMagicPacket : Enabled WakeOnPattern : Enabled 请注意您需要管理员权限来查看电源管理设置，否则会得到一个误导性的错误信息，提示设备工作不正常。 本文国际来源：Examining Wi-Fi Adapters and Power Management","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 Finally 来处理关键的清理任务","slug":"using-finally-for-crucial-cleanup-tasks","date":"2015-03-06T04:00:00.000Z","updated":"2017-03-17T15:26:25.299Z","comments":true,"path":"2015/03/06/using-finally-for-crucial-cleanup-tasks/","link":"","permalink":"http://blog.vichamp.com/2015/03/06/using-finally-for-crucial-cleanup-tasks/","excerpt":"适用于 PowerShell 2.0 及以上版本 在前一个技能中我们介绍了一个“有声的进度条”，它能令 PowerShell 在忙时播放一段声音。以下还是那段代码： # find first available WAV file in Windows folder $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it $player = New-Object Media.SoundPlayer $WAVPath $player.PlayLooping() 1..100 | ForEach-Object { Write-Progress -Activity &apos;Doing Something. Hang in&apos; -Status $_ -PercentComplete $_ Start-Sleep -MilliSeconds (Get-Random -Minimum 300 -Maximum 1300) } $player.Stop() 这个脚本工作是正常的——除非您把它中断，例如按下 CTRL+C。如果按下这个组合键，脚本立即停止执行，并且 $player.Stop() 没有机会执行所以没有机会停止声音。 这就使用 PowerShell 中的 finally() 最为合适。它确保一个脚本退出前执行清理代码： # find first available WAV file in Windows folder $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it $player = New-Object Media.SoundPlayer $WAVPath try { $player.PlayLooping() 1..100 | ForEach-Object { Write-Progress -Activity &apos;Doing Something&apos; -Status $_ -PercentComplete $_ Start-Sleep -MilliSeconds (Get-Random -Minimum 300 -Maximum 1300) } } finally { $player.Stop() }","text":"适用于 PowerShell 2.0 及以上版本 在前一个技能中我们介绍了一个“有声的进度条”，它能令 PowerShell 在忙时播放一段声音。以下还是那段代码： # find first available WAV file in Windows folder $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it $player = New-Object Media.SoundPlayer $WAVPath $player.PlayLooping() 1..100 | ForEach-Object { Write-Progress -Activity &apos;Doing Something. Hang in&apos; -Status $_ -PercentComplete $_ Start-Sleep -MilliSeconds (Get-Random -Minimum 300 -Maximum 1300) } $player.Stop() 这个脚本工作是正常的——除非您把它中断，例如按下 CTRL+C。如果按下这个组合键，脚本立即停止执行，并且 $player.Stop() 没有机会执行所以没有机会停止声音。 这就使用 PowerShell 中的 finally() 最为合适。它确保一个脚本退出前执行清理代码： # find first available WAV file in Windows folder $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it $player = New-Object Media.SoundPlayer $WAVPath try { $player.PlayLooping() 1..100 | ForEach-Object { Write-Progress -Activity &apos;Doing Something&apos; -Status $_ -PercentComplete $_ Start-Sleep -MilliSeconds (Get-Random -Minimum 300 -Maximum 1300) } } finally { $player.Stop() } 本文国际来源：Using Finally for Crucial Cleanup Tasks","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 播放 WAV 文件","slug":"playing-wav-files-0","date":"2015-03-05T04:00:00.000Z","updated":"2017-03-17T15:26:25.277Z","comments":true,"path":"2015/03/05/playing-wav-files-0/","link":"","permalink":"http://blog.vichamp.com/2015/03/05/playing-wav-files-0/","excerpt":"适用于 PowerShell 所有版本 以下是一个简单的用 PowerShell 播放 WAV 声音文件的方法： # find first available WAV file in Windows folder $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it &quot;Playing $WAVPath...&quot; $player = New-Object Media.SoundPlayer $WAVPath $player.Play() &quot;Done!&quot; 这段脚本的第一部分在 Windows 文件夹中查找第一个 WAV 文件。当然，您可以将您喜欢的 WAV 文件路径赋给 $WAVFile。 下一步， Media.SoundPlayer 读取并播放 WAV 文件。请注意 Play() 如何播放声音：它在一个单独的线程中播放，而 PowerShell 将会立即继续运行。 您可以用这种方法来创建一个有声的进度条：当 PowerShell 在做某件事的时候持续播放声音： # find first available WAV file in Windows folder $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it $player = New-Object Media.SoundPlayer $WAVPath $player.PlayLooping() 1..100 | ForEach-Object { Write-Progress -Activity &apos;Doing Something. Hang in&apos; -Status $_ -PercentComplete $_ Start-Sleep -MilliSeconds (Get-Random -Minimum 300 -Maximum 1300) } $player.Stop() 现在，PlayLooping() 用于循环播放声音。该声音会一直播放下去，所以您需要手动调用 Stop()。这是脚本结束的时候需要做的事情。","text":"适用于 PowerShell 所有版本 以下是一个简单的用 PowerShell 播放 WAV 声音文件的方法： # find first available WAV file in Windows folder $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it &quot;Playing $WAVPath...&quot; $player = New-Object Media.SoundPlayer $WAVPath $player.Play() &quot;Done!&quot; 这段脚本的第一部分在 Windows 文件夹中查找第一个 WAV 文件。当然，您可以将您喜欢的 WAV 文件路径赋给 $WAVFile。 下一步， Media.SoundPlayer 读取并播放 WAV 文件。请注意 Play() 如何播放声音：它在一个单独的线程中播放，而 PowerShell 将会立即继续运行。 您可以用这种方法来创建一个有声的进度条：当 PowerShell 在做某件事的时候持续播放声音： # find first available WAV file in Windows folder $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it $player = New-Object Media.SoundPlayer $WAVPath $player.PlayLooping() 1..100 | ForEach-Object { Write-Progress -Activity &apos;Doing Something. Hang in&apos; -Status $_ -PercentComplete $_ Start-Sleep -MilliSeconds (Get-Random -Minimum 300 -Maximum 1300) } $player.Stop() 现在，PlayLooping() 用于循环播放声音。该声音会一直播放下去，所以您需要手动调用 Stop()。这是脚本结束的时候需要做的事情。 本文国际来源：Playing WAV Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - PowerShell ISE 自动化","slug":"automating-powershell-ise","date":"2015-03-04T04:00:00.000Z","updated":"2017-03-17T15:26:25.276Z","comments":true,"path":"2015/03/04/automating-powershell-ise/","link":"","permalink":"http://blog.vichamp.com/2015/03/04/automating-powershell-ise/","excerpt":"适用于 PowerShell 3.0 及以上版本 PowerShell ISE 是可以通过 $psISE 脚本化编程的。这个变量只在 PowerShell ISE 环境中有效。 要获得当前可见的脚本内容，请试试以下代码： PS&gt; $psise.CurrentFile.Editor.Text 这段代码可以实现一个简单的重命名方法，将 PowerShell ISE 当前打开的脚本中的 所有 “testserver” 替换成 “productionserver”（前提是在您当前的脚本代码中有一系列 “testserver” 字眼出现）： $psise.CurrentFile.Editor.Text = $psise.CurrentFile.Editor.Text -replace &apos;testserver&apos;, &apos;ProductionServer&apos;","text":"适用于 PowerShell 3.0 及以上版本 PowerShell ISE 是可以通过 $psISE 脚本化编程的。这个变量只在 PowerShell ISE 环境中有效。 要获得当前可见的脚本内容，请试试以下代码： PS&gt; $psise.CurrentFile.Editor.Text 这段代码可以实现一个简单的重命名方法，将 PowerShell ISE 当前打开的脚本中的 所有 “testserver” 替换成 “productionserver”（前提是在您当前的脚本代码中有一系列 “testserver” 字眼出现）： $psise.CurrentFile.Editor.Text = $psise.CurrentFile.Editor.Text -replace &apos;testserver&apos;, &apos;ProductionServer&apos; 本文国际来源：Automating PowerShell ISE","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找进程所有者","slug":"finding-process-owner","date":"2015-03-03T04:00:00.000Z","updated":"2017-03-17T15:26:25.255Z","comments":true,"path":"2015/03/03/finding-process-owner/","link":"","permalink":"http://blog.vichamp.com/2015/03/03/finding-process-owner/","excerpt":"适用于 PowerShell 3.0 及以上版本 Get-Process 能够返回所有运行中的进程，但是它；并不包含进程所有者。要查看进程所有者，您需要采用调用 WMI 服务等方法。 要让使用过程更方便些，一下是一个小巧的工具函数： filter Get-ProcessOwner { $id = $_.ID $info = (Get-WmiObject -Class Win32_Process -Filter &quot;Handle=$id&quot;).GetOwner() if ($info.ReturnValue -eq 2) { $owner = &apos;[Access Denied]&apos; } else { $owner = &apos;{0}\\{1}&apos; -f $info.Domain, $info.User } $_ | Add-Member -MemberType NoteProperty -Name Owner -Value $owner -PassThru } 当您将进程对象通过管道传递给 Get-ProcessOwner 时，它为进程对象附加了一个新的 “Owner“ 属性。该属性是一个隐藏属性，要通过 Select-Object 才能显示： PS&gt; Get-Process -Id $pid | Get-ProcessOwner | Select-Object -Property Name, ID, Owner Name Id Owner ---- -- ----- powershell_ise 10080 TOBI2\\Tobias 它也适用于多个进程对象： PS&gt; Get-Process | Where-Object MainWindowTitle | Get-ProcessOwner | Select-Object -Property Name, ID, Owner Name Id Owner ---- -- ----- chrome 13028 TOBI2\\Tobias devenv 13724 TOBI2\\Tobias Energy Manager 6120 TOBI2\\Tobias ILSpy 14928 TOBI2\\Tobias (...) 请注意只有获得了管理员权限才可以获取进程所有者。如果没有货的管理员权限，您只能获得您自己进程的所有者，这样相对意义不大。","text":"适用于 PowerShell 3.0 及以上版本 Get-Process 能够返回所有运行中的进程，但是它；并不包含进程所有者。要查看进程所有者，您需要采用调用 WMI 服务等方法。 要让使用过程更方便些，一下是一个小巧的工具函数： filter Get-ProcessOwner { $id = $_.ID $info = (Get-WmiObject -Class Win32_Process -Filter &quot;Handle=$id&quot;).GetOwner() if ($info.ReturnValue -eq 2) { $owner = &apos;[Access Denied]&apos; } else { $owner = &apos;{0}\\{1}&apos; -f $info.Domain, $info.User } $_ | Add-Member -MemberType NoteProperty -Name Owner -Value $owner -PassThru } 当您将进程对象通过管道传递给 Get-ProcessOwner 时，它为进程对象附加了一个新的 “Owner“ 属性。该属性是一个隐藏属性，要通过 Select-Object 才能显示： PS&gt; Get-Process -Id $pid | Get-ProcessOwner | Select-Object -Property Name, ID, Owner Name Id Owner ---- -- ----- powershell_ise 10080 TOBI2\\Tobias 它也适用于多个进程对象： PS&gt; Get-Process | Where-Object MainWindowTitle | Get-ProcessOwner | Select-Object -Property Name, ID, Owner Name Id Owner ---- -- ----- chrome 13028 TOBI2\\Tobias devenv 13724 TOBI2\\Tobias Energy Manager 6120 TOBI2\\Tobias ILSpy 14928 TOBI2\\Tobias (...) 请注意只有获得了管理员权限才可以获取进程所有者。如果没有货的管理员权限，您只能获得您自己进程的所有者，这样相对意义不大。 本文国际来源：Finding Process Owner","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用基于 JSON 的 Web Service","slug":"using-json-based-web-services","date":"2015-03-02T04:00:00.000Z","updated":"2017-03-17T15:26:25.255Z","comments":true,"path":"2015/03/02/using-json-based-web-services/","link":"","permalink":"http://blog.vichamp.com/2015/03/02/using-json-based-web-services/","excerpt":"适用于 PowerShell 3.0 及以上版本 Internet 有许多信息提供服务，许多返回的是 JSON 数据格式。以下是一个演示如何用 PowerShell 查询这类 Web Service，并将 JSON 结果转换为对象的例子。 这个例子使用一个德国铁路公司的 Web Service。您只要输入火车站或城市名字的一部分，就能得到包含输入信息的所有火车站名： # ask for part of the train station name $name = Read-Host &apos;Enter part of train station Name&apos; # query webservice $url = &quot;http://openbahnapi.appspot.com/rest/stations/list?contains=$name&quot; $site = Invoke-WebRequest -Uri $url # get JSON result ($site.Content | ConvertFrom-Json ).value 结果看起来类似这样： PS&gt; Enter part of train station name: hanno Hannover Hbf HANNOVER MESSE Hannoversch Münden Hannover-Nordstadt Hannover Bismarckstr. Hannover Karl-Wiechert-Allee Hannover-Ledeburg Hannover-Linden/Fischerhof Hannover-Vinnhorst Hannover-Leinhausen Hannover Anderten-Misburg Hannover-Bornum PS&gt; 这段代码并不仅限于德国铁路系统，所以如果您不是对德国铁路系统特别兴趣的话，可以调用任何基于 JSON 的 Web Service。 重要的环节是 Invoke-WebRequest（该命令和 Web Service 通信并返回结果），以及 ConvertFrom-Json（该命令接收上一步的结果并将它转换为对象）。 请注意 Web Service 的提供者可能随时改变服务的实现。示例代码中的 Web Service 只能当做学习的例子来用。","text":"适用于 PowerShell 3.0 及以上版本 Internet 有许多信息提供服务，许多返回的是 JSON 数据格式。以下是一个演示如何用 PowerShell 查询这类 Web Service，并将 JSON 结果转换为对象的例子。 这个例子使用一个德国铁路公司的 Web Service。您只要输入火车站或城市名字的一部分，就能得到包含输入信息的所有火车站名： # ask for part of the train station name $name = Read-Host &apos;Enter part of train station Name&apos; # query webservice $url = &quot;http://openbahnapi.appspot.com/rest/stations/list?contains=$name&quot; $site = Invoke-WebRequest -Uri $url # get JSON result ($site.Content | ConvertFrom-Json ).value 结果看起来类似这样： PS&gt; Enter part of train station name: hanno Hannover Hbf HANNOVER MESSE Hannoversch Münden Hannover-Nordstadt Hannover Bismarckstr. Hannover Karl-Wiechert-Allee Hannover-Ledeburg Hannover-Linden/Fischerhof Hannover-Vinnhorst Hannover-Leinhausen Hannover Anderten-Misburg Hannover-Bornum PS&gt; 这段代码并不仅限于德国铁路系统，所以如果您不是对德国铁路系统特别兴趣的话，可以调用任何基于 JSON 的 Web Service。 重要的环节是 Invoke-WebRequest（该命令和 Web Service 通信并返回结果），以及 ConvertFrom-Json（该命令接收上一步的结果并将它转换为对象）。 请注意 Web Service 的提供者可能随时改变服务的实现。示例代码中的 Web Service 只能当做学习的例子来用。 本文国际来源：Using JSON-based Web Services","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用数组作为参数的缺省值","slug":"using-arrays-as-parameter-default-values","date":"2015-02-27T04:00:00.000Z","updated":"2017-03-17T15:26:25.239Z","comments":true,"path":"2015/02/27/using-arrays-as-parameter-default-values/","link":"","permalink":"http://blog.vichamp.com/2015/02/27/using-arrays-as-parameter-default-values/","excerpt":"适用于 PowerShell 3.0 及以上版本 如果您定义的 PowerShell 函数有几个参数，并且希望某个参数的缺省值是一个数组，您可能会遇到语法问题： function Get-SomeData { param ( $ServerID = 1,2,5,10,11 ) &quot;Your choice: $ServerID&quot; } PowerShell 使用逗号来分隔参数，所以在 param() 块中的 “1” 之后的逗号会被曲解，PowerShell 会认为这是一个接下来定义的新参数。 当会发生歧义的时候，使用圆括号来确保这些部分是一个整体。以下是一段完美合法的代码： function Get-SomeData { param ( $ServerID = (1,2,5,10,11) ) &quot;Your choice: $ServerID&quot; }","text":"适用于 PowerShell 3.0 及以上版本 如果您定义的 PowerShell 函数有几个参数，并且希望某个参数的缺省值是一个数组，您可能会遇到语法问题： function Get-SomeData { param ( $ServerID = 1,2,5,10,11 ) &quot;Your choice: $ServerID&quot; } PowerShell 使用逗号来分隔参数，所以在 param() 块中的 “1” 之后的逗号会被曲解，PowerShell 会认为这是一个接下来定义的新参数。 当会发生歧义的时候，使用圆括号来确保这些部分是一个整体。以下是一段完美合法的代码： function Get-SomeData { param ( $ServerID = (1,2,5,10,11) ) &quot;Your choice: $ServerID&quot; } 本文国际来源：Using Arrays as Parameter Default Values","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 简化命令提示符","slug":"shorten-the-prompt","date":"2015-02-26T04:00:00.000Z","updated":"2017-03-17T15:26:25.239Z","comments":true,"path":"2015/02/26/shorten-the-prompt/","link":"","permalink":"http://blog.vichamp.com/2015/02/26/shorten-the-prompt/","excerpt":"适用于 PowerShell 3.0 及以上版本 缺省情况下，PowerShell 的命令提示符中包含了当前路径。当您以一个普通用户启动 PowerShell 时，当前路径就是您的用户路径。那是一个很长的路径，会占用命令行很多空间。 最有效最简单的方法是将当前目录改为根目录： PS C:\\Users\\Tobias\\Documents&gt; cd \\ PS C:\\&gt; 或者，可以调整 prompt 函数，使它在其它地方显示当前路径，例如在标题栏： function prompt { &apos;PS&gt; &apos; $host.UI.RawUI.WindowTitle = Get-Location }","text":"适用于 PowerShell 3.0 及以上版本 缺省情况下，PowerShell 的命令提示符中包含了当前路径。当您以一个普通用户启动 PowerShell 时，当前路径就是您的用户路径。那是一个很长的路径，会占用命令行很多空间。 最有效最简单的方法是将当前目录改为根目录： PS C:\\Users\\Tobias\\Documents&gt; cd \\ PS C:\\&gt; 或者，可以调整 prompt 函数，使它在其它地方显示当前路径，例如在标题栏： function prompt { &apos;PS&gt; &apos; $host.UI.RawUI.WindowTitle = Get-Location } 本文国际来源：Shorten the Prompt","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取 DELL 保修信息（第二部分）","slug":"getting-dell-warranty-information-part-2","date":"2015-02-25T04:00:00.000Z","updated":"2017-03-17T15:26:25.239Z","comments":true,"path":"2015/02/25/getting-dell-warranty-information-part-2/","link":"","permalink":"http://blog.vichamp.com/2015/02/25/getting-dell-warranty-information-part-2/","excerpt":"适用于 PowerShell 2.0 及以上版本 在前一个技巧中我们演示了如何用一个 Web Service 来获取 DELL 电脑的保修信息。我们收到了许多反馈，所以在我们介绍新内容之前，先展示这段可以获取保修信息的代码： $serial = &apos;36GPL41&apos; $service = New-WebServiceProxy -Uri http://143.166.84.118/services/assetservice.asmx?WSDL $guid = [Guid]::NewGuid() $info = $service.GetAssetInformation($guid,&apos;warrantycheck&apos;,$serial) $Entitlements = $info.Entitlements $Entitlements 现在，如果您试着将 $Entitlements 加到一个用户界面的文本框中，或者将它输出为文本，结果可能不是您想要的： PS&gt; &quot;Your Entitlements: $Entitlements&quot; Your Entitlements: Microsoft.PowerShell.Commands.NewWebserviceProxy.AutogeneratedTypes.WebServiceProxy1ervices_assetservice_asmx_WSDL.EntitlementData Microsoft.PowerShell.Commands.NewWebserviceProxy.AutogeneratedTypes.WebServiceProxy1ervices_assetservice_asmx_WSDL.EntitlementData Microsoft.PowerShell.Commands.NewWebserviceProxy.AutogeneratedTypes.WebServiceProxy1ervices_assetservice_asmx_WSDL.EntitlementData PS&gt; 这是因为 $Entitlements 是一个对象数组。当将它以文本方式显示时，我们希望 PowerShell 扩展类型系统能处理这些对象，所以将它们用 Out-String 处理一下： PS&gt; $EntitlementsText = $Entitlements | Out-String PS&gt; &quot;Your Entitlements: $EntitlementsText&quot; Your Entitlements: ServiceLevelCode : TS ServiceLevelDescription : P, ProSupport Provider : DELL StartDate : 23.03.2004 00:00:00 EndDate : 23.03.2007 00:00:00 DaysLeft : 0 EntitlementType : Expired ServiceLevelCode : ND ServiceLevelDescription : C, NBD ONSITE Provider : UNY StartDate : 23.03.2005 00:00:00 EndDate : 23.03.2007 00:00:00 DaysLeft : 0 EntitlementType : Expired ServiceLevelCode : ND ServiceLevelDescription : C, NBD ONSITE Provider : UNY StartDate : 23.03.2004 00:00:00 EndDate : 24.03.2005 00:00:00 DaysLeft : 0 EntitlementType : Expired","text":"适用于 PowerShell 2.0 及以上版本 在前一个技巧中我们演示了如何用一个 Web Service 来获取 DELL 电脑的保修信息。我们收到了许多反馈，所以在我们介绍新内容之前，先展示这段可以获取保修信息的代码： $serial = &apos;36GPL41&apos; $service = New-WebServiceProxy -Uri http://143.166.84.118/services/assetservice.asmx?WSDL $guid = [Guid]::NewGuid() $info = $service.GetAssetInformation($guid,&apos;warrantycheck&apos;,$serial) $Entitlements = $info.Entitlements $Entitlements 现在，如果您试着将 $Entitlements 加到一个用户界面的文本框中，或者将它输出为文本，结果可能不是您想要的： PS&gt; &quot;Your Entitlements: $Entitlements&quot; Your Entitlements: Microsoft.PowerShell.Commands.NewWebserviceProxy.AutogeneratedTypes.WebServiceProxy1ervices_assetservice_asmx_WSDL.EntitlementData Microsoft.PowerShell.Commands.NewWebserviceProxy.AutogeneratedTypes.WebServiceProxy1ervices_assetservice_asmx_WSDL.EntitlementData Microsoft.PowerShell.Commands.NewWebserviceProxy.AutogeneratedTypes.WebServiceProxy1ervices_assetservice_asmx_WSDL.EntitlementData PS&gt; 这是因为 $Entitlements 是一个对象数组。当将它以文本方式显示时，我们希望 PowerShell 扩展类型系统能处理这些对象，所以将它们用 Out-String 处理一下： PS&gt; $EntitlementsText = $Entitlements | Out-String PS&gt; &quot;Your Entitlements: $EntitlementsText&quot; Your Entitlements: ServiceLevelCode : TS ServiceLevelDescription : P, ProSupport Provider : DELL StartDate : 23.03.2004 00:00:00 EndDate : 23.03.2007 00:00:00 DaysLeft : 0 EntitlementType : Expired ServiceLevelCode : ND ServiceLevelDescription : C, NBD ONSITE Provider : UNY StartDate : 23.03.2005 00:00:00 EndDate : 23.03.2007 00:00:00 DaysLeft : 0 EntitlementType : Expired ServiceLevelCode : ND ServiceLevelDescription : C, NBD ONSITE Provider : UNY StartDate : 23.03.2004 00:00:00 EndDate : 24.03.2005 00:00:00 DaysLeft : 0 EntitlementType : Expired 本文国际来源：Getting DELL Warranty Information (Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将文件的扩展名正常化","slug":"normalizing-file-extensions","date":"2015-02-24T04:00:00.000Z","updated":"2017-03-17T15:26:25.224Z","comments":true,"path":"2015/02/24/normalizing-file-extensions/","link":"","permalink":"http://blog.vichamp.com/2015/02/24/normalizing-file-extensions/","excerpt":"适用于 PowerShell 2.0 及以上版本 假设您希望用户提交一个文件扩展名的列表，或者是从某些其它来源获取这个列表。 文件扩展名是模糊标准的绝好例子。您要如何指定一个文本文件的扩展名呢？是用 “.txt” 还是 “*.txt”？ 以下是一个将文件的扩展名正常化的简单技巧，无论它们如何拼写都有效： $extensions = &apos;*.ps1&apos;, &apos;.txt&apos; $cleanExtensions = $extensions -replace &apos;^\\.&apos;, &apos;*.&apos; $extensions $cleanExtensions","text":"适用于 PowerShell 2.0 及以上版本 假设您希望用户提交一个文件扩展名的列表，或者是从某些其它来源获取这个列表。 文件扩展名是模糊标准的绝好例子。您要如何指定一个文本文件的扩展名呢？是用 “.txt” 还是 “*.txt”？ 以下是一个将文件的扩展名正常化的简单技巧，无论它们如何拼写都有效： $extensions = &apos;*.ps1&apos;, &apos;.txt&apos; $cleanExtensions = $extensions -replace &apos;^\\.&apos;, &apos;*.&apos; $extensions $cleanExtensions 本文国际来源：Normalizing File Extensions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 PowerShell ISE 调试器","slug":"using-the-powershell-ise-debugger","date":"2015-02-23T04:00:00.000Z","updated":"2017-03-17T15:26:25.224Z","comments":true,"path":"2015/02/23/using-the-powershell-ise-debugger/","link":"","permalink":"http://blog.vichamp.com/2015/02/23/using-the-powershell-ise-debugger/","excerpt":"适用于 PowerShell 3.0 及以上版本 有些时候，很难找出 PowerShell 脚本为什么不按期望工作的原因。要更好地了解脚本工作的过程，请使用 PowerShell ISE 内置的调试器。 在您开始调试一个脚本之前请先保存它。无标题的脚本实际上还不算脚本，所以 PowerShell ISE 还无法调试它。 以下是调试一个脚本的简单步骤： 设置断点。断点是您希望调试器在代码中停下的位置，这样您可以检查当前变量的状态。要设置一个断点，请单击某一行，然后按下 F9 键。该行代码将会变成红色。如果该行未变红，说明您还没有保存该脚本，或是该行代码不包含可执行的代码。 运行脚本：脚本将会正常运行，但当运行到一个断点时，PowerShell ISE 将会暂停。当前行会标记成黄色。您可以将光标悬停到代码中的变量上来查看它们的值，或是在交互式窗口中执行任意代码，例如导出变量的值，甚至改变变量的值。 继续：要继续执行下一条指令，请按 F10 或 F11。F10 将执行当前作用域内的下一条指令。F11 将执行下一条指令，无论是哪个作用域。所以如果当前行将要执行一个函数，而您按下 F10，那么将执行整个函数。如果您按下 F11，那么您将执行到该函数的第一行。这有点像“一小步”的概念。 按下 F5 继续执行整个脚本。它将运行到整个脚本结束，或是遇到下一个断点。 按下 SHIFT+F5 退出执行过程并且停止调试器。 一旦您掌握了这些步骤，调试过程会变得十分容易。并且它可以给您带来许多领悟和帮助。如果不采用调试方法的话将很难调查脚本错误。","text":"适用于 PowerShell 3.0 及以上版本 有些时候，很难找出 PowerShell 脚本为什么不按期望工作的原因。要更好地了解脚本工作的过程，请使用 PowerShell ISE 内置的调试器。 在您开始调试一个脚本之前请先保存它。无标题的脚本实际上还不算脚本，所以 PowerShell ISE 还无法调试它。 以下是调试一个脚本的简单步骤： 设置断点。断点是您希望调试器在代码中停下的位置，这样您可以检查当前变量的状态。要设置一个断点，请单击某一行，然后按下 F9 键。该行代码将会变成红色。如果该行未变红，说明您还没有保存该脚本，或是该行代码不包含可执行的代码。 运行脚本：脚本将会正常运行，但当运行到一个断点时，PowerShell ISE 将会暂停。当前行会标记成黄色。您可以将光标悬停到代码中的变量上来查看它们的值，或是在交互式窗口中执行任意代码，例如导出变量的值，甚至改变变量的值。 继续：要继续执行下一条指令，请按 F10 或 F11。F10 将执行当前作用域内的下一条指令。F11 将执行下一条指令，无论是哪个作用域。所以如果当前行将要执行一个函数，而您按下 F10，那么将执行整个函数。如果您按下 F11，那么您将执行到该函数的第一行。这有点像“一小步”的概念。 按下 F5 继续执行整个脚本。它将运行到整个脚本结束，或是遇到下一个断点。 按下 SHIFT+F5 退出执行过程并且停止调试器。 一旦您掌握了这些步骤，调试过程会变得十分容易。并且它可以给您带来许多领悟和帮助。如果不采用调试方法的话将很难调查脚本错误。 本文国际来源：Using the PowerShell ISE Debugger","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 ISE 中使用代码区域","slug":"using-code-regions-in-ise","date":"2015-02-20T04:00:00.000Z","updated":"2017-03-17T15:26:25.208Z","comments":true,"path":"2015/02/20/using-code-regions-in-ise/","link":"","permalink":"http://blog.vichamp.com/2015/02/20/using-code-regions-in-ise/","excerpt":"适用于 PowerShell 3.0 及以上版本 PowerShell ISE 已经支持了可折叠的代码区域。当您编写函数、循环，或是条件时，您也许会注意到在左边距的上方有一个“减号”符号。点击它可实现折叠该区域。 如果看不到区域特性，您可以这样启用它们：视图/显示大纲(区域)。 您也可以在脚本的其它部分使用区域和代码折叠。要将代码的任意部分包括在一个可折叠的区域内，请在代码中加入一些特殊的注释： #region Variable Declarations $a = $b = $c = 1 $d, $e, $f = 2,3,4 #endregion 请注意这些特殊的注释是大小写敏感的。在将区域折叠之后，”#region“ 后的文本将变为折叠区域的标题。","text":"适用于 PowerShell 3.0 及以上版本 PowerShell ISE 已经支持了可折叠的代码区域。当您编写函数、循环，或是条件时，您也许会注意到在左边距的上方有一个“减号”符号。点击它可实现折叠该区域。 如果看不到区域特性，您可以这样启用它们：视图/显示大纲(区域)。 您也可以在脚本的其它部分使用区域和代码折叠。要将代码的任意部分包括在一个可折叠的区域内，请在代码中加入一些特殊的注释： #region Variable Declarations $a = $b = $c = 1 $d, $e, $f = 2,3,4 #endregion 请注意这些特殊的注释是大小写敏感的。在将区域折叠之后，”#region“ 后的文本将变为折叠区域的标题。 本文国际来源：Using Code Regions in ISE","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 进程终结器（和一些陷阱）","slug":"process-killer-and-some-gotchas","date":"2015-02-19T04:00:00.000Z","updated":"2017-03-17T15:26:25.208Z","comments":true,"path":"2015/02/19/process-killer-and-some-gotchas/","link":"","permalink":"http://blog.vichamp.com/2015/02/19/process-killer-and-some-gotchas/","excerpt":"适用于 PowerShell 3.0 及以上版本 在前一个技能中我们介绍了如何利用 Out-GridView 做一个选择对话框，并且提供了一些建议。一个点子是列出所有桌面应用，并且允许用户选择一个进程并终结它。 要列出所有桌面应用，请试试这段代码： PS&gt; Get-Process | Where-Object MainWindowTitle | Select-Object -Property Name, Description, MainWindowTitle, StartTime 这行代码对进程列表进行过滤并只列出设置了 MainWindowTitle 的进程。实际上，它返回了一个包含窗体的列表，忽略了所有不可见的后台进程。 接下来，将结果通过管道输出到 Out-GridView 并允许单选： PS&gt; Get-Process | Where-Object MainWindowTitle | Select-Object -Property Name, Description, MainWindowTitle, StartTime | Out-GridView -Title &apos;Kill Application&apos; -OutputMode Single | Stop-Process -WhatIf 这行代码将打开一个网格视图窗口，显示所有运行中的进程。当您选中一个进程并点击“确定”按钮，将会杀掉该进程。不过，还差一点：这段示例代码包含了 -WhatIf 开关，所以只是 Stop-Process 只是模拟操作。 所以这是个好东西，因为您可能会注意到选择一个进程将会导致杀掉所有同名的进程。 这是由于 Stop-Process 可以接受两个不同的信息：名字（字符串），或是进程 ID (int)。由于这行代码使用了 Select-Object 来筛选属性，并且不包含进程 ID，所以 Stop-Process 将会使用进程名字，并杀掉所有同名的进程。 要实现杀除更具体的进程，请确保包含了进程的 ID： PS&gt; Get-Process | Where-Object MainWindowTitle | Select-Object -Property Name, Id, Description, MainWindowTitle, StartTime | Out-GridView -Title &apos;Kill Application&apos; -OutputMode Single | Stop-Process -WhatIf","text":"适用于 PowerShell 3.0 及以上版本 在前一个技能中我们介绍了如何利用 Out-GridView 做一个选择对话框，并且提供了一些建议。一个点子是列出所有桌面应用，并且允许用户选择一个进程并终结它。 要列出所有桌面应用，请试试这段代码： PS&gt; Get-Process | Where-Object MainWindowTitle | Select-Object -Property Name, Description, MainWindowTitle, StartTime 这行代码对进程列表进行过滤并只列出设置了 MainWindowTitle 的进程。实际上，它返回了一个包含窗体的列表，忽略了所有不可见的后台进程。 接下来，将结果通过管道输出到 Out-GridView 并允许单选： PS&gt; Get-Process | Where-Object MainWindowTitle | Select-Object -Property Name, Description, MainWindowTitle, StartTime | Out-GridView -Title &apos;Kill Application&apos; -OutputMode Single | Stop-Process -WhatIf 这行代码将打开一个网格视图窗口，显示所有运行中的进程。当您选中一个进程并点击“确定”按钮，将会杀掉该进程。不过，还差一点：这段示例代码包含了 -WhatIf 开关，所以只是 Stop-Process 只是模拟操作。 所以这是个好东西，因为您可能会注意到选择一个进程将会导致杀掉所有同名的进程。 这是由于 Stop-Process 可以接受两个不同的信息：名字（字符串），或是进程 ID (int)。由于这行代码使用了 Select-Object 来筛选属性，并且不包含进程 ID，所以 Stop-Process 将会使用进程名字，并杀掉所有同名的进程。 要实现杀除更具体的进程，请确保包含了进程的 ID： PS&gt; Get-Process | Where-Object MainWindowTitle | Select-Object -Property Name, Id, Description, MainWindowTitle, StartTime | Out-GridView -Title &apos;Kill Application&apos; -OutputMode Single | Stop-Process -WhatIf 本文国际来源：Process Killer (and some gotchas)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将结果复制到剪贴板","slug":"copying-results-to-clipboard-021815","date":"2015-02-18T04:00:00.000Z","updated":"2017-03-17T15:26:25.208Z","comments":true,"path":"2015/02/18/copying-results-to-clipboard-021815/","link":"","permalink":"http://blog.vichamp.com/2015/02/18/copying-results-to-clipboard-021815/","excerpt":"适用于 PowerShell 3.0 及以上版本 在前一个技能中我们介绍了如何简单地从 Out-GridView 的网格视图窗口中复制粘贴信息。不过这并不会复制列头。 您可以将这行代码加到任意命令中，并将它的结果复制到剪贴板中（包括列头）： PS&gt; Get-Service | Format-Table -AutoSize -Wrap | Out-String -Width 200 | clip.exe 当您运行完这行代码后，所有服务的清单就保存到剪贴板中了，接下来可以将内容粘贴到 Word 或其它接受文本输入的应用程序中。 请注意 Format-Table 和 Out-String 的用法：它们确保数据不会按照 PowerShell 控制台的边界来格式化。相反地，可用的宽度被设为设为 200 字符，如果结果仍比这个长，那么将会折行。 如果忽略掉这两个 cmdlet，然后查看一下结果：如果没有它们，文本将会输出到 PowerShell 控制台。过长的结果将会被截断。 为了简化操作，您可以将这行代码封装为一个简单的函数，例如： PS&gt; function Out-Clipboard { $input | Format-Table -AutoSize -Wrap | Out-String -Width 1000 | clip.exe } 现在，当您想将结果复制到剪贴板时，可以使用 Out-Clipboard： PS&gt; Get-Process | Out-Clipboard","text":"适用于 PowerShell 3.0 及以上版本 在前一个技能中我们介绍了如何简单地从 Out-GridView 的网格视图窗口中复制粘贴信息。不过这并不会复制列头。 您可以将这行代码加到任意命令中，并将它的结果复制到剪贴板中（包括列头）： PS&gt; Get-Service | Format-Table -AutoSize -Wrap | Out-String -Width 200 | clip.exe 当您运行完这行代码后，所有服务的清单就保存到剪贴板中了，接下来可以将内容粘贴到 Word 或其它接受文本输入的应用程序中。 请注意 Format-Table 和 Out-String 的用法：它们确保数据不会按照 PowerShell 控制台的边界来格式化。相反地，可用的宽度被设为设为 200 字符，如果结果仍比这个长，那么将会折行。 如果忽略掉这两个 cmdlet，然后查看一下结果：如果没有它们，文本将会输出到 PowerShell 控制台。过长的结果将会被截断。 为了简化操作，您可以将这行代码封装为一个简单的函数，例如： PS&gt; function Out-Clipboard { $input | Format-Table -AutoSize -Wrap | Out-String -Width 1000 | clip.exe } 现在，当您想将结果复制到剪贴板时，可以使用 Out-Clipboard： PS&gt; Get-Process | Out-Clipboard 本文国际来源：Copying Results to Clipboard","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Out-GridView：通用对话框","slug":"out-gridview-universal-dialog","date":"2015-02-17T04:00:00.000Z","updated":"2017-03-17T15:26:25.193Z","comments":true,"path":"2015/02/17/out-gridview-universal-dialog/","link":"","permalink":"http://blog.vichamp.com/2015/02/17/out-gridview-universal-dialog/","excerpt":"适用于 PowerShell 3.0 及以上版本 默认情况下，Out-GridView 是一条单行道：您可以将数据用管道输出到该命令，将结果显示在一个网格视图窗口中，但是您无法将数据再往下传递。 当您添加了 -PassThru 开关参数时，情况就变了。这时 Out-GridView 的右下角显示了两个新按钮：“确定”和“取消”。它将自己变为一个通用的对话框。 试试这行代码： PS&gt; Get-Service | Where-Object CanStop | Out-GridView -Title &apos;Stoppable Services&apos; -PassThru 这将打开一个标题为 “Stoppable Services” 的网格视图窗口，并列出所有可停止的服务（您可能还需要管理员权限才可以停止它们）。 您现在可以选择一个或多个项目（按住 CTRL 键多选），然后点击网格视图窗口右下角的“确定”按钮。 如您所见，返回了选中的对象。 要将这行代码变为一个有用的工具，您可以将 Out-GridView 的结果输出到 cmdlet，来执行具体的操作。这行代码将试图停止所有选中的服务： PS&gt; Get-Service | Where-Object CanStop | Out-GridView -Title &apos;Stoppable Services&apos; -PassThru | Stop-Service -WhatIf 请注意，出于安全考虑，我们对 Stop-Service 命令增加了 -WhatIf 参数，所以该 cmdlet 只会模拟停止服务。当您移除了这个参数，该行代码就不是模拟执行，而是真实停止服务了。 只需要坐下喝杯咖啡，然后思考一下它的原理：Out-GridView 接受任何类型的数据，所以您可以用它创建任何工具。例如，使用 Active Directory cmdlet Get-ADUser 来查找当前禁用的用户，然后让 PowerShell 为您启用所有选中的用户。 或者显示一个有主窗口的进程（桌面应用），并且杀掉所有选中的进程。 如果想达到这个目的，您可能会期望 Out-GridView 禁止多选。要想只允许选择单条记录，请试试以下代码： PS&gt; 1..10 | Out-GridView -Title &apos;Pick favorite number&apos; -OutputMode Single","text":"适用于 PowerShell 3.0 及以上版本 默认情况下，Out-GridView 是一条单行道：您可以将数据用管道输出到该命令，将结果显示在一个网格视图窗口中，但是您无法将数据再往下传递。 当您添加了 -PassThru 开关参数时，情况就变了。这时 Out-GridView 的右下角显示了两个新按钮：“确定”和“取消”。它将自己变为一个通用的对话框。 试试这行代码： PS&gt; Get-Service | Where-Object CanStop | Out-GridView -Title &apos;Stoppable Services&apos; -PassThru 这将打开一个标题为 “Stoppable Services” 的网格视图窗口，并列出所有可停止的服务（您可能还需要管理员权限才可以停止它们）。 您现在可以选择一个或多个项目（按住 CTRL 键多选），然后点击网格视图窗口右下角的“确定”按钮。 如您所见，返回了选中的对象。 要将这行代码变为一个有用的工具，您可以将 Out-GridView 的结果输出到 cmdlet，来执行具体的操作。这行代码将试图停止所有选中的服务： PS&gt; Get-Service | Where-Object CanStop | Out-GridView -Title &apos;Stoppable Services&apos; -PassThru | Stop-Service -WhatIf 请注意，出于安全考虑，我们对 Stop-Service 命令增加了 -WhatIf 参数，所以该 cmdlet 只会模拟停止服务。当您移除了这个参数，该行代码就不是模拟执行，而是真实停止服务了。 只需要坐下喝杯咖啡，然后思考一下它的原理：Out-GridView 接受任何类型的数据，所以您可以用它创建任何工具。例如，使用 Active Directory cmdlet Get-ADUser 来查找当前禁用的用户，然后让 PowerShell 为您启用所有选中的用户。 或者显示一个有主窗口的进程（桌面应用），并且杀掉所有选中的进程。 如果想达到这个目的，您可能会期望 Out-GridView 禁止多选。要想只允许选择单条记录，请试试以下代码： PS&gt; 1..10 | Out-GridView -Title &apos;Pick favorite number&apos; -OutputMode Single 本文国际来源：Out-GridView: Universal Dialog","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找所有可停止的服务","slug":"finding-all-stoppable-services","date":"2015-02-16T04:00:00.000Z","updated":"2017-03-17T15:26:25.193Z","comments":true,"path":"2015/02/16/finding-all-stoppable-services/","link":"","permalink":"http://blog.vichamp.com/2015/02/16/finding-all-stoppable-services/","excerpt":"适用于 PowerShell 3.0 及以上版本 Get-Service 可以列出您计算机上所有已安装的服务。不过它没有可以选择仅包含运行或停止的服务的参数。 用一个简单的 Where-Object 从句，您可以实现这个目的。最常见的是，您会见到类似如下的用法： PS&gt; Get-Service | Where-Object Status -eq Running 基本上，Where-Object 可以指定对象拥有的任意属性并且允许您定义需要的条件。 If you planned to get a list of stoppable services, the above line would not work well. Some services may be running but cannot be stopped. By adjusting your filter slightly, you still get what you need. This produces a list of running services that are actually stoppable:如果您打算获得一个可停止的服务的列表，那么上述代码不能达到您所要的目的。一些服务可能正在运行但是不能被停止。稍微调整一下过滤条件，您就可以达到所要的目的了。这段代码列出所有运行中并且可以停止的服务： PS&gt; Get-Service | Where-Object CanStop 并且这种写法缩短了代码量：由于 “CanStop“ 属性本身是个布尔值（true 或 false），所以无需使用比较运算符。 要查看这个列表的补集，即所有不可停止的服务，可使用比较运算符： PS&gt; Get-Service | Where-Object CanStop -eq $false 请注意用 Where-Object 的简化语法，您无法取得相反的结果。以下代码并不会生效： PS&gt; Get-Service | Where-Object !CanStop PS&gt; Get-Service | Where-Object -not CanStop 要使用这些条件，或者要合并比较条件，请使用完整语法： PS&gt; Get-Service | Where-Object { !$_.CanStop -and $_.Status -eq &apos;Running&apos; }","text":"适用于 PowerShell 3.0 及以上版本 Get-Service 可以列出您计算机上所有已安装的服务。不过它没有可以选择仅包含运行或停止的服务的参数。 用一个简单的 Where-Object 从句，您可以实现这个目的。最常见的是，您会见到类似如下的用法： PS&gt; Get-Service | Where-Object Status -eq Running 基本上，Where-Object 可以指定对象拥有的任意属性并且允许您定义需要的条件。 If you planned to get a list of stoppable services, the above line would not work well. Some services may be running but cannot be stopped. By adjusting your filter slightly, you still get what you need. This produces a list of running services that are actually stoppable:如果您打算获得一个可停止的服务的列表，那么上述代码不能达到您所要的目的。一些服务可能正在运行但是不能被停止。稍微调整一下过滤条件，您就可以达到所要的目的了。这段代码列出所有运行中并且可以停止的服务： PS&gt; Get-Service | Where-Object CanStop 并且这种写法缩短了代码量：由于 “CanStop“ 属性本身是个布尔值（true 或 false），所以无需使用比较运算符。 要查看这个列表的补集，即所有不可停止的服务，可使用比较运算符： PS&gt; Get-Service | Where-Object CanStop -eq $false 请注意用 Where-Object 的简化语法，您无法取得相反的结果。以下代码并不会生效： PS&gt; Get-Service | Where-Object !CanStop PS&gt; Get-Service | Where-Object -not CanStop 要使用这些条件，或者要合并比较条件，请使用完整语法： PS&gt; Get-Service | Where-Object { !$_.CanStop -and $_.Status -eq &apos;Running&apos; } 本文国际来源：Finding All Stoppable Services","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"随机抽奖中的粘连现象","slug":"Concatenation-in-Random","date":"2015-02-14T03:22:56.000Z","updated":"2017-03-17T15:26:25.177Z","comments":true,"path":"2015/02/14/Concatenation-in-Random/","link":"","permalink":"http://blog.vichamp.com/2015/02/14/Concatenation-in-Random/","excerpt":"现象公司年会中的抽奖环节，是用一个计算机程序来随机抽取中奖姓名，嘉宾喊一声停，屏幕上就出现五个姓名。不过每抽取一次，大屏幕上显示的姓名往往是按部门粘连在一块的。也就是同一个部门连续出现 3-4 个中奖人。 重现这种现象是怎么产生的呢？从程序上，可以想象到一种可能性。我们用 C# 写一个随机数生成器，并假设录入数据的时候，是按部门录入的： 1234567891011121314151617181920212223242526internal class Generator&#123; private readonly IList&lt;string&gt; candidateList; private Random random = new Random(); internal Generator(string[] candidates) &#123; candidateList = new List&lt;string&gt;(candidates); &#125; internal string Pick() &#123; var random = new Random(); // 会导致粘连 //var random = this.random; // 不会粘连 int index = random.Next(candidateList.Count); Debug.Write(index + &quot;, &quot;); Thread.Sleep(5); // 延时，模拟计算机性能差的情况。 // 设为 5 时，有很多“粘连”的数据。 // 设为 15 时，“粘连”现象就消失了！ string choosen = candidateList[index]; candidateList.Remove(choosen); return choosen; &#125;&#125; 在 Pick() 方法中，采用 var random = new Random();，则生成的中奖名单如下： 从 Debug 窗口中可以观察到，每一轮（5 个）抽取的序号中实际上有许多是重复的或者是相邻的。而这一轮和下一轮之间的序号并不相邻。 3, 3, 3, 3, 3, 35, 35, 35, 34, 34, 14, 14, 13, 13, 13, 16, 15, 15, 15, 15, 60, 59, 58, 57, 57, 42, 41, 41, 40, 40, 8, 8, 7, 7, 7, 32, 32, 31, 31, 30, 12, 12, 11, 11, 11, 而且，调节 Thread.Sleep(x); 中的延时值，模拟计算机性能的快慢，可以改变结果粘连的程度！当延时小于 5 毫秒时，粘连现象十分明显；当延时大于 15 时，粘连现象基本消失。 消除粘连计算机性能是不可控制的，那么应当如何产生正确的随机数呢？正确的做法是，在一系列随机数生成的过程中，应该自始至终用同一个随机数发生器，而不是每生成一个随机数就临时创建一个随机数发生器。 所以在 Pick() 方法里 var random = new Random(); 的写法是不正确的。应该采用生存周期更长的 var random = this.random; 写法。代码修改后粘连现象消失了： 结论造成粘连现象的本质原因如下： 随机数的生成是从种子值开始。 如果反复使用同一个种子，就会生成相同的数字系列。 产生不同序列的一种方法是使种子值与时间相关，从而对于 Random 的每个新实例，都会产生不同的系列。 默认情况下，Random 类的无参数构造函数使用系统时钟生成其种子值，而参数化构造函数可根据当前时间的计时周期数采用 Int32 值。 但是，因为时钟的分辨率有限，所以，如果使用无参数构造函数连续创建不同的 Random 对象，就会创建生成相同随机数序列的随机数生成器。 在一轮中，每次抽号抽取的是相同的随机数序列的第一个元素，所以结果很有可能是相同的。由于中奖的号码从列表中移走，所以很可能连续抽到相邻部门的姓名。 注意，虽然结果有些不符合常理，但是对于个人来说，中奖概率还是均等的。 完整的代码如下：","text":"现象公司年会中的抽奖环节，是用一个计算机程序来随机抽取中奖姓名，嘉宾喊一声停，屏幕上就出现五个姓名。不过每抽取一次，大屏幕上显示的姓名往往是按部门粘连在一块的。也就是同一个部门连续出现 3-4 个中奖人。 重现这种现象是怎么产生的呢？从程序上，可以想象到一种可能性。我们用 C# 写一个随机数生成器，并假设录入数据的时候，是按部门录入的： 1234567891011121314151617181920212223242526internal class Generator&#123; private readonly IList&lt;string&gt; candidateList; private Random random = new Random(); internal Generator(string[] candidates) &#123; candidateList = new List&lt;string&gt;(candidates); &#125; internal string Pick() &#123; var random = new Random(); // 会导致粘连 //var random = this.random; // 不会粘连 int index = random.Next(candidateList.Count); Debug.Write(index + &quot;, &quot;); Thread.Sleep(5); // 延时，模拟计算机性能差的情况。 // 设为 5 时，有很多“粘连”的数据。 // 设为 15 时，“粘连”现象就消失了！ string choosen = candidateList[index]; candidateList.Remove(choosen); return choosen; &#125;&#125; 在 Pick() 方法中，采用 var random = new Random();，则生成的中奖名单如下： 从 Debug 窗口中可以观察到，每一轮（5 个）抽取的序号中实际上有许多是重复的或者是相邻的。而这一轮和下一轮之间的序号并不相邻。 3, 3, 3, 3, 3, 35, 35, 35, 34, 34, 14, 14, 13, 13, 13, 16, 15, 15, 15, 15, 60, 59, 58, 57, 57, 42, 41, 41, 40, 40, 8, 8, 7, 7, 7, 32, 32, 31, 31, 30, 12, 12, 11, 11, 11, 而且，调节 Thread.Sleep(x); 中的延时值，模拟计算机性能的快慢，可以改变结果粘连的程度！当延时小于 5 毫秒时，粘连现象十分明显；当延时大于 15 时，粘连现象基本消失。 消除粘连计算机性能是不可控制的，那么应当如何产生正确的随机数呢？正确的做法是，在一系列随机数生成的过程中，应该自始至终用同一个随机数发生器，而不是每生成一个随机数就临时创建一个随机数发生器。 所以在 Pick() 方法里 var random = new Random(); 的写法是不正确的。应该采用生存周期更长的 var random = this.random; 写法。代码修改后粘连现象消失了： 结论造成粘连现象的本质原因如下： 随机数的生成是从种子值开始。 如果反复使用同一个种子，就会生成相同的数字系列。 产生不同序列的一种方法是使种子值与时间相关，从而对于 Random 的每个新实例，都会产生不同的系列。 默认情况下，Random 类的无参数构造函数使用系统时钟生成其种子值，而参数化构造函数可根据当前时间的计时周期数采用 Int32 值。 但是，因为时钟的分辨率有限，所以，如果使用无参数构造函数连续创建不同的 Random 对象，就会创建生成相同随机数序列的随机数生成器。 在一轮中，每次抽号抽取的是相同的随机数序列的第一个元素，所以结果很有可能是相同的。由于中奖的号码从列表中移走，所以很可能连续抽到相邻部门的姓名。 注意，虽然结果有些不符合常理，但是对于个人来说，中奖概率还是均等的。 完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System;using System.Collections.Generic;using System.Diagnostics;using System.Text;using System.Threading;namespace Lottery&#123; internal class Generator &#123; private readonly IList&lt;string&gt; candidateList; private Random random = new Random(); internal Generator(string[] candidates) &#123; candidateList = new List&lt;string&gt;(candidates); &#125; internal string Pick() &#123; var random = new Random(); // 会导致粘连 //var random = this.random; // 不会粘连 int index = random.Next(candidateList.Count); Debug.Write(index + &quot;, &quot;); Thread.Sleep(5); // 延时，模拟电脑性能差的情况。 // 设为 5 时，有很多“粘连”的数据。 // 设为 15 时，“粘连”现象就消失了！ string choosen = candidateList[index]; candidateList.Remove(choosen); return choosen; &#125; &#125; internal class Program &#123; private static void Main(string[] args) &#123; string[] candidates = &#123; &quot;公司领导-宋江&quot;, &quot;公司领导-卢俊义&quot;, &quot;公司领导-吴用&quot;, &quot;公司领导-公孙胜&quot;, &quot;公司领导-关胜&quot;, &quot;公司领导-林冲&quot;, &quot;公司领导-秦明&quot;, &quot;公司领导-呼延灼&quot;, &quot;市场部-花荣&quot;, &quot;市场部-柴进&quot;, &quot;市场部-李应&quot;, &quot;市场部-朱仝&quot;, &quot;市场部-鲁智深&quot;, &quot;测试中心-武松&quot;, &quot;测试中心-董平&quot;, &quot;测试中心-张清&quot;, &quot;测试中心-杨志&quot;, &quot;测试中心-徐宁&quot;, &quot;测试中心-索超&quot;, &quot;测试中心-戴宗&quot;, &quot;测试中心-刘唐&quot;, &quot;财务部-李逵&quot;, &quot;财务部-史进&quot;, &quot;财务部-穆弘&quot;, &quot;财务部-雷横&quot;, &quot;财务部-李俊&quot;, &quot;财务部-阮小二&quot;, &quot;财务部-张横&quot;, &quot;品质管理部-阮小五&quot;, &quot;品质管理部-张顺&quot;, &quot;品质管理部-阮小七&quot;, &quot;品质管理部-杨雄&quot;, &quot;品质管理部-石秀&quot;, &quot;品质管理部-解珍&quot;, &quot;人力资源部-解宝&quot;, &quot;人力资源部-燕青&quot;, &quot;人力资源部-朱武&quot;, &quot;人力资源部-黄信&quot;, &quot;人力资源部-孙立&quot;, &quot;人力资源部-宣赞&quot;, &quot;人力资源部-郝思文&quot;, &quot;系统支持部-韩滔&quot;, &quot;系统支持部-彭玘&quot;, &quot;系统支持部-单廷珪&quot;, &quot;系统支持部-魏定国&quot;, &quot;系统支持部-萧让&quot;, &quot;信息中心-裴宣&quot;, &quot;信息中心-欧鹏&quot;, &quot;信息中心-邓飞&quot;, &quot;信息中心-燕顺&quot;, &quot;信息中心-杨林&quot;, &quot;信息中心-凌振&quot;, &quot;信息中心-蒋敬&quot;, &quot;研发一部-吕方&quot;, &quot;研发一部-郭盛&quot;, &quot;研发一部-安道全&quot;, &quot;研发一部-皇甫端&quot;, &quot;研发一部-王英&quot;, &quot;研发一部-扈三娘&quot;, &quot;研发一部-鲍旭&quot;, &quot;研发一部-樊瑞&quot;, &quot;研发二部-孔明&quot;, &quot;研发二部-孔亮&quot;, &quot;研发二部-项充&quot;, &quot;研发二部-李衮&quot;, &quot;研发二部-金大坚&quot;, &quot;研发二部-马麟&quot;, &quot;研发二部-童威&quot;, &quot;研发三部-童猛&quot;, &quot;研发三部-孟康&quot;, &quot;研发三部-侯健&quot;, &quot;研发三部-陈达&quot;, &quot;研发三部-杨春&quot;, &quot;研发三部-郑天寿&quot;, &quot;研发三部-陶宗旺&quot;, &quot;研发三部-宋清&quot;, &quot;研发三部-乐和&quot;, &quot;研发三部-龚旺&quot;, &quot;研发三部-丁得孙&quot;, &quot;研发四部-穆春&quot;, &quot;研发四部-曹正&quot;, &quot;研发四部-宋万&quot;, &quot;研发四部-杜迁&quot;, &quot;研发四部-薛永&quot;, &quot;研发四部-施恩&quot;, &quot;研发四部-李忠&quot;, &quot;研发四部-周通&quot;, &quot;研发四部-汤隆&quot;, &quot;研发四部-杜兴&quot;, &quot;研发四部-邹渊&quot;, &quot;研发五部-邹润&quot;, &quot;研发五部-朱贵&quot;, &quot;研发五部-朱富&quot;, &quot;研发五部-蔡福&quot;, &quot;研发五部-蔡庆&quot;, &quot;研发五部-李立&quot;, &quot;研发五部-李云&quot;, &quot;研发五部-焦挺&quot;, &quot;研发六部-石勇&quot;, &quot;研发六部-孙新&quot;, &quot;研发六部-顾大嫂&quot;, &quot;研发六部-张青&quot;, &quot;研发六部-孙二娘&quot;, &quot;研发六部-王定六&quot;, &quot;研发六部-郁保四&quot;, &quot;研发六部-白胜&quot;, &quot;研发六部-时迁&quot;, &quot;研发六部-段景住&quot; &#125;; var generator = new Generator(candidates); Console.WindowWidth = 100; while (Console.ReadKey().Key != ConsoleKey.Escape) &#123; var sb = new StringBuilder(); for (int i = 0; i &lt; 5; i++) &#123; var choosen = generator.Pick(); sb.Append(choosen); sb.Append(&apos;\\t&apos;); &#125; Console.WriteLine(sb.ToString().TrimEnd()); &#125; &#125; &#125;&#125; 您也可以在这里下载完整的代码。","categories":[{"name":"C#","slug":"C","permalink":"http://blog.vichamp.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://blog.vichamp.com/tags/C/"}],"keywords":[{"name":"C#","slug":"C","permalink":"http://blog.vichamp.com/categories/C/"}]},{"title":"PowerShell 技能连载 - 导出 Out-GridView 的内容","slug":"exporting-out-gridview-content","date":"2015-02-13T04:00:00.000Z","updated":"2017-03-17T15:26:25.174Z","comments":true,"path":"2015/02/13/exporting-out-gridview-content/","link":"","permalink":"http://blog.vichamp.com/2015/02/13/exporting-out-gridview-content/","excerpt":"适用于 PowerShell 3.0 及以上版本 Out-GridView 是一个非常有用的将结果输出到一个外部窗口的 cmdlet。和输出到控制台不同，Out-GridView 不会将文本截断。不过它好像没有很明显的方法将信息拷贝出来。 试试这种方法！首先，生成一些数据，然后将它用管道输出到网格视图窗口： PS&gt; Get-Process | Out-GridView 接下来，可以用顶部的文本框过滤结果，或单击列头来排序。 最后，要将信息导出到别的地方，例如要将进程列表导出到一个 Word 文档中，只需要在结果的任意位置单击，然后按下 CTRL+A 全选，然后按 CTRL+C 将选中的内容复制到剪贴板。 这样，您可以简单地将复制的数据粘贴到您要的应用程序中。不幸的是，列头并不会被复制到剪贴板中。 请注意 Out-GridView 有个内置的限制：它只能显示最多 30 个属性（列）。所以如果您的输入数据有更多的属性，您可能需要限制只显示您确实需要的属性： PS&gt; Get-Process | Select-Object -Property Name, Company, StartTime | Out-GridView","text":"适用于 PowerShell 3.0 及以上版本 Out-GridView 是一个非常有用的将结果输出到一个外部窗口的 cmdlet。和输出到控制台不同，Out-GridView 不会将文本截断。不过它好像没有很明显的方法将信息拷贝出来。 试试这种方法！首先，生成一些数据，然后将它用管道输出到网格视图窗口： PS&gt; Get-Process | Out-GridView 接下来，可以用顶部的文本框过滤结果，或单击列头来排序。 最后，要将信息导出到别的地方，例如要将进程列表导出到一个 Word 文档中，只需要在结果的任意位置单击，然后按下 CTRL+A 全选，然后按 CTRL+C 将选中的内容复制到剪贴板。 这样，您可以简单地将复制的数据粘贴到您要的应用程序中。不幸的是，列头并不会被复制到剪贴板中。 请注意 Out-GridView 有个内置的限制：它只能显示最多 30 个属性（列）。所以如果您的输入数据有更多的属性，您可能需要限制只显示您确实需要的属性： PS&gt; Get-Process | Select-Object -Property Name, Company, StartTime | Out-GridView 本文国际来源：Exporting Out-GridView Content","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获得一个干净的 PowerShell 环境","slug":"getting-a-clean-powershell-environment","date":"2015-02-12T04:00:00.000Z","updated":"2017-03-17T15:26:25.155Z","comments":true,"path":"2015/02/12/getting-a-clean-powershell-environment/","link":"","permalink":"http://blog.vichamp.com/2015/02/12/getting-a-clean-powershell-environment/","excerpt":"适用于 PowerShell 3.0 及以上版本 当您在 PowerShell ISE 中开发 PowerShell 脚本时，您可能做了很多更改和修订，并且测试运行了脚本。 这将“污染”您的环境：所有在脚本作用域内定义的变量仍然是定义过的状态，所以后续的测试不再是在一个干净的缺省环境中执行。 要确保一个脚本是在一个完全干净的测试环境中执行，您当然可以重启 PowerShell ISE。一个更便捷的方法是打开一个新的 PowerShell 选项卡：在 PowerShell ISE 中，选择文件/新建 PowerShell 选项卡。 这个操作将在脚本面板中新建一个选项卡。该选项卡代表一个全新的 PowerShell 宿主。您可以在这个新选项卡中加载您的测试脚本，并且在那儿进行测试。当测试完毕后，只需要点击关闭选项卡，即可从内存中消除掉它的所有相关内容。 请注意您可以在多个标签页中连续打开同一个脚本。当您这么操作时，ISE 会警告您该脚本已在另一个选项卡中打开了。当您编辑该脚本时，所有的编辑操作都会作用到所有打开该脚本的选项卡实例。","text":"适用于 PowerShell 3.0 及以上版本 当您在 PowerShell ISE 中开发 PowerShell 脚本时，您可能做了很多更改和修订，并且测试运行了脚本。 这将“污染”您的环境：所有在脚本作用域内定义的变量仍然是定义过的状态，所以后续的测试不再是在一个干净的缺省环境中执行。 要确保一个脚本是在一个完全干净的测试环境中执行，您当然可以重启 PowerShell ISE。一个更便捷的方法是打开一个新的 PowerShell 选项卡：在 PowerShell ISE 中，选择文件/新建 PowerShell 选项卡。 这个操作将在脚本面板中新建一个选项卡。该选项卡代表一个全新的 PowerShell 宿主。您可以在这个新选项卡中加载您的测试脚本，并且在那儿进行测试。当测试完毕后，只需要点击关闭选项卡，即可从内存中消除掉它的所有相关内容。 请注意您可以在多个标签页中连续打开同一个脚本。当您这么操作时，ISE 会警告您该脚本已在另一个选项卡中打开了。当您编辑该脚本时，所有的编辑操作都会作用到所有打开该脚本的选项卡实例。 本文国际来源：Getting a Clean PowerShell Environment","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将 PowerShell 工具增加到 Windows 8 启动屏幕","slug":"adding-powershell-tools-to-windows","date":"2015-02-11T04:00:00.000Z","updated":"2017-03-17T15:26:25.155Z","comments":true,"path":"2015/02/11/adding-powershell-tools-to-windows/","link":"","permalink":"http://blog.vichamp.com/2015/02/11/adding-powershell-tools-to-windows/","excerpt":"适用于 Windows 8/Windows 8.1 您可能注意到了 Windows 8 启动屏幕默认没有 PowerShell ISE 之类的 PowerShell 工具。当您转到开始屏幕并且输入 “ISE” 时，搜不到任何结果。 要改变这种情况，请确保开始屏幕显示了“管理员工具”。在开始屏幕上，将鼠标移动到最右侧，直到出来一个菜单。然后，点击“设置”，然后点击“磁贴”。 现在打开“显示管理员工具”的滑块。 当您做完这步，Windows 8 启动屏幕将会显示 PowerShell 工具，并且当您键入 “ISE” 时内置的搜索工具将会显示 PowerShell ISE。 在搜索结果中右键单击 “Windows PowerShell ISE” 可以看到额外的选项，并且可以将编辑器钉在任务栏上。","text":"适用于 Windows 8/Windows 8.1 您可能注意到了 Windows 8 启动屏幕默认没有 PowerShell ISE 之类的 PowerShell 工具。当您转到开始屏幕并且输入 “ISE” 时，搜不到任何结果。 要改变这种情况，请确保开始屏幕显示了“管理员工具”。在开始屏幕上，将鼠标移动到最右侧，直到出来一个菜单。然后，点击“设置”，然后点击“磁贴”。 现在打开“显示管理员工具”的滑块。 当您做完这步，Windows 8 启动屏幕将会显示 PowerShell 工具，并且当您键入 “ISE” 时内置的搜索工具将会显示 PowerShell ISE。 在搜索结果中右键单击 “Windows PowerShell ISE” 可以看到额外的选项，并且可以将编辑器钉在任务栏上。 本文国际来源：Adding PowerShell Tools to Windows 8 Start Screen","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找 AD 复制失败信息","slug":"find-ad-replication-failures","date":"2015-02-10T04:00:00.000Z","updated":"2017-03-17T15:26:25.155Z","comments":true,"path":"2015/02/10/find-ad-replication-failures/","link":"","permalink":"http://blog.vichamp.com/2015/02/10/find-ad-replication-failures/","excerpt":"适用于 Windows 8.1、Server 2012 R2 在 Windows 8.1 和 Server 2012 R2 中，查看 Active Directory 复制失败的信息变得更简单了。Get-ADReplicationFailure 这个新的 cmdlet 将会输出最近的复制失败信息。用它来检查一个特定的域控制器的方法： PS&gt; Get-ADReplicationFailure dc1.test.com 或者检查整个站点： PS&gt; Get-ADReplicationFailure -Scope Site -Target Hannover 该 cmdlet 是随 Windows 8.1 和 Server 2012 R2 发布的 ActiveDirectory 模块的一部分。在您使用它之前，请确保您在控制面板/软件/启用或关闭 Windows 功能中启用了它。它是“远程服务器管理工具 (RSAT)”的一部分。如果您的 Windows 8.1 没有预装 RSAT，您可以从这里下载它：http://www.microsoft.com/de-de/download/details.aspx?id=39296。 要查看该模块提供的其它 cmdlet，请试试这行代码： PS&gt; Get-Command -Module ActiveDirectory CommandType Name ModuleName ----------- ---- ---------- Cmdlet Add-ADCentralAccessPolicyMember ActiveDir... Cmdlet Add-ADComputerServiceAccount ActiveDir... Cmdlet Add-ADDomainControllerPasswordReplicationPolicy ActiveDir... Cmdlet Add-ADFineGrainedPasswordPolicySubject ActiveDir... (...) 请注意针对 Windows 8.1/Server 2012 R2 的 RSAT提供了一些额外的 cmdlet，这些 cmdlet 在针对 Windows 早期版本的 RSAT 中并没有提供。","text":"适用于 Windows 8.1、Server 2012 R2 在 Windows 8.1 和 Server 2012 R2 中，查看 Active Directory 复制失败的信息变得更简单了。Get-ADReplicationFailure 这个新的 cmdlet 将会输出最近的复制失败信息。用它来检查一个特定的域控制器的方法： PS&gt; Get-ADReplicationFailure dc1.test.com 或者检查整个站点： PS&gt; Get-ADReplicationFailure -Scope Site -Target Hannover 该 cmdlet 是随 Windows 8.1 和 Server 2012 R2 发布的 ActiveDirectory 模块的一部分。在您使用它之前，请确保您在控制面板/软件/启用或关闭 Windows 功能中启用了它。它是“远程服务器管理工具 (RSAT)”的一部分。如果您的 Windows 8.1 没有预装 RSAT，您可以从这里下载它：http://www.microsoft.com/de-de/download/details.aspx?id=39296。 要查看该模块提供的其它 cmdlet，请试试这行代码： PS&gt; Get-Command -Module ActiveDirectory CommandType Name ModuleName ----------- ---- ---------- Cmdlet Add-ADCentralAccessPolicyMember ActiveDir... Cmdlet Add-ADComputerServiceAccount ActiveDir... Cmdlet Add-ADDomainControllerPasswordReplicationPolicy ActiveDir... Cmdlet Add-ADFineGrainedPasswordPolicySubject ActiveDir... (...) 请注意针对 Windows 8.1/Server 2012 R2 的 RSAT提供了一些额外的 cmdlet，这些 cmdlet 在针对 Windows 早期版本的 RSAT 中并没有提供。 本文国际来源：Find AD Replication Failures","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 有用的静态 .NET 方法","slug":"useful-static-net-methods","date":"2015-02-09T04:00:00.000Z","updated":"2017-03-17T15:26:25.139Z","comments":true,"path":"2015/02/09/useful-static-net-methods/","link":"","permalink":"http://blog.vichamp.com/2015/02/09/useful-static-net-methods/","excerpt":"适用于 PowerShell 所有版本 PowerShell 可以调用 .NET 类型的静态方法。以下是一些很好用的单行代码： [Math]::Round(7.9) [Convert]::ToString(576255753217, 8) [Guid]::NewGuid() [Net.Dns]::GetHostByName(&apos;schulung12&apos;) [IO.Path]::GetExtension(&apos;c:\\test.txt&apos;) [IO.Path]::ChangeExtension(&apos;c:\\test.txt&apos;, &apos;bak&apos;) 要查看更多的用法，请删除类型（方括号中的文字）后的代码，然后键入两个冒号。PowerShell ISE 将会自动弹出一个快捷菜单列出该类型可用的方法。在 PowerShell 控制台中，只需要按下 TAB 键即可得到自动完成的建议。 您也可以将一个类型通过管道输出到 Get-Member 命令： PS&gt; [Math] | Get-Member -MemberType *Method -Static TypeName: System.Math Name MemberType Definition ---- ---------- ---------- Abs Method static sbyte Abs(sbyte value), static int16 Abs(int16 value), static int Abs(int value), sta... Acos Method static double Acos(double d) Asin Method static double Asin(double d) Atan Method static double Atan(double d) Atan2 Method static double Atan2(double y, double x) BigMul Method static long BigMul(int a, int b) Ceiling Method static decimal Ceiling(decimal d), static double Ceiling(double a) Cos Method static double Cos(double d) Cosh Method static double Cosh(double value DivRem Method static int DivRem(int a, int b, [ref] int result), static long DivRem(long a, long b, [ref] ... Equals Method static bool Equals(System.Object objA, System.Object objB) Exp Method static double Exp(double d) Floor Method static decimal Floor(decimal d), static double Floor(double d) IEEERemainder Method static double IEEERemainder(double x, double y) Log Method static double Log(double d), static double Log(double a, double newBase) Log10 Method static double Log10(double d) Max Method static sbyte Max(sbyte val1, sbyte val2), static byte Max(byte val1, byte val2), static int1... Min Method static sbyte Min(sbyte val1, sbyte val2), static byte Min(byte val1, byte val2), static int1... Pow Method static double Pow(double x, double y) ReferenceEquals Method static bool ReferenceEquals(System.Object objA, System.Object objB) Round Method static double Round(double a), static double Round(double value, int digits), static double ... Sign Method static int Sign(sbyte value), static int Sign(int16 value), static int Sign(int value), stat... Sin Method static double Sin(double a) Sinh Method static double Sinh(double value) Sqrt Method static double Sqrt(double d) Tan Method static double Tan(double a) Tanh Method static double Tanh(double value) Truncate Method static decimal Truncate(decimal d), static double Truncate(double d) 要查看某个方法的所有重载的签名，请去掉圆括号： PS&gt; Get-Something -Path test You entered test. PS&gt; [Math]::Round OverloadDefinitions ------------------- static double Round(double a static double Round(double value, int digits) static double Round(double value, System.MidpointRounding mode) static double Round(double value, int digits, System.MidpointRounding mode static decimal Round(decimal d static decimal Round(decimal d, int decimals) static decimal Round(decimal d, System.MidpointRounding mode) static decimal Round(decimal d, int decimals, System.MidpointRounding mode)","text":"适用于 PowerShell 所有版本 PowerShell 可以调用 .NET 类型的静态方法。以下是一些很好用的单行代码： [Math]::Round(7.9) [Convert]::ToString(576255753217, 8) [Guid]::NewGuid() [Net.Dns]::GetHostByName(&apos;schulung12&apos;) [IO.Path]::GetExtension(&apos;c:\\test.txt&apos;) [IO.Path]::ChangeExtension(&apos;c:\\test.txt&apos;, &apos;bak&apos;) 要查看更多的用法，请删除类型（方括号中的文字）后的代码，然后键入两个冒号。PowerShell ISE 将会自动弹出一个快捷菜单列出该类型可用的方法。在 PowerShell 控制台中，只需要按下 TAB 键即可得到自动完成的建议。 您也可以将一个类型通过管道输出到 Get-Member 命令： PS&gt; [Math] | Get-Member -MemberType *Method -Static TypeName: System.Math Name MemberType Definition ---- ---------- ---------- Abs Method static sbyte Abs(sbyte value), static int16 Abs(int16 value), static int Abs(int value), sta... Acos Method static double Acos(double d) Asin Method static double Asin(double d) Atan Method static double Atan(double d) Atan2 Method static double Atan2(double y, double x) BigMul Method static long BigMul(int a, int b) Ceiling Method static decimal Ceiling(decimal d), static double Ceiling(double a) Cos Method static double Cos(double d) Cosh Method static double Cosh(double value DivRem Method static int DivRem(int a, int b, [ref] int result), static long DivRem(long a, long b, [ref] ... Equals Method static bool Equals(System.Object objA, System.Object objB) Exp Method static double Exp(double d) Floor Method static decimal Floor(decimal d), static double Floor(double d) IEEERemainder Method static double IEEERemainder(double x, double y) Log Method static double Log(double d), static double Log(double a, double newBase) Log10 Method static double Log10(double d) Max Method static sbyte Max(sbyte val1, sbyte val2), static byte Max(byte val1, byte val2), static int1... Min Method static sbyte Min(sbyte val1, sbyte val2), static byte Min(byte val1, byte val2), static int1... Pow Method static double Pow(double x, double y) ReferenceEquals Method static bool ReferenceEquals(System.Object objA, System.Object objB) Round Method static double Round(double a), static double Round(double value, int digits), static double ... Sign Method static int Sign(sbyte value), static int Sign(int16 value), static int Sign(int value), stat... Sin Method static double Sin(double a) Sinh Method static double Sinh(double value) Sqrt Method static double Sqrt(double d) Tan Method static double Tan(double a) Tanh Method static double Tanh(double value) Truncate Method static decimal Truncate(decimal d), static double Truncate(double d) 要查看某个方法的所有重载的签名，请去掉圆括号： PS&gt; Get-Something -Path test You entered test. PS&gt; [Math]::Round OverloadDefinitions ------------------- static double Round(double a static double Round(double value, int digits) static double Round(double value, System.MidpointRounding mode) static double Round(double value, int digits, System.MidpointRounding mode static decimal Round(decimal d static decimal Round(decimal d, int decimals) static decimal Round(decimal d, System.MidpointRounding mode) static decimal Round(decimal d, int decimals, System.MidpointRounding mode) 本文国际来源：Useful Static .NET Methods","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"如何用 PowerShell 撰写心灵鸡汤","slug":"How-to-Encourage","date":"2015-02-08T14:10:11.000Z","updated":"2017-03-17T15:26:25.139Z","comments":true,"path":"2015/02/08/How-to-Encourage/","link":"","permalink":"http://blog.vichamp.com/2015/02/08/How-to-Encourage/","excerpt":"关于励志段子微信上传着一个励志段子，大意是： 如果26个英文字母 A B C D EF G H I J K L M N O P Q R S T U V W X Y Z 分别等于:1 2 3 4 5 6 7 8 9 10 11 12 13 14 1516 17 18 19 20 21 22 23 24 25 26。那么： Knowledge (知识)： K+N+O+W+L+E+D+G+E＝ 11+14+15+23+12+5+4+7+5=96% Workhard (努力工作）：W+O+R+K+H+A+R+D＝ 23+15+18+11+8+1+18+4 =98% Luck（好运） L+U+C+K＝12+21+3+11=47% Love（爱情） L+O+V+E＝12+15+22+5=54% Money（金钱） M+O+N+E+Y=13+15+14+5+25=72% Leadership（领导能力）L+E+A+D+E+R+S+H+I+P=12+5+1+4+5+18+19+9+16=89% ATTITUDE（心态）A+T+T+I+T+U+D+E＝1+20+20+9+20+21+4+5=100% 于是得出结论：用什么样的态度去看待人生，就会得到什么样的人生。 分析这样的心灵鸡汤是怎样来的呢？我们用 PowerShell 脚本来琢磨一下。 12345678function Get-Weight([string]$word) &#123; $word = $word.ToLower() #Write-Host ([System.Text.Encoding]::ASCII.GetBytes($word) | # ForEach-Object &#123; $_ - 96 &#125;) return ([System.Text.Encoding]::ASCII.GetBytes($word) | ForEach-Object &#123; $_ - 96 &#125; | Measure-Object -Sum).Sum&#125; 这个函数可以对任意字符串求值，例如以下测试代码将返回 6(abc = 1+2+3)： 1Get-Weight 'abc' 现在可以测试一下段子里用到的几个单词，并对结果进行排序： 12'Knowledge', 'Workhard', 'Luck', 'Love', 'Money', 'Leadership', 'ATTITUDE' | Sort-Object -Property @&#123;Expression = &#123; Get-Weight $_ &#125;&#125; 结果符合预期： Luck Love Money Knowledge Leadership Workhard ATTITUDE 如何撰写鸡汤以上实现了输入任意字符串数组，对它们进行求值和排序。但是如何选出这些单词呢？我们可以找一篇长文，例如从麻省理工找到莎士比亚的《哈姆雷特》全文，将它输进去拆解成单词试试： 12345$resp = Invoke-WebRequest 'http://shakespeare.mit.edu/hamlet/full.html'$fullText = $resp.ParsedHtml.documentElement.innerText$words = [regex]::Matches($fullText, '\\b\\w+\\b') | ForEach-Object &#123; $_.Value &#125; | Sort-Object -Unique 这样几行代码，就可以将《哈姆雷特》全文的所有单词挑出来进行排序，并将结果保存在 $words 变量中。 最后套用我们上面写好的函数即可实现对所有单词求值排序： 12345$words | Sort-Object -Property @&#123;Expression = &#123; Get-Weight $_ &#125;&#125; | ForEach-Object &#123; \"$_`t$(Get-Weight $_)\" &#125; 结果大概是这样： word weight a 1 c 3 d 4 e 5 bad 7 be 7 I 9 … … letters 99 firmament 99 temperance 100 Writing 100 … … prosperously 199 unproportioned 200 有了这个长长的表格之后，撰写鸡汤就容易多了。只要按顺序挑出一些单词，设计一下台词即可。 完整的代码如下：","text":"关于励志段子微信上传着一个励志段子，大意是： 如果26个英文字母 A B C D EF G H I J K L M N O P Q R S T U V W X Y Z 分别等于:1 2 3 4 5 6 7 8 9 10 11 12 13 14 1516 17 18 19 20 21 22 23 24 25 26。那么： Knowledge (知识)： K+N+O+W+L+E+D+G+E＝ 11+14+15+23+12+5+4+7+5=96% Workhard (努力工作）：W+O+R+K+H+A+R+D＝ 23+15+18+11+8+1+18+4 =98% Luck（好运） L+U+C+K＝12+21+3+11=47% Love（爱情） L+O+V+E＝12+15+22+5=54% Money（金钱） M+O+N+E+Y=13+15+14+5+25=72% Leadership（领导能力）L+E+A+D+E+R+S+H+I+P=12+5+1+4+5+18+19+9+16=89% ATTITUDE（心态）A+T+T+I+T+U+D+E＝1+20+20+9+20+21+4+5=100% 于是得出结论：用什么样的态度去看待人生，就会得到什么样的人生。 分析这样的心灵鸡汤是怎样来的呢？我们用 PowerShell 脚本来琢磨一下。 12345678function Get-Weight([string]$word) &#123; $word = $word.ToLower() #Write-Host ([System.Text.Encoding]::ASCII.GetBytes($word) | # ForEach-Object &#123; $_ - 96 &#125;) return ([System.Text.Encoding]::ASCII.GetBytes($word) | ForEach-Object &#123; $_ - 96 &#125; | Measure-Object -Sum).Sum&#125; 这个函数可以对任意字符串求值，例如以下测试代码将返回 6(abc = 1+2+3)： 1Get-Weight 'abc' 现在可以测试一下段子里用到的几个单词，并对结果进行排序： 12'Knowledge', 'Workhard', 'Luck', 'Love', 'Money', 'Leadership', 'ATTITUDE' | Sort-Object -Property @&#123;Expression = &#123; Get-Weight $_ &#125;&#125; 结果符合预期： Luck Love Money Knowledge Leadership Workhard ATTITUDE 如何撰写鸡汤以上实现了输入任意字符串数组，对它们进行求值和排序。但是如何选出这些单词呢？我们可以找一篇长文，例如从麻省理工找到莎士比亚的《哈姆雷特》全文，将它输进去拆解成单词试试： 12345$resp = Invoke-WebRequest 'http://shakespeare.mit.edu/hamlet/full.html'$fullText = $resp.ParsedHtml.documentElement.innerText$words = [regex]::Matches($fullText, '\\b\\w+\\b') | ForEach-Object &#123; $_.Value &#125; | Sort-Object -Unique 这样几行代码，就可以将《哈姆雷特》全文的所有单词挑出来进行排序，并将结果保存在 $words 变量中。 最后套用我们上面写好的函数即可实现对所有单词求值排序： 12345$words | Sort-Object -Property @&#123;Expression = &#123; Get-Weight $_ &#125;&#125; | ForEach-Object &#123; \"$_`t$(Get-Weight $_)\" &#125; 结果大概是这样： word weight a 1 c 3 d 4 e 5 bad 7 be 7 I 9 … … letters 99 firmament 99 temperance 100 Writing 100 … … prosperously 199 unproportioned 200 有了这个长长的表格之后，撰写鸡汤就容易多了。只要按顺序挑出一些单词，设计一下台词即可。 完整的代码如下： function Get-Weight([string]$word) { $word = $word.ToLower() #Write-Host ([System.Text.Encoding]::ASCII.GetBytes($word) | # ForEach-Object { $_ - 96 }) return ([System.Text.Encoding]::ASCII.GetBytes($word) | ForEach-Object { $_ - 96 } | Measure-Object -Sum).Sum } # Test # Get-Weight &apos;abc&apos; if (!$resp) { $resp = Invoke-WebRequest &apos;http://shakespeare.mit.edu/hamlet/full.html&apos; } $fullText = $resp.ParsedHtml.documentElement.innerText $words = [regex]::Matches($fullText, &apos;\\b\\w+\\b&apos;) | ForEach-Object { $_.Value } | Sort-Object -Unique # The following code will procuce output: # Luck # Love # Money # Knowledge # Leadership # Workhard # ATTITUDE &apos;Knowledge&apos;, &apos;Workhard&apos;, &apos;Luck&apos;, &apos;Love&apos;, &apos;Money&apos;, &apos;Leadership&apos;, &apos;ATTITUDE&apos; | Sort-Object -Property @{Expression = { Get-Weight $_ }} $words | Sort-Object -Property @{Expression = { Get-Weight $_ }} | ForEach-Object { &quot;$_`t$(Get-Weight $_)&quot; } 后记完整的代码可以在这里下载。鸡汤的原文请参见《是哪位高人琢磨出的这条微信，太牛了》。顺便发现了原文中的一个计算 bug——Leadership（领导能力）应是L+E+A+D+E+R+S+H+I+P=12+5+1+4+5+18+19+8+9+16=97%，而不是 89%。 怎么样，有没有一点理工男秒杀心灵鸡汤的味道？","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"text","slug":"text","permalink":"http://blog.vichamp.com/tags/text/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 为必须的参数弹出一个对话框","slug":"mandatory-parameters-with-a-dialog","date":"2015-02-06T04:00:00.000Z","updated":"2017-03-17T15:26:25.124Z","comments":true,"path":"2015/02/06/mandatory-parameters-with-a-dialog/","link":"","permalink":"http://blog.vichamp.com/2015/02/06/mandatory-parameters-with-a-dialog/","excerpt":"适用于 PowerShell 所有版本 通常，但您将一个参数定义为必选的，并且用户没有传入对应的实参，PowerShell 能够处理好这种情况并提示用户输入这个值： function Get-Something { param ( [Parameter(Mandatory = $true)] $Path ) &quot;You entered $Path.&quot; } 结果类似这样（您无法控制提示信息）： PS&gt; Get-Something -Path test You entered test. PS&gt; Get-Something Cmdlet Get-Something at command pipeline position 1 Supply values for the following parameters: Path: test You entered test. PS&gt; 但是您是否知道还可以通过这种方式获取一个必选参数？ function Get-Something { param ( $Path = $(Read-Host &apos;Please, enter a Path value&apos;) ) &quot;You entered $Path.&quot; } 这种方法将控制权交给您，以下是它看起来的样子： PS&gt; Get-Something -Path test You entered test. PS&gt; Get-Something Please, enter a Path value: test You entered test. PS&gt;","text":"适用于 PowerShell 所有版本 通常，但您将一个参数定义为必选的，并且用户没有传入对应的实参，PowerShell 能够处理好这种情况并提示用户输入这个值： function Get-Something { param ( [Parameter(Mandatory = $true)] $Path ) &quot;You entered $Path.&quot; } 结果类似这样（您无法控制提示信息）： PS&gt; Get-Something -Path test You entered test. PS&gt; Get-Something Cmdlet Get-Something at command pipeline position 1 Supply values for the following parameters: Path: test You entered test. PS&gt; 但是您是否知道还可以通过这种方式获取一个必选参数？ function Get-Something { param ( $Path = $(Read-Host &apos;Please, enter a Path value&apos;) ) &quot;You entered $Path.&quot; } 这种方法将控制权交给您，以下是它看起来的样子： PS&gt; Get-Something -Path test You entered test. PS&gt; Get-Something Please, enter a Path value: test You entered test. PS&gt; 本文国际来源：Mandatory Parameters with a Dialog","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用打开文件夹对话框","slug":"use-open-file-dialog","date":"2015-02-05T04:00:00.000Z","updated":"2017-03-17T15:26:25.124Z","comments":true,"path":"2015/02/05/use-open-file-dialog/","link":"","permalink":"http://blog.vichamp.com/2015/02/05/use-open-file-dialog/","excerpt":"适用于 PowerShell 所有版本 为了在您的脚本中输入一些东西，以下是一个简单的打开“打开文件”对话框并让用户选择一个文件的函数。 function Show-OpenFileDialog { param ($Title = &apos;Pick a File&apos;, $Filter = &apos;All|*.*|PowerShell|*.ps1&apos;) $type = &apos;Microsoft.Win32.OpenFileDialog&apos; $dialog = New-Object -TypeName $type $dialog.Title = $Title $dialog.Filter = $Filter if ($dialog.ShowDialog() -eq $true) { $dialog.FileName } else { Write-Warning &apos;Cancelled&apos; } } 如您所见，您可以控制该对话框的标题栏和显示的文件类型。","text":"适用于 PowerShell 所有版本 为了在您的脚本中输入一些东西，以下是一个简单的打开“打开文件”对话框并让用户选择一个文件的函数。 function Show-OpenFileDialog { param ($Title = &apos;Pick a File&apos;, $Filter = &apos;All|*.*|PowerShell|*.ps1&apos;) $type = &apos;Microsoft.Win32.OpenFileDialog&apos; $dialog = New-Object -TypeName $type $dialog.Title = $Title $dialog.Filter = $Filter if ($dialog.ShowDialog() -eq $true) { $dialog.FileName } else { Write-Warning &apos;Cancelled&apos; } } 如您所见，您可以控制该对话框的标题栏和显示的文件类型。 本文国际来源：Use Open File Dialog","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 记录拒绝存取的文件夹","slug":"logging-folders-with-access-denied-errors","date":"2015-02-04T04:00:00.000Z","updated":"2017-03-17T15:26:25.108Z","comments":true,"path":"2015/02/04/logging-folders-with-access-denied-errors/","link":"","permalink":"http://blog.vichamp.com/2015/02/04/logging-folders-with-access-denied-errors/","excerpt":"适用于 PowerShell 所有版本 当您用 Get-ChildItem 浏览文件系统的时候，您可能偶尔会碰到没有查看权限的文件夹。如果您希望将抛出次异常的所有文件夹都记录下来，请试试这个方法： $result = Get-ChildItem -Path c:\\Windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable abcd Write-Warning &apos;Unable to access these folders:&apos; Write-Warning ($abcd.TargetObject -join &quot;`r`n&quot;) 这个技巧是隐藏所有错误提示（-ErrorAction SilentlyContinue）但将错误都保存到一个变量中（-ErrorVariable abce）。","text":"适用于 PowerShell 所有版本 当您用 Get-ChildItem 浏览文件系统的时候，您可能偶尔会碰到没有查看权限的文件夹。如果您希望将抛出次异常的所有文件夹都记录下来，请试试这个方法： $result = Get-ChildItem -Path c:\\Windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable abcd Write-Warning &apos;Unable to access these folders:&apos; Write-Warning ($abcd.TargetObject -join &quot;`r`n&quot;) 这个技巧是隐藏所有错误提示（-ErrorAction SilentlyContinue）但将错误都保存到一个变量中（-ErrorVariable abce）。 本文国际来源：Logging Folders with Access Denied Errors","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理终端服务设置","slug":"managing-terminal-service-settings","date":"2015-02-03T04:00:00.000Z","updated":"2017-03-17T15:26:25.108Z","comments":true,"path":"2015/02/03/managing-terminal-service-settings/","link":"","permalink":"http://blog.vichamp.com/2015/02/03/managing-terminal-service-settings/","excerpt":"_需要 ActiveDirectory 模块 有些时候您也许希望在一个 AD 账户中直接存取终端服务相关的属性。以下是一些演示如何实现该功能的示例代码： $Identity = &apos;SomeUserName&apos; $distinguishedName = (Get-ADUser -Identity $Identity -Properties distinguishedName).distinguishedName $ADUser = [ADSI]&quot;LDAP://$distinguishedName&quot; $TSProfilePath = $ADUser.psbase.InvokeGet(&apos;terminalservicesprofilepath&apos;) $TSHomeDir = $ADUser.psbase.InvokeGet(&apos;TerminalServicesHomeDirectory&apos;) $TSHomeDrive = $ADUser.psbase.InvokeGet(&apos;TerminalServicesHomeDrive&apos;) $TSAllowLogOn = $ADUser.psbase.InvokeGet(&apos;allowLogon&apos;)","text":"_需要 ActiveDirectory 模块 有些时候您也许希望在一个 AD 账户中直接存取终端服务相关的属性。以下是一些演示如何实现该功能的示例代码： $Identity = &apos;SomeUserName&apos; $distinguishedName = (Get-ADUser -Identity $Identity -Properties distinguishedName).distinguishedName $ADUser = [ADSI]&quot;LDAP://$distinguishedName&quot; $TSProfilePath = $ADUser.psbase.InvokeGet(&apos;terminalservicesprofilepath&apos;) $TSHomeDir = $ADUser.psbase.InvokeGet(&apos;TerminalServicesHomeDirectory&apos;) $TSHomeDrive = $ADUser.psbase.InvokeGet(&apos;TerminalServicesHomeDrive&apos;) $TSAllowLogOn = $ADUser.psbase.InvokeGet(&apos;allowLogon&apos;) 本文国际来源：Managing Terminal Service Settings","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"个人管理","slug":"Personal-Management","date":"2015-02-02T07:01:00.000Z","updated":"2017-03-17T15:26:25.092Z","comments":true,"path":"2015/02/02/Personal-Management/","link":"","permalink":"http://blog.vichamp.com/2015/02/02/Personal-Management/","excerpt":"","text":"网站幸福进化俱乐部活动论坛活页DIY会所","categories":[{"name":"career","slug":"career","permalink":"http://blog.vichamp.com/categories/career/"}],"tags":[{"name":"career","slug":"career","permalink":"http://blog.vichamp.com/tags/career/"},{"name":"productivity","slug":"productivity","permalink":"http://blog.vichamp.com/tags/productivity/"}],"keywords":[{"name":"career","slug":"career","permalink":"http://blog.vichamp.com/categories/career/"}]},{"title":"PowerShell 技能连载 - 凭据混淆器","slug":"credential-obfuscator","date":"2015-02-02T04:00:00.000Z","updated":"2017-03-17T15:26:25.092Z","comments":true,"path":"2015/02/02/credential-obfuscator/","link":"","permalink":"http://blog.vichamp.com/2015/02/02/credential-obfuscator/","excerpt":"适用于 PowerShell ISE 3.0 及以上版本 虽然一般不建议将密码硬编码在脚本里，但有些情况下已经这么做了。相比于硬编码明文密码，一个最基本的改进是将密码混淆。密码混淆是一种弱的保护方式，但它能确保非掌握 PowerShell 知识的人员轻易地得到密码。 这是段小脚本会询问用户名和密码，然后生成一段混淆脚本来产生凭据对象。 当您运行下面这段脚本生成的脚本，在 $cred 变量将会保存一个包含用户名和密码的凭据对象，它可以用于任何带 -Credential 参数的 cmdlet。 $cred = Get-Credential -Message &apos;Enter Domain\\Username and Password&apos; $pwd = $cred.Password $user = $cred.UserName $key = 1..32 | ForEach-Object { Get-Random -Maximum 256 } $pwdencrypted = $pwd | ConvertFrom-SecureString -Key $key $private:ofs = &apos; &apos; $generatedScript = @() $generatedScript += &apos;$password = &apos;&apos;{0}&apos;&apos;&apos; -f $pwdencrypted $generatedScript += &apos;$key = &apos;&apos;{0}&apos;&apos;&apos; -f &quot;$key&quot; $generatedScript += &apos;$passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(&apos;&apos; &apos;&apos;))&apos; $generatedScript += &apos;$cred = New-Object system.Management.Automation.PSCredential(&apos;&apos;{0}&apos;&apos;, $passwordSecure)&apos; -f $user $generatedScript += &apos;$cred&apos; $file = $psise.CurrentPowerShellTab.Files.Add() $file.Editor.Text = $generatedScript | Out-String $file.Editor.SetCaretPosition(1,1) 自动生成的密码脚本看起来类似这样： $password = &apos;76492d1116743f0423413b16050a5345MgB8AHMAUQA3AFAAVwB0AGkAUQBUAC8AdwBqADYAUABVAFYAUwB4AEYAYgB4AFEAPQA9AHwAZgA0ADgAOQA4AGYANwA0AGEAMAA0ADUANwA5ADkAMwA5ADkAMwA1ADUANQA0AGYANwA5AGQANwBkAGYAOQBmAGEAYQA3ADMAYgBkADIAOQA3AGMAYQBmADUAMgA3ADEANwA3AGEAYgBmADAAYgA1AGYAYwAyADYAYgAzADkAOAA=&apos; $key = &apos;187 98 34 82 148 52 13 86 246 2 130 197 217 97 147 98 75 197 149 246 74 35 27 7 211 15 131 93 182 231 171 3&apos; $passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(&apos; &apos;)) $cred = New-Object system.Management.Automation.PSCredential(&apos;mickey\\mouse&apos;, $passwordSecure) $cred","text":"适用于 PowerShell ISE 3.0 及以上版本 虽然一般不建议将密码硬编码在脚本里，但有些情况下已经这么做了。相比于硬编码明文密码，一个最基本的改进是将密码混淆。密码混淆是一种弱的保护方式，但它能确保非掌握 PowerShell 知识的人员轻易地得到密码。 这是段小脚本会询问用户名和密码，然后生成一段混淆脚本来产生凭据对象。 当您运行下面这段脚本生成的脚本，在 $cred 变量将会保存一个包含用户名和密码的凭据对象，它可以用于任何带 -Credential 参数的 cmdlet。 $cred = Get-Credential -Message &apos;Enter Domain\\Username and Password&apos; $pwd = $cred.Password $user = $cred.UserName $key = 1..32 | ForEach-Object { Get-Random -Maximum 256 } $pwdencrypted = $pwd | ConvertFrom-SecureString -Key $key $private:ofs = &apos; &apos; $generatedScript = @() $generatedScript += &apos;$password = &apos;&apos;{0}&apos;&apos;&apos; -f $pwdencrypted $generatedScript += &apos;$key = &apos;&apos;{0}&apos;&apos;&apos; -f &quot;$key&quot; $generatedScript += &apos;$passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(&apos;&apos; &apos;&apos;))&apos; $generatedScript += &apos;$cred = New-Object system.Management.Automation.PSCredential(&apos;&apos;{0}&apos;&apos;, $passwordSecure)&apos; -f $user $generatedScript += &apos;$cred&apos; $file = $psise.CurrentPowerShellTab.Files.Add() $file.Editor.Text = $generatedScript | Out-String $file.Editor.SetCaretPosition(1,1) 自动生成的密码脚本看起来类似这样： $password = &apos;76492d1116743f0423413b16050a5345MgB8AHMAUQA3AFAAVwB0AGkAUQBUAC8AdwBqADYAUABVAFYAUwB4AEYAYgB4AFEAPQA9AHwAZgA0ADgAOQA4AGYANwA0AGEAMAA0ADUANwA5ADkAMwA5ADkAMwA1ADUANQA0AGYANwA5AGQANwBkAGYAOQBmAGEAYQA3ADMAYgBkADIAOQA3AGMAYQBmADUAMgA3ADEANwA3AGEAYgBmADAAYgA1AGYAYwAyADYAYgAzADkAOAA=&apos; $key = &apos;187 98 34 82 148 52 13 86 246 2 130 197 217 97 147 98 75 197 149 246 74 35 27 7 211 15 131 93 182 231 171 3&apos; $passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(&apos; &apos;)) $cred = New-Object system.Management.Automation.PSCredential(&apos;mickey\\mouse&apos;, $passwordSecure) $cred 本文国际来源：Credential Obfuscator","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 自动展开和内存消耗","slug":"automatic-unrolling-and-memory-consumption","date":"2015-01-30T04:00:00.000Z","updated":"2017-03-17T15:26:25.092Z","comments":true,"path":"2015/01/30/automatic-unrolling-and-memory-consumption/","link":"","permalink":"http://blog.vichamp.com/2015/01/30/automatic-unrolling-and-memory-consumption/","excerpt":"适用于 PowerShell 3.0 及以上版本 在 PowerShell 3.0 中，增加了一个称为“自动回滚”的特性。通过这个特性，您可以这样书写代码： (Get-ChildItem -Path $env:windir\\system32 -Filter *.dll).VersionInfo 这行代码查找 System32 子文件夹下的所有 DLL 文件并且对它们进行迭代，对每个文件返回其 VersionInfo 属性（实际上是 DLL 版本）。在使用自动展开功能之前，您需要手工编写循环语句： Get-ChildItem -Path $env:windir\\system32 -Filter *.dll | ForEach-Object { $_.VersionInfo } 当您运行以上两段代码时，它们返回完全相同的结果。然而，您将立刻发现自动展开特性所带来的代价：它消耗了更多的时间才返回结果。第一行结果出来时可能要消耗 10 秒之多的时间，而“传统”的方法几乎是连续地返回信息。 总体消耗的时间是差不多的。实际上，自动展开特性等价的代码如下： $data = Get-ChildItem -Path $env:windir\\system32 -Filter *.dll Foreach ($element in $data) { $element.VersionInfo } 自动展开代码更直观，更容易书写；手写循环兼容性更好，更快输出结果。","text":"适用于 PowerShell 3.0 及以上版本 在 PowerShell 3.0 中，增加了一个称为“自动回滚”的特性。通过这个特性，您可以这样书写代码： (Get-ChildItem -Path $env:windir\\system32 -Filter *.dll).VersionInfo 这行代码查找 System32 子文件夹下的所有 DLL 文件并且对它们进行迭代，对每个文件返回其 VersionInfo 属性（实际上是 DLL 版本）。在使用自动展开功能之前，您需要手工编写循环语句： Get-ChildItem -Path $env:windir\\system32 -Filter *.dll | ForEach-Object { $_.VersionInfo } 当您运行以上两段代码时，它们返回完全相同的结果。然而，您将立刻发现自动展开特性所带来的代价：它消耗了更多的时间才返回结果。第一行结果出来时可能要消耗 10 秒之多的时间，而“传统”的方法几乎是连续地返回信息。 总体消耗的时间是差不多的。实际上，自动展开特性等价的代码如下： $data = Get-ChildItem -Path $env:windir\\system32 -Filter *.dll Foreach ($element in $data) { $element.VersionInfo } 自动展开代码更直观，更容易书写；手写循环兼容性更好，更快输出结果。 本文国际来源：Automatic Unrolling and Memory Consumption","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 复制命令行历史","slug":"copying-command-line-history","date":"2015-01-29T04:00:00.000Z","updated":"2017-03-17T15:26:25.077Z","comments":true,"path":"2015/01/29/copying-command-line-history/","link":"","permalink":"http://blog.vichamp.com/2015/01/29/copying-command-line-history/","excerpt":"适用于 PowerShell 所有版本 要将 PowerShell 会话中键入过的所有 PowerShell 命令保存下来，请试试这行代码： (Get-History).CommandLine | clip.exe 它将所有的命令拷贝至剪贴板。然后您就可以将它们粘贴到 PowerShell ISE 并保存为文件。","text":"适用于 PowerShell 所有版本 要将 PowerShell 会话中键入过的所有 PowerShell 命令保存下来，请试试这行代码： (Get-History).CommandLine | clip.exe 它将所有的命令拷贝至剪贴板。然后您就可以将它们粘贴到 PowerShell ISE 并保存为文件。 本文国际来源：Copying Command Line History","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取计算机序列号","slug":"getting-computer-serial-number","date":"2015-01-28T04:00:00.000Z","updated":"2017-03-17T15:26:25.074Z","comments":true,"path":"2015/01/28/getting-computer-serial-number/","link":"","permalink":"http://blog.vichamp.com/2015/01/28/getting-computer-serial-number/","excerpt":"适用于 PowerShell 所有版本 在前一个技巧里我们演示了如何通过 DELL 的序列号在线检查保修状态。其它厂家也会提供类似的服务。 这段代码可以读取序列号： $ComputerName = $env:COMPUTERNAME $serial = (Get-WmiObject -ComputerName $ComputerName -Class Win32_BIOS).SerialNumber &quot;Your computer serial is $serial&quot;","text":"适用于 PowerShell 所有版本 在前一个技巧里我们演示了如何通过 DELL 的序列号在线检查保修状态。其它厂家也会提供类似的服务。 这段代码可以读取序列号： $ComputerName = $env:COMPUTERNAME $serial = (Get-WmiObject -ComputerName $ComputerName -Class Win32_BIOS).SerialNumber &quot;Your computer serial is $serial&quot; 本文国际来源：Getting Computer Serial Number","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在线检测 DELL 保修","slug":"checking-dell-warranty-online","date":"2015-01-27T04:00:00.000Z","updated":"2017-03-17T15:26:25.055Z","comments":true,"path":"2015/01/27/checking-dell-warranty-online/","link":"","permalink":"http://blog.vichamp.com/2015/01/27/checking-dell-warranty-online/","excerpt":"适用于 PowerShell 2.0 及以上版本 如果您拥有一台 DELL 电脑，您可以通过 Web Service 提交电脑的序列号得到授权信息： $serial = &apos;36GPL41&apos; $service = New-WebServiceProxy -Uri http://143.166.84.118/services/assetservice.asmx?WSDL $guid = [Guid]::NewGuid() $info = $service.GetAssetInformation($guid,&apos;warrantycheck&apos;,$serial) $info.Entitlements 结果可能看起来如下： $info.Entitlements ServiceLevelCode : TS ServiceLevelDescription : P, ProSupport Provider : DELL StartDate : 23.03.2004 00:00:00 EndDate : 23.03.2007 00:00:00 DaysLeft : 0 EntitlementType : Expired ServiceLevelCode : ND ServiceLevelDescription : C, NBD ONSITE Provider : UNY StartDate : 23.03.2005 00:00:00 EndDate : 23.03.2007 00:00:00 DaysLeft : 0 EntitlementType : Expired ServiceLevelCode : ND ServiceLevelDescription : C, NBD ONSITE Provider : UNY StartDate : 23.03.2004 00:00:00 EndDate : 24.03.2005 00:00:00 DaysLeft : 0 EntitlementType : Expired 这些从 Web Service 返回的信息还包括了其它有用的信息，例如计算机的系统类型： PS&gt; $info.AssetHeaderData ServiceTag : 36GPL41 SystemID : PLX_PNT_CEL_GX270 Buid : 11 Region : Americas SystemType : OptiPlex SystemModel : GX270 SystemShipDate : 23.03.2004 07:00:00","text":"适用于 PowerShell 2.0 及以上版本 如果您拥有一台 DELL 电脑，您可以通过 Web Service 提交电脑的序列号得到授权信息： $serial = &apos;36GPL41&apos; $service = New-WebServiceProxy -Uri http://143.166.84.118/services/assetservice.asmx?WSDL $guid = [Guid]::NewGuid() $info = $service.GetAssetInformation($guid,&apos;warrantycheck&apos;,$serial) $info.Entitlements 结果可能看起来如下： $info.Entitlements ServiceLevelCode : TS ServiceLevelDescription : P, ProSupport Provider : DELL StartDate : 23.03.2004 00:00:00 EndDate : 23.03.2007 00:00:00 DaysLeft : 0 EntitlementType : Expired ServiceLevelCode : ND ServiceLevelDescription : C, NBD ONSITE Provider : UNY StartDate : 23.03.2005 00:00:00 EndDate : 23.03.2007 00:00:00 DaysLeft : 0 EntitlementType : Expired ServiceLevelCode : ND ServiceLevelDescription : C, NBD ONSITE Provider : UNY StartDate : 23.03.2004 00:00:00 EndDate : 24.03.2005 00:00:00 DaysLeft : 0 EntitlementType : Expired 这些从 Web Service 返回的信息还包括了其它有用的信息，例如计算机的系统类型： PS&gt; $info.AssetHeaderData ServiceTag : 36GPL41 SystemID : PLX_PNT_CEL_GX270 Buid : 11 Region : Americas SystemType : OptiPlex SystemModel : GX270 SystemShipDate : 23.03.2004 07:00:00 本文国际来源：Checking DELL Warranty Online","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 Cmdlet 来管理 MSI 安装包","slug":"cmdlets-to-manage-msi-packages","date":"2015-01-26T04:00:00.000Z","updated":"2017-03-17T15:26:25.055Z","comments":true,"path":"2015/01/26/cmdlets-to-manage-msi-packages/","link":"","permalink":"http://blog.vichamp.com/2015/01/26/cmdlets-to-manage-msi-packages/","excerpt":"适用于 PowerShell 2.0 及以上版本 需要管理 MSI 安装包的朋友可以从这个开源项目中受益：http://psmsi.codeplex.com/。 只需要下载 PowerShell 模块——它自己包含了一个安装包。请确保在安装它之前对 MSI 文件进行解锁。否则，Windows 可能会拒绝安装它。 不幸的是，这个模块将它自己安装到一个很特殊的地方(AppData\\Local\\Apps...)，并且扩展了 $env:PSModulePath 环境变量，所以 PowerShell 可以找到这个模块。这是为什么您在安装完模块之后需要重启 PowerShell 的原因，因为 PowerShell 不能自动感知到 $env:PSModulePath 发生了改变。 这是获取新的 MSI 相关 cmdlet 的方法： PS&gt; Get-Command -Module MSI CommandType Name ModuleName ----------- ---- ---------- Function Get-MSIComponentState MSI Function Get-MSISharedComponentInfo MSI Function Install-MSIAdvertisedFeature MSI Cmdlet Add-MSISource MSI Cmdlet Clear-MSISource MSI Cmdlet Edit-MSIPackage MSI Cmdlet Export-MSIPatchXml MSI Cmdlet Get-MSIComponentInfo MSI Cmdlet Get-MSIFeatureInfo MSI Cmdlet Get-MSIFileHash MSI Cmdlet Get-MSIFileType MSI Cmdlet Get-MSILoggingPolicy MSI Cmdlet Get-MSIPatchInfo MSI Cmdlet Get-MSIPatchSequence MSI Cmdlet Get-MSIProductInfo MSI Cmdlet Get-MSIProperty MSI Cmdlet Get-MSIRelatedProductInfo MSI Cmdlet Get-MSISource MSI Cmdlet Get-MSISummaryInfo MSI Cmdlet Get-MSITable MSI Cmdlet Install-MSIPatch MSI Cmdlet Install-MSIProduct MSI Cmdlet Measure-MSIProduct MSI Cmdlet Remove-MSILoggingPolicy MSI Cmdlet Remove-MSISource MSI Cmdlet Repair-MSIProduct MSI Cmdlet Set-MSILoggingPolicy MSI Cmdlet Test-MSIProduct MSI Cmdlet Uninstall-MSIPatch MSI Cmdlet Uninstall-MSIProduct MSI","text":"适用于 PowerShell 2.0 及以上版本 需要管理 MSI 安装包的朋友可以从这个开源项目中受益：http://psmsi.codeplex.com/。 只需要下载 PowerShell 模块——它自己包含了一个安装包。请确保在安装它之前对 MSI 文件进行解锁。否则，Windows 可能会拒绝安装它。 不幸的是，这个模块将它自己安装到一个很特殊的地方(AppData\\Local\\Apps...)，并且扩展了 $env:PSModulePath 环境变量，所以 PowerShell 可以找到这个模块。这是为什么您在安装完模块之后需要重启 PowerShell 的原因，因为 PowerShell 不能自动感知到 $env:PSModulePath 发生了改变。 这是获取新的 MSI 相关 cmdlet 的方法： PS&gt; Get-Command -Module MSI CommandType Name ModuleName ----------- ---- ---------- Function Get-MSIComponentState MSI Function Get-MSISharedComponentInfo MSI Function Install-MSIAdvertisedFeature MSI Cmdlet Add-MSISource MSI Cmdlet Clear-MSISource MSI Cmdlet Edit-MSIPackage MSI Cmdlet Export-MSIPatchXml MSI Cmdlet Get-MSIComponentInfo MSI Cmdlet Get-MSIFeatureInfo MSI Cmdlet Get-MSIFileHash MSI Cmdlet Get-MSIFileType MSI Cmdlet Get-MSILoggingPolicy MSI Cmdlet Get-MSIPatchInfo MSI Cmdlet Get-MSIPatchSequence MSI Cmdlet Get-MSIProductInfo MSI Cmdlet Get-MSIProperty MSI Cmdlet Get-MSIRelatedProductInfo MSI Cmdlet Get-MSISource MSI Cmdlet Get-MSISummaryInfo MSI Cmdlet Get-MSITable MSI Cmdlet Install-MSIPatch MSI Cmdlet Install-MSIProduct MSI Cmdlet Measure-MSIProduct MSI Cmdlet Remove-MSILoggingPolicy MSI Cmdlet Remove-MSISource MSI Cmdlet Repair-MSIProduct MSI Cmdlet Set-MSILoggingPolicy MSI Cmdlet Test-MSIProduct MSI Cmdlet Uninstall-MSIPatch MSI Cmdlet Uninstall-MSIProduct MSI 本文国际来源：Cmdlets to Manage MSI Packages","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 读取多行文本","slug":"reading-multiline-text","date":"2015-01-23T04:00:00.000Z","updated":"2017-03-17T15:26:25.039Z","comments":true,"path":"2015/01/23/reading-multiline-text/","link":"","permalink":"http://blog.vichamp.com/2015/01/23/reading-multiline-text/","excerpt":"适用于 PowerShell 3.0 及以上版本 有些时候您偶然会见到类似这样的技巧： $FilePath = &quot;$env:SystemRoot\\WindowsUpdate.log&quot; $ContentsWithLinebreaks = (Get-Content $FilePath) -join &quot;`r`n&quot; 您能否出猜出它的用意？Get-Content 缺省情况下返回由一行一行组成的字符串数组，然后 -join 操作符将该数组转化为一个字符串。 从 PowerShell 3.0 开始，Get-Content 多了一个参数：-Raw。它比起刚才的方法高效的多，并且可以得到相同的结果： $FilePath = &quot;$env:SystemRoot\\WindowsUpdate.log&quot; $ContentsWithLinebreaks = (Get-Content $FilePath) -join &quot;`r`n&quot; $ContentsWithLinebreaks2 = Get-Content $FilePath -Raw $ContentsWithLinebreaks -eq $ContentsWithLinebreaks2 当您使用这段代码时，会发现 $ontentWithLinebreaks 和 $ContentWithLinebreaks2 是不同的。唯一的区别是在 $ContentsWithLinebreaks2 尾部有一个换行符： PS&gt; $ContentsWithLinebreaks -eq $ContentsWithLinebreaks2.TrimEnd(&quot;`r`n&quot;) True PS&gt;","text":"适用于 PowerShell 3.0 及以上版本 有些时候您偶然会见到类似这样的技巧： $FilePath = &quot;$env:SystemRoot\\WindowsUpdate.log&quot; $ContentsWithLinebreaks = (Get-Content $FilePath) -join &quot;`r`n&quot; 您能否出猜出它的用意？Get-Content 缺省情况下返回由一行一行组成的字符串数组，然后 -join 操作符将该数组转化为一个字符串。 从 PowerShell 3.0 开始，Get-Content 多了一个参数：-Raw。它比起刚才的方法高效的多，并且可以得到相同的结果： $FilePath = &quot;$env:SystemRoot\\WindowsUpdate.log&quot; $ContentsWithLinebreaks = (Get-Content $FilePath) -join &quot;`r`n&quot; $ContentsWithLinebreaks2 = Get-Content $FilePath -Raw $ContentsWithLinebreaks -eq $ContentsWithLinebreaks2 当您使用这段代码时，会发现 $ontentWithLinebreaks 和 $ContentWithLinebreaks2 是不同的。唯一的区别是在 $ContentsWithLinebreaks2 尾部有一个换行符： PS&gt; $ContentsWithLinebreaks -eq $ContentsWithLinebreaks2.TrimEnd(&quot;`r`n&quot;) True PS&gt; 本文国际来源：Reading Multiline Text","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 要求管理员权限","slug":"requiring-administrator-privileges","date":"2015-01-22T04:00:00.000Z","updated":"2017-03-17T15:26:25.039Z","comments":true,"path":"2015/01/22/requiring-administrator-privileges/","link":"","permalink":"http://blog.vichamp.com/2015/01/22/requiring-administrator-privileges/","excerpt":"适用于 PowerShell 4.0 及以上版本 如果您知道某个脚本需要管理员权限，只需要一个简单的 #requres 语句就可以确保符合该需求的才可以运行： #requires -version 4.0 #requires –runasadministrator &apos;I am Admin!&apos; 如果这个脚本没有使用管理员身份运行，它将显示一个有意义错误提示信息，说明它为何无法运行。 实际上，在这个例子中您可以看到两条 #requires 语句。第一条确保该脚本至少运行在 PowerShell 4.0 以上的环境中，这是第二条 #requires 的先决条件。它是由 PowerShell 4.0 引入的，不支持 PowerShell 更低的版本。 所以最好不要在 PowerShell 3.0 或更早的环境中使用这个技术。在那些环境中，您还是需要手工确认脚本是否拥有管理员权限。","text":"适用于 PowerShell 4.0 及以上版本 如果您知道某个脚本需要管理员权限，只需要一个简单的 #requres 语句就可以确保符合该需求的才可以运行： #requires -version 4.0 #requires –runasadministrator &apos;I am Admin!&apos; 如果这个脚本没有使用管理员身份运行，它将显示一个有意义错误提示信息，说明它为何无法运行。 实际上，在这个例子中您可以看到两条 #requires 语句。第一条确保该脚本至少运行在 PowerShell 4.0 以上的环境中，这是第二条 #requires 的先决条件。它是由 PowerShell 4.0 引入的，不支持 PowerShell 更低的版本。 所以最好不要在 PowerShell 3.0 或更早的环境中使用这个技术。在那些环境中，您还是需要手工确认脚本是否拥有管理员权限。 本文国际来源：Requiring Administrator Privileges","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"JavaScript 中的匿名函数和立即执行函数","slug":"Anonymous-Function-and-IIFE-in-JavaScript","date":"2015-01-22T03:27:15.000Z","updated":"2017-03-17T15:26:25.039Z","comments":true,"path":"2015/01/22/Anonymous-Function-and-IIFE-in-JavaScript/","link":"","permalink":"http://blog.vichamp.com/2015/01/22/Anonymous-Function-and-IIFE-in-JavaScript/","excerpt":"","text":"命名函数123function foo() &#123;&#125; 这种写法和 C 语言中定义一个函数的写法差不多。 匿名函数 + 赋值语句123var bar = function() &#123;&#125;; 例子中变量 bar 指向一个匿名函数。由于这是一个赋值语句，所以应该以 ; 结尾。虽然分号可以省略。 命名函数 + 赋值语句123var bar = function foo() &#123;&#125;; 此处的 foo 可以省略，不会影响代码逻辑。但是加上 foo 在调试工具中查看调用堆栈时，可以更清晰地看到函数的名称。所以这是一个推荐的实践。 立即执行函数 (IIFE)123(function() &#123;&#125;()); 还有一种变体： 123(function() &#123;&#125;)(); 请注意上述两种写法的圆括号的位置区别。前一种写法是 JSLint 推荐的写法，所以推荐采用第一种写法。 这种模式本质上只是一个函数表达式（无论是命名或匿名的），该函数会在创建后立刻执行。以下是用命名函数来实现 IIFE 的例子： 123(function foo() &#123; var bar = 1;&#125;()); 代码中用 foo 作为 IIFE 的名字。 这种模式是非常有用的，因为它为初始化代码提供了一个作用于沙箱(sandbox)。代码中的 bar 变量此时会成为一个局部变量，不会污染全局的 window (global) 对象。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/categories/javascript/"}]},{"title":"PowerShell 技能连载 - 分析并移除打印任务","slug":"analyzing-and-removing-print-jobs","date":"2015-01-21T04:00:00.000Z","updated":"2017-03-17T15:26:25.023Z","comments":true,"path":"2015/01/21/analyzing-and-removing-print-jobs/","link":"","permalink":"http://blog.vichamp.com/2015/01/21/analyzing-and-removing-print-jobs/","excerpt":"适用于 Windows 8.1 或 Server 2012 R2 Windows 8.1 和 Server 2012 R2 引入了一个名为“PrintManagement”的模块。它包含了管理本地和远程打印机所需的所有 cmdlet。 在前一个技能中我们演示了如何读取打印任务。每个打印任务都有一个 JobStatus 属性告诉您该 PrintJob 是否成功完成。 可以通过这种方式获取所有的状态码： PS&gt; Import-Module PrintManagement PS&gt; [Microsoft.PowerShell.Cmdletization.GeneratedTypes.PrintJob.JobStatus]::GetNames([Microsoft.PowerShell.Cmdletization.GeneratedTypes.PrintJob.JobStatus]) Normal Paused Error Deleting Spooling Printing Offline PaperOut Printed Deleted Blocked UserIntervention Restarted Complete Retained RenderingLocally 接下来，您可以过滤已有的打印任务。并且，比如打印出所有已完成或有错误的打印任务。这段代码将列出所有有错误或已完成的打印任务： $ComputerName = $env:COMPUTERNAME Get-Printer -ComputerName $ComputerName | ForEach-Object { Get-PrintJob -PrinterName $_.Name -ComputerName $ComputerName | Where-Object { $_.JobStatus -eq &apos;Complete&apos; -or $_.JobStatus -eq &apos;Error&apos; -or $_.JobStatus -eq &apos;Printed&apos;} } 要移除这些打印任务，只需要加上 Remove-PrintJob 命令： $ComputerName = $env:COMPUTERNAME Get-Printer -ComputerName $ComputerName | ForEach-Object { Get-PrintJob -PrinterName $_.Name -ComputerName $ComputerName | Where-Object { $_.JobStatus -eq &apos;Complete&apos; -or $_.JobStatus -eq &apos;Error&apos; -or $_.JobStatus -eq &apos;Printed&apos;} } | Remove-PrintJob -CimSession $ComputerName","text":"适用于 Windows 8.1 或 Server 2012 R2 Windows 8.1 和 Server 2012 R2 引入了一个名为“PrintManagement”的模块。它包含了管理本地和远程打印机所需的所有 cmdlet。 在前一个技能中我们演示了如何读取打印任务。每个打印任务都有一个 JobStatus 属性告诉您该 PrintJob 是否成功完成。 可以通过这种方式获取所有的状态码： PS&gt; Import-Module PrintManagement PS&gt; [Microsoft.PowerShell.Cmdletization.GeneratedTypes.PrintJob.JobStatus]::GetNames([Microsoft.PowerShell.Cmdletization.GeneratedTypes.PrintJob.JobStatus]) Normal Paused Error Deleting Spooling Printing Offline PaperOut Printed Deleted Blocked UserIntervention Restarted Complete Retained RenderingLocally 接下来，您可以过滤已有的打印任务。并且，比如打印出所有已完成或有错误的打印任务。这段代码将列出所有有错误或已完成的打印任务： $ComputerName = $env:COMPUTERNAME Get-Printer -ComputerName $ComputerName | ForEach-Object { Get-PrintJob -PrinterName $_.Name -ComputerName $ComputerName | Where-Object { $_.JobStatus -eq &apos;Complete&apos; -or $_.JobStatus -eq &apos;Error&apos; -or $_.JobStatus -eq &apos;Printed&apos;} } 要移除这些打印任务，只需要加上 Remove-PrintJob 命令： $ComputerName = $env:COMPUTERNAME Get-Printer -ComputerName $ComputerName | ForEach-Object { Get-PrintJob -PrinterName $_.Name -ComputerName $ComputerName | Where-Object { $_.JobStatus -eq &apos;Complete&apos; -or $_.JobStatus -eq &apos;Error&apos; -or $_.JobStatus -eq &apos;Printed&apos;} } | Remove-PrintJob -CimSession $ComputerName 本文国际来源：Analyzing and Removing Print Jobs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"JavaScript 最佳实践","slug":"JavaScript-Best-Practices","date":"2015-01-21T02:02:56.000Z","updated":"2017-03-17T15:26:25.023Z","comments":true,"path":"2015/01/21/JavaScript-Best-Practices/","link":"","permalink":"http://blog.vichamp.com/2015/01/21/JavaScript-Best-Practices/","excerpt":"","text":"45 Useful JavaScript Tips, Tricks and Best Practices - Modern Web","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/tags/javascript/"},{"name":"bestpractice","slug":"bestpractice","permalink":"http://blog.vichamp.com/tags/bestpractice/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/categories/javascript/"}]},{"title":"AngularJS 最佳实践","slug":"AngularJS-Best-Practices","date":"2015-01-21T01:44:06.000Z","updated":"2017-03-17T15:26:25.023Z","comments":true,"path":"2015/01/21/AngularJS-Best-Practices/","link":"","permalink":"http://blog.vichamp.com/2015/01/21/AngularJS-Best-Practices/","excerpt":"","text":"johnpapa/angularjs-styleguide Watch 419 Star 5,141 Fork 569 mgechev/angularjs-style-guide Watch 191 Star 2,625 Fork 313 中文版：README-zh-cn.md turingou/Angular-Best-Practices本repo由支付宝前端开发工程师 @莫登（新浪微博@郭宇）维护，部分案例包括Angular在 支付宝某些系统上的使用经验 Watch 7 Star 21 Fork 6 AngularJS移动开发中的坑汇总 Watch 7 Star 21 Fork 6 AngularJS 最佳实践 – 尘埃落定","categories":[{"name":"angularjs","slug":"angularjs","permalink":"http://blog.vichamp.com/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://blog.vichamp.com/tags/angularjs/"},{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/tags/javascript/"},{"name":"guide","slug":"guide","permalink":"http://blog.vichamp.com/tags/guide/"},{"name":"bestpractice","slug":"bestpractice","permalink":"http://blog.vichamp.com/tags/bestpractice/"}],"keywords":[{"name":"angularjs","slug":"angularjs","permalink":"http://blog.vichamp.com/categories/angularjs/"}]},{"title":"JavaScript 中的坑","slug":"Gochas-in-JavaScript","date":"2015-01-20T06:38:34.000Z","updated":"2017-03-17T15:26:25.008Z","comments":true,"path":"2015/01/20/Gochas-in-JavaScript/","link":"","permalink":"http://blog.vichamp.com/2015/01/20/Gochas-in-JavaScript/","excerpt":"","text":"AngularJS移动开发中的坑汇总","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/categories/javascript/"}]},{"title":"JavaScript 编码规范","slug":"JavaScript-Style-Guide","date":"2015-01-20T06:08:22.000Z","updated":"2017-03-17T15:26:25.008Z","comments":true,"path":"2015/01/20/JavaScript-Style-Guide/","link":"","permalink":"http://blog.vichamp.com/2015/01/20/JavaScript-Style-Guide/","excerpt":"","text":"Google’s JavaScript style guide Mozilla’s JavaScript style guide GitHub’s JavaScript style guide Douglas Crockford’s JavaScript style guide Airbnb JavaScript style guide","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/tags/javascript/"},{"name":"style","slug":"style","permalink":"http://blog.vichamp.com/tags/style/"},{"name":"guide","slug":"guide","permalink":"http://blog.vichamp.com/tags/guide/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/categories/javascript/"}]},{"title":"PowerShell 技能连载 - 列出所有打印任务","slug":"listing-all-print-jobs","date":"2015-01-20T04:00:00.000Z","updated":"2017-03-17T15:26:25.008Z","comments":true,"path":"2015/01/20/listing-all-print-jobs/","link":"","permalink":"http://blog.vichamp.com/2015/01/20/listing-all-print-jobs/","excerpt":"适用于 Windows 8.1 或 Server 2012 R2 Windows 8.1 和 Server 2012 R2 引入了一个名为“PrintManagement”的模块。它包含了管理本地和远程打印机所需的所有 cmdlet。 要列出指定计算机的所有打印任务，首先确定可用的打印机，然后用循环取出每个打印机的打印任务。这实际做起来十分简单： $ComputerName = $env:COMPUTERNAME Get-Printer -ComputerName $ComputerName | ForEach-Object { Get-PrintJob -PrinterName $_.Name -ComputerName $ComputerName } 如果该代码返回空，那么说明没有打印任务（或者您没有读取它们的权限）。","text":"适用于 Windows 8.1 或 Server 2012 R2 Windows 8.1 和 Server 2012 R2 引入了一个名为“PrintManagement”的模块。它包含了管理本地和远程打印机所需的所有 cmdlet。 要列出指定计算机的所有打印任务，首先确定可用的打印机，然后用循环取出每个打印机的打印任务。这实际做起来十分简单： $ComputerName = $env:COMPUTERNAME Get-Printer -ComputerName $ComputerName | ForEach-Object { Get-PrintJob -PrinterName $_.Name -ComputerName $ComputerName } 如果该代码返回空，那么说明没有打印任务（或者您没有读取它们的权限）。 本文国际来源：Listing All Print Jobs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 远程更新组策略","slug":"remotely-updating-group-policy","date":"2015-01-19T04:00:00.000Z","updated":"2017-03-17T15:26:24.992Z","comments":true,"path":"2015/01/19/remotely-updating-group-policy/","link":"","permalink":"http://blog.vichamp.com/2015/01/19/remotely-updating-group-policy/","excerpt":"适用于 Windows 8.1 或 Server 2012 R2 要更新远程计算机上的组策略设置，请使用 Invoke-GPUpdate，并且传入希望更新设置的计算机名。 Invoke-GPUpdate 在远程计算机上创建“gpupdate”计划任务。您可以使用 –RandomDelayInMinutes 指定一个 0 至 44640 分钟（31 天）之间的值。该 cmdlet 将使用一个随机的时间因子来避免网络阻塞。","text":"适用于 Windows 8.1 或 Server 2012 R2 要更新远程计算机上的组策略设置，请使用 Invoke-GPUpdate，并且传入希望更新设置的计算机名。 Invoke-GPUpdate 在远程计算机上创建“gpupdate”计划任务。您可以使用 –RandomDelayInMinutes 指定一个 0 至 44640 分钟（31 天）之间的值。该 cmdlet 将使用一个随机的时间因子来避免网络阻塞。 本文国际来源：Remotely Updating Group Policy","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 管理打印机","slug":"managing-printers","date":"2015-01-16T04:00:00.000Z","updated":"2017-03-17T15:26:24.992Z","comments":true,"path":"2015/01/16/managing-printers/","link":"","permalink":"http://blog.vichamp.com/2015/01/16/managing-printers/","excerpt":"适用于 Windows 8.1 和 Server 2012 R2 Windows 8.1 和 Server 2012 R2 带来了一个叫做“PrintManagement”的模块。它包含了管理本地和远程打印机所需的所有 Cmdlet。 以下是一个示例脚本，演示了安装打印机驱动、设置打印机端口、安装打印机、共享该打印机，以及设置某些打印机属性的过程。 $ComputerName = $env:COMPUTERNAME $DriverName = &apos;Samsung SCX-483x 5x3x Series XPS&apos; $IPAddress = &apos;192.168.2.107&apos; $PortName = &apos;NetworkPrint_192.168.2.107&apos; $PrinterName = &apos;BWPrint&apos; $ShareName = &apos;Office 12&apos; Add-PrinterDriver -ComputerName $ComputerName -Name $DriverName Add-PrinterPort -Name $PortName -ComputerName $ComputerName Add-Printer -ComputerName $ComputerName -Name $PrinterName -DriverName $DriverName -Shared -ShareName $ShareName -PortName $PortName Set-PrintConfiguration -ComputerName $ComputerName -PrinterName $PrinterName -PaperSize A4 要使用它，请确保您修改了 $IPAddress 并指向一个存在的打印机。请将 $ComputerName 修改指向一个远程计算机而不是您的本地计算机。 要列出 PrintManagement 模块所带的所有 Cmdlet，请试试以下代码： PS&gt; Get-Command -Module PrintManagement CommandType Name ModuleName ----------- ---- ---------- Function Add-Printer PrintManagement Function Add-PrinterDriver PrintManagement Function Add-PrinterPort PrintManagement Function Get-PrintConfiguration PrintManagement Function Get-Printer PrintManagement Function Get-PrinterDriver PrintManagement Function Get-PrinterPort PrintManagement Function Get-PrinterProperty PrintManagement Function Get-PrintJob PrintManagement Function Read-PrinterNfcTag PrintManagement Function Remove-Printer PrintManagement Function Remove-PrinterDriver PrintManagement Function Remove-PrinterPort PrintManagement Function Remove-PrintJob PrintManagement Function Rename-Printer PrintManagement Function Restart-PrintJob PrintManagement Function Resume-PrintJob PrintManagement Function Set-PrintConfiguration PrintManagement Function Set-Printer PrintManagement Function Set-PrinterProperty PrintManagement Function Suspend-PrintJob PrintManagement Function Write-PrinterNfcTag PrintManagement 如您所见，它们实际上是 PowerShell 函数而不是二进制 Cmdlet。","text":"适用于 Windows 8.1 和 Server 2012 R2 Windows 8.1 和 Server 2012 R2 带来了一个叫做“PrintManagement”的模块。它包含了管理本地和远程打印机所需的所有 Cmdlet。 以下是一个示例脚本，演示了安装打印机驱动、设置打印机端口、安装打印机、共享该打印机，以及设置某些打印机属性的过程。 $ComputerName = $env:COMPUTERNAME $DriverName = &apos;Samsung SCX-483x 5x3x Series XPS&apos; $IPAddress = &apos;192.168.2.107&apos; $PortName = &apos;NetworkPrint_192.168.2.107&apos; $PrinterName = &apos;BWPrint&apos; $ShareName = &apos;Office 12&apos; Add-PrinterDriver -ComputerName $ComputerName -Name $DriverName Add-PrinterPort -Name $PortName -ComputerName $ComputerName Add-Printer -ComputerName $ComputerName -Name $PrinterName -DriverName $DriverName -Shared -ShareName $ShareName -PortName $PortName Set-PrintConfiguration -ComputerName $ComputerName -PrinterName $PrinterName -PaperSize A4 要使用它，请确保您修改了 $IPAddress 并指向一个存在的打印机。请将 $ComputerName 修改指向一个远程计算机而不是您的本地计算机。 要列出 PrintManagement 模块所带的所有 Cmdlet，请试试以下代码： PS&gt; Get-Command -Module PrintManagement CommandType Name ModuleName ----------- ---- ---------- Function Add-Printer PrintManagement Function Add-PrinterDriver PrintManagement Function Add-PrinterPort PrintManagement Function Get-PrintConfiguration PrintManagement Function Get-Printer PrintManagement Function Get-PrinterDriver PrintManagement Function Get-PrinterPort PrintManagement Function Get-PrinterProperty PrintManagement Function Get-PrintJob PrintManagement Function Read-PrinterNfcTag PrintManagement Function Remove-Printer PrintManagement Function Remove-PrinterDriver PrintManagement Function Remove-PrinterPort PrintManagement Function Remove-PrintJob PrintManagement Function Rename-Printer PrintManagement Function Restart-PrintJob PrintManagement Function Resume-PrintJob PrintManagement Function Set-PrintConfiguration PrintManagement Function Set-Printer PrintManagement Function Set-PrinterProperty PrintManagement Function Suspend-PrintJob PrintManagement Function Write-PrinterNfcTag PrintManagement 如您所见，它们实际上是 PowerShell 函数而不是二进制 Cmdlet。 本文国际来源：Managing Printers","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 显示 黑客帝国数码雨动画","slug":"matrix","date":"2015-01-15T09:28:00.000Z","updated":"2017-03-17T15:26:24.973Z","comments":true,"path":"2015/01/15/matrix/","link":"","permalink":"http://blog.vichamp.com/2015/01/15/matrix/","excerpt":"请在 PowerShell 控制台中执行本脚本 今天在群里看到一个数码雨的课题，试着实现了一下： 【话痨】powershell传教士(1328486072) 12:58:11话说有人用bat写出了数码雨，谁也用powershell写一个，我用powershell写了几个，总感觉不对。【话痨】powershell传教士(1328486072) 12:58:52有人对命令行数码雨，感兴趣么？ 根据传教士的提示，改了一下，避免了闪烁。 实现效果 源代码","text":"请在 PowerShell 控制台中执行本脚本 今天在群里看到一个数码雨的课题，试着实现了一下： 【话痨】powershell传教士(1328486072) 12:58:11话说有人用bat写出了数码雨，谁也用powershell写一个，我用powershell写了几个，总感觉不对。【话痨】powershell传教士(1328486072) 12:58:52有人对命令行数码雨，感兴趣么？ 根据传教士的提示，改了一下，避免了闪烁。 实现效果 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111## Prepare the screen$host.UI.RawUI.BackgroundColor = \"Black\"$host.UI.RawUI.ForegroundColor = \"Green\"$charSet = '0123456789'.ToCharArray()$width = 75$height = [Console]::WindowHeight$maxStringLength = 7$minStringLength = 2$maxSpaceLength = 20$minSpaceLength = 6$lines = New-Object System.Collections.ArrayList$symbols = @()for ($i = 0; $i -lt $width; $i++) &#123; $symbols += ''&#125;function AddLine([string]$line) &#123; $lines.insert(0, $line) if ($lines.Count -eq $height) &#123; $lines.RemoveAt($lines.Count - 1) &#125;&#125;function ShowFrame() &#123; Write-Host ($lines.ToArray() -join \"`n\")&#125;function TryGenerateSymbol() &#123; for ($i = 0; $i -lt $width; $i++) &#123; $column = $symbols[$i] if ($column -eq '') &#123; # initial state, generate spaces $symbols[$i] = New-Object String ' ', (Get-Random -Minimum $minSpaceLength -Maximum $maxSpaceLength) &#125; elseif ($column -eq ' ') &#123; # last space $randomCount = Get-Random -Minimum $minStringLength -Maximum $maxStringLength $chars = Get-Random -InputObject $charSet -Count $randomCount $symbols[$i] = $column + ($chars -join '') &#125; elseif ($column.Length -eq 1) &#123; # last char $symbols[$i] = $column + (New-Object String ' ', (Get-Random -Minimum $minSpaceLength -Maximum $maxSpaceLength)) &#125; &#125;&#125;function UpdateFrame() &#123; TryGenerateSymbol $line = @() for ($i = 0; $i -lt $width; $i++) &#123; $column = $symbols[$i] $line += $column[0] $symbols[$i] = $column.Substring(1, $column.Length - 1) &#125; $line = $line -join '' AddLine $line&#125;try&#123; $host.UI.RawUI.WindowSize = New-Object System.Management.Automation.Host.Size $width + 1, $height + 1&#125;catch &#123;&#125;try&#123; $host.UI.RawUI.BufferSize = New-Object System.Management.Automation.Host.Size $width + 1, $height + 1&#125; catch &#123;&#125;try&#123; while($true) &#123; if([Console]::KeyAvailable) &#123; $key = [Console]::ReadKey() if(($key.Key -eq 'Escape') -or ($key.Key -eq 'Q') -or ($key.Key -eq 'C')) &#123; break &#125; &#125; # Clear-Host $host.UI.RawUI.CursorPosition = New-Object System.Management.Automation.Host.Coordinates 0,0 UpdateFrame ShowFrame $host.UI.RawUI.CursorPosition = New-Object System.Management.Automation.Host.Coordinates ` 0,([Console]::WindowHeight - 1) Write-Host -NoNewLine 'Q or ESC to Quit' Start-Sleep -m 100 &#125;&#125;finally&#123; ## Clean up, display exit screen Clear-Host \"`n\" \" Happy Scripting from PowerShell...\" \" by Victor.Woo!\" \"`n`n`n\"&#125; 您也可以在这里下载 Matrix.ps1","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"geek","slug":"powershell/geek","permalink":"http://blog.vichamp.com/categories/powershell/geek/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"text","slug":"text","permalink":"http://blog.vichamp.com/tags/text/"},{"name":"asciiart","slug":"asciiart","permalink":"http://blog.vichamp.com/tags/asciiart/"},{"name":"animation","slug":"animation","permalink":"http://blog.vichamp.com/tags/animation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"geek","slug":"powershell/geek","permalink":"http://blog.vichamp.com/categories/powershell/geek/"}]},{"title":"PowerShell 技能连载 - 简化 .NET 类型","slug":"simplifying-net-types","date":"2015-01-15T04:00:00.000Z","updated":"2017-03-17T15:26:24.976Z","comments":true,"path":"2015/01/15/simplifying-net-types/","link":"","permalink":"http://blog.vichamp.com/2015/01/15/simplifying-net-types/","excerpt":"适用于 PowerShell 所有版本 PowerShell 为多数常见的 .NET 类型定义了一个短名字。要查看已有多少个 .NET 类型定义了短名称，请使用以下代码： PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;System.String&quot;) [string] PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;System.Int32&quot;) [int] PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;System.Management.ManagementObject&quot;) [wmi] PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;System.DirectoryServices.DirectoryEntry&quot;) [adsi] PS&gt; 要查用另一种方法看真实的 .NET 名称，请使用以下方法： PS&gt; [string].FullName System.String PS&gt; [int].FullName System.Int32 PS&gt; [wmi].FullName System.Management.ManagementObject PS&gt; [adsi].FullName System.DirectoryServices.DirectoryEntry PS&gt; 通过这个技巧，您还可以更好地理解 PowerShell 转换数据类型的机制： PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;UInt8&quot;) [Byte] PS&gt; 这表明了，当 PowerShell 遇到一个无符号 8 位整型数值，将自动把它转换为一个 Byte 数据。整个魔法是由 ConvertTypeNameToPSTypeName() 完成的。在内部，PowerShell 使用一个检索表来转换特定的数据类型： $field = [System.Management.Automation.LanguagePrimitives].GetField(&apos;nameMap&apos;, &apos;NonPublic,Static&apos;) $field.GetValue([System.Management.Automation.LanguagePrimitives]) 该检索表看起来类似这样： Key Value --- ----- SInt8 SByte UInt8 Byte SInt16 Int16 UInt16 UInt16 SInt32 Int32 UInt32 UInt32 SInt64 Int64 UInt64 UInt64 Real32 Single Real64 double Boolean bool String string DateTime DateTime Reference CimInstance Char16 char Instance CimInstance BooleanArray bool[] UInt8Array byte[] SInt8Array Sbyte[] UInt16Array uint16[] SInt16Array int64[] UInt32Array UInt32[] SInt32Array Int32[] UInt64Array UInt64[] SInt64Array Int64[] Real32Array Single[] Real64Array double[] Char16Array char[] DateTimeArray DateTime[] StringArray string[] ReferenceArray CimInstance[] InstanceArray CimInstance[] Unknown UnknownType","text":"适用于 PowerShell 所有版本 PowerShell 为多数常见的 .NET 类型定义了一个短名字。要查看已有多少个 .NET 类型定义了短名称，请使用以下代码： PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;System.String&quot;) [string] PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;System.Int32&quot;) [int] PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;System.Management.ManagementObject&quot;) [wmi] PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;System.DirectoryServices.DirectoryEntry&quot;) [adsi] PS&gt; 要查用另一种方法看真实的 .NET 名称，请使用以下方法： PS&gt; [string].FullName System.String PS&gt; [int].FullName System.Int32 PS&gt; [wmi].FullName System.Management.ManagementObject PS&gt; [adsi].FullName System.DirectoryServices.DirectoryEntry PS&gt; 通过这个技巧，您还可以更好地理解 PowerShell 转换数据类型的机制： PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;UInt8&quot;) [Byte] PS&gt; 这表明了，当 PowerShell 遇到一个无符号 8 位整型数值，将自动把它转换为一个 Byte 数据。整个魔法是由 ConvertTypeNameToPSTypeName() 完成的。在内部，PowerShell 使用一个检索表来转换特定的数据类型： $field = [System.Management.Automation.LanguagePrimitives].GetField(&apos;nameMap&apos;, &apos;NonPublic,Static&apos;) $field.GetValue([System.Management.Automation.LanguagePrimitives]) 该检索表看起来类似这样： Key Value --- ----- SInt8 SByte UInt8 Byte SInt16 Int16 UInt16 UInt16 SInt32 Int32 UInt32 UInt32 SInt64 Int64 UInt64 UInt64 Real32 Single Real64 double Boolean bool String string DateTime DateTime Reference CimInstance Char16 char Instance CimInstance BooleanArray bool[] UInt8Array byte[] SInt8Array Sbyte[] UInt16Array uint16[] SInt16Array int64[] UInt32Array UInt32[] SInt32Array Int32[] UInt64Array UInt64[] SInt64Array Int64[] Real32Array Single[] Real64Array double[] Char16Array char[] DateTimeArray DateTime[] StringArray string[] ReferenceArray CimInstance[] InstanceArray CimInstance[] Unknown UnknownType 本文国际来源：Simplifying .NET Types","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将代码转为大写","slug":"converting-code-to-uppercase","date":"2015-01-14T04:00:00.000Z","updated":"2017-03-17T15:26:24.956Z","comments":true,"path":"2015/01/14/converting-code-to-uppercase/","link":"","permalink":"http://blog.vichamp.com/2015/01/14/converting-code-to-uppercase/","excerpt":"适用于 PowerShell 3.0 及以上版本 在 PowerShell ISE 中要将 PowerShell 的代码转为全大写，请选中文本，并按下 CTRL + SHIFT + U。 To turn text to all lowercase letters, press CTRL+U.要将文本转为全小写，请按 CTRL+U。","text":"适用于 PowerShell 3.0 及以上版本 在 PowerShell ISE 中要将 PowerShell 的代码转为全大写，请选中文本，并按下 CTRL + SHIFT + U。 To turn text to all lowercase letters, press CTRL+U.要将文本转为全小写，请按 CTRL+U。 本文国际来源：Converting Code to Uppercase","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 映射驱动器","slug":"mapping-drives","date":"2015-01-13T04:00:00.000Z","updated":"2017-03-17T15:26:24.939Z","comments":true,"path":"2015/01/13/mapping-drives/","link":"","permalink":"http://blog.vichamp.com/2015/01/13/mapping-drives/","excerpt":"适用于 PowerShell 3.0 及以上版本 要永久地映射一个网络驱动器，请使用 New-PSDrive 加上 -Persist 参数。这个参数使得驱动器在 PowerShell 之外可见。 要真正地创建一个永久的网络驱动器，请确保加上 -Scope Global。如果 New-PSDrive 在全局作用域范围之外运行（例如，在一个脚本中运行），该驱动器只会在脚本运行时出现在文件管理器中。 这个实例代码演示了如何映射一个网络驱动器： New-PSDrive -Name k -PSProvider FileSystem -Root \\\\storage2\\vid -Persist -Scope Global","text":"适用于 PowerShell 3.0 及以上版本 要永久地映射一个网络驱动器，请使用 New-PSDrive 加上 -Persist 参数。这个参数使得驱动器在 PowerShell 之外可见。 要真正地创建一个永久的网络驱动器，请确保加上 -Scope Global。如果 New-PSDrive 在全局作用域范围之外运行（例如，在一个脚本中运行），该驱动器只会在脚本运行时出现在文件管理器中。 这个实例代码演示了如何映射一个网络驱动器： New-PSDrive -Name k -PSProvider FileSystem -Root \\\\storage2\\vid -Persist -Scope Global 本文国际来源：Mapping Drives","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在输出中使用系统的错误颜色","slug":"using-system-error-colors-for-output","date":"2015-01-12T04:00:00.000Z","updated":"2017-03-17T15:26:24.908Z","comments":true,"path":"2015/01/12/using-system-error-colors-for-output/","link":"","permalink":"http://blog.vichamp.com/2015/01/12/using-system-error-colors-for-output/","excerpt":"适用于 PowerShell 所有版本 如果您的脚本希望输出警告或错误信息，您可以使用 Write-Warning 或 Write-Error 指令。两个 cmdlet 都会使用缺省的 PowerShell 颜色来显示警告和错误。然而，这两个 cmdlet 也会为您的输出结果套用一个文字模板： PS&gt; Write-Warning -Message &apos;This is a warning&apos; WARNING: This is a warning PS&gt; Write-Error -Message &apos;Something went wrong&apos; Write-Error -Message &apos;Something went wrong&apos; : Something went wrong + CategoryInfo : NotSpecified: (:) [Write-Error], WriteErrorException + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException Write-Error 添加了一堆无意义的异常详细信息，而您所需要的只是错误文本。一个更好的方式是： PS&gt; $host.UI.WriteErrorLine(&apos;Something went wrong...&apos;) Something went wrong... 警告和错误的颜色可以通过这种方式配置： PS&gt; $host.UI.WriteErrorLine(&apos;Something went wrong...&apos;) Something went wrong... PS&gt; $host.PrivateData.ErrorBackgroundColor = &apos;White&apos; PS&gt; $host.UI.WriteErrorLine(&apos;Something went wrong...&apos;) Something went wrong... PS&gt; $host.PrivateData (...) ErrorForegroundColor : #FFFF0000 ErrorBackgroundColor : #FFFFFFFF WarningForegroundColor : #FFFF8C00 WarningBackgroundColor : #00FFFFFF VerboseForegroundColor : #FF00FFFF VerboseBackgroundColor : #00FFFFFF DebugForegroundColor : #FF00FFFF DebugBackgroundColor : #00FFFFFF (...)","text":"适用于 PowerShell 所有版本 如果您的脚本希望输出警告或错误信息，您可以使用 Write-Warning 或 Write-Error 指令。两个 cmdlet 都会使用缺省的 PowerShell 颜色来显示警告和错误。然而，这两个 cmdlet 也会为您的输出结果套用一个文字模板： PS&gt; Write-Warning -Message &apos;This is a warning&apos; WARNING: This is a warning PS&gt; Write-Error -Message &apos;Something went wrong&apos; Write-Error -Message &apos;Something went wrong&apos; : Something went wrong + CategoryInfo : NotSpecified: (:) [Write-Error], WriteErrorException + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException Write-Error 添加了一堆无意义的异常详细信息，而您所需要的只是错误文本。一个更好的方式是： PS&gt; $host.UI.WriteErrorLine(&apos;Something went wrong...&apos;) Something went wrong... 警告和错误的颜色可以通过这种方式配置： PS&gt; $host.UI.WriteErrorLine(&apos;Something went wrong...&apos;) Something went wrong... PS&gt; $host.PrivateData.ErrorBackgroundColor = &apos;White&apos; PS&gt; $host.UI.WriteErrorLine(&apos;Something went wrong...&apos;) Something went wrong... PS&gt; $host.PrivateData (...) ErrorForegroundColor : #FFFF0000 ErrorBackgroundColor : #FFFFFFFF WarningForegroundColor : #FFFF8C00 WarningBackgroundColor : #00FFFFFF VerboseForegroundColor : #FF00FFFF VerboseBackgroundColor : #00FFFFFF DebugForegroundColor : #FF00FFFF DebugBackgroundColor : #00FFFFFF (...) 本文国际来源：Using System Error Colors for Output","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 解析 IP 地址（和参数类型）","slug":"resolving-ip-addresses-and-parameter-types-too","date":"2015-01-09T04:00:00.000Z","updated":"2017-03-17T15:26:24.908Z","comments":true,"path":"2015/01/09/resolving-ip-addresses-and-parameter-types-too/","link":"","permalink":"http://blog.vichamp.com/2015/01/09/resolving-ip-addresses-and-parameter-types-too/","excerpt":"适用于 PowerShell 2.0 及以上版本 这个例子演示了两件事情：如何限制一个参数为指定的数据类型、如何使用 .NET 方法来将 IP 地址转化为机器名： function Resolve-IPAddress { param ( [IPAddress] $IPAddress ) [Net.DNS]::GetHostByAddress($IPAddress) } 通过为 $IPAddress 参数前附加一个类型（例如“IPAddress”），您可以让 PowerShell 来校验输入数据的合法性。 “System.Net.DNS” .NET 类型提供了许多有用的静态方法供您解析 IP 地址。请注意在 PowerShell 中您不需要为 .NET 类型指定“System”命名空间。如果您愿意，您也可以使用完整的“`System.Net.DNS”全名。 这是您使用了新的 Resolve-IPAddress 函数的效果： PS&gt; Resolve-IPAddress -IPAddress 127.0.0.1 HostName Aliases AddressList -------- ------- ----------- TobiasAir1 {} {127.0.0.1} PS&gt; Resolve-IPAddress -IPAddress 300.200.100.1 Resolve-IPAddress : Cannot process argument transformation on parameter &apos;IPAddress&apos;. Cannot convert value &quot;300.200.100.1&quot; to type &quot;System.Net.IPAddress&quot;. Error: &quot;An invalid IP address was specified.&quot; At line:1 char:30 + Resolve-IPAddress -IPAddress 300.200.100.1 + ~~~~~~~~~~~~~ + CategoryInfo : InvalidData: (:) [Resolve-IPAddress], ParameterBindin gArgumentTransformationException + FullyQualifiedErrorId : ParameterArgumentTransformationError,Resolve-IPAddres s","text":"适用于 PowerShell 2.0 及以上版本 这个例子演示了两件事情：如何限制一个参数为指定的数据类型、如何使用 .NET 方法来将 IP 地址转化为机器名： function Resolve-IPAddress { param ( [IPAddress] $IPAddress ) [Net.DNS]::GetHostByAddress($IPAddress) } 通过为 $IPAddress 参数前附加一个类型（例如“IPAddress”），您可以让 PowerShell 来校验输入数据的合法性。 “System.Net.DNS” .NET 类型提供了许多有用的静态方法供您解析 IP 地址。请注意在 PowerShell 中您不需要为 .NET 类型指定“System”命名空间。如果您愿意，您也可以使用完整的“`System.Net.DNS”全名。 这是您使用了新的 Resolve-IPAddress 函数的效果： PS&gt; Resolve-IPAddress -IPAddress 127.0.0.1 HostName Aliases AddressList -------- ------- ----------- TobiasAir1 {} {127.0.0.1} PS&gt; Resolve-IPAddress -IPAddress 300.200.100.1 Resolve-IPAddress : Cannot process argument transformation on parameter &apos;IPAddress&apos;. Cannot convert value &quot;300.200.100.1&quot; to type &quot;System.Net.IPAddress&quot;. Error: &quot;An invalid IP address was specified.&quot; At line:1 char:30 + Resolve-IPAddress -IPAddress 300.200.100.1 + ~~~~~~~~~~~~~ + CategoryInfo : InvalidData: (:) [Resolve-IPAddress], ParameterBindin gArgumentTransformationException + FullyQualifiedErrorId : ParameterArgumentTransformationError,Resolve-IPAddres s 本文国际来源：Resolving IP Addresses (and Parameter Types, Too)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 条件断点","slug":"conditional-breakpoints","date":"2015-01-08T04:00:00.000Z","updated":"2017-03-17T15:26:24.892Z","comments":true,"path":"2015/01/08/conditional-breakpoints/","link":"","permalink":"http://blog.vichamp.com/2015/01/08/conditional-breakpoints/","excerpt":"适用于 PowerShell 3.0 及以上版本 PowerShell ISE 只支持行断点：它们的作用是当调试器命中指定的行时，使代码暂停执行。您可以在 PowerShell ISE 中按 F9 来切换行断点。只需要保证脚本已经保存。未保存的脚本（“无标题”）中的断点是无效的。 一个更复杂的做法是使用动态（或称为“条件”）断点。它们并不是关联于某一行上而是和某一种情况有关联。 要在某个变量被赋予一个新值的时候使脚本停下来，请使用这段示例代码（请先保存后执行）： $bp = Set-PSBreakpoint -Variable a -Mode Write -Script $psise.CurrentFile.FullPath $a = 1 $a $a $a = 200 $a Remove-PSBreakpoint -Breakpoint $bp 当您运行它时，PowerShell 调试器将会在 $a 被赋予一个新值的时候暂停脚本执行。 您甚至可以为它绑定一个更复杂的条件。这个例子将只会在对 $a 赋予一个大于 100 的整数值时才使脚本暂停。 $Condition = { if ($a -is [Int] -and $a -gt 100) { break } } $bp = Set-PSBreakpoint -Variable a -Mode Write -Script $psise.CurrentFile.FullPath -Action $Condition $a = 1 $a $a $a = 200 $a Remove-PSBreakpoint -Breakpoint $bp","text":"适用于 PowerShell 3.0 及以上版本 PowerShell ISE 只支持行断点：它们的作用是当调试器命中指定的行时，使代码暂停执行。您可以在 PowerShell ISE 中按 F9 来切换行断点。只需要保证脚本已经保存。未保存的脚本（“无标题”）中的断点是无效的。 一个更复杂的做法是使用动态（或称为“条件”）断点。它们并不是关联于某一行上而是和某一种情况有关联。 要在某个变量被赋予一个新值的时候使脚本停下来，请使用这段示例代码（请先保存后执行）： $bp = Set-PSBreakpoint -Variable a -Mode Write -Script $psise.CurrentFile.FullPath $a = 1 $a $a $a = 200 $a Remove-PSBreakpoint -Breakpoint $bp 当您运行它时，PowerShell 调试器将会在 $a 被赋予一个新值的时候暂停脚本执行。 您甚至可以为它绑定一个更复杂的条件。这个例子将只会在对 $a 赋予一个大于 100 的整数值时才使脚本暂停。 $Condition = { if ($a -is [Int] -and $a -gt 100) { break } } $bp = Set-PSBreakpoint -Variable a -Mode Write -Script $psise.CurrentFile.FullPath -Action $Condition $a = 1 $a $a $a = 200 $a Remove-PSBreakpoint -Breakpoint $bp 本文国际来源：Conditional Breakpoints","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检测 64 位操作系统","slug":"detecting-64-bit-operating-system","date":"2015-01-07T04:00:00.000Z","updated":"2017-03-17T15:26:24.892Z","comments":true,"path":"2015/01/07/detecting-64-bit-operating-system/","link":"","permalink":"http://blog.vichamp.com/2015/01/07/detecting-64-bit-operating-system/","excerpt":"适用于 Windows 7/Server 2008 R2 要检测一个脚本是运行在 32 位环境还是 64 位环境是十分简单的：只需要检查指针的大小，看是等于 4 字节还是 8 字节： if ([IntPtr]::Size -eq 8) { &apos;64-bit&apos; } else { &apos;32-bit&apos; } 不过这并不会告诉您操作系统的类型。这是由于 PowerShell 脚本可以在 64 位机器中运行在 32 位进程里。 要检测 OS 类型，请试试这段代码： if ([Environment]::Is64BitOperatingSystem) { &apos;64-bit&apos; } else { &apos;32-bit&apos; } 而且，Environment 类也可以检查您的进程类型： if ([Environment]::Is64BitProcess) { &apos;64-bit&apos; } else { &apos;32-bit&apos; }","text":"适用于 Windows 7/Server 2008 R2 要检测一个脚本是运行在 32 位环境还是 64 位环境是十分简单的：只需要检查指针的大小，看是等于 4 字节还是 8 字节： if ([IntPtr]::Size -eq 8) { &apos;64-bit&apos; } else { &apos;32-bit&apos; } 不过这并不会告诉您操作系统的类型。这是由于 PowerShell 脚本可以在 64 位机器中运行在 32 位进程里。 要检测 OS 类型，请试试这段代码： if ([Environment]::Is64BitOperatingSystem) { &apos;64-bit&apos; } else { &apos;32-bit&apos; } 而且，Environment 类也可以检查您的进程类型： if ([Environment]::Is64BitProcess) { &apos;64-bit&apos; } else { &apos;32-bit&apos; } 本文国际来源：Detecting 64-bit Operating System","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建 NTFS 安全报告","slug":"creating-ntfs-security-report","date":"2015-01-06T04:00:00.000Z","updated":"2017-03-17T15:26:24.892Z","comments":true,"path":"2015/01/06/creating-ntfs-security-report/","link":"","permalink":"http://blog.vichamp.com/2015/01/06/creating-ntfs-security-report/","excerpt":"适用于 PowerShell 所有版本 如果您希望审计您文件系统中的 NTFS 权限，以下是您起步的建议。 这个脚本递归扫描 Windows 目录和子目录。只要将 $Path 替换为其它路径就可以扫描您文件系统的其它路径。 $Path = &apos;C:\\Windows&apos; Get-ChildItem -Path $Path -Recurse -Directory -ErrorAction SilentlyContinue | ForEach-Object { $result = $_ | Select-Object -Property FullName, ExplicitePermissions, Count, Preview $result.ExplicitePermissions = (Get-Acl -Path $_.FullName -ErrorAction SilentlyContinue).Access | Where-Object { $_.isInherited -eq $false } $result.Count = $result.ExplicitePermissions.Count $result.Preview = $result.ExplicitePermissions.IdentityReference -join &apos;,&apos; if ($result.ExplicitePermissions.Count -gt 0) { $result } } | Out-GridView 该脚本读取每个子文件夹的安全描述符并查找非继承的安全控制项。如果找到了，那么就加这个信息加入文件夹对象。 结果将输出到一个网格视图窗口。如果您移除掉 Out-GridView，那么您会得到类似如下的信息： PS&gt; G:\\ FullName ExplicitePermissions Count Preview -------- -------------------- ----- ------- C:\\windows\\addins {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\AppPatch {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\Boot {System.Security.Access... 8 NT AUTHORITY\\SYSTEM,NT ... C:\\windows\\Branding {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\Cursors {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\de-DE {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\diagnostics {System.Security.Access... 8 NT AUTHORITY\\SYSTEM,NT ... C:\\windows\\Downloaded P... {System.Security.Access... 11 CREATOR OWNER,NT AUTHOR... 您可以将这个例子作为更深入的工具的基础。例如，您可以将缺省受信任者（例如“CREATOR”，或“SYSTEM”）加入一个列表，并从结果中排除这个列表。","text":"适用于 PowerShell 所有版本 如果您希望审计您文件系统中的 NTFS 权限，以下是您起步的建议。 这个脚本递归扫描 Windows 目录和子目录。只要将 $Path 替换为其它路径就可以扫描您文件系统的其它路径。 $Path = &apos;C:\\Windows&apos; Get-ChildItem -Path $Path -Recurse -Directory -ErrorAction SilentlyContinue | ForEach-Object { $result = $_ | Select-Object -Property FullName, ExplicitePermissions, Count, Preview $result.ExplicitePermissions = (Get-Acl -Path $_.FullName -ErrorAction SilentlyContinue).Access | Where-Object { $_.isInherited -eq $false } $result.Count = $result.ExplicitePermissions.Count $result.Preview = $result.ExplicitePermissions.IdentityReference -join &apos;,&apos; if ($result.ExplicitePermissions.Count -gt 0) { $result } } | Out-GridView 该脚本读取每个子文件夹的安全描述符并查找非继承的安全控制项。如果找到了，那么就加这个信息加入文件夹对象。 结果将输出到一个网格视图窗口。如果您移除掉 Out-GridView，那么您会得到类似如下的信息： PS&gt; G:\\ FullName ExplicitePermissions Count Preview -------- -------------------- ----- ------- C:\\windows\\addins {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\AppPatch {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\Boot {System.Security.Access... 8 NT AUTHORITY\\SYSTEM,NT ... C:\\windows\\Branding {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\Cursors {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\de-DE {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\diagnostics {System.Security.Access... 8 NT AUTHORITY\\SYSTEM,NT ... C:\\windows\\Downloaded P... {System.Security.Access... 11 CREATOR OWNER,NT AUTHOR... 您可以将这个例子作为更深入的工具的基础。例如，您可以将缺省受信任者（例如“CREATOR”，或“SYSTEM”）加入一个列表，并从结果中排除这个列表。 本文国际来源：Creating NTFS Security Report","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找非继承的权限","slug":"finding-explicit-permissions","date":"2015-01-05T04:00:00.000Z","updated":"2017-03-17T15:26:24.892Z","comments":true,"path":"2015/01/05/finding-explicit-permissions/","link":"","permalink":"http://blog.vichamp.com/2015/01/05/finding-explicit-permissions/","excerpt":"适用于 PowerShell 所有版本 通常，文件系统的 NTFS 权限是继承的。然而，您可以显式地为文件和文件夹添加权限。 您可以使用这段示例代码查找何处禁用了继承以及何处添加了权限项目： Get-ChildItem c:\\Windows -Recurse -Directory -ErrorAction SilentlyContinue | Where-Object { (Get-Acl -Path $_.FullName -ErrorAction SilentlyContinue).Access | Where-Object { $_.isInherited -eq $false } } 在这个例子中，Get-ChildItem 在 Windows 文件夹中搜索所有子文件夹。您可以将“C:\\Windows”改为您想测试的任意文件夹。 然后，该脚本读取每个文件夹的安全描述符并查看是否有 isInherited 属性被设为 $false 的存取控制记录。 如果结果为真，该文件夹会汇报给您。","text":"适用于 PowerShell 所有版本 通常，文件系统的 NTFS 权限是继承的。然而，您可以显式地为文件和文件夹添加权限。 您可以使用这段示例代码查找何处禁用了继承以及何处添加了权限项目： Get-ChildItem c:\\Windows -Recurse -Directory -ErrorAction SilentlyContinue | Where-Object { (Get-Acl -Path $_.FullName -ErrorAction SilentlyContinue).Access | Where-Object { $_.isInherited -eq $false } } 在这个例子中，Get-ChildItem 在 Windows 文件夹中搜索所有子文件夹。您可以将“C:\\Windows”改为您想测试的任意文件夹。 然后，该脚本读取每个文件夹的安全描述符并查看是否有 isInherited 属性被设为 $false 的存取控制记录。 如果结果为真，该文件夹会汇报给您。 本文国际来源：Finding Explicit Permissions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 不通过 ProgID 操作 COM 对象","slug":"accessing-com-objects-without-progid","date":"2015-01-02T04:00:00.000Z","updated":"2017-03-17T15:26:24.876Z","comments":true,"path":"2015/01/02/accessing-com-objects-without-progid/","link":"","permalink":"http://blog.vichamp.com/2015/01/02/accessing-com-objects-without-progid/","excerpt":"适用于 PowerShell 所有版本 通常在操作 COM 对象时，它们需要将自身在注册表中注册，并且 PowerShell 需要注册的 ProgID 字符串来加载对象。 以下是一个例子： $object = New-Object -ComObject Scripting.FileSystemObject $object.Drives 若不使用 New-Object 命令，您也可以用 .NET 方法来实现相同的目的： $type = [Type]::GetTypeFromProgID(&apos;Scripting.FileSystemObject&apos;) $object = [Activator]::CreateInstance($type) $object.Drives 采用后一种方法，您甚至可以实例化一个未暴露 ProgID 的 COM 对象。您所需的只是 GUID： $clsid = New-Object Guid &apos;0D43FE01-F093-11CF-8940-00A0C9054228&apos; $type = [Type]::GetTypeFromCLSID($clsid) $object = [Activator]::CreateInstance($type) $object.Drives","text":"适用于 PowerShell 所有版本 通常在操作 COM 对象时，它们需要将自身在注册表中注册，并且 PowerShell 需要注册的 ProgID 字符串来加载对象。 以下是一个例子： $object = New-Object -ComObject Scripting.FileSystemObject $object.Drives 若不使用 New-Object 命令，您也可以用 .NET 方法来实现相同的目的： $type = [Type]::GetTypeFromProgID(&apos;Scripting.FileSystemObject&apos;) $object = [Activator]::CreateInstance($type) $object.Drives 采用后一种方法，您甚至可以实例化一个未暴露 ProgID 的 COM 对象。您所需的只是 GUID： $clsid = New-Object Guid &apos;0D43FE01-F093-11CF-8940-00A0C9054228&apos; $type = [Type]::GetTypeFromCLSID($clsid) $object = [Activator]::CreateInstance($type) $object.Drives 本文国际来源：Accessing COM Objects without ProgID","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 处理隐藏文件","slug":"dealing-with-hidden-files","date":"2015-01-01T04:00:00.000Z","updated":"2017-03-17T15:26:24.876Z","comments":true,"path":"2015/01/01/dealing-with-hidden-files/","link":"","permalink":"http://blog.vichamp.com/2015/01/01/dealing-with-hidden-files/","excerpt":"适用于 PowerShell 3.0 及更高版本 当您使用 Get-ChildItem 来列出文件时，缺省情况下不包含隐藏文件。 要包含隐藏文件，请使用 -Force 参数： PS&gt; Get-ChildItem -Path $home -Force 要只列出隐藏文件，请使用 -Hidden 参数。这个参数是在 PowerShell 3.0 引入的： PS&gt; Get-ChildItem -Path $home -Hidden Directory: C:\\Users\\Tobias Mode LastWriteTime Length Name ---- ------------- ------ ---- d--h- 08.01.2012 10:38 AppData d--hs 08.01.2012 10:38 Application Data d--hs 08.01.2012 10:38 Cookies d--hs 08.01.2012 10:38 Local Settings d--hs 08.01.2012 10:38 My Documents d--hs 08.01.2012 10:38 NetHood (...)","text":"适用于 PowerShell 3.0 及更高版本 当您使用 Get-ChildItem 来列出文件时，缺省情况下不包含隐藏文件。 要包含隐藏文件，请使用 -Force 参数： PS&gt; Get-ChildItem -Path $home -Force 要只列出隐藏文件，请使用 -Hidden 参数。这个参数是在 PowerShell 3.0 引入的： PS&gt; Get-ChildItem -Path $home -Hidden Directory: C:\\Users\\Tobias Mode LastWriteTime Length Name ---- ------------- ------ ---- d--h- 08.01.2012 10:38 AppData d--hs 08.01.2012 10:38 Application Data d--hs 08.01.2012 10:38 Cookies d--hs 08.01.2012 10:38 Local Settings d--hs 08.01.2012 10:38 My Documents d--hs 08.01.2012 10:38 NetHood (...) 本文国际来源：Dealing with Hidden Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 改变 GPO 描述/备注","slug":"changing-gpo-description-comment","date":"2014-12-31T04:00:00.000Z","updated":"2017-03-17T15:26:24.876Z","comments":true,"path":"2014/12/31/changing-gpo-description-comment/","link":"","permalink":"http://blog.vichamp.com/2014/12/31/changing-gpo-description-comment/","excerpt":"需要 GroupPolicy 模块 当您创建了一个新的组策略，您可以设置一个备注（或描述）。然而，没有一种明显的办法来修改这个备注值。 以下这段代码用于获取一个组策略，然后读取并/或修改它的描述。请确保您将“PolicyName”的名称修改为在您环境中实际存在的一个组策略名： Import-Module -Name GroupPolicy $policy = Get-Gpo -Name &apos;PolicyName&apos; $policy.Description $policy.Description = &apos;New Description&apos; 请注意只有当您重新打开了组策略客户端工具时，修改的内容才会反映到 UI 中。还请注意您需要 GroupPolicy PowerShell 模块。它随 Microsoft 的 RSAT 工具免费发布。在客户端，GroupPolicy 模块需要在控制面板/程序中启用才可以使用。","text":"需要 GroupPolicy 模块 当您创建了一个新的组策略，您可以设置一个备注（或描述）。然而，没有一种明显的办法来修改这个备注值。 以下这段代码用于获取一个组策略，然后读取并/或修改它的描述。请确保您将“PolicyName”的名称修改为在您环境中实际存在的一个组策略名： Import-Module -Name GroupPolicy $policy = Get-Gpo -Name &apos;PolicyName&apos; $policy.Description $policy.Description = &apos;New Description&apos; 请注意只有当您重新打开了组策略客户端工具时，修改的内容才会反映到 UI 中。还请注意您需要 GroupPolicy PowerShell 模块。它随 Microsoft 的 RSAT 工具免费发布。在客户端，GroupPolicy 模块需要在控制面板/程序中启用才可以使用。 本文国际来源：Changing GPO Description/Comment","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检查 PowerShell 安全性","slug":"checking-powershell-security","date":"2014-12-30T04:00:00.000Z","updated":"2017-03-17T15:26:24.874Z","comments":true,"path":"2014/12/30/checking-powershell-security/","link":"","permalink":"http://blog.vichamp.com/2014/12/30/checking-powershell-security/","excerpt":"适用于 PowerShell 2.0 及以上版本 这段代码在指定的驱动器里查找所有 PowerShell 脚本，然后检查这些脚本是否有合法的数字签名，并汇报哪些脚本没有签名，或签名非法： Get-ChildItem C:\\ -Filter *.ps1 -Recurse | Where-Object { $_.Extension -eq &apos;.ps1&apos; } | Get-AuthenticodeSignature | Where-Object { $_.Status -ne &apos;Valid&apos; } “好吧”，也许您会辩论，“可是我们没有签名证书或 PKI”。这不是问题。数字签名只和信任有关。所以即便是用免费的自签名证书也可以信任。您只需要声明信任谁即可。 相对于依赖需要昂贵的官方代码签名的 Windows “根证书认证”，在您的内部安全审计中，您可以使用类似这样的自制方案： $whitelist = @(&apos;D3037720F7E5CF2A9DBA855B65D98C2FE1387AD9&apos;, &apos;6262A18EC19996DD521F7BDEAA0E079544B84241&apos;) Get-ChildItem y:\\Advanced -Filter *.ps1 -Recurse | Where-Object { $_.Extension -eq &apos;.ps1&apos; } | Get-AuthenticodeSignature | Select-Object -ExpandProperty SignerCertificate | Where-Object { $whitelist -notcontains $_.Thumbprint -or $_.Status -eq &apos;HashMismatch&apos; } 只需要将任何您信任的证书的唯一的证书指纹添加到白名单中。该证书是否是自签名的并不重要。白名单是最重要的，并且它是您私人的“吊销列表”：如果您不再信任某个证书，或某个证书丢失了，只需要将它的指纹从您的白名单中移除即可。 生成的报告包括所有未使用您的白名单中的证书合法地签名的脚本。如果某个脚本使用白名单中的一个证书签过名，但是后来改变过，它也会出现在报告中。","text":"适用于 PowerShell 2.0 及以上版本 这段代码在指定的驱动器里查找所有 PowerShell 脚本，然后检查这些脚本是否有合法的数字签名，并汇报哪些脚本没有签名，或签名非法： Get-ChildItem C:\\ -Filter *.ps1 -Recurse | Where-Object { $_.Extension -eq &apos;.ps1&apos; } | Get-AuthenticodeSignature | Where-Object { $_.Status -ne &apos;Valid&apos; } “好吧”，也许您会辩论，“可是我们没有签名证书或 PKI”。这不是问题。数字签名只和信任有关。所以即便是用免费的自签名证书也可以信任。您只需要声明信任谁即可。 相对于依赖需要昂贵的官方代码签名的 Windows “根证书认证”，在您的内部安全审计中，您可以使用类似这样的自制方案： $whitelist = @(&apos;D3037720F7E5CF2A9DBA855B65D98C2FE1387AD9&apos;, &apos;6262A18EC19996DD521F7BDEAA0E079544B84241&apos;) Get-ChildItem y:\\Advanced -Filter *.ps1 -Recurse | Where-Object { $_.Extension -eq &apos;.ps1&apos; } | Get-AuthenticodeSignature | Select-Object -ExpandProperty SignerCertificate | Where-Object { $whitelist -notcontains $_.Thumbprint -or $_.Status -eq &apos;HashMismatch&apos; } 只需要将任何您信任的证书的唯一的证书指纹添加到白名单中。该证书是否是自签名的并不重要。白名单是最重要的，并且它是您私人的“吊销列表”：如果您不再信任某个证书，或某个证书丢失了，只需要将它的指纹从您的白名单中移除即可。 生成的报告包括所有未使用您的白名单中的证书合法地签名的脚本。如果某个脚本使用白名单中的一个证书签过名，但是后来改变过，它也会出现在报告中。 本文国际来源：Checking PowerShell Security","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 处理 %ERRORLEVEL%","slug":"dealing-with-errorlevel","date":"2014-12-29T04:00:00.000Z","updated":"2017-03-17T15:26:24.854Z","comments":true,"path":"2014/12/29/dealing-with-errorlevel/","link":"","permalink":"http://blog.vichamp.com/2014/12/29/dealing-with-errorlevel/","excerpt":"适用于 PowerShell 所有版本 当您在脚本里运行原生的 EXE 控制台命令，这些命令通常返回一个数字型的返回值。这个值被称为“ErrorLevel”。在批处理文件里，您可以通过 %ERRORLEVEL% 访问这个返回值。 让我们看看 PowerShell 如何获取和存放这个数字型返回值，以及一个 PowerShell 脚本如何返回自己的“ErrorLevel”——它将被 PowerShell 脚本的调用者接收到： ping 1.2.3.4 -n 1 -w 500 $result1 = $LASTEXITCODE ping 127.0.0.1 -n 1 -w 500 $result2 = $LASTEXITCODE $result1 $result2 if ($result1 -eq 0 -and $result2 -eq 0) { exit 0 } else { exit 1 } 在这个例子里，代码中 ping 了两个 IP 地址。第一个调用失败了，第二个调用成功了。该脚本将 $LASTEXITCODE 的返回值保存在两个变量里。 然后它计算出这些返回值的影响结果。在这个例子中，如果所有调用返回 0，PowerShell 脚本将 ErrorLevel 代码设置为 0，否则为 1。 当然，这只是一个简单的例子。您可以配合您自己的原生命令使用。只需要确保调用原生应用程序之后立刻保存 $LASTEXITCODE 值，因为它会被后续的调用覆盖。","text":"适用于 PowerShell 所有版本 当您在脚本里运行原生的 EXE 控制台命令，这些命令通常返回一个数字型的返回值。这个值被称为“ErrorLevel”。在批处理文件里，您可以通过 %ERRORLEVEL% 访问这个返回值。 让我们看看 PowerShell 如何获取和存放这个数字型返回值，以及一个 PowerShell 脚本如何返回自己的“ErrorLevel”——它将被 PowerShell 脚本的调用者接收到： ping 1.2.3.4 -n 1 -w 500 $result1 = $LASTEXITCODE ping 127.0.0.1 -n 1 -w 500 $result2 = $LASTEXITCODE $result1 $result2 if ($result1 -eq 0 -and $result2 -eq 0) { exit 0 } else { exit 1 } 在这个例子里，代码中 ping 了两个 IP 地址。第一个调用失败了，第二个调用成功了。该脚本将 $LASTEXITCODE 的返回值保存在两个变量里。 然后它计算出这些返回值的影响结果。在这个例子中，如果所有调用返回 0，PowerShell 脚本将 ErrorLevel 代码设置为 0，否则为 1。 当然，这只是一个简单的例子。您可以配合您自己的原生命令使用。只需要确保调用原生应用程序之后立刻保存 $LASTEXITCODE 值，因为它会被后续的调用覆盖。 本文国际来源：Dealing with %ERRORLEVEL%","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 压缩路径","slug":"compacting-paths","date":"2014-12-26T04:00:00.000Z","updated":"2017-03-17T15:26:24.839Z","comments":true,"path":"2014/12/26/compacting-paths/","link":"","permalink":"http://blog.vichamp.com/2014/12/26/compacting-paths/","excerpt":"适用于 PowerShell 2.0 及以上版本 有些时候报表中的路径名太长了。要缩短一个路径，您当然可以将字符串截断成指定的长度，但是这将导致路径丧失可读性。一个更好的办法是使用内置的 Windows API 函数来更智能地缩短路径。 以下例子也演示了如何在 PowerShell 脚本中使用 C# 代码： $newType = @&apos; using System; using System.Text; using System.Runtime.InteropServices; namespace WindowsAPILib { public class Helper { [DllImport(&quot;shlwapi.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)] internal static extern bool PathCompactPathEx(System.Text.StringBuilder pszOut, string pszSrc, Int32 cchMax, Int32 dwFlags); public static string CompactPath(string Path, int DesiredLength) { StringBuilder sb = new StringBuilder(260); if (PathCompactPathEx(sb, Path, DesiredLength + 1, 0)) { return sb.ToString(); } else { return Path; } } } } &apos;@ Add-Type -TypeDefinition $newType 当您执行了该代码，就创建了一个名为 WindowsAPILib 的新的 .NET 类型，从而得到一个新的名为 CompactPath 的新的静态方法。您现在可以这样的使用： PS&gt; $pshome C:\\Windows\\System32\\WindowsPowerShell\\v1.0 PS&gt; [WindowsAPILib.Helper]::CompactPath($pshome, 12) C:\\W...\\v1.0 PS&gt; [WindowsAPILib.Helper]::CompactPath($pshome, 18) C:\\Windows...\\v1.0 PS&gt; [WindowsAPILib.Helper]::CompactPath($pshome, 22) C:\\Windows\\Sys...\\v1.0","text":"适用于 PowerShell 2.0 及以上版本 有些时候报表中的路径名太长了。要缩短一个路径，您当然可以将字符串截断成指定的长度，但是这将导致路径丧失可读性。一个更好的办法是使用内置的 Windows API 函数来更智能地缩短路径。 以下例子也演示了如何在 PowerShell 脚本中使用 C# 代码： $newType = @&apos; using System; using System.Text; using System.Runtime.InteropServices; namespace WindowsAPILib { public class Helper { [DllImport(&quot;shlwapi.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)] internal static extern bool PathCompactPathEx(System.Text.StringBuilder pszOut, string pszSrc, Int32 cchMax, Int32 dwFlags); public static string CompactPath(string Path, int DesiredLength) { StringBuilder sb = new StringBuilder(260); if (PathCompactPathEx(sb, Path, DesiredLength + 1, 0)) { return sb.ToString(); } else { return Path; } } } } &apos;@ Add-Type -TypeDefinition $newType 当您执行了该代码，就创建了一个名为 WindowsAPILib 的新的 .NET 类型，从而得到一个新的名为 CompactPath 的新的静态方法。您现在可以这样的使用： PS&gt; $pshome C:\\Windows\\System32\\WindowsPowerShell\\v1.0 PS&gt; [WindowsAPILib.Helper]::CompactPath($pshome, 12) C:\\W...\\v1.0 PS&gt; [WindowsAPILib.Helper]::CompactPath($pshome, 18) C:\\Windows...\\v1.0 PS&gt; [WindowsAPILib.Helper]::CompactPath($pshome, 22) C:\\Windows\\Sys...\\v1.0 本文国际来源：Compacting Paths","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从 LDAP 路径获取 OU","slug":"get-the-ou-from-an-ldap-path","date":"2014-12-25T04:00:00.000Z","updated":"2017-03-17T15:26:24.839Z","comments":true,"path":"2014/12/25/get-the-ou-from-an-ldap-path/","link":"","permalink":"http://blog.vichamp.com/2014/12/25/get-the-ou-from-an-ldap-path/","excerpt":"适用于 PowerShell 所有版本 要从原始字符串从截取特定的部分，您常常需要使用一系列文本分割和取子串的命令。 例如，要从一个 LDAP 陆军中截取最后一个 OU 的名字，一下是一种办法： $dn = &apos;OU=Test,OU=People,CN=Testing,OU=Everyone,DC=Company,DC=com&apos; ($dn.Split(&apos;,&apos;) -like &apos;OU=*&apos; ).Substring(3)[0] 这段代码将返回该 LDAP 路径（LDAP 路径是从右往左读的，所以最后一个 OU 是字符串中的第一个 OU），而且稍作修改就可以读取其它部分。例如，将下标从 0 改为 -1 就可以读取路径中的第一个 OU。","text":"适用于 PowerShell 所有版本 要从原始字符串从截取特定的部分，您常常需要使用一系列文本分割和取子串的命令。 例如，要从一个 LDAP 陆军中截取最后一个 OU 的名字，一下是一种办法： $dn = &apos;OU=Test,OU=People,CN=Testing,OU=Everyone,DC=Company,DC=com&apos; ($dn.Split(&apos;,&apos;) -like &apos;OU=*&apos; ).Substring(3)[0] 这段代码将返回该 LDAP 路径（LDAP 路径是从右往左读的，所以最后一个 OU 是字符串中的第一个 OU），而且稍作修改就可以读取其它部分。例如，将下标从 0 改为 -1 就可以读取路径中的第一个 OU。 本文国际来源：Get the OU from an LDAP Path","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建一大堆测试文件","slug":"creating-huge-dummy-files","date":"2014-12-24T04:00:00.000Z","updated":"2017-03-17T15:26:24.839Z","comments":true,"path":"2014/12/24/creating-huge-dummy-files/","link":"","permalink":"http://blog.vichamp.com/2014/12/24/creating-huge-dummy-files/","excerpt":"适用于 PowerShell 所有版本 如果您需要对系统进行压力测试，或因为别的原因需要大量测试文件，以下是在瞬间创建大量文件（可以是大文件）的代码： $Path = &quot;$env:temp\\hugefile.txt&quot; $Size = 200MB $stream = New-Object System.IO.FileStream($Path, [System.IO.FileMode]::CreateNew) $stream.Seek($Size, [System.IO.SeekOrigin]::Begin) $stream.WriteByte(0) $Stream.Close() explorer.exe &quot;/select,$Path&quot;","text":"适用于 PowerShell 所有版本 如果您需要对系统进行压力测试，或因为别的原因需要大量测试文件，以下是在瞬间创建大量文件（可以是大文件）的代码： $Path = &quot;$env:temp\\hugefile.txt&quot; $Size = 200MB $stream = New-Object System.IO.FileStream($Path, [System.IO.FileMode]::CreateNew) $stream.Seek($Size, [System.IO.SeekOrigin]::Begin) $stream.WriteByte(0) $Stream.Close() explorer.exe &quot;/select,$Path&quot; 本文国际来源：Creating Huge Dummy Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 限制 String 的最大长度","slug":"limiting-maximum-string-length","date":"2014-12-23T04:00:00.000Z","updated":"2017-03-17T15:26:24.823Z","comments":true,"path":"2014/12/23/limiting-maximum-string-length/","link":"","permalink":"http://blog.vichamp.com/2014/12/23/limiting-maximum-string-length/","excerpt":"适用于 PowerShell 所有版本 要限制输出的文本不会过长，您可以使用类似这样的的逻辑来缩短超过指定长度的文本： if ($text.Length -gt $MaxLength) { $text.Substring(0,$MaxLength) + &apos;...&apos; } else { $text }","text":"适用于 PowerShell 所有版本 要限制输出的文本不会过长，您可以使用类似这样的的逻辑来缩短超过指定长度的文本： if ($text.Length -gt $MaxLength) { $text.Substring(0,$MaxLength) + &apos;...&apos; } else { $text } 本文国际来源：Limiting Maximum String Length","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 设置 AD 或 Windows 的权限","slug":"setting-permissions-in-ad-or-windows-registry","date":"2014-12-22T04:00:00.000Z","updated":"2017-03-17T15:26:24.823Z","comments":true,"path":"2014/12/22/setting-permissions-in-ad-or-windows-registry/","link":"","permalink":"http://blog.vichamp.com/2014/12/22/setting-permissions-in-ad-or-windows-registry/","excerpt":"需要 ActiveDirectory 模块 我们之前已经演示了如何用 Get/Set-Acl 来读写文件和文件夹的权限。 实际上这两个 cmdlet 可以处理所有合法的 PowerShell 路径。说以您可以同样地在 Windows 注册表中使用相同的方法来读取、克隆和写入属性。 这个例子从一个注册表键中读取已有的安全信息，并应用到另一个键上： # both Registry keys must exist $KeyToCopySecurityFrom = &apos;HKLM:\\Software\\Key1&apos; $KeyToCopySecurityTo = &apos;HKLM:\\Software\\Key1&apos; $securityDescriptor = Get-Acl -Path $KeyToCopySecurityFrom Set-Acl -Path $KeyToCopySecurityTo -AclObject $securityDescriptor 类似地，如果您从微软安装了 RSAT 工具并启用了 ActiveDirectory PowerShell 模块，您就可以使用它的 PowerShell 驱动器 AD: 来对 AD 对象做类似的操作，例如，从一个 OU 克隆委派权限到另一个 OU 上。 您现在可以根据需要读取、修改或重新应用如委派控制、防止意外删除等 Active Directory 特性。 Import-Module ActiveDirectory # both OUs must exist $OUtoCopyFrom = &apos;AD:\\OU=Employees,DC=TRAINING,DC=POWERSHELL&apos; $OUtoCopyTo = &apos;AD:\\OU=TestEmployees,DC=TRAINING,DC=POWERSHELL&apos; $securityDescriptor = Get-Acl -Path $OUtoCopyFrom Set-Acl -Path $OUtoCopyTo -AclObject $securityDescriptor 您现在可以对任何 AD 对象通过这种方式读取和写入安全信息，包括 DNS 信息。您所需要的只是知道您想读写的对象的 LDAP 路径。","text":"需要 ActiveDirectory 模块 我们之前已经演示了如何用 Get/Set-Acl 来读写文件和文件夹的权限。 实际上这两个 cmdlet 可以处理所有合法的 PowerShell 路径。说以您可以同样地在 Windows 注册表中使用相同的方法来读取、克隆和写入属性。 这个例子从一个注册表键中读取已有的安全信息，并应用到另一个键上： # both Registry keys must exist $KeyToCopySecurityFrom = &apos;HKLM:\\Software\\Key1&apos; $KeyToCopySecurityTo = &apos;HKLM:\\Software\\Key1&apos; $securityDescriptor = Get-Acl -Path $KeyToCopySecurityFrom Set-Acl -Path $KeyToCopySecurityTo -AclObject $securityDescriptor 类似地，如果您从微软安装了 RSAT 工具并启用了 ActiveDirectory PowerShell 模块，您就可以使用它的 PowerShell 驱动器 AD: 来对 AD 对象做类似的操作，例如，从一个 OU 克隆委派权限到另一个 OU 上。 您现在可以根据需要读取、修改或重新应用如委派控制、防止意外删除等 Active Directory 特性。 Import-Module ActiveDirectory # both OUs must exist $OUtoCopyFrom = &apos;AD:\\OU=Employees,DC=TRAINING,DC=POWERSHELL&apos; $OUtoCopyTo = &apos;AD:\\OU=TestEmployees,DC=TRAINING,DC=POWERSHELL&apos; $securityDescriptor = Get-Acl -Path $OUtoCopyFrom Set-Acl -Path $OUtoCopyTo -AclObject $securityDescriptor 您现在可以对任何 AD 对象通过这种方式读取和写入安全信息，包括 DNS 信息。您所需要的只是知道您想读写的对象的 LDAP 路径。 本文国际来源：Setting Permissions in AD or Windows Registry","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 捕获本地 EXE 的错误（第 2 部分）","slug":"catching-errors-in-native-exes-part-2","date":"2014-12-19T04:00:00.000Z","updated":"2017-03-17T15:26:24.823Z","comments":true,"path":"2014/12/19/catching-errors-in-native-exes-part-2/","link":"","permalink":"http://blog.vichamp.com/2014/12/19/catching-errors-in-native-exes-part-2/","excerpt":"适用于 PowerShell 所有版本 以下是检测控制台程序发出的错误的另一种方法： $ErrorActionPreference = &apos;Continue&apos; $result = net.exe user UserDoesNotExist 2&gt;&amp;1 # $? is $false when something went wrong if ($? -eq $false) { # read last error: $errMsg = $result.Exception.Message -join &apos;,&apos; Write-Host &quot;Something went wrong: $errMsg&quot; } else { Write-Host &apos;All is fine.&apos; } 请注意 $ErrorActionPreference 的用法：当它设置为‘Stop’时，错误将被转换为一个 .NET 异常。$ErrorActionPreference 的缺省设置是‘Continue’。通过这个设置，脚本可以通过 $err 获得错误信息。 如果最后一次调用失败了，内置的 $? 变量将会返回 $false。在这种情况下，代码将会返回一条错误信息（或者做其它事情，例如写日志文件）。","text":"适用于 PowerShell 所有版本 以下是检测控制台程序发出的错误的另一种方法： $ErrorActionPreference = &apos;Continue&apos; $result = net.exe user UserDoesNotExist 2&gt;&amp;1 # $? is $false when something went wrong if ($? -eq $false) { # read last error: $errMsg = $result.Exception.Message -join &apos;,&apos; Write-Host &quot;Something went wrong: $errMsg&quot; } else { Write-Host &apos;All is fine.&apos; } 请注意 $ErrorActionPreference 的用法：当它设置为‘Stop’时，错误将被转换为一个 .NET 异常。$ErrorActionPreference 的缺省设置是‘Continue’。通过这个设置，脚本可以通过 $err 获得错误信息。 如果最后一次调用失败了，内置的 $? 变量将会返回 $false。在这种情况下，代码将会返回一条错误信息（或者做其它事情，例如写日志文件）。 本文国际来源：Catching Errors in Native EXEs (Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 SDDL 替换 NTFS 权限","slug":"replacing-ntfs-permissions-with-sddl-information","date":"2014-12-18T04:00:00.000Z","updated":"2017-03-17T15:26:24.807Z","comments":true,"path":"2014/12/18/replacing-ntfs-permissions-with-sddl-information/","link":"","permalink":"http://blog.vichamp.com/2014/12/18/replacing-ntfs-permissions-with-sddl-information/","excerpt":"适用于 PowerShell 所有版本 您可以通过 Get-Acl 命令将文件和文件夹的安全信息导出成 SDDL 格式（安全描述定义语言）的纯文本文件： $FolderToRead = &apos;C:\\folder1&apos; $securityDescriptor = Get-Acl -Path $FolderToRead $securityDescriptor.GetSecurityDescriptorSddlForm(&apos;All&apos;) 您可以将 SDDL 通过管道输出到剪贴板，然后将它粘贴到另一个脚本中： $FolderToRead = &apos;C:\\folder1&apos; $securityDescriptor = Get-Acl -Path $FolderToRead $securityDescriptor.GetSecurityDescriptorSddlForm(&apos;All&apos;) | clip.exe 类似这样将 SDDL 加入脚本中，例如（请注意 SDDL 总是只有一行，所以请不要添加换行符）： $sddl = &apos;O:S-1-5-21-2649034417-1209187175-3910605729-1000G:S-1-5-21-2649034417-1209187175-3910605729-513D:(A;ID;FA;;;BA)(A;OICIIOID;GA;;;BA)(A;ID;FA;;;SY)(A;OICIIOID;GA;;;SY)(A;OICIID;0x1200a9;;;BU)(A;ID;0x1301bf;;;AU)(A;OICIIOID;SDGXGWGR;;;AU)&apos; $FolderToConfigure = &apos;C:\\folder2&apos; $securityDescriptor = Get-Acl -Path $FolderToConfigure $securityDescriptor.SetSecurityDescriptorSddlForm($sddl) Set-Acl -Path $FolderToConfigure -AclObject $securityDescriptor 将 SDDL 插入脚本之后，您就不再需要生成 SDDL 用的模板文件夹了。您可以将安全信息应用到其它文件系统对象中，例如设置基本 NTFS 权限，或先编辑 SDDL 再应用它。 为您提供一些启示，在域迁移的场景中，您可以比如创建一个转换表，用于将旧的 SID 转换为新的 SID。然后，将旧的 SID 替换成新的 SID，然后将记录下的安全信息克隆到一个新的（或测试的）域中。","text":"适用于 PowerShell 所有版本 您可以通过 Get-Acl 命令将文件和文件夹的安全信息导出成 SDDL 格式（安全描述定义语言）的纯文本文件： $FolderToRead = &apos;C:\\folder1&apos; $securityDescriptor = Get-Acl -Path $FolderToRead $securityDescriptor.GetSecurityDescriptorSddlForm(&apos;All&apos;) 您可以将 SDDL 通过管道输出到剪贴板，然后将它粘贴到另一个脚本中： $FolderToRead = &apos;C:\\folder1&apos; $securityDescriptor = Get-Acl -Path $FolderToRead $securityDescriptor.GetSecurityDescriptorSddlForm(&apos;All&apos;) | clip.exe 类似这样将 SDDL 加入脚本中，例如（请注意 SDDL 总是只有一行，所以请不要添加换行符）： $sddl = &apos;O:S-1-5-21-2649034417-1209187175-3910605729-1000G:S-1-5-21-2649034417-1209187175-3910605729-513D:(A;ID;FA;;;BA)(A;OICIIOID;GA;;;BA)(A;ID;FA;;;SY)(A;OICIIOID;GA;;;SY)(A;OICIID;0x1200a9;;;BU)(A;ID;0x1301bf;;;AU)(A;OICIIOID;SDGXGWGR;;;AU)&apos; $FolderToConfigure = &apos;C:\\folder2&apos; $securityDescriptor = Get-Acl -Path $FolderToConfigure $securityDescriptor.SetSecurityDescriptorSddlForm($sddl) Set-Acl -Path $FolderToConfigure -AclObject $securityDescriptor 将 SDDL 插入脚本之后，您就不再需要生成 SDDL 用的模板文件夹了。您可以将安全信息应用到其它文件系统对象中，例如设置基本 NTFS 权限，或先编辑 SDDL 再应用它。 为您提供一些启示，在域迁移的场景中，您可以比如创建一个转换表，用于将旧的 SID 转换为新的 SID。然后，将旧的 SID 替换成新的 SID，然后将记录下的安全信息克隆到一个新的（或测试的）域中。 本文国际来源：Replacing NTFS Permissions with SDDL Information","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 克隆 NTFS 权限","slug":"cloning-ntfs-permissions","date":"2014-12-17T04:00:00.000Z","updated":"2017-03-17T15:26:24.792Z","comments":true,"path":"2014/12/17/cloning-ntfs-permissions/","link":"","permalink":"http://blog.vichamp.com/2014/12/17/cloning-ntfs-permissions/","excerpt":"适用于 PowerShell 所有版本 以下代码从一个文件夹读取 NTFS 权限并将该设置应用到另外一个文件夹上。请注意两个文件夹都必须存在： $FolderToCopyFrom = &apos;C:\\folder1&apos; $FolderToCopyTo = &apos;C:\\folder2&apos; $securityDescriptor = Get-Acl -Path $FolderToCopyFrom Set-Acl -Path $FolderToCopyTo -AclObject $securityDescriptor 复制安全描述符操作可能需要管理员权限。请注意第二个文件夹的所有安全规则都会被第一个文件夹的安全信息覆盖。","text":"适用于 PowerShell 所有版本 以下代码从一个文件夹读取 NTFS 权限并将该设置应用到另外一个文件夹上。请注意两个文件夹都必须存在： $FolderToCopyFrom = &apos;C:\\folder1&apos; $FolderToCopyTo = &apos;C:\\folder2&apos; $securityDescriptor = Get-Acl -Path $FolderToCopyFrom Set-Acl -Path $FolderToCopyTo -AclObject $securityDescriptor 复制安全描述符操作可能需要管理员权限。请注意第二个文件夹的所有安全规则都会被第一个文件夹的安全信息覆盖。 本文国际来源：Cloning NTFS Permissions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 捕获本地 EXE 的错误（第 1 部分）","slug":"catching-errors-in-native-exes-part-1","date":"2014-12-16T04:00:00.000Z","updated":"2017-03-17T15:26:24.792Z","comments":true,"path":"2014/12/16/catching-errors-in-native-exes-part-1/","link":"","permalink":"http://blog.vichamp.com/2014/12/16/catching-errors-in-native-exes-part-1/","excerpt":"适用于 PowerShell 所有版本 当您运行本地控制台命令，例如 robocopy.exe、ipconfig.exe 或类似的命令时，您可以处理这些命令中抛出的错误： try { $current = $ErrorActionPreference $ErrorActionPreference = &apos;Stop&apos; # this will cause an EXE command to emit an error # (replace with any console-based EXE command) net.exe user nonexistentUser 2&gt;&amp;1 $ErrorActionPreference = $current } catch { Write-Host (&apos;Error occured: &apos; + $_.Exception.Message) } 要捕获错误，您需要临时将 $ErrorActionPreference 设为“Stop”。另外，您需要用“2&gt;&amp;1”将错误信息重定向到输出控制台。 这么做完之后，例如 .NET 错误等错误就可以被 PowerShell 处理了。","text":"适用于 PowerShell 所有版本 当您运行本地控制台命令，例如 robocopy.exe、ipconfig.exe 或类似的命令时，您可以处理这些命令中抛出的错误： try { $current = $ErrorActionPreference $ErrorActionPreference = &apos;Stop&apos; # this will cause an EXE command to emit an error # (replace with any console-based EXE command) net.exe user nonexistentUser 2&gt;&amp;1 $ErrorActionPreference = $current } catch { Write-Host (&apos;Error occured: &apos; + $_.Exception.Message) } 要捕获错误，您需要临时将 $ErrorActionPreference 设为“Stop”。另外，您需要用“2&gt;&amp;1”将错误信息重定向到输出控制台。 这么做完之后，例如 .NET 错误等错误就可以被 PowerShell 处理了。 本文国际来源：Catching Errors in Native EXEs (Part 1)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 WMI 继承","slug":"using-wmi-inheritance","date":"2014-12-15T04:00:00.000Z","updated":"2017-03-17T15:26:24.792Z","comments":true,"path":"2014/12/15/using-wmi-inheritance/","link":"","permalink":"http://blog.vichamp.com/2014/12/15/using-wmi-inheritance/","excerpt":"适用于 PowerShell 所有版本 WMI 类是彼此继承的，我们可以利用这个特性。例如这行代码： PS&gt; Get-WmiObject -Class Win32_Printer 它将返回通过 WMI 获取到的所有打印机。打印机是从更多的通用类继承的，这段代码可以显示继承树： PS&gt; Get-WmiObject -Class Win32_Printer | Select-Object -ExpandProperty __derivation -First 1 CIM_Printer CIM_LogicalDevice CIM_LogicalElement CIM_ManagedSystemElement 所以如果您不只是对打印机感兴趣，而是对更多的硬件感兴趣，那么选择更通用的父类，例如 CIM_LogicalDevice。这行代码可以获取所有的硬件清单： PS&gt; Get-WmiObject -Class CIM_LogicalDevice Manufacturer Name Status StatusInfo ------------ ---- ------ ---------- Realtek Realtek High Def... OK 3 Kona OK Intel Corporation Intel(R) 8 Serie... OK Intel Corporation Intel(R) Wireles... Microsoft Microsoft Kernel... ASIX AX88772B US... Microsoft Virtueller Micro... Microsoft Bluetooth-Gerät ... Microsoft Microsoft-ISATAP... Microsoft-ISATAP... Microsoft Teredo Tunneling... Microsoft Von Microsoft ge... Microsoft-ISATAP... Microsoft-ISATAP... Microsoft-ISATAP... Microsoft-ISATAP... ASIX AX88772B US... Microsoft-ISATAP... Microsoft-ISATAP... Virtueller Micro... Microsoft-ISATAP... Microsoft-ISATAP... Microsoft-ISATAP... -Virtual Battery 0- CRB Battery 0 (...) 这段代码将返回有关的类，这样的您就可以清晰地看到 WMI 如何调用您的硬件类型： PS&gt; Get-WmiObject -Class CIM_LogicalDevice | Group-Object -Property __Class -NoElement Count Name ----- ---- 1 Win32_SoundDevice 1 Win32_Battery 1 Win32_IDEController 20 Win32_NetworkAdapter 1 Win32_PortableBattery 10 Win32_Printer 1 Win32_Processor 2 Win32_DiskDrive 7 Win32_DiskPartition 1 Win32_Fan 2 Win32_Keyboard 5 Win32_LogicalDisk 2 Win32_MappedLogicalDisk 1 Win32_MemoryArray 2 Win32_MemoryDevice 2 Win32_PointingDevice 1 Win32_SCSIController 2 Win32_USBController 6 Win32_USBHub 5 Win32_Volume 4 Win32_CacheMemory 1 Win32_DesktopMonitor 1 Win32_VideoController 1 Win32_VoltageProbe 1 Win32_MotherboardDevice 8 Win32_Bus 134 Win32_PnPEntity It basically takes all the instances derived from CIM_LogicalDevice and groups them by “Class” which is their real class name.它基本上获取从 CIM_LogicalDevice 继承的所有实例并按照“`Class`”分组。这是它们的真实类名。","text":"适用于 PowerShell 所有版本 WMI 类是彼此继承的，我们可以利用这个特性。例如这行代码： PS&gt; Get-WmiObject -Class Win32_Printer 它将返回通过 WMI 获取到的所有打印机。打印机是从更多的通用类继承的，这段代码可以显示继承树： PS&gt; Get-WmiObject -Class Win32_Printer | Select-Object -ExpandProperty __derivation -First 1 CIM_Printer CIM_LogicalDevice CIM_LogicalElement CIM_ManagedSystemElement 所以如果您不只是对打印机感兴趣，而是对更多的硬件感兴趣，那么选择更通用的父类，例如 CIM_LogicalDevice。这行代码可以获取所有的硬件清单： PS&gt; Get-WmiObject -Class CIM_LogicalDevice Manufacturer Name Status StatusInfo ------------ ---- ------ ---------- Realtek Realtek High Def... OK 3 Kona OK Intel Corporation Intel(R) 8 Serie... OK Intel Corporation Intel(R) Wireles... Microsoft Microsoft Kernel... ASIX AX88772B US... Microsoft Virtueller Micro... Microsoft Bluetooth-Gerät ... Microsoft Microsoft-ISATAP... Microsoft-ISATAP... Microsoft Teredo Tunneling... Microsoft Von Microsoft ge... Microsoft-ISATAP... Microsoft-ISATAP... Microsoft-ISATAP... Microsoft-ISATAP... ASIX AX88772B US... Microsoft-ISATAP... Microsoft-ISATAP... Virtueller Micro... Microsoft-ISATAP... Microsoft-ISATAP... Microsoft-ISATAP... -Virtual Battery 0- CRB Battery 0 (...) 这段代码将返回有关的类，这样的您就可以清晰地看到 WMI 如何调用您的硬件类型： PS&gt; Get-WmiObject -Class CIM_LogicalDevice | Group-Object -Property __Class -NoElement Count Name ----- ---- 1 Win32_SoundDevice 1 Win32_Battery 1 Win32_IDEController 20 Win32_NetworkAdapter 1 Win32_PortableBattery 10 Win32_Printer 1 Win32_Processor 2 Win32_DiskDrive 7 Win32_DiskPartition 1 Win32_Fan 2 Win32_Keyboard 5 Win32_LogicalDisk 2 Win32_MappedLogicalDisk 1 Win32_MemoryArray 2 Win32_MemoryDevice 2 Win32_PointingDevice 1 Win32_SCSIController 2 Win32_USBController 6 Win32_USBHub 5 Win32_Volume 4 Win32_CacheMemory 1 Win32_DesktopMonitor 1 Win32_VideoController 1 Win32_VoltageProbe 1 Win32_MotherboardDevice 8 Win32_Bus 134 Win32_PnPEntity It basically takes all the instances derived from CIM_LogicalDevice and groups them by “Class” which is their real class name.它基本上获取从 CIM_LogicalDevice 继承的所有实例并按照“`Class`”分组。这是它们的真实类名。 本文国际来源：Using WMI Inheritance","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取系统启动时间","slug":"gettingsystemuptime","date":"2014-12-12T04:00:00.000Z","updated":"2017-03-17T15:26:24.776Z","comments":true,"path":"2014/12/12/gettingsystemuptime/","link":"","permalink":"http://blog.vichamp.com/2014/12/12/gettingsystemuptime/","excerpt":"适用于 PowerShell 所有版本 这个简单的函数可以返回当前系统的启动时间： function Get-Uptime { $millisec = [Environment]::TickCount [Timespan]::FromMilliseconds($millisec) }","text":"适用于 PowerShell 所有版本 这个简单的函数可以返回当前系统的启动时间： function Get-Uptime { $millisec = [Environment]::TickCount [Timespan]::FromMilliseconds($millisec) } 本文国际来源：Getting System Uptime","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找进程所有者","slug":"finding-process-owners","date":"2014-12-11T04:00:00.000Z","updated":"2017-03-17T15:26:24.776Z","comments":true,"path":"2014/12/11/finding-process-owners/","link":"","permalink":"http://blog.vichamp.com/2014/12/11/finding-process-owners/","excerpt":"适用于 PowerShell 所有版本 要查看某个进程的所有者以及有多少个实例在运行，请试试以下这段代码： $ProcessName = &apos;explorer.exe&apos; (Get-WmiObject -Query &quot;select * from Win32_Process where name=&apos;$ProcessName&apos;&quot;).GetOwner().User 请注意：有许多办法能够查看当前登录的用户，并且根据您使用环境的不同，这里展示的方法可能有一定的局限性。它假设当前用户使用图形界面登录。由于在 server core 的机器上，只能运行非图形界面的进程，所以该脚本在该情况下不能检测连接到主机的用户名。 这个例子返回这台机器上所有“explorer.exe”进程的所有者。如果您有管理员权限并且远程进行此操作，那么该用户列表将类似已交互式登录的用户，因为每个桌面用户都创建了一个 explorer 进程。 当加入一个 Sort-Object 命令之后，您就可以轻松地排除重复项： $ProcessName = &apos;explorer.exe&apos; (Get-WmiObject –Query &quot;select * from Win32_Process where name=&apos;$ProcessName&apos;&quot;).GetOwner().User | Sort-Object -Unique 如果改变进程名，您会发现其它有趣的东西。这段代码将列出当前通过 PowerShell 远程操作访问您机器的所有用户： $ProcessName = &apos;wsmprovhost.exe&apos; try { (Get-WmiObject -Query &quot;select * from Win32_Process where name=&apos;$ProcessName&apos;&quot;).GetOwner().User | Sort-Object -Unique } catch { Write-Warning &quot;No user found.&quot; }","text":"适用于 PowerShell 所有版本 要查看某个进程的所有者以及有多少个实例在运行，请试试以下这段代码： $ProcessName = &apos;explorer.exe&apos; (Get-WmiObject -Query &quot;select * from Win32_Process where name=&apos;$ProcessName&apos;&quot;).GetOwner().User 请注意：有许多办法能够查看当前登录的用户，并且根据您使用环境的不同，这里展示的方法可能有一定的局限性。它假设当前用户使用图形界面登录。由于在 server core 的机器上，只能运行非图形界面的进程，所以该脚本在该情况下不能检测连接到主机的用户名。 这个例子返回这台机器上所有“explorer.exe”进程的所有者。如果您有管理员权限并且远程进行此操作，那么该用户列表将类似已交互式登录的用户，因为每个桌面用户都创建了一个 explorer 进程。 当加入一个 Sort-Object 命令之后，您就可以轻松地排除重复项： $ProcessName = &apos;explorer.exe&apos; (Get-WmiObject –Query &quot;select * from Win32_Process where name=&apos;$ProcessName&apos;&quot;).GetOwner().User | Sort-Object -Unique 如果改变进程名，您会发现其它有趣的东西。这段代码将列出当前通过 PowerShell 远程操作访问您机器的所有用户： $ProcessName = &apos;wsmprovhost.exe&apos; try { (Get-WmiObject -Query &quot;select * from Win32_Process where name=&apos;$ProcessName&apos;&quot;).GetOwner().User | Sort-Object -Unique } catch { Write-Warning &quot;No user found.&quot; } 本文国际来源：Finding Process Owners","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 解析 DISM 日志文件","slug":"parsing-dism-log-file","date":"2014-12-10T04:00:00.000Z","updated":"2017-03-17T15:26:24.776Z","comments":true,"path":"2014/12/10/parsing-dism-log-file/","link":"","permalink":"http://blog.vichamp.com/2014/12/10/parsing-dism-log-file/","excerpt":"适用于 PowerShell 2.0 及更高版本 在您的 Windows 文件夹中，您会见到各种系统日志文件。其中一种是 DISM 日志文件，它包含了 Windows 的配置信息（特性状态等）。 以下是一个简单的实践，演示如何解析这类日志文件并得到可用 PowerShell cmdlet 操作的富对象： $path = &quot;$env:windir\\logs\\dism\\dism.log&quot; Get-Content -Path $path | ForEach-Object { $_ -replace &apos;\\s{2,}&apos;, &apos;,&apos; } | ConvertFrom-Csv -Header (1..20) | ForEach-Object { $array = @() $array += $_.1 -split &apos; &apos; $array += $_.2 $array += $_.3 $array += $_.4 $array += $_.5 $array -join &apos;,&apos; } | ConvertFrom-Csv -Header (1..20) | Out-GridView","text":"适用于 PowerShell 2.0 及更高版本 在您的 Windows 文件夹中，您会见到各种系统日志文件。其中一种是 DISM 日志文件，它包含了 Windows 的配置信息（特性状态等）。 以下是一个简单的实践，演示如何解析这类日志文件并得到可用 PowerShell cmdlet 操作的富对象： $path = &quot;$env:windir\\logs\\dism\\dism.log&quot; Get-Content -Path $path | ForEach-Object { $_ -replace &apos;\\s{2,}&apos;, &apos;,&apos; } | ConvertFrom-Csv -Header (1..20) | ForEach-Object { $array = @() $array += $_.1 -split &apos; &apos; $array += $_.2 $array += $_.3 $array += $_.4 $array += $_.5 $array -join &apos;,&apos; } | ConvertFrom-Csv -Header (1..20) | Out-GridView 本文国际来源：Parsing DISM Log File","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 设置 Active Directory 属性","slug":"setting-active-directory-attributes","date":"2014-12-09T04:00:00.000Z","updated":"2017-03-17T15:26:24.776Z","comments":true,"path":"2014/12/09/setting-active-directory-attributes/","link":"","permalink":"http://blog.vichamp.com/2014/12/09/setting-active-directory-attributes/","excerpt":"需要 ActiveDirectory 模块 PowerShell 用哈希表来设置一个用户账户的 AD 属性这是一种多功能的指定任意键值对的方法。 这个简单的例子将设置用户“testuser”的“l”和“mail”属性。您可以向哈希表加入任意多的键值对，假设在您的 AD schema 中不存在该属性名，并且指定的数据类型是合法的： $infos = @{} $infos.l = &apos;Bahamas&apos; $infos.mail = &apos;sunny@offshore.com&apos; Set-ADUser -Identity testuser -Replace $infos","text":"需要 ActiveDirectory 模块 PowerShell 用哈希表来设置一个用户账户的 AD 属性这是一种多功能的指定任意键值对的方法。 这个简单的例子将设置用户“testuser”的“l”和“mail”属性。您可以向哈希表加入任意多的键值对，假设在您的 AD schema 中不存在该属性名，并且指定的数据类型是合法的： $infos = @{} $infos.l = &apos;Bahamas&apos; $infos.mail = &apos;sunny@offshore.com&apos; Set-ADUser -Identity testuser -Replace $infos 本文国际来源：Setting Active Directory Attributes","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 根据 Excel 表批量创建 AD 用户","slug":"bulk-creating-ad-users-from-excel-sheets","date":"2014-12-08T04:00:00.000Z","updated":"2017-03-17T15:26:24.754Z","comments":true,"path":"2014/12/08/bulk-creating-ad-users-from-excel-sheets/","link":"","permalink":"http://blog.vichamp.com/2014/12/08/bulk-creating-ad-users-from-excel-sheets/","excerpt":"需要 ActiveDirectory Module 为了创建大量新的 Active Directory 用户，您可以从 CSV 文件中导入用户信息，这个 CSV 可以由 Excel 表导出。 下一步，这段代码将会把 CSV 数据转为真实的 Active Directory 用户账户。 Import-Csv -Path F:\\userlist.csv -UseCulture -Encoding Default | ForEach-Object { $_.AccountPassword = $_.AccountPassword | ConvertTo-SecureString -Force -AsPlainText $_ } | New-ADUser -WhatIf CSV 文件所需的只是 New-ADUser 所需要的参数作为列名。一个详尽的列表可能包含以下列名：Name、SamAccountName、Description、Company、City、Path、AccountPassword。 请注意 CSV 文件天生只能包含字符串数据类型。由于 AccountPassword 属性需要一个 SecureString 数据类型的值，所以 PowerShell 代码将从 CSV 文件中读取字符串转换为 SecureString 之后再传递给 New-ADUser。 这个技术可以用于创建用户前预处理任何原始数据。","text":"需要 ActiveDirectory Module 为了创建大量新的 Active Directory 用户，您可以从 CSV 文件中导入用户信息，这个 CSV 可以由 Excel 表导出。 下一步，这段代码将会把 CSV 数据转为真实的 Active Directory 用户账户。 Import-Csv -Path F:\\userlist.csv -UseCulture -Encoding Default | ForEach-Object { $_.AccountPassword = $_.AccountPassword | ConvertTo-SecureString -Force -AsPlainText $_ } | New-ADUser -WhatIf CSV 文件所需的只是 New-ADUser 所需要的参数作为列名。一个详尽的列表可能包含以下列名：Name、SamAccountName、Description、Company、City、Path、AccountPassword。 请注意 CSV 文件天生只能包含字符串数据类型。由于 AccountPassword 属性需要一个 SecureString 数据类型的值，所以 PowerShell 代码将从 CSV 文件中读取字符串转换为 SecureString 之后再传递给 New-ADUser。 这个技术可以用于创建用户前预处理任何原始数据。 本文国际来源：Bulk Creating AD Users from Excel Sheets","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - PowerShell 技能连载 - 移除 AD 组成员","slug":"removing-ad-group-members","date":"2014-12-05T04:00:00.000Z","updated":"2017-03-17T15:26:24.754Z","comments":true,"path":"2014/12/05/removing-ad-group-members/","link":"","permalink":"http://blog.vichamp.com/2014/12/05/removing-ad-group-members/","excerpt":"需要 ActiveDirectory Module 要从 Active Directory 组中移除一个或多个用户，尝试以下方法： 123456$user = @()$user += Get-ADUser -Filter &#123; Name -like 'H*'&#125; $user += Get-ADUser -Filter &#123; Name -like '*ll*'&#125; $user.NameRemove-ADGroupMember -Identity 'SomeGroup' -Members $user 这段代码将查找名字符合指定模式的所有用户，然后将用户列表传递给 Remove-ADGroupMember 来将用户从该组中移除掉。 请注意空数组的使用。一个空数组可以通过“+=”运算符一次或多次加入元素，并且该操作符可以接受单个用户也可以接受一个数组。所以您可以向列表添加一个或多个用户——例如过滤查询的结果。","text":"需要 ActiveDirectory Module 要从 Active Directory 组中移除一个或多个用户，尝试以下方法： 123456$user = @()$user += Get-ADUser -Filter &#123; Name -like 'H*'&#125; $user += Get-ADUser -Filter &#123; Name -like '*ll*'&#125; $user.NameRemove-ADGroupMember -Identity 'SomeGroup' -Members $user 这段代码将查找名字符合指定模式的所有用户，然后将用户列表传递给 Remove-ADGroupMember 来将用户从该组中移除掉。 请注意空数组的使用。一个空数组可以通过“+=”运算符一次或多次加入元素，并且该操作符可以接受单个用户也可以接受一个数组。所以您可以向列表添加一个或多个用户——例如过滤查询的结果。 本文国际来源：Removing AD Group Members","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - PowerShell 技能连载 - 配置 PowerShell 的步骤（第 3 部分）","slug":"steps-to-configure-powershell-part-3","date":"2014-12-04T04:00:00.000Z","updated":"2017-03-17T15:26:24.738Z","comments":true,"path":"2014/12/04/steps-to-configure-powershell-part-3/","link":"","permalink":"http://blog.vichamp.com/2014/12/04/steps-to-configure-powershell-part-3/","excerpt":"适用于 PowerShell 所有版本 如果您在家中或其它不重要的场合使用 PowerShell，那么可以通过以下步骤使 PowerShell 发挥最大功能。 要在您自己的的机器上启用 PowerShell 远程操作，您需要在您的机器上启用 PowerShell 远程操作功能。实现的方式是用管理员权限启动 PowerShell，然后运行该命令： 1PS&gt; Enable-PSRemoting -SkipNetworkProfileCheck -Force 请注意 -SkipNetworkProfileCheck 是 PowerShell 3.0 引入的概念。如果您仍在 使用 PowerShell 2.0，请忽略这个参数。如果 PowerShell 提示公用网络连接可用，您需要手动临时禁用公用网络连接。 该命令在您的机器上启用 PowerShell 远程操作。其他人现在可以连接到您的计算机，如果他是您计算机上的 Administrators 组成员。 然而，您只能用 Kerberos 身份验证方式来连接到别的计算机。所以此时，远程操作只适用于域环境。如果您在一个简单的点对点网络环境中或是想跨域使用远程操作功能，那么需要启用 NTLM 验证。请注意：只需要在客户端设置。不是在您想连接的目标机器上设，而是在您发起远程操作的机器上设： 1PS&gt; Set-Item -Path WSMan:\\localhost\\Client\\TrustedHosts -Value * -Force 使用“*”允许您通过 NTLM 验证方式连接到任何目标机器。由于 NTLM 是一种非双向认证方式，所以当您使用该方式连接到一台不受信任或可能已被入侵的机器时，会增加安全风险。所以最好不要用“*”，而是指定 IP 地址或 IP 地址段，例如“10.10.*”。 当设置好 PowerShell 远程操作之后，您可以开始使用。 这行代码将会在 ABC 机器上运行任意的 PowerShell 代码（需要您事先在 ABC 机器上启用远程操作功能，并且拥有 ABC 机器上的管理员权限）： 1PS&gt; Invoke-Command -ScriptBlock &#123; \"Hello\" &gt; c:\\IwasHERE.txt &#125; -ComputerName ABC 这段代码将实现同样的效果，但这里您需要显式地制定凭据。当您指定了一个账户，请确定指定了域名和用户名。如果它不是一个域账户，请指定机器名和用户名： 1Invoke-Command -ScriptBlock &#123; \"Hello\" &gt; c:\\IwasHERE.txt &#125; -ComputerName ABC -Credential ABC\\localAdminAccount 请注意：当您想用非 Kerberos 验证的时候，加入域的计算机需要使用 -Credential 参数。","text":"适用于 PowerShell 所有版本 如果您在家中或其它不重要的场合使用 PowerShell，那么可以通过以下步骤使 PowerShell 发挥最大功能。 要在您自己的的机器上启用 PowerShell 远程操作，您需要在您的机器上启用 PowerShell 远程操作功能。实现的方式是用管理员权限启动 PowerShell，然后运行该命令： 1PS&gt; Enable-PSRemoting -SkipNetworkProfileCheck -Force 请注意 -SkipNetworkProfileCheck 是 PowerShell 3.0 引入的概念。如果您仍在 使用 PowerShell 2.0，请忽略这个参数。如果 PowerShell 提示公用网络连接可用，您需要手动临时禁用公用网络连接。 该命令在您的机器上启用 PowerShell 远程操作。其他人现在可以连接到您的计算机，如果他是您计算机上的 Administrators 组成员。 然而，您只能用 Kerberos 身份验证方式来连接到别的计算机。所以此时，远程操作只适用于域环境。如果您在一个简单的点对点网络环境中或是想跨域使用远程操作功能，那么需要启用 NTLM 验证。请注意：只需要在客户端设置。不是在您想连接的目标机器上设，而是在您发起远程操作的机器上设： 1PS&gt; Set-Item -Path WSMan:\\localhost\\Client\\TrustedHosts -Value * -Force 使用“*”允许您通过 NTLM 验证方式连接到任何目标机器。由于 NTLM 是一种非双向认证方式，所以当您使用该方式连接到一台不受信任或可能已被入侵的机器时，会增加安全风险。所以最好不要用“*”，而是指定 IP 地址或 IP 地址段，例如“10.10.*”。 当设置好 PowerShell 远程操作之后，您可以开始使用。 这行代码将会在 ABC 机器上运行任意的 PowerShell 代码（需要您事先在 ABC 机器上启用远程操作功能，并且拥有 ABC 机器上的管理员权限）： 1PS&gt; Invoke-Command -ScriptBlock &#123; \"Hello\" &gt; c:\\IwasHERE.txt &#125; -ComputerName ABC 这段代码将实现同样的效果，但这里您需要显式地制定凭据。当您指定了一个账户，请确定指定了域名和用户名。如果它不是一个域账户，请指定机器名和用户名： 1Invoke-Command -ScriptBlock &#123; \"Hello\" &gt; c:\\IwasHERE.txt &#125; -ComputerName ABC -Credential ABC\\localAdminAccount 请注意：当您想用非 Kerberos 验证的时候，加入域的计算机需要使用 -Credential 参数。 本文国际来源：Steps to Configure PowerShell (Part 3)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 配置 PowerShell 的步骤（第 2 部分）","slug":"steps-to-configure-powershell-part-2","date":"2014-12-03T04:00:00.000Z","updated":"2017-03-17T15:26:24.738Z","comments":true,"path":"2014/12/03/steps-to-configure-powershell-part-2/","link":"","permalink":"http://blog.vichamp.com/2014/12/03/steps-to-configure-powershell-part-2/","excerpt":"适用于 PowerShell 2.0 及以上版本 如果您在家中或其它不重要的场合使用 PowerShell，那么可以通过以下步骤使 PowerShell 发挥最大功能。 要允许系统管理员远程连接到您的机器并运行 Get-Process 或 Get-Service 等 cmdlets，您也许需要启用远程管理的防火墙例外规则。请以管理员身份打开 PowerShell 并运行这段代码： 12345678910PS&gt; netsh firewall set service remoteadmin enableIMPORTANT: Command executed successfully.However, \"netsh firewall\" is deprecated;use \"netsh advfirewall firewall\" instead.For more information on using \"netsh advfirewall firewall\" commandsinstead of \"netsh firewall\", see KB article 947709at http://go.microsoft.com/fwlink/?linkid=121488 .Ok. 该命令返回的信息告诉我们该命令已过时，有一个更新的命令替代了它，但它任然可用并启用了防火墙例外。新的命令更难使用，因为它的参数是本地化的，并且您需要知道防火墙例外的确切名称。 要真正地用上 cmdlet 的远程功能，您还需要启用 RemoteRegistry 服务并将它设为自动启动： 123PS&gt; Start-Service RemoteRegistryPS&gt; Set-Service -Name Remoteregistry -StartupType Automatic 您现在可以使用 Get-Process、Get-Service 或其它暴露了 -ComputerName 参数的 cmdlet 来远程连接到您的计算机，假设运行这些 cmdlet 的用户拥有您系统上的管理员权限。 在简单的点对点家庭环境中，为每台计算机的 Administrator 账号设置相同的名字就足够了。","text":"适用于 PowerShell 2.0 及以上版本 如果您在家中或其它不重要的场合使用 PowerShell，那么可以通过以下步骤使 PowerShell 发挥最大功能。 要允许系统管理员远程连接到您的机器并运行 Get-Process 或 Get-Service 等 cmdlets，您也许需要启用远程管理的防火墙例外规则。请以管理员身份打开 PowerShell 并运行这段代码： 12345678910PS&gt; netsh firewall set service remoteadmin enableIMPORTANT: Command executed successfully.However, \"netsh firewall\" is deprecated;use \"netsh advfirewall firewall\" instead.For more information on using \"netsh advfirewall firewall\" commandsinstead of \"netsh firewall\", see KB article 947709at http://go.microsoft.com/fwlink/?linkid=121488 .Ok. 该命令返回的信息告诉我们该命令已过时，有一个更新的命令替代了它，但它任然可用并启用了防火墙例外。新的命令更难使用，因为它的参数是本地化的，并且您需要知道防火墙例外的确切名称。 要真正地用上 cmdlet 的远程功能，您还需要启用 RemoteRegistry 服务并将它设为自动启动： 123PS&gt; Start-Service RemoteRegistryPS&gt; Set-Service -Name Remoteregistry -StartupType Automatic 您现在可以使用 Get-Process、Get-Service 或其它暴露了 -ComputerName 参数的 cmdlet 来远程连接到您的计算机，假设运行这些 cmdlet 的用户拥有您系统上的管理员权限。 在简单的点对点家庭环境中，为每台计算机的 Administrator 账号设置相同的名字就足够了。 本文国际来源：Steps to Configure PowerShell (Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 配置 PowerShell 的步骤（第 1 部分）","slug":"steps-to-configure-powershell-part-1","date":"2014-12-02T04:00:00.000Z","updated":"2017-03-17T15:26:24.723Z","comments":true,"path":"2014/12/02/steps-to-configure-powershell-part-1/","link":"","permalink":"http://blog.vichamp.com/2014/12/02/steps-to-configure-powershell-part-1/","excerpt":"适用于 PowerShell 2.0 及以上版本 如果您在家中或其它不重要的场合使用 PowerShell，那么可以通过以下步骤使 PowerShell 发挥最大功能。 您可以通过以下代码查看正在使用的 PowerShell 版本： 123PS&gt; $PSVersionTable.PSVersion.Major4 如果版本号小于 4，请审查一下为什么使用过期的版本，是不是可以升级了。 要启用脚本执行功能，请运行以下代码： 1PS&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Bypass -Force 您现在可以自由地执行任意位置的脚本了。如果您是初学者并且希望得到更多的安全保障，请将“Bypass”改为“RemoteSigned”。这将防止您运行下载自 Internet 或电子邮件附件的脚本。它也将防止您运行您拥有的域之外的脚本。","text":"适用于 PowerShell 2.0 及以上版本 如果您在家中或其它不重要的场合使用 PowerShell，那么可以通过以下步骤使 PowerShell 发挥最大功能。 您可以通过以下代码查看正在使用的 PowerShell 版本： 123PS&gt; $PSVersionTable.PSVersion.Major4 如果版本号小于 4，请审查一下为什么使用过期的版本，是不是可以升级了。 要启用脚本执行功能，请运行以下代码： 1PS&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Bypass -Force 您现在可以自由地执行任意位置的脚本了。如果您是初学者并且希望得到更多的安全保障，请将“Bypass”改为“RemoteSigned”。这将防止您运行下载自 Internet 或电子邮件附件的脚本。它也将防止您运行您拥有的域之外的脚本。 本文国际来源：Steps to Configure PowerShell (Part 1)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 数组中的空值","slug":"null-values-in-arrays","date":"2014-12-01T04:00:00.000Z","updated":"2017-03-17T15:26:24.723Z","comments":true,"path":"2014/12/01/null-values-in-arrays/","link":"","permalink":"http://blog.vichamp.com/2014/12/01/null-values-in-arrays/","excerpt":"适用于 PowerShell 所有版本 当您将 NULL 值赋给数组元素时，它们会记入数组元素中，但不会输出（毕竟，它们是所谓的空值）。这会导致调试时的困难。所以当数组的大小看起来和内容不一样时，请查查是否有空值： 123456789$a = @()$a += 1$a += $null$a += $null$a += 212Count: 4","text":"适用于 PowerShell 所有版本 当您将 NULL 值赋给数组元素时，它们会记入数组元素中，但不会输出（毕竟，它们是所谓的空值）。这会导致调试时的困难。所以当数组的大小看起来和内容不一样时，请查查是否有空值： 123456789$a = @()$a += 1$a += $null$a += $null$a += 212Count: 4 本文国际来源：NULL Values in Arrays","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 随机排列数字列表","slug":"randomize-lists-of-numbers","date":"2014-11-28T04:00:00.000Z","updated":"2017-03-17T15:26:24.707Z","comments":true,"path":"2014/11/28/randomize-lists-of-numbers/","link":"","permalink":"http://blog.vichamp.com/2014/11/28/randomize-lists-of-numbers/","excerpt":"适用于 PowerShell 所有版本 这行代码将输入一个数字列表并对它们随机排序： 1Get-Random -InputObject 1, 2, 3, 5, 8, 13 -Count ([int]::MaxValue) 也可以用管道，不过速度更慢： 11, 2, 3, 5, 8, 13 | Sort-Object -Property &#123; Get-Random &#125;","text":"适用于 PowerShell 所有版本 这行代码将输入一个数字列表并对它们随机排序： 1Get-Random -InputObject 1, 2, 3, 5, 8, 13 -Count ([int]::MaxValue) 也可以用管道，不过速度更慢： 11, 2, 3, 5, 8, 13 | Sort-Object -Property &#123; Get-Random &#125; 本文国际来源：Randomize Lists of Numbers","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 读取磁盘和分区信息","slug":"reading-disks-and-partitions","date":"2014-11-27T04:00:00.000Z","updated":"2017-03-17T15:26:24.707Z","comments":true,"path":"2014/11/27/reading-disks-and-partitions/","link":"","permalink":"http://blog.vichamp.com/2014/11/27/reading-disks-and-partitions/","excerpt":"适用于 Windows 8.1 / Server 2012 R2 Windows 8.1 和 Server 2012 R2 带来的许多客户端和服务器 cmdlet 可以极大地简化磁盘的管理。 让我们从查看磁盘和分区开始。这将列出所有加载的磁盘： 1PS&gt; Get-Disk 这将列出分区： 1PS&gt; Get-Partition 这两个 cmdlet 都位于“Storage”模块中： 12345PS&gt; Get-Command -Name Get-Disk | Select-Object -ExpandProperty ModuleModuleType Version Name ExportedCommands ---------- ------- ---- ---------------- Manifest 2.0.0.0 Storage &#123;Add-InitiatorIdToMas... 这将列出该模块中的所有存储管理命令： 1234567891011PS&gt; Get-Command -Module storageCommandType Name ModuleName ----------- ---- ---------- Alias Flush-Volume Storage Alias Initialize-Volume Storage Alias Write-FileSystemCache Storage Function Add-InitiatorIdToMaskingSet Storage Function Add-PartitionAccessPath Storage Function Add-PhysicalDisk Storage (...)","text":"适用于 Windows 8.1 / Server 2012 R2 Windows 8.1 和 Server 2012 R2 带来的许多客户端和服务器 cmdlet 可以极大地简化磁盘的管理。 让我们从查看磁盘和分区开始。这将列出所有加载的磁盘： 1PS&gt; Get-Disk 这将列出分区： 1PS&gt; Get-Partition 这两个 cmdlet 都位于“Storage”模块中： 12345PS&gt; Get-Command -Name Get-Disk | Select-Object -ExpandProperty ModuleModuleType Version Name ExportedCommands ---------- ------- ---- ---------------- Manifest 2.0.0.0 Storage &#123;Add-InitiatorIdToMas... 这将列出该模块中的所有存储管理命令： 1234567891011PS&gt; Get-Command -Module storageCommandType Name ModuleName ----------- ---- ---------- Alias Flush-Volume Storage Alias Initialize-Volume Storage Alias Write-FileSystemCache Storage Function Add-InitiatorIdToMaskingSet Storage Function Add-PartitionAccessPath Storage Function Add-PhysicalDisk Storage (...) 本文国际来源：Reading Disks and Partitions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查看 Windows 版本","slug":"finding-out-windows-version","date":"2014-11-26T04:00:00.000Z","updated":"2017-03-17T15:26:24.692Z","comments":true,"path":"2014/11/26/finding-out-windows-version/","link":"","permalink":"http://blog.vichamp.com/2014/11/26/finding-out-windows-version/","excerpt":"适用于 PowerShell 所有版本 您有安装 Windows 8.1 Basic 版、Pro 版，或 Enterprise 版吗？查看 Windows 版本号很容易，但查看具体是哪个子系列则不这么容易。 最好的方法是，获取 SKU 号，它能精确地体现 Windows 的版本类型，但如何将数字转化为一个有意义的名字也不太容易： 123PS&gt; Get-WmiObject -Class Win32_OperatingSystem | Select-Object -ExpandProperty OperatingSystemSKU48 一个稍好的方式是用这段代码返回您当前使用的许可类型的明确的文字描述： 123PS&gt; Get-WmiObject SoftwareLicensingProduct -Filter 'Name like \"Windows%\" and LicenseStatus=1' | Select-Object -ExpandProperty Name Windows(R), Professional edition 另一种方法也可以返回 Windows 的主要版本信息： 123PS&gt; Get-WmiObject -Class Win32_OperatingSystem | Select-Object -ExpandProperty CaptionMicrosoft Windows 8.1 Pro","text":"适用于 PowerShell 所有版本 您有安装 Windows 8.1 Basic 版、Pro 版，或 Enterprise 版吗？查看 Windows 版本号很容易，但查看具体是哪个子系列则不这么容易。 最好的方法是，获取 SKU 号，它能精确地体现 Windows 的版本类型，但如何将数字转化为一个有意义的名字也不太容易： 123PS&gt; Get-WmiObject -Class Win32_OperatingSystem | Select-Object -ExpandProperty OperatingSystemSKU48 一个稍好的方式是用这段代码返回您当前使用的许可类型的明确的文字描述： 123PS&gt; Get-WmiObject SoftwareLicensingProduct -Filter 'Name like \"Windows%\" and LicenseStatus=1' | Select-Object -ExpandProperty Name Windows(R), Professional edition 另一种方法也可以返回 Windows 的主要版本信息： 123PS&gt; Get-WmiObject -Class Win32_OperatingSystem | Select-Object -ExpandProperty CaptionMicrosoft Windows 8.1 Pro 本文国际来源：Finding Out Windows Version","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Join-Path 遇上不存在的驱动器会失败","slug":"join-path-fails-with-non-existing-drives","date":"2014-11-25T04:00:00.000Z","updated":"2017-03-17T15:26:24.676Z","comments":true,"path":"2014/11/25/join-path-fails-with-non-existing-drives/","link":"","permalink":"http://blog.vichamp.com/2014/11/25/join-path-fails-with-non-existing-drives/","excerpt":"适用于 PowerShell 所有版本 您可能已经使用 Join-Path 通过父文件夹和文件来创建路径名。这个 cmdlet 在合并路径元素的时候能够正确地处理反斜杠的个数： 12345$part1 = 'C:\\somefolder\\'$part2 = '\\myfile.txt'$result = Join-Path -Path $part1 -ChildPath $part2$result 然而，如果路径元素存在，Join-Path 将会失败。所以您无法为一个没有加载的驱动器创建路径： 1234567$part1 = 'L:\\somefolder\\'$part2 = '\\myfile.txt'$result = Join-Path -Path $part1 -ChildPath $part2$resultJoin-Path : Cannot find drive. A drive with the name 'L' does not exist. 其实，Join-Path 所做的事也可以通过手工很好地完成。这段代码将合并两段路径元素并且能处理好反斜杠： 12345$part1 = 'L:\\somefolder\\'$part2 = '\\myfile.txt'$result = $part1.TrimEnd('\\') + '\\' + $part2.TrimStart('\\')$result 如果您在 Windows 功能中启用了 Hyper-V 的 PowerShell 模块（如前一个技能中描述的一样的），您现在就可以通过 PowerShell 管理虚拟磁盘。","text":"适用于 PowerShell 所有版本 您可能已经使用 Join-Path 通过父文件夹和文件来创建路径名。这个 cmdlet 在合并路径元素的时候能够正确地处理反斜杠的个数： 12345$part1 = 'C:\\somefolder\\'$part2 = '\\myfile.txt'$result = Join-Path -Path $part1 -ChildPath $part2$result 然而，如果路径元素存在，Join-Path 将会失败。所以您无法为一个没有加载的驱动器创建路径： 1234567$part1 = 'L:\\somefolder\\'$part2 = '\\myfile.txt'$result = Join-Path -Path $part1 -ChildPath $part2$resultJoin-Path : Cannot find drive. A drive with the name 'L' does not exist. 其实，Join-Path 所做的事也可以通过手工很好地完成。这段代码将合并两段路径元素并且能处理好反斜杠： 12345$part1 = 'L:\\somefolder\\'$part2 = '\\myfile.txt'$result = $part1.TrimEnd('\\') + '\\' + $part2.TrimStart('\\')$result 如果您在 Windows 功能中启用了 Hyper-V 的 PowerShell 模块（如前一个技能中描述的一样的），您现在就可以通过 PowerShell 管理虚拟磁盘。 本文国际来源：Join-Path Fails with Nonexistent Drives","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 Cmdlet 管理虚拟硬盘驱动器","slug":"using-cmdlets-to-manage-virtual-hard-drives","date":"2014-11-24T04:00:00.000Z","updated":"2017-03-17T15:26:24.676Z","comments":true,"path":"2014/11/24/using-cmdlets-to-manage-virtual-hard-drives/","link":"","permalink":"http://blog.vichamp.com/2014/11/24/using-cmdlets-to-manage-virtual-hard-drives/","excerpt":"适用于 Windows 8.1 Pro/Enterprise 或 Server 2012 R2 Windows 8.1 和 Server 2012 R2 带来一系列额外的 cmdlet 命令，有一部分用于管理虚拟磁盘。不过，在使用这些 cmdlet 之前，您需要先启用“Hyper-V 角色”（请注意需要 Windows 8.1 Pro 或 Enterprise 版才支持客户端的 Hyper-V。“Home”版则不支持该功能）。 在 Windows 8.1 中，您需要手动做以下操作：打开控制面板，进入程序/程序和功能。您也可以在 PowerShell 中键入“appwiz.cpl”打开该功能。 下一步，点击“启用或关闭 Windows 功能”。这将打开一个列出所有功能的对话框。请定位到“Hyper-V”节点并启用它。然后点击 OK。如果找不到“Hyper-V”节点，那么您的 Windows 版本不支持客户端的 Hyper-V。如果“Hyper-V 平台”选项呈灰色，那么您需要在计算机的 BIOS 设置中启用虚拟化支持。 安装该功能需要几秒钟。当安装完成以后，您就可以使用一系列新的 cmdlet： 12345678910PS&gt; Get-Command -Module Hyper-VCommandType Name ModuleName ----------- ---- ---------- Cmdlet Add-VMDvdDrive Hyper-V Cmdlet Add-VMFibreChannelHba Hyper-V Cmdlet Add-VMHardDiskDrive Hyper-V Cmdlet Add-VMMigrationNetwork Hyper-V Cmdlet Add-VMNetworkAdapter Hyper-V (...)","text":"适用于 Windows 8.1 Pro/Enterprise 或 Server 2012 R2 Windows 8.1 和 Server 2012 R2 带来一系列额外的 cmdlet 命令，有一部分用于管理虚拟磁盘。不过，在使用这些 cmdlet 之前，您需要先启用“Hyper-V 角色”（请注意需要 Windows 8.1 Pro 或 Enterprise 版才支持客户端的 Hyper-V。“Home”版则不支持该功能）。 在 Windows 8.1 中，您需要手动做以下操作：打开控制面板，进入程序/程序和功能。您也可以在 PowerShell 中键入“appwiz.cpl”打开该功能。 下一步，点击“启用或关闭 Windows 功能”。这将打开一个列出所有功能的对话框。请定位到“Hyper-V”节点并启用它。然后点击 OK。如果找不到“Hyper-V”节点，那么您的 Windows 版本不支持客户端的 Hyper-V。如果“Hyper-V 平台”选项呈灰色，那么您需要在计算机的 BIOS 设置中启用虚拟化支持。 安装该功能需要几秒钟。当安装完成以后，您就可以使用一系列新的 cmdlet： 12345678910PS&gt; Get-Command -Module Hyper-VCommandType Name ModuleName ----------- ---- ---------- Cmdlet Add-VMDvdDrive Hyper-V Cmdlet Add-VMFibreChannelHba Hyper-V Cmdlet Add-VMHardDiskDrive Hyper-V Cmdlet Add-VMMigrationNetwork Hyper-V Cmdlet Add-VMNetworkAdapter Hyper-V (...) 本文国际来源：Using Cmdlets to Manage Virtual Hard Drives","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 IPv4 来 Ping","slug":"pinging-via-ipv4","date":"2014-11-13T04:00:00.000Z","updated":"2017-03-17T15:26:24.676Z","comments":true,"path":"2014/11/13/pinging-via-ipv4/","link":"","permalink":"http://blog.vichamp.com/2014/11/13/pinging-via-ipv4/","excerpt":"适用于 PowerShell 所有版本 您可以像其它命令一样在 PowerShell 脚本中使用 ping.exe。向 ping 命令加入“-4”参数之后，您可以强制 ping 命令使用 IPv4 协议（也可以用“-6”参数强制使用 IPv6）。 PS&gt; ping localhost -4","text":"适用于 PowerShell 所有版本 您可以像其它命令一样在 PowerShell 脚本中使用 ping.exe。向 ping 命令加入“-4”参数之后，您可以强制 ping 命令使用 IPv4 协议（也可以用“-6”参数强制使用 IPv6）。 PS&gt; ping localhost -4 本文国际来源：Pinging via IPv4","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中使用 F1 键","slug":"use-f1-in-powershell-ise","date":"2014-11-12T04:00:00.000Z","updated":"2017-03-17T15:26:24.674Z","comments":true,"path":"2014/11/12/use-f1-in-powershell-ise/","link":"","permalink":"http://blog.vichamp.com/2014/11/12/use-f1-in-powershell-ise/","excerpt":"适用于 PowerShell ISE 3 及以上版本 当您下载了 PowerShell 帮助文件之后（在提升权限的 shell 中，用 Update-Help），您就可以用 Get-Help 命令来查找许多有用主题背后的信息。例如，以下代码将列出所有包含关键字“Parameter”的主题： PS&gt; Get-Help parameter Name Category Module Synopsis ---- -------- ------ -------- Get-ClusterParameter Cmdlet FailoverClusters Get-Cl... Set-ClusterParameter Cmdlet FailoverClusters Set-Cl... about_CommonParameters HelpFile Descri... about_Functions_Advanced_Param... HelpFile Explai... about_Parameters HelpFile Descri... about_Parameters_Default_Values HelpFile Descri... about_ActivityCommonParameters HelpFile Descri... about_WorkflowCommonParameters HelpFile 一般性的帮助主题都是以“about_”开头的。 在 PowerShell ISE 中，只需要单击任何一个列出的名称，然后按下 F1 键，就可以在独立的帮主窗口中打开关联的主题。","text":"适用于 PowerShell ISE 3 及以上版本 当您下载了 PowerShell 帮助文件之后（在提升权限的 shell 中，用 Update-Help），您就可以用 Get-Help 命令来查找许多有用主题背后的信息。例如，以下代码将列出所有包含关键字“Parameter”的主题： PS&gt; Get-Help parameter Name Category Module Synopsis ---- -------- ------ -------- Get-ClusterParameter Cmdlet FailoverClusters Get-Cl... Set-ClusterParameter Cmdlet FailoverClusters Set-Cl... about_CommonParameters HelpFile Descri... about_Functions_Advanced_Param... HelpFile Explai... about_Parameters HelpFile Descri... about_Parameters_Default_Values HelpFile Descri... about_ActivityCommonParameters HelpFile Descri... about_WorkflowCommonParameters HelpFile 一般性的帮助主题都是以“about_”开头的。 在 PowerShell ISE 中，只需要单击任何一个列出的名称，然后按下 F1 键，就可以在独立的帮主窗口中打开关联的主题。 本文国际来源：Use F1 in PowerShell ISE","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 函数的优先级永远比 cmdlet 高","slug":"functions-always-beat-cmdlets","date":"2014-11-11T04:00:00.000Z","updated":"2017-03-17T15:26:24.665Z","comments":true,"path":"2014/11/11/functions-always-beat-cmdlets/","link":"","permalink":"http://blog.vichamp.com/2014/11/11/functions-always-beat-cmdlets/","excerpt":"适用于 PowerShell 所有版本 函数的优先级永远比 cmdlet 高，所以如果两者名字相同，函数将会被执行。 这个函数将切实有效地改变 Get-Process 的行为： function Get-Process { &apos;go away&apos; } 以下是意料之中的执行结果： PS&gt; Get-Process go away 甚至如果您指定了 cmdlet 的完整限定名，函数也可以优先执行： function Microsoft.PowerShell.Management\\Get-Process { &apos;go away&apos; } 执行结果： PS&gt; Microsoft.PowerShell.Management\\Get-Process -Id $pid go away 这也适用于别名。它们的优先级甚至比函数更高。 唯一能确保确实执行的是 cmdlet 的方法是直接存取模块，选择希望执行的 cmdlet，然后直接调用它： $module = Get-Module Microsoft.PowerShell.Management $cmdlet = $module.ExportedCmdlets[&apos;Get-Process&apos;] &amp; $cmdlet 或者，只需要用 -noprofile 参数启动一个新的 PowerShell，确保没有人能混进您的 PowerShell 环境即可。","text":"适用于 PowerShell 所有版本 函数的优先级永远比 cmdlet 高，所以如果两者名字相同，函数将会被执行。 这个函数将切实有效地改变 Get-Process 的行为： function Get-Process { &apos;go away&apos; } 以下是意料之中的执行结果： PS&gt; Get-Process go away 甚至如果您指定了 cmdlet 的完整限定名，函数也可以优先执行： function Microsoft.PowerShell.Management\\Get-Process { &apos;go away&apos; } 执行结果： PS&gt; Microsoft.PowerShell.Management\\Get-Process -Id $pid go away 这也适用于别名。它们的优先级甚至比函数更高。 唯一能确保确实执行的是 cmdlet 的方法是直接存取模块，选择希望执行的 cmdlet，然后直接调用它： $module = Get-Module Microsoft.PowerShell.Management $cmdlet = $module.ExportedCmdlets[&apos;Get-Process&apos;] &amp; $cmdlet 或者，只需要用 -noprofile 参数启动一个新的 PowerShell，确保没有人能混进您的 PowerShell 环境即可。 本文国际来源：Functions Always Beat Cmdlets","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 EFS 加解密文件","slug":"encrypting-and-decrypting-files-with-efs","date":"2014-11-10T04:00:00.000Z","updated":"2017-03-17T15:26:24.647Z","comments":true,"path":"2014/11/10/encrypting-and-decrypting-files-with-efs/","link":"","permalink":"http://blog.vichamp.com/2014/11/10/encrypting-and-decrypting-files-with-efs/","excerpt":"适用于 PowerShell 所有版本 假设您的系统启用了 EFS (Encrypting File System)，并且您想将文件保存到一个 NTFS 盘中，那么以下是加密以及确保只有您可以读取该文件的方法： (Get-Item -Path &apos;C:\\path..to..some..file.txt&apos;).Encrypt() 如果加密成功，那么在 explorer.exe 中将会显示为绿色而不是平常的黑色。用 Decrypt() 代替 Encrypt() 来撤销加密。 请注意需要事先设置了 EFS，并且您的公司可能需要一个集中存放的备份加密秘钥。","text":"适用于 PowerShell 所有版本 假设您的系统启用了 EFS (Encrypting File System)，并且您想将文件保存到一个 NTFS 盘中，那么以下是加密以及确保只有您可以读取该文件的方法： (Get-Item -Path &apos;C:\\path..to..some..file.txt&apos;).Encrypt() 如果加密成功，那么在 explorer.exe 中将会显示为绿色而不是平常的黑色。用 Decrypt() 代替 Encrypt() 来撤销加密。 请注意需要事先设置了 EFS，并且您的公司可能需要一个集中存放的备份加密秘钥。 本文国际来源：Encrypting and Decrypting Files with EFS","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 Out-Host 代替 More","slug":"use-out-host-instead-of-more","date":"2014-11-07T04:00:00.000Z","updated":"2017-03-17T15:26:24.647Z","comments":true,"path":"2014/11/07/use-out-host-instead-of-more/","link":"","permalink":"http://blog.vichamp.com/2014/11/07/use-out-host-instead-of-more/","excerpt":"适用于 PowerShell 控制台 请注意本文所述的内容仅限于“真实的”控制台使用。它不适用于 PowerShell ISE 编辑器。 在 PowerShell 控制台中，许多用户在要分页输出数据时仍然采用管道输出到 more.com 的老办法： PS&gt; dir c:\\windows | more 这看起来能用。不过当您输出大量数据到管道的时候，PowerShell 看起来卡住了： PS&gt; dir c:\\windows -Recurse -ErrorAction SilentlyContinue | more 这是因为 more.com 无法实时工作。它会首先收集所有的输入数据，然后开始分页输出。 更好的办法是使用 Out-Host cmdlet，结合 -Paging 参数： PS&gt; dir c:\\windows -Recurse -ErrorAction SilentlyContinue | Out-Host -Paging 它能即时输出结果，因为它一旦从管道接收到数据，就可以开始处理。","text":"适用于 PowerShell 控制台 请注意本文所述的内容仅限于“真实的”控制台使用。它不适用于 PowerShell ISE 编辑器。 在 PowerShell 控制台中，许多用户在要分页输出数据时仍然采用管道输出到 more.com 的老办法： PS&gt; dir c:\\windows | more 这看起来能用。不过当您输出大量数据到管道的时候，PowerShell 看起来卡住了： PS&gt; dir c:\\windows -Recurse -ErrorAction SilentlyContinue | more 这是因为 more.com 无法实时工作。它会首先收集所有的输入数据，然后开始分页输出。 更好的办法是使用 Out-Host cmdlet，结合 -Paging 参数： PS&gt; dir c:\\windows -Recurse -ErrorAction SilentlyContinue | Out-Host -Paging 它能即时输出结果，因为它一旦从管道接收到数据，就可以开始处理。 本文国际来源：Use Out-Host instead of More","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Invoke-Expression 是邪恶的","slug":"invoke-expression-is-evil","date":"2014-11-06T04:00:00.000Z","updated":"2017-03-17T15:26:24.632Z","comments":true,"path":"2014/11/06/invoke-expression-is-evil/","link":"","permalink":"http://blog.vichamp.com/2014/11/06/invoke-expression-is-evil/","excerpt":"适用于 PowerShell 所有版本 请在您的脚本中避免使用 Invoke-Expression。这个 cmdlet 接受一个字符串，并且像一个命令一样执行它。在大多数情况下，这是没必要的，它只能带来风险。 以下是一个故意构造的例子： function Test-BadBehavior($Path) { Invoke-Expression &quot;Get-ChildItem -Path $Path&quot; } 这个函数用 Invoke-Expression 来运行一个命令并且加上一个参数值，用来返回输入参数代表的路径下的文件列表。 由于 Invoke-Expression 接受任意的字符串参数，所以您将自己带入了类似“SQL 注入攻击”的环境中。请试着以这种方式运行脚本： PS&gt; Test-BadBehavior &apos;c:\\;Get-Process&apos; 这样写第二个命令也会被执行，并会列出所有运行中的进程。Invoke-Expression 常常被攻击者用于从外部 URL 下载恶意的程序并轻松地执行。 当然，Invoke-Expression 本来就没必要用。平时在生产系统的脚本中基本没什么用。请注意确保以硬编码的方式编写您想执行的命令： function Test-BadBehavior($Path) { Get-ChildItem -Path $Path }","text":"适用于 PowerShell 所有版本 请在您的脚本中避免使用 Invoke-Expression。这个 cmdlet 接受一个字符串，并且像一个命令一样执行它。在大多数情况下，这是没必要的，它只能带来风险。 以下是一个故意构造的例子： function Test-BadBehavior($Path) { Invoke-Expression &quot;Get-ChildItem -Path $Path&quot; } 这个函数用 Invoke-Expression 来运行一个命令并且加上一个参数值，用来返回输入参数代表的路径下的文件列表。 由于 Invoke-Expression 接受任意的字符串参数，所以您将自己带入了类似“SQL 注入攻击”的环境中。请试着以这种方式运行脚本： PS&gt; Test-BadBehavior &apos;c:\\;Get-Process&apos; 这样写第二个命令也会被执行，并会列出所有运行中的进程。Invoke-Expression 常常被攻击者用于从外部 URL 下载恶意的程序并轻松地执行。 当然，Invoke-Expression 本来就没必要用。平时在生产系统的脚本中基本没什么用。请注意确保以硬编码的方式编写您想执行的命令： function Test-BadBehavior($Path) { Get-ChildItem -Path $Path } 本文国际来源：Invoke-Expression is Evil","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 显示 PowerShell 的命令行历史","slug":"display-command-history-in-powershell-console","date":"2014-11-05T04:00:00.000Z","updated":"2017-03-17T15:26:24.632Z","comments":true,"path":"2014/11/05/display-command-history-in-powershell-console/","link":"","permalink":"http://blog.vichamp.com/2014/11/05/display-command-history-in-powershell-console/","excerpt":"适用于 PowerShell 所有版本 在 PowerShell 控制台（非 PowerShell ISE）中，您只要按下 F7 键就可以列出刚才键入的命令列表。当然，如果还没有执行过任何命令，就不会显示任何内容。 按 ALT+F7 键将会清空命令行历史列表。","text":"适用于 PowerShell 所有版本 在 PowerShell 控制台（非 PowerShell ISE）中，您只要按下 F7 键就可以列出刚才键入的命令列表。当然，如果还没有执行过任何命令，就不会显示任何内容。 按 ALT+F7 键将会清空命令行历史列表。 本文国际来源：Display Command History in PowerShell Console","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 导入及安装证书","slug":"importing-and-installing-certificate","date":"2014-11-04T04:00:00.000Z","updated":"2017-03-17T15:26:24.632Z","comments":true,"path":"2014/11/04/importing-and-installing-certificate/","link":"","permalink":"http://blog.vichamp.com/2014/11/04/importing-and-installing-certificate/","excerpt":"适用于 PowerShell 所有版本 若要以编程的方式从文件中加载证书并将它安装到证书管理其的指定位置，请看以下脚本： $pfxpath = &apos;C:\\temp\\test.pfx&apos; $password = &apos;test&apos; [System.Security.Cryptography.X509Certificates.StoreLocation]$Store = &apos;CurrentUser&apos; $StoreName = &apos;root&apos; Add-Type -AssemblyName System.Security $certificate = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 $certificate.Import($pfxpath, $password, &apos;Exportable&apos;) $Store = New-Object system.security.cryptography.X509Certificates.x509Store($StoreName, $StoreLocation) $Store.Open(&apos;ReadWrite&apos;) $Store.Add($certificate) $Store.Close() 您可以配置这个脚本并指定待导入的证书文件的路径和密码。您还可以指定其存储的位置（当前用户或本地计算机），以及将其放入的容器（例如“root”代表受信任的根证书颁发机构，“my”代表个人）。","text":"适用于 PowerShell 所有版本 若要以编程的方式从文件中加载证书并将它安装到证书管理其的指定位置，请看以下脚本： $pfxpath = &apos;C:\\temp\\test.pfx&apos; $password = &apos;test&apos; [System.Security.Cryptography.X509Certificates.StoreLocation]$Store = &apos;CurrentUser&apos; $StoreName = &apos;root&apos; Add-Type -AssemblyName System.Security $certificate = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 $certificate.Import($pfxpath, $password, &apos;Exportable&apos;) $Store = New-Object system.security.cryptography.X509Certificates.x509Store($StoreName, $StoreLocation) $Store.Open(&apos;ReadWrite&apos;) $Store.Add($certificate) $Store.Close() 您可以配置这个脚本并指定待导入的证书文件的路径和密码。您还可以指定其存储的位置（当前用户或本地计算机），以及将其放入的容器（例如“root”代表受信任的根证书颁发机构，“my”代表个人）。 本文国际来源：Importing and Installing Certificate","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 调用记事本打印文本","slug":"using-notepad-to-print-things","date":"2014-11-03T04:00:00.000Z","updated":"2017-03-17T15:26:24.616Z","comments":true,"path":"2014/11/03/using-notepad-to-print-things/","link":"","permalink":"http://blog.vichamp.com/2014/11/03/using-notepad-to-print-things/","excerpt":"适用于 PowerShell 所有版本 若要调用记事本打印纯文本文件，请使用这行代码（请将路径替换成需要的值，否则将打印出长长的系统日志文件）： Start-Process -FilePath notepad -ArgumentList &apos;/P C:\\windows\\WindowsUpdate.log&apos;","text":"适用于 PowerShell 所有版本 若要调用记事本打印纯文本文件，请使用这行代码（请将路径替换成需要的值，否则将打印出长长的系统日志文件）： Start-Process -FilePath notepad -ArgumentList &apos;/P C:\\windows\\WindowsUpdate.log&apos; 本文国际来源：Using Notepad to Print Things","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建新的共享文件夹","slug":"creating-newshares","date":"2014-10-31T03:00:00.000Z","updated":"2017-03-17T15:26:24.616Z","comments":true,"path":"2014/10/31/creating-newshares/","link":"","permalink":"http://blog.vichamp.com/2014/10/31/creating-newshares/","excerpt":"适用于 PowerShell 所有版本 WMI 可以方便地创建新的共享文件夹。以下是一段创建本地共享文件夹的代码： $ShareName = &apos;NewShare&apos; $Path = &apos;c:\\123&apos; If (!(Get-WmiObject -Class Win32_Share -Filter &quot;name=&apos;$ShareName&apos;&quot;)) { $Shares=[WMICLASS]&quot;WIN32_Share&quot; $Shares.Create($Path,$ShareName,0).ReturnValue } else { Write-Warning &quot;Share $ShareName exists already.&quot; } 如果您有远程机器的管理员权限的话，也可以在远程的机器上创建共享文件夹。只需要像这样使用完整 WMI 即可： $ShareName = &apos;NewShare&apos; $Path = &apos;c:\\123&apos; $Server = &apos;MyServer&apos; If (!(Get-WmiObject -Class Win32_Share -Filter &quot;name=&apos;$ShareName&apos;&quot;)) { $Shares=[WMICLASS]&quot;\\\\$Server\\root\\cimv2:WIN32_Share&quot; $Shares.Create($Path,$ShareName,0).ReturnValue } else { Write-Warning &quot;Share $ShareName exists already.&quot; }","text":"适用于 PowerShell 所有版本 WMI 可以方便地创建新的共享文件夹。以下是一段创建本地共享文件夹的代码： $ShareName = &apos;NewShare&apos; $Path = &apos;c:\\123&apos; If (!(Get-WmiObject -Class Win32_Share -Filter &quot;name=&apos;$ShareName&apos;&quot;)) { $Shares=[WMICLASS]&quot;WIN32_Share&quot; $Shares.Create($Path,$ShareName,0).ReturnValue } else { Write-Warning &quot;Share $ShareName exists already.&quot; } 如果您有远程机器的管理员权限的话，也可以在远程的机器上创建共享文件夹。只需要像这样使用完整 WMI 即可： $ShareName = &apos;NewShare&apos; $Path = &apos;c:\\123&apos; $Server = &apos;MyServer&apos; If (!(Get-WmiObject -Class Win32_Share -Filter &quot;name=&apos;$ShareName&apos;&quot;)) { $Shares=[WMICLASS]&quot;\\\\$Server\\root\\cimv2:WIN32_Share&quot; $Shares.Create($Path,$ShareName,0).ReturnValue } else { Write-Warning &quot;Share $ShareName exists already.&quot; } 本文国际来源：Creating New Shares","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 改变 PowerShell 的优先级","slug":"changing-powershell-priority","date":"2014-10-30T03:00:00.000Z","updated":"2017-03-17T15:26:24.600Z","comments":true,"path":"2014/10/30/changing-powershell-priority/","link":"","permalink":"http://blog.vichamp.com/2014/10/30/changing-powershell-priority/","excerpt":"适用于 PowerShell 所有版本 也许您有时候希望 PowerShell 脚本在后台运行，例如复制文件时，但又不希望脚本抢占过多 CPU 或干预其它任务。 一种减慢 PowerShell 脚本运行速度的方法是降低它们的优先级。以下是一个实现该效果的函数： function Set-Priority { [CmdletBinding()] param ( [Parameter(Mandatory=$true)] [System.Diagnostics.ProcessPriorityClass] $Priority ) $process = Get-Process -Id $pid $process.PriorityClass = $Priority } 要降低脚本的优先级，请这样调用： Set-Priority -Priority BelowNormal 您可以稍后将优先级调回 Normal，甚至可以调高优先级使脚本获得更多资源执行。例如需要执行更重的任务，不过这会使 UI 响应性变得更差。","text":"适用于 PowerShell 所有版本 也许您有时候希望 PowerShell 脚本在后台运行，例如复制文件时，但又不希望脚本抢占过多 CPU 或干预其它任务。 一种减慢 PowerShell 脚本运行速度的方法是降低它们的优先级。以下是一个实现该效果的函数： function Set-Priority { [CmdletBinding()] param ( [Parameter(Mandatory=$true)] [System.Diagnostics.ProcessPriorityClass] $Priority ) $process = Get-Process -Id $pid $process.PriorityClass = $Priority } 要降低脚本的优先级，请这样调用： Set-Priority -Priority BelowNormal 您可以稍后将优先级调回 Normal，甚至可以调高优先级使脚本获得更多资源执行。例如需要执行更重的任务，不过这会使 UI 响应性变得更差。 本文国际来源：Changing PowerShell Priority","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 读取 PFX 证书","slug":"reading-in-pfx-certificate","date":"2014-10-29T03:00:00.000Z","updated":"2017-03-17T15:26:24.585Z","comments":true,"path":"2014/10/29/reading-in-pfx-certificate/","link":"","permalink":"http://blog.vichamp.com/2014/10/29/reading-in-pfx-certificate/","excerpt":"适用于 PowerShell 所有版本 当您使用 Get-PfxCertificate 命令时，您可以读取 PFX 证书文件，并使用证书来为脚本签名。然而，该命令总是交互式地询问证书的密码。 以下这段代码可以通过脚本来提交密码： $PathToPfxFile = &apos;C:\\temp\\test.pfx&apos; $PFXPassword = &apos;test&apos; Add-Type -AssemblyName System.Security $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 $cert.Import($PathToPfxFile, $PFXPassword, &apos;Exportable&apos;) $cert","text":"适用于 PowerShell 所有版本 当您使用 Get-PfxCertificate 命令时，您可以读取 PFX 证书文件，并使用证书来为脚本签名。然而，该命令总是交互式地询问证书的密码。 以下这段代码可以通过脚本来提交密码： $PathToPfxFile = &apos;C:\\temp\\test.pfx&apos; $PFXPassword = &apos;test&apos; Add-Type -AssemblyName System.Security $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 $cert.Import($PathToPfxFile, $PFXPassword, &apos;Exportable&apos;) $cert 本文国际来源：Reading In PFX-Certificate","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 存取 SQLServer 数据库","slug":"accessing-sqlserver-database","date":"2014-10-28T03:00:00.000Z","updated":"2017-03-17T15:26:24.585Z","comments":true,"path":"2014/10/28/accessing-sqlserver-database/","link":"","permalink":"http://blog.vichamp.com/2014/10/28/accessing-sqlserver-database/","excerpt":"适用于 PowerShell 所有版本及 SQLServer 您在使用 SQL Server 吗？以下是一段可以进行 SQL 查询并获取数据的 PowerShell 脚本模板。只需要确保填写了正确的用户信息、服务器地址和 SQL 语句即可： $Database = &apos;Name_Of_SQLDatabase&apos; $Server = &apos;192.168.100.200&apos; $UserName = &apos;DatabaseUserName&apos; $Password = &apos;SecretPassword&apos; $SqlQuery = &apos;Select * FROM TestTable&apos; # Accessing Data Base $SqlConnection = New-Object -TypeName System.Data.SqlClient.SqlConnection $SqlConnection.ConnectionString = &quot;Data Source=$Server;Initial Catalog=$Database;user id=$UserName;pwd=$Password&quot; $SqlCmd = New-Object System.Data.SqlClient.SqlCommand $SqlCmd.CommandText = $SqlQuery $SqlCmd.Connection = $SqlConnection $SqlAdapter = New-Object System.Data.SqlClient.SqlDataAdapter $SqlAdapter.SelectCommand = $SqlCmd $set = New-Object data.dataset # Filling Dataset $SqlAdapter.Fill($set) # Consuming Data $Path = &quot;$env:temp\\report.hta&quot; $set.Tables[0] | ConvertTo-Html | Out-File -FilePath $Path Invoke-Item -Path $Path","text":"适用于 PowerShell 所有版本及 SQLServer 您在使用 SQL Server 吗？以下是一段可以进行 SQL 查询并获取数据的 PowerShell 脚本模板。只需要确保填写了正确的用户信息、服务器地址和 SQL 语句即可： $Database = &apos;Name_Of_SQLDatabase&apos; $Server = &apos;192.168.100.200&apos; $UserName = &apos;DatabaseUserName&apos; $Password = &apos;SecretPassword&apos; $SqlQuery = &apos;Select * FROM TestTable&apos; # Accessing Data Base $SqlConnection = New-Object -TypeName System.Data.SqlClient.SqlConnection $SqlConnection.ConnectionString = &quot;Data Source=$Server;Initial Catalog=$Database;user id=$UserName;pwd=$Password&quot; $SqlCmd = New-Object System.Data.SqlClient.SqlCommand $SqlCmd.CommandText = $SqlQuery $SqlCmd.Connection = $SqlConnection $SqlAdapter = New-Object System.Data.SqlClient.SqlDataAdapter $SqlAdapter.SelectCommand = $SqlCmd $set = New-Object data.dataset # Filling Dataset $SqlAdapter.Fill($set) # Consuming Data $Path = &quot;$env:temp\\report.hta&quot; $set.Tables[0] | ConvertTo-Html | Out-File -FilePath $Path Invoke-Item -Path $Path 本文国际来源：Accessing SQLServer Database","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"AngularJS 中 $scope 的原型继承问题","slug":"Scope-Inheritance-in-AngularJS","date":"2014-10-28T02:33:30.000Z","updated":"2017-03-17T15:26:24.585Z","comments":true,"path":"2014/10/28/Scope-Inheritance-in-AngularJS/","link":"","permalink":"http://blog.vichamp.com/2014/10/28/Scope-Inheritance-in-AngularJS/","excerpt":"","text":"问题描述如下 AngularJS 代码的 INPUT 中键入“Separate reality”，执行效果是什么？ 12var HelloCtrl = function ($scope) &#123;&#125;; 1234567&lt;body ng-app ng-init=\"name='World'\"&gt; &lt;h1&gt;Hello, &#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;div ng-controller=\"HelloCtrl\"&gt; Say hello to: &lt;input type=\"text\" ng-model=\"name\"&gt; &lt;h2&gt;Hello, &#123;&#123;name&#125;&#125;!&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt; 执行结果 外层 H1 始终显示 World 内层 H2 先显示 World；在 INPUT 中键入之后，H2 显示“Separate reality”。 原因ng-controller 创建了一个新的 Scope，该作用域原型继承于父 Scope。 解决方案方案 1 - 采用 $parent 访问父作用域这种方法带导致强耦合，不提倡！ 1&lt;input type=\"text\" ng-model=\"$parent.name\"&gt; 方案 2 - 绑定到对象的属性最佳实践！ 1234567&lt;body ng-app ng-init=\"thing = &#123;name : 'World'&#125;\"&gt; &lt;h1&gt;Hello, &#123;&#123;thing.name&#125;&#125;&lt;/h1&gt; &lt;div ng-controller=\"HelloCtrl\"&gt; Say hello to: &lt;input type=\"text\" ng-model=\" thing.name\"&gt; &lt;h2&gt;Hello, &#123;&#123;thing.name&#125;&#125;!&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt; 模拟以下例子模拟了原始问题 vs 解决方案 2。 1234567891011121314151617181920var a = &#123; x: 1, y: &#123; z: 2 &#125;&#125;;var b = &#123;&#125;;b.__proto__ = a;console.log(b.x); // 1console.log(b.y.z); // 2// 原始问题b.x = 11; // 模拟在 INPUT 中输入console.log(a.x); // 1// 解决方案 2b.y.z = 22; // 模拟在 INPUT 中输入console.log(a.y.z); // 22","categories":[{"name":"angularjs","slug":"angularjs","permalink":"http://blog.vichamp.com/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://blog.vichamp.com/tags/angularjs/"}],"keywords":[{"name":"angularjs","slug":"angularjs","permalink":"http://blog.vichamp.com/categories/angularjs/"}]},{"title":"PowerShell 技能连载 - 创建彩色的 HTML 报告","slug":"creating-colorful-html-reports","date":"2014-10-27T03:00:00.000Z","updated":"2017-03-17T15:26:24.585Z","comments":true,"path":"2014/10/27/creating-colorful-html-reports/","link":"","permalink":"http://blog.vichamp.com/2014/10/27/creating-colorful-html-reports/","excerpt":"适用于 PowerShell 所有版本 要将结果转换为彩色的自定义报告，只需要定义三个脚本块：一个生成 HTML 文档的头部，另一个生成尾部，还有一个对报表中的列表做循环，针对每一个列表项做处理。 然后，将这些脚本块传递给 ForEach-Object。它接受一个 begin、一个 process 和一个 end 脚本块。 以下是一个示例代码，演示了如何创建一个彩色的服务状态报表： $path = &quot;$env:temp\\report.hta&quot; $beginning = { @&apos; &lt;html&gt; &lt;head&gt; &lt;title&gt;Report&lt;/title&gt; &lt;STYLE type=&quot;text/css&quot;&gt; h1 {font-family:SegoeUI, sans-serif; font-size:20} th {font-family:SegoeUI, sans-serif; font-size:15} td {font-family:Consolas, sans-serif; font-size:12} &lt;/STYLE&gt; &lt;/head&gt; &lt;image src=&quot;http://www.yourcompany.com/yourlogo.gif&quot; /&gt; &lt;h1&gt;System Report&lt;/h1&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;Status&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;/tr&gt; &apos;@ } $process = { $status = $_.Status $name = $_.DisplayName if ($status -eq &apos;Running&apos;) { &apos;&lt;tr&gt;&apos; &apos;&lt;td bgcolor=&quot;#00FF00&quot;&gt;{0}&lt;/td&gt;&apos; -f $status &apos;&lt;td bgcolor=&quot;#00FF00&quot;&gt;{0}&lt;/td&gt;&apos; -f $name &apos;&lt;/tr&gt;&apos; } else { &apos;&lt;tr&gt;&apos; &apos;&lt;td bgcolor=&quot;#FF0000&quot;&gt;{0}&lt;/td&gt;&apos; -f $status &apos;&lt;td bgcolor=&quot;#FF0000&quot;&gt;{0}&lt;/td&gt;&apos; -f $name &apos;&lt;/tr&gt;&apos; } } $end = { @&apos; &lt;/table&gt; &lt;/html&gt; &lt;/body&gt; &apos;@ } Get-Service | ForEach-Object -Begin $beginning -Process $process -End $end | Out-File -FilePath $path -Encoding utf8 Invoke-Item -Path $path","text":"适用于 PowerShell 所有版本 要将结果转换为彩色的自定义报告，只需要定义三个脚本块：一个生成 HTML 文档的头部，另一个生成尾部，还有一个对报表中的列表做循环，针对每一个列表项做处理。 然后，将这些脚本块传递给 ForEach-Object。它接受一个 begin、一个 process 和一个 end 脚本块。 以下是一个示例代码，演示了如何创建一个彩色的服务状态报表： $path = &quot;$env:temp\\report.hta&quot; $beginning = { @&apos; &lt;html&gt; &lt;head&gt; &lt;title&gt;Report&lt;/title&gt; &lt;STYLE type=&quot;text/css&quot;&gt; h1 {font-family:SegoeUI, sans-serif; font-size:20} th {font-family:SegoeUI, sans-serif; font-size:15} td {font-family:Consolas, sans-serif; font-size:12} &lt;/STYLE&gt; &lt;/head&gt; &lt;image src=&quot;http://www.yourcompany.com/yourlogo.gif&quot; /&gt; &lt;h1&gt;System Report&lt;/h1&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;Status&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;/tr&gt; &apos;@ } $process = { $status = $_.Status $name = $_.DisplayName if ($status -eq &apos;Running&apos;) { &apos;&lt;tr&gt;&apos; &apos;&lt;td bgcolor=&quot;#00FF00&quot;&gt;{0}&lt;/td&gt;&apos; -f $status &apos;&lt;td bgcolor=&quot;#00FF00&quot;&gt;{0}&lt;/td&gt;&apos; -f $name &apos;&lt;/tr&gt;&apos; } else { &apos;&lt;tr&gt;&apos; &apos;&lt;td bgcolor=&quot;#FF0000&quot;&gt;{0}&lt;/td&gt;&apos; -f $status &apos;&lt;td bgcolor=&quot;#FF0000&quot;&gt;{0}&lt;/td&gt;&apos; -f $name &apos;&lt;/tr&gt;&apos; } } $end = { @&apos; &lt;/table&gt; &lt;/html&gt; &lt;/body&gt; &apos;@ } Get-Service | ForEach-Object -Begin $beginning -Process $process -End $end | Out-File -FilePath $path -Encoding utf8 Invoke-Item -Path $path 本文国际来源：Creating Colorful HTML Reports","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 关闭“完整语言”模式","slug":"turning-off-fulllanguage-mode","date":"2014-10-24T03:00:00.000Z","updated":"2017-03-17T15:26:24.582Z","comments":true,"path":"2014/10/24/turning-off-fulllanguage-mode/","link":"","permalink":"http://blog.vichamp.com/2014/10/24/turning-off-fulllanguage-mode/","excerpt":"适用于 PowerShell 所有版本 PowerShell 可以有多种方法作出限制。一种是将语言模式从 FullLanguage 改为 RestrictedLanguage。这是一种无法撤销的方法，最坏可以关闭并重开 PowerShell： $host.Runspace.SessionStateProxy.LanguageMode = &apos;RestrictedLanguage&apos; 一旦设置成 RestrictedLanguage，PowerShell 将只能执行指令。它将再也无法执行对象的方法或存取对象的属性，并且您也无法定义新的函数。 所以 RestrictedLanguage 基本上是一个安全的锁，锁定以后 PowerShell 只能执行指令但无法深入到底层的 .NET 或用新创建的函数覆盖现有的命令。","text":"适用于 PowerShell 所有版本 PowerShell 可以有多种方法作出限制。一种是将语言模式从 FullLanguage 改为 RestrictedLanguage。这是一种无法撤销的方法，最坏可以关闭并重开 PowerShell： $host.Runspace.SessionStateProxy.LanguageMode = &apos;RestrictedLanguage&apos; 一旦设置成 RestrictedLanguage，PowerShell 将只能执行指令。它将再也无法执行对象的方法或存取对象的属性，并且您也无法定义新的函数。 所以 RestrictedLanguage 基本上是一个安全的锁，锁定以后 PowerShell 只能执行指令但无法深入到底层的 .NET 或用新创建的函数覆盖现有的命令。 本文国际来源：Turning Off “FullLanguage” Mode","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 控制可执行文件的执行","slug":"controlling-execution-of-executables","date":"2014-10-23T03:00:00.000Z","updated":"2017-03-17T15:26:24.572Z","comments":true,"path":"2014/10/23/controlling-execution-of-executables/","link":"","permalink":"http://blog.vichamp.com/2014/10/23/controlling-execution-of-executables/","excerpt":"适用于 PowerShell 所有版本 PowerShell 将所有可执行程序（扩展名为 EXE 的文件）视为普通的命令。您甚至可以限制 PowerShell 不能执行任何可执行程序或只能执行白名单内的程序。 缺省的设置是允许任何 EXE 执行： PS&gt; $ExecutionContext.SessionState.Applications * 该设置为仅允许 ping.exe 和 regedit.exe 执行： $ExecutionContext.SessionState.Applications.Clear() $ExecutionContext.SessionState.Applications.Add(&apos;ping.exe&apos;) $ExecutionContext.SessionState.Applications.Add(&apos;regedit.exe&apos;) 以下是结果： PS&gt; $ExecutionContext.SessionState.Applications ping.exe regedit.exe 显然地，您可以轻松地将设置恢复到缺省状态： PS&gt; $ExecutionContext.SessionState.Applications.Add(&apos;*&apos;) PS&gt; explorer PS&gt; 所以，该设置可以使执行 EXE 程序变得更困难（或者说防止不小心运行了不该运行的 EXE）。若真要将它作为安全策略，您还需要关闭所谓的“语言模式”。 当语言模式关闭时，您无法直接存取 .NET 对象。这意味着您无法在当前的 PowerShell 会话中回退该操作。我们将在明天详细介绍语言模式设置。","text":"适用于 PowerShell 所有版本 PowerShell 将所有可执行程序（扩展名为 EXE 的文件）视为普通的命令。您甚至可以限制 PowerShell 不能执行任何可执行程序或只能执行白名单内的程序。 缺省的设置是允许任何 EXE 执行： PS&gt; $ExecutionContext.SessionState.Applications * 该设置为仅允许 ping.exe 和 regedit.exe 执行： $ExecutionContext.SessionState.Applications.Clear() $ExecutionContext.SessionState.Applications.Add(&apos;ping.exe&apos;) $ExecutionContext.SessionState.Applications.Add(&apos;regedit.exe&apos;) 以下是结果： PS&gt; $ExecutionContext.SessionState.Applications ping.exe regedit.exe 显然地，您可以轻松地将设置恢复到缺省状态： PS&gt; $ExecutionContext.SessionState.Applications.Add(&apos;*&apos;) PS&gt; explorer PS&gt; 所以，该设置可以使执行 EXE 程序变得更困难（或者说防止不小心运行了不该运行的 EXE）。若真要将它作为安全策略，您还需要关闭所谓的“语言模式”。 当语言模式关闭时，您无法直接存取 .NET 对象。这意味着您无法在当前的 PowerShell 会话中回退该操作。我们将在明天详细介绍语言模式设置。 本文国际来源：Controlling Execution of Executables","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 伪造对象类型","slug":"faking-object-type","date":"2014-10-22T03:00:00.000Z","updated":"2017-03-17T15:26:24.568Z","comments":true,"path":"2014/10/22/faking-object-type/","link":"","permalink":"http://blog.vichamp.com/2014/10/22/faking-object-type/","excerpt":"适用于 PowerShell 3.0 及以上版本 PowerShell 内部的类型扩展系统的作用是负责将对象转换为文本。它的实现方法是通过查询一个名为“PSTypeName”的属性。您可以为自定义的对象添加这个属性来模拟其它对象类型并使 ETS 用相同方式显示该对象： $object = [PSCustomObject]@{ ProcessName = &apos;notepad&apos; ID = -1 PSTypeName = &apos;System.Diagnostics.Process&apos; } The object pretends to be a process object, and ETS will format it accordingly: PS&gt; $object Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 0 0 0 0 -1 notepad PS&gt;","text":"适用于 PowerShell 3.0 及以上版本 PowerShell 内部的类型扩展系统的作用是负责将对象转换为文本。它的实现方法是通过查询一个名为“PSTypeName”的属性。您可以为自定义的对象添加这个属性来模拟其它对象类型并使 ETS 用相同方式显示该对象： $object = [PSCustomObject]@{ ProcessName = &apos;notepad&apos; ID = -1 PSTypeName = &apos;System.Diagnostics.Process&apos; } The object pretends to be a process object, and ETS will format it accordingly: PS&gt; $object Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 0 0 0 0 -1 notepad PS&gt; 本文国际来源：Faking Object Type","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"获取所有支持管道的 Cmdlet","slug":"List-Cmdlets-Support-Pipeline","date":"2014-10-21T07:05:44.000Z","updated":"2017-03-17T15:26:24.560Z","comments":true,"path":"2014/10/21/List-Cmdlets-Support-Pipeline/","link":"","permalink":"http://blog.vichamp.com/2014/10/21/List-Cmdlets-Support-Pipeline/","excerpt":"","text":"用这段代码可以获取所有支持管道的 PowerShell 命令： Get-Command -CommandType Cmdlet | Where-Object { $_.Parameters.Values | Where-Object { $_.Attributes.ValueFromPipeline } }","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 创建新对象","slug":"creating-newobjects","date":"2014-10-21T03:00:00.000Z","updated":"2017-03-17T15:26:24.556Z","comments":true,"path":"2014/10/21/creating-newobjects/","link":"","permalink":"http://blog.vichamp.com/2014/10/21/creating-newobjects/","excerpt":"适用于 PowerShell 3.0 或以上版本 这是一个创建自定义对象的简单有效的方法： $object = [PSCustomObject]@{ Name = &apos;Weltner&apos; ID = 123 Active = $true } 这将创建一个包含预设属性值的完整功能的 PowerShell 对象： PS&gt; $object Name ID Active ---- -- ------ Weltner 123 True PS&gt; $object.Name Weltner PS&gt; $object.Active True PS&gt;","text":"适用于 PowerShell 3.0 或以上版本 这是一个创建自定义对象的简单有效的方法： $object = [PSCustomObject]@{ Name = &apos;Weltner&apos; ID = 123 Active = $true } 这将创建一个包含预设属性值的完整功能的 PowerShell 对象： PS&gt; $object Name ID Active ---- -- ------ Weltner 123 True PS&gt; $object.Name Weltner PS&gt; $object.Active True PS&gt; 本文国际来源：Creating New Objects","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在非域环境中使用 PowerShell 远程操作","slug":"using-powershell-remoting-without-domain","date":"2014-10-20T03:00:00.000Z","updated":"2017-03-17T15:26:24.539Z","comments":true,"path":"2014/10/20/using-powershell-remoting-without-domain/","link":"","permalink":"http://blog.vichamp.com/2014/10/20/using-powershell-remoting-without-domain/","excerpt":"适用于 PowerShell 3.0 及以上版本 缺省情况下，当您通过 Enable-PSRemoting 来启用 PowerShell 远程操作时，只启用了 Kerberos 身份验证。这要求双方主机处于同一个域（或信任的域）中，并且仅能通过计算机名访问（很可能包括域名前缀）。它无法跨域、通过域之外的机器，或通过 IP 地址来访问。 要达到上述目的，您需要在启用远程操作的机器上做一些调整。在初始化连接的机器上以管理员权限运行 PowerShell 控制台，键入以下代码： PS&gt; Set-Item WSMan:\\localhost\\Client\\TrustedHosts -Value * -Force 如果该路径不可用，您可能需要在该机器上（临时地）启用 PowerShell 远程操作（用 Enable-PSRemoting –SkipNetworkProfileCheck –Force）。 当您做了上述改动以后，就可以支持 NTLM 验证了。只需要记住从现在开始，要访问加入域的计算机，您需要通过 -Credential 参数提交用户名和密码。","text":"适用于 PowerShell 3.0 及以上版本 缺省情况下，当您通过 Enable-PSRemoting 来启用 PowerShell 远程操作时，只启用了 Kerberos 身份验证。这要求双方主机处于同一个域（或信任的域）中，并且仅能通过计算机名访问（很可能包括域名前缀）。它无法跨域、通过域之外的机器，或通过 IP 地址来访问。 要达到上述目的，您需要在启用远程操作的机器上做一些调整。在初始化连接的机器上以管理员权限运行 PowerShell 控制台，键入以下代码： PS&gt; Set-Item WSMan:\\localhost\\Client\\TrustedHosts -Value * -Force 如果该路径不可用，您可能需要在该机器上（临时地）启用 PowerShell 远程操作（用 Enable-PSRemoting –SkipNetworkProfileCheck –Force）。 当您做了上述改动以后，就可以支持 NTLM 验证了。只需要记住从现在开始，要访问加入域的计算机，您需要通过 -Credential 参数提交用户名和密码。 本文国际来源：Using PowerShell Remoting without Domain","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 启用、禁用 PowerShell 远程操作","slug":"enabling-and-disabling-powershell-remoting","date":"2014-10-17T03:00:00.000Z","updated":"2017-03-17T15:26:24.539Z","comments":true,"path":"2014/10/17/enabling-and-disabling-powershell-remoting/","link":"","permalink":"http://blog.vichamp.com/2014/10/17/enabling-and-disabling-powershell-remoting/","excerpt":"适用于 PowerShell 3.0 及更高版本 如果您想通过 PowerShell 访问一台远程计算机，那么在目标机器（您想访问的机器）上，以管理员身份运行这行代码： PS&gt; Enable-PSRemoting -SkipNetworkProfileCheck -Force 执行完之后，您就可以通过别的计算机访问该计算机了——假设您拥有目标机器的管理员权限，您需要指定计算机名而不是它的 IP 地址，并且两台机器都需要在同一个域中。 要交互式地连接目标机器，使用这行代码： PS&gt; Enter-PSSession -ComputerName targetComputerName 要在远程计算机上运行代码，请使用这种方式： PS&gt; Invoke-Command -ScriptBlock { Get-Service } -ComputerName targetComputerName","text":"适用于 PowerShell 3.0 及更高版本 如果您想通过 PowerShell 访问一台远程计算机，那么在目标机器（您想访问的机器）上，以管理员身份运行这行代码： PS&gt; Enable-PSRemoting -SkipNetworkProfileCheck -Force 执行完之后，您就可以通过别的计算机访问该计算机了——假设您拥有目标机器的管理员权限，您需要指定计算机名而不是它的 IP 地址，并且两台机器都需要在同一个域中。 要交互式地连接目标机器，使用这行代码： PS&gt; Enter-PSSession -ComputerName targetComputerName 要在远程计算机上运行代码，请使用这种方式： PS&gt; Invoke-Command -ScriptBlock { Get-Service } -ComputerName targetComputerName 本文国际来源：Enabling and Disabling PowerShell Remoting","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从文件中读取系统日志","slug":"reading-system-logs-from-file","date":"2014-10-16T03:00:00.000Z","updated":"2017-03-17T15:26:24.523Z","comments":true,"path":"2014/10/16/reading-system-logs-from-file/","link":"","permalink":"http://blog.vichamp.com/2014/10/16/reading-system-logs-from-file/","excerpt":"适用于 PowerShell 所有版本 有些时候，您可能会需要读取已经导出到磁盘上的系统日志文件，或者您希望直接从一个“evtx”格式的文件中读取系统日志。 以下是实现的方法： $path = &quot;$env:windir\\System32\\Winevt\\Logs\\Setup.evtx&quot; Get-WinEvent -Path $path","text":"适用于 PowerShell 所有版本 有些时候，您可能会需要读取已经导出到磁盘上的系统日志文件，或者您希望直接从一个“evtx”格式的文件中读取系统日志。 以下是实现的方法： $path = &quot;$env:windir\\System32\\Winevt\\Logs\\Setup.evtx&quot; Get-WinEvent -Path $path 本文国际来源：Reading System Logs from File","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - WMI 搜索工具","slug":"wmi-search-tool","date":"2014-10-15T03:00:00.000Z","updated":"2017-03-17T15:26:24.523Z","comments":true,"path":"2014/10/15/wmi-search-tool/","link":"","permalink":"http://blog.vichamp.com/2014/10/15/wmi-search-tool/","excerpt":"适用于 PowerShell 所有版本 WMI 是一个很棒很强大的技术：只需要指定一个 WMI 类名，您就可以获取该类的所有实体。 PS&gt; Get-WmiObject -Class Win32_BIOS SMBIOSBIOSVersion : 76CN27WW Manufacturer : LENOVO Name : 76CN27WW SerialNumber : 1006250300406 Version : LENOVO - 1 那么如何知道有哪些 WMI 类呢？以下是一个搜索工具函数： function Find-WMIClass { param ( [Parameter(Mandatory=$true)] $SearchTerm = &apos;Resolution&apos; ) Get-WmiObject -Class * -List | Where-Object { $_.Properties.Count -ge 3 } | Where-Object { $_.Name -notlike &apos;Win32_Perf*&apos; } | Where-Object { $ListOfNames = $_.Properties | Select-Object -ExpandProperty Name ($ListOfNames -like &quot;*$SearchTerm*&quot;) -ne $null } | Sort-Object -Property Name } 只需要指定一个搜索条件。该函数将会查找所有属性名中包含搜索条件的 WMI 类（可以用通配符来扩大搜索范围）。 这段代码能搜索属性以“resolution”结尾的 WMI 类： PS&gt; Find-WMIClass -SearchTerm *resolution NameSpace: ROOT\\cimv2 Name Methods Properties ---- ------- ---------- CIM_CacheMemory {SetPowerState, R... {Access, AdditionalErr... CIM_CurrentSensor {SetPowerState, R... {Accuracy, Availabilit... CIM_FlatPanel {SetPowerState, R... {Availability, Caption... CIM_Memory {SetPowerState, R... {Access, AdditionalErr... CIM_MonitorResolution {} {Caption, Description,... CIM_NonVolatileStorage {SetPowerState, R... {Access, AdditionalErr... CIM_NumericSensor {SetPowerState, R... {Accuracy, Availabilit... CIM_PCVideoController {SetPowerState, R... {AcceleratorCapabiliti... CIM_PointingDevice {SetPowerState, R... {Availability, Caption... CIM_Printer {SetPowerState, R... {Availability, Availab... CIM_Tachometer {SetPowerState, R... {Accuracy, Availabilit... CIM_TemperatureSensor {SetPowerState, R... {Accuracy, Availabilit... CIM_VideoController {SetPowerState, R... {AcceleratorCapabiliti... CIM_VideoControllerResolution {} {Caption, Description,... CIM_VolatileStorage {SetPowerState, R... {Access, AdditionalErr... CIM_VoltageSensor {SetPowerState, R... {Accuracy, Availabilit... Win32_CacheMemory {SetPowerState, R... {Access, AdditionalErr... Win32_CurrentProbe {SetPowerState, R... {Accuracy, Availabilit... Win32_DisplayControllerConfigura... {} {BitsPerPixel, Caption... Win32_MemoryArray {SetPowerState, R... {Access, AdditionalErr... Win32_MemoryDevice {SetPowerState, R... {Access, AdditionalErr... Win32_NetworkAdapterConfiguration {EnableDHCP, Rene... {ArpAlwaysSourceRoute,... Win32_PointingDevice {SetPowerState, R... {Availability, Caption... Win32_Printer {SetPowerState, R... {Attributes, Availabil... Win32_PrinterConfiguration {} {BitsPerPel, Caption, ... Win32_SMBIOSMemory {SetPowerState, R... {Access, AdditionalErr... Win32_TemperatureProbe {SetPowerState, R... {Accuracy, Availabilit... Win32_VideoConfiguration {} {ActualColorResolution... Win32_VideoController {SetPowerState, R... {AcceleratorCapabiliti... Win32_VoltageProbe {SetPowerState, R... {Accuracy, Availabilit... 下一步，选择一个类名并观察它的实际数据： PS&gt; Get-WmiObject -Class CIM_CacheMemory | Select-Object -Property *","text":"适用于 PowerShell 所有版本 WMI 是一个很棒很强大的技术：只需要指定一个 WMI 类名，您就可以获取该类的所有实体。 PS&gt; Get-WmiObject -Class Win32_BIOS SMBIOSBIOSVersion : 76CN27WW Manufacturer : LENOVO Name : 76CN27WW SerialNumber : 1006250300406 Version : LENOVO - 1 那么如何知道有哪些 WMI 类呢？以下是一个搜索工具函数： function Find-WMIClass { param ( [Parameter(Mandatory=$true)] $SearchTerm = &apos;Resolution&apos; ) Get-WmiObject -Class * -List | Where-Object { $_.Properties.Count -ge 3 } | Where-Object { $_.Name -notlike &apos;Win32_Perf*&apos; } | Where-Object { $ListOfNames = $_.Properties | Select-Object -ExpandProperty Name ($ListOfNames -like &quot;*$SearchTerm*&quot;) -ne $null } | Sort-Object -Property Name } 只需要指定一个搜索条件。该函数将会查找所有属性名中包含搜索条件的 WMI 类（可以用通配符来扩大搜索范围）。 这段代码能搜索属性以“resolution”结尾的 WMI 类： PS&gt; Find-WMIClass -SearchTerm *resolution NameSpace: ROOT\\cimv2 Name Methods Properties ---- ------- ---------- CIM_CacheMemory {SetPowerState, R... {Access, AdditionalErr... CIM_CurrentSensor {SetPowerState, R... {Accuracy, Availabilit... CIM_FlatPanel {SetPowerState, R... {Availability, Caption... CIM_Memory {SetPowerState, R... {Access, AdditionalErr... CIM_MonitorResolution {} {Caption, Description,... CIM_NonVolatileStorage {SetPowerState, R... {Access, AdditionalErr... CIM_NumericSensor {SetPowerState, R... {Accuracy, Availabilit... CIM_PCVideoController {SetPowerState, R... {AcceleratorCapabiliti... CIM_PointingDevice {SetPowerState, R... {Availability, Caption... CIM_Printer {SetPowerState, R... {Availability, Availab... CIM_Tachometer {SetPowerState, R... {Accuracy, Availabilit... CIM_TemperatureSensor {SetPowerState, R... {Accuracy, Availabilit... CIM_VideoController {SetPowerState, R... {AcceleratorCapabiliti... CIM_VideoControllerResolution {} {Caption, Description,... CIM_VolatileStorage {SetPowerState, R... {Access, AdditionalErr... CIM_VoltageSensor {SetPowerState, R... {Accuracy, Availabilit... Win32_CacheMemory {SetPowerState, R... {Access, AdditionalErr... Win32_CurrentProbe {SetPowerState, R... {Accuracy, Availabilit... Win32_DisplayControllerConfigura... {} {BitsPerPixel, Caption... Win32_MemoryArray {SetPowerState, R... {Access, AdditionalErr... Win32_MemoryDevice {SetPowerState, R... {Access, AdditionalErr... Win32_NetworkAdapterConfiguration {EnableDHCP, Rene... {ArpAlwaysSourceRoute,... Win32_PointingDevice {SetPowerState, R... {Availability, Caption... Win32_Printer {SetPowerState, R... {Attributes, Availabil... Win32_PrinterConfiguration {} {BitsPerPel, Caption, ... Win32_SMBIOSMemory {SetPowerState, R... {Access, AdditionalErr... Win32_TemperatureProbe {SetPowerState, R... {Accuracy, Availabilit... Win32_VideoConfiguration {} {ActualColorResolution... Win32_VideoController {SetPowerState, R... {AcceleratorCapabiliti... Win32_VoltageProbe {SetPowerState, R... {Accuracy, Availabilit... 下一步，选择一个类名并观察它的实际数据： PS&gt; Get-WmiObject -Class CIM_CacheMemory | Select-Object -Property * 本文国际来源：WMI Search Tool","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 列出所有信息","slug":"list-all-information","date":"2014-10-14T03:00:00.000Z","updated":"2017-03-17T15:26:24.523Z","comments":true,"path":"2014/10/14/list-all-information/","link":"","permalink":"http://blog.vichamp.com/2014/10/14/list-all-information/","excerpt":"适用于 PowerShell 所有版本 大多数时候，PowerShell 不会显示从 cmdlet 中返回的所有信息。相反地，PowerShell 限制了只显示信息中最常见的部分。 PS&gt; Get-WmiObject -Class CIM_CacheMemory BlockSize : 1024 CacheSpeed : CacheType : 4 DeviceID : Cache Memory 0 InstalledSize : 32 Level : 3 MaxCacheSize : 32 NumberOfBlocks : 32 Status : OK (...) 要看到完整的信息，请像这样加一句 Select-Object 语句： PS&gt; Get-WmiObject -Class CIM_CacheMemory | Select-Object -Property * PSComputerName : TOBI2 DeviceID : Cache Memory 0 ErrorCorrectType : 5 Availability : 3 Status : OK StatusInfo : 3 BlockSize : 1024 CacheSpeed : CacheType : 4 InstalledSize : 32 Level : 3 MaxCacheSize : 32 NumberOfBlocks : 32 WritePolicy : 3 __GENUS : 2 __CLASS : Win32_CacheMemory __SUPERCLASS : CIM_CacheMemory __DYNASTY : CIM_ManagedSystemElement __RELPATH : Win32_CacheMemory.DeviceID=&quot;Cache Memory 0&quot; __PROPERTY_COUNT : 53 __DERIVATION : {CIM_CacheMemory, CIM_Memory, CIM_StorageExtent, CIM_LogicalDevice...} __SERVER : TOBI2 __NAMESPACE : root\\cimv2 __PATH : \\\\TOBI2\\root\\cimv2:Win32_CacheMemory.DeviceID=&quot;Cache Memory 0&quot; Access : AdditionalErrorData : Associativity : 7 Caption : Cache Memory ConfigManagerErrorCode : ConfigManagerUserConfig : CorrectableError : CreationClassName : Win32_CacheMemory CurrentSRAM : {5} Description : Cache Memory EndingAddress : ErrorAccess : ErrorAddress : ErrorCleared : ErrorData : ErrorDataOrder : ErrorDescription : ErrorInfo : ErrorMethodology : ErrorResolution : ErrorTime : ErrorTransferSize : FlushTimer : InstallDate : LastErrorCode : LineSize : Location : 0 Name : Cache Memory OtherErrorDescription : PNPDeviceID : PowerManagementCapabilities : PowerManagementSupported : Purpose : L1 Cache ReadPolicy : ReplacementPolicy : StartingAddress : SupportedSRAM : {5} SystemCreationClassName : Win32_ComputerSystem SystemLevelAddress : SystemName : TOBI2 Scope : System.Management.ManagementScope Path : \\\\TOBI2\\root\\cimv2:Win32_CacheMemory.DeviceID=&quot;Cache Memory 0&quot; Options : System.Management.ObjectGetOptions ClassPath : \\\\TOBI2\\root\\cimv2:Win32_CacheMemory Properties : {Access, AdditionalErrorData, Associativity, Availability...} SystemProperties : {__GENUS, __CLASS, __SUPERCLASS, __DYNASTY...} Qualifiers : {dynamic, Locale, provider, UUID} Site : Container : (...)","text":"适用于 PowerShell 所有版本 大多数时候，PowerShell 不会显示从 cmdlet 中返回的所有信息。相反地，PowerShell 限制了只显示信息中最常见的部分。 PS&gt; Get-WmiObject -Class CIM_CacheMemory BlockSize : 1024 CacheSpeed : CacheType : 4 DeviceID : Cache Memory 0 InstalledSize : 32 Level : 3 MaxCacheSize : 32 NumberOfBlocks : 32 Status : OK (...) 要看到完整的信息，请像这样加一句 Select-Object 语句： PS&gt; Get-WmiObject -Class CIM_CacheMemory | Select-Object -Property * PSComputerName : TOBI2 DeviceID : Cache Memory 0 ErrorCorrectType : 5 Availability : 3 Status : OK StatusInfo : 3 BlockSize : 1024 CacheSpeed : CacheType : 4 InstalledSize : 32 Level : 3 MaxCacheSize : 32 NumberOfBlocks : 32 WritePolicy : 3 __GENUS : 2 __CLASS : Win32_CacheMemory __SUPERCLASS : CIM_CacheMemory __DYNASTY : CIM_ManagedSystemElement __RELPATH : Win32_CacheMemory.DeviceID=&quot;Cache Memory 0&quot; __PROPERTY_COUNT : 53 __DERIVATION : {CIM_CacheMemory, CIM_Memory, CIM_StorageExtent, CIM_LogicalDevice...} __SERVER : TOBI2 __NAMESPACE : root\\cimv2 __PATH : \\\\TOBI2\\root\\cimv2:Win32_CacheMemory.DeviceID=&quot;Cache Memory 0&quot; Access : AdditionalErrorData : Associativity : 7 Caption : Cache Memory ConfigManagerErrorCode : ConfigManagerUserConfig : CorrectableError : CreationClassName : Win32_CacheMemory CurrentSRAM : {5} Description : Cache Memory EndingAddress : ErrorAccess : ErrorAddress : ErrorCleared : ErrorData : ErrorDataOrder : ErrorDescription : ErrorInfo : ErrorMethodology : ErrorResolution : ErrorTime : ErrorTransferSize : FlushTimer : InstallDate : LastErrorCode : LineSize : Location : 0 Name : Cache Memory OtherErrorDescription : PNPDeviceID : PowerManagementCapabilities : PowerManagementSupported : Purpose : L1 Cache ReadPolicy : ReplacementPolicy : StartingAddress : SupportedSRAM : {5} SystemCreationClassName : Win32_ComputerSystem SystemLevelAddress : SystemName : TOBI2 Scope : System.Management.ManagementScope Path : \\\\TOBI2\\root\\cimv2:Win32_CacheMemory.DeviceID=&quot;Cache Memory 0&quot; Options : System.Management.ObjectGetOptions ClassPath : \\\\TOBI2\\root\\cimv2:Win32_CacheMemory Properties : {Access, AdditionalErrorData, Associativity, Availability...} SystemProperties : {__GENUS, __CLASS, __SUPERCLASS, __DYNASTY...} Qualifiers : {dynamic, Locale, provider, UUID} Site : Container : (...) 本文国际来源：List All Information","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取美国邮政编码","slug":"getting-us-zip-codes","date":"2014-10-13T03:00:00.000Z","updated":"2017-03-17T15:26:24.507Z","comments":true,"path":"2014/10/13/getting-us-zip-codes/","link":"","permalink":"http://blog.vichamp.com/2014/10/13/getting-us-zip-codes/","excerpt":"适用于 PowerShell 所有版本 是否曾需要查找某个（美国）城市的邮政编码，或者反过来通过邮政编码查找城市的名称？ 只需要简单地用 PowerShell 连接到一个免费的 Web Service 就可以获得这些信息： $webservice = New-WebServiceProxy -Uri &apos;http://www.webservicex.net/uszip.asmx?WSDL&apos; $webservice.GetInfoByCity(&apos;New York&apos;).Table $webservice.GetInfoByZIP(&apos;10286&apos;).Table","text":"适用于 PowerShell 所有版本 是否曾需要查找某个（美国）城市的邮政编码，或者反过来通过邮政编码查找城市的名称？ 只需要简单地用 PowerShell 连接到一个免费的 Web Service 就可以获得这些信息： $webservice = New-WebServiceProxy -Uri &apos;http://www.webservicex.net/uszip.asmx?WSDL&apos; $webservice.GetInfoByCity(&apos;New York&apos;).Table $webservice.GetInfoByZIP(&apos;10286&apos;).Table 本文国际来源：Getting US ZIP Codes","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"在 PowerShell 中利用正则表达式来解析文本块","slug":"Use-Regular-Expression-to-Extract-Text-Blocks-in-PowerShell","date":"2014-10-11T08:51:28.000Z","updated":"2017-03-17T15:26:24.507Z","comments":true,"path":"2014/10/11/Use-Regular-Expression-to-Extract-Text-Blocks-in-PowerShell/","link":"","permalink":"http://blog.vichamp.com/2014/10/11/Use-Regular-Expression-to-Extract-Text-Blocks-in-PowerShell/","excerpt":"","text":"需求给定一段文本，如： 1, abcd [xxxx] vkjl gas kje asld gew wef 2, bbb [wefs] oioias wmfjalkjs 3, ccc [wegas] kzxlj kjlwiewe ii 要求分割成多段以数字开头的文本块，如： 第一块： 1, abcd [xxxx] vkjl gas kje asld gew wef 第二块： 2, bbb [wefs] oioias wmfjalkjs 第三块： 3, ccc [wegas] kzxlj kjlwiewe ii 思路 定义我们要东西为 n 个“block”。 每个“block”的特征是： 以数字开头 block 之前可能是整段文本的起始；也有可能是一个回车符。 block 之后可能是一个回车符+下一行的数字；也有可能是整段文本的结束。 block 之前和之后的回车符是不需要的 block 应该尽可能“非贪婪”，遇到下一个符合条件的，算作一个新的 block 开始。 其中，“block 之前和之后的回车符是不需要的”可以用正则表达式的“零宽断言”来解决。 代码$subject = @&apos; 1, abcd [xxxx] vkjl gas kje asld gew wef 2, bbb [wefs] oioias wmfjalkjs 3, ccc [wegas] kzxlj kjlwiewe ii &apos;@ $resultlist = new-object System.Collections.Specialized.StringCollection $regex = [regex]@&apos; (?snx)(^|(?&lt;=\\n)) (?&lt;block&gt;\\d, .*?) ((?=\\n\\d, )|$) &apos;@ $match = $regex.Match($subject) while ($match.Success) { $resultlist.Add($match.Groups[&apos;block&apos;].Value) | out-null $match = $match.NextMatch() } $resultlist | ForEach-Object { echo $_ echo --- } 输出结果1, abcd [xxxx] vkjl gas kje asld gew wef --- 2, bbb [wefs] oioias wmfjalkjs --- 3, ccc [wegas] kzxlj kjlwiewe ii ---","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"regex","slug":"regex","permalink":"http://blog.vichamp.com/tags/regex/"},{"name":"text","slug":"text","permalink":"http://blog.vichamp.com/tags/text/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}]},{"title":"PowerShell 技能连载 - 获取包含数据类型信息在内的注册表键值","slug":"reading-registry-values-with-type","date":"2014-10-10T03:00:00.000Z","updated":"2017-03-17T15:26:24.507Z","comments":true,"path":"2014/10/10/reading-registry-values-with-type/","link":"","permalink":"http://blog.vichamp.com/2014/10/10/reading-registry-values-with-type/","excerpt":"适用于 PowerShell 所有版本 读取所有注册表信息时，如果您不需要数据类型信息，那么十分简单：只需要用 Get-ItemProperty 即可： Get-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 如果您确实需要数据类新信息，那么需要做点额外的事情： $key = Get-Item -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run $key.GetValueNames() | ForEach-Object { $ValueName = $_ $rv = 1 | Select-Object -Property Name, Type, Value $rv.Name = $ValueName $rv.Type = $key.GetValueKind($ValueName) $rv.Value = $key.GetValue($ValueName) $rv }","text":"适用于 PowerShell 所有版本 读取所有注册表信息时，如果您不需要数据类型信息，那么十分简单：只需要用 Get-ItemProperty 即可： Get-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 如果您确实需要数据类新信息，那么需要做点额外的事情： $key = Get-Item -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run $key.GetValueNames() | ForEach-Object { $ValueName = $_ $rv = 1 | Select-Object -Property Name, Type, Value $rv.Name = $ValueName $rv.Type = $key.GetValueKind($ValueName) $rv.Value = $key.GetValue($ValueName) $rv } 本文国际来源：Reading Registry Values with Type","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找文件以及错误信息","slug":"finding-files-plus-errors","date":"2014-10-09T03:00:00.000Z","updated":"2017-03-17T15:26:24.492Z","comments":true,"path":"2014/10/09/finding-files-plus-errors/","link":"","permalink":"http://blog.vichamp.com/2014/10/09/finding-files-plus-errors/","excerpt":"适用于 PowerShell 所有版本 当您使用 Get-ChildItem 在目录中递归查找文件时，您有时候会遇到一些权限不足的文件夹。为了禁止错误信息，您可能会使用 -ErrorAction SilentlyContinue 的方法。 这是个不错的实践，但是您也许还希望得到一份权限不足的文件夹的清单。 以下是一段在 Windows 文件夹中搜索所有 PowerShell 脚本的脚本。它将这些文件保存在 $PSScripts 变量中。同时，它将所有的错误信息记录在 $ErrorList 变量中，并列出所有不可存取的文件夹。 $PSScripts = Get-ChildItem -Path c:\\windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable ErrorList $ErrorList | ForEach-Object { Write-Warning (&apos;Access denied: &apos; + $_.CategoryInfo.TargetName) }","text":"适用于 PowerShell 所有版本 当您使用 Get-ChildItem 在目录中递归查找文件时，您有时候会遇到一些权限不足的文件夹。为了禁止错误信息，您可能会使用 -ErrorAction SilentlyContinue 的方法。 这是个不错的实践，但是您也许还希望得到一份权限不足的文件夹的清单。 以下是一段在 Windows 文件夹中搜索所有 PowerShell 脚本的脚本。它将这些文件保存在 $PSScripts 变量中。同时，它将所有的错误信息记录在 $ErrorList 变量中，并列出所有不可存取的文件夹。 $PSScripts = Get-ChildItem -Path c:\\windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable ErrorList $ErrorList | ForEach-Object { Write-Warning (&apos;Access denied: &apos; + $_.CategoryInfo.TargetName) } 本文国际来源：Finding Files plus Errors","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找可改变的属性","slug":"finding-changeable-properties","date":"2014-10-08T03:00:00.000Z","updated":"2017-03-17T15:26:24.476Z","comments":true,"path":"2014/10/08/finding-changeable-properties/","link":"","permalink":"http://blog.vichamp.com/2014/10/08/finding-changeable-properties/","excerpt":"适用于 PowerShell 所有版本 当您从 PowerShell cmdlet 中获取结果时，返回的结果都是包含属性的对象。有些属性是可改变的，另一些是只读的。 以下是一个获取可改变的属性的简单技巧。这段代码是以当前 PowerShell 宿主的进程对象为例，但您可以用任意的 cmdlet 结果。 $myProcess = Get-Process -Id $Pid $myProcess | Get-Member -MemberType Properties | Out-String -Stream | Where-Object { $_ -like &apos;*set;*&apos; } 结果类似如下： EnableRaisingEvents Property bool EnableRaisingEvents {get;set;} MaxWorkingSet Property System.IntPtr MaxWorkingSet {get;set;} MinWorkingSet Property System.IntPtr MinWorkingSet {get;set;} PriorityBoostEnabled Property bool PriorityBoostEnabled {get;set;}","text":"适用于 PowerShell 所有版本 当您从 PowerShell cmdlet 中获取结果时，返回的结果都是包含属性的对象。有些属性是可改变的，另一些是只读的。 以下是一个获取可改变的属性的简单技巧。这段代码是以当前 PowerShell 宿主的进程对象为例，但您可以用任意的 cmdlet 结果。 $myProcess = Get-Process -Id $Pid $myProcess | Get-Member -MemberType Properties | Out-String -Stream | Where-Object { $_ -like &apos;*set;*&apos; } 结果类似如下： EnableRaisingEvents Property bool EnableRaisingEvents {get;set;} MaxWorkingSet Property System.IntPtr MaxWorkingSet {get;set;} MinWorkingSet Property System.IntPtr MinWorkingSet {get;set;} PriorityBoostEnabled Property bool PriorityBoostEnabled {get;set;} 本文国际来源：Finding Changeable Properties","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取变量详细清单","slug":"getting-a-variable-inventory","date":"2014-10-07T03:00:00.000Z","updated":"2017-03-17T15:26:24.476Z","comments":true,"path":"2014/10/07/getting-a-variable-inventory/","link":"","permalink":"http://blog.vichamp.com/2014/10/07/getting-a-variable-inventory/","excerpt":"适用于 PowerShell ISE 3 或更高版本 出于写文档等目的，您可能需要获得一份 PowerShell 脚本用到的所有变量的清单。 以下是一个名为 Get-Variable 的函数： function Get-Variable { $token = $null $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseInput($psise.CurrentFile.Editor.Text, [ref] $token, [ref] $errors) # not complete, add variables you want to exclude from the list: $systemVariables = &apos;_&apos;, &apos;null&apos;, &apos;psitem&apos;, &apos;true&apos;, &apos;false&apos;, &apos;args&apos;, &apos;host&apos; $null = $ast.FindAll({ $args[0] -is [System.Management.Automation.Language.CommandAst] }, $true) $token | Where-Object { $_.Kind -eq &apos;Variable&apos;} | Select-Object -ExpandProperty Name | Where-Object { $systemVariables -notcontains $_ } | Sort-Object -Unique } 只需要用系统自带的 ISE 编辑器打开这个脚本，然后在交互式控制台中运行 Get-Variable。 您将会得到一个排序过的列表，内容是当前打开的脚本用到的所有变量。 如果您将“$psise.CurrentFile.Editor.Text”替换成一个包含脚本代码的变量，那么您可以在 ISE 编辑器之外运行这个函数。只需要用 Get-Content 将任意脚本的内容读取进一个变量，然后就可以在上述代码中使用这个变量。","text":"适用于 PowerShell ISE 3 或更高版本 出于写文档等目的，您可能需要获得一份 PowerShell 脚本用到的所有变量的清单。 以下是一个名为 Get-Variable 的函数： function Get-Variable { $token = $null $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseInput($psise.CurrentFile.Editor.Text, [ref] $token, [ref] $errors) # not complete, add variables you want to exclude from the list: $systemVariables = &apos;_&apos;, &apos;null&apos;, &apos;psitem&apos;, &apos;true&apos;, &apos;false&apos;, &apos;args&apos;, &apos;host&apos; $null = $ast.FindAll({ $args[0] -is [System.Management.Automation.Language.CommandAst] }, $true) $token | Where-Object { $_.Kind -eq &apos;Variable&apos;} | Select-Object -ExpandProperty Name | Where-Object { $systemVariables -notcontains $_ } | Sort-Object -Unique } 只需要用系统自带的 ISE 编辑器打开这个脚本，然后在交互式控制台中运行 Get-Variable。 您将会得到一个排序过的列表，内容是当前打开的脚本用到的所有变量。 如果您将“$psise.CurrentFile.Editor.Text”替换成一个包含脚本代码的变量，那么您可以在 ISE 编辑器之外运行这个函数。只需要用 Get-Content 将任意脚本的内容读取进一个变量，然后就可以在上述代码中使用这个变量。 本文国际来源：Getting a Variable Inventory","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 重命名变量","slug":"renaming-variables","date":"2014-10-06T03:00:00.000Z","updated":"2017-03-17T15:26:24.476Z","comments":true,"path":"2014/10/06/renaming-variables/","link":"","permalink":"http://blog.vichamp.com/2014/10/06/renaming-variables/","excerpt":"适用于 PowerShell ISE 3 或更高版本 以下是一个简单的变量重命名函数，您可以在 PowerShell 3.0 及以上版本的 ISE 编辑器中使用它 它将识别某个变量的所有实例，然后将它重命名为一个新的名字。 function Rename-Variable { param ( [Parameter(Mandatory=$true)] $OldName, [Parameter(Mandatory=$true)] $NewName ) $InputText = $psise.CurrentFile.Editor.Text $token = $null $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseInput($InputText, [ref] $token, [ref] $errors) $token | Where-Object { $_.Kind -eq &apos;Variable&apos;} | Where-Object { $_.Name -eq $OldName } | Sort-Object { $_.Extent.StartOffset } -Descending | ForEach-Object { $start = $_.Extent.StartOffset + 1 $end = $_.Extent.EndOffset $InputText = $InputText.Remove($start, $end-$start).Insert($start, $NewName) } $psise.CurrentFile.Editor.Text = $InputText } 运行这个函数之后，您将得到一个名为 Rename-Variable 的新命令。 下一步，在 ISE 编辑器中打开一个脚本，然后在控制台面板中，键入以下内容（当然，需要将旧的变量名“oldVariableName”改为您当前所打开的 ISE 脚本中实际存在的变量名）。 PS&gt; Rename-Variable -OldName oldVariableName -NewName theNEWname 立刻，旧变量的所有出现的地方都被替换成新的变量名。 注意：这是一个非常简易的变量重命名函数。一定要记得备份您的脚本。它还不能算是一个能用在生产环境的重构方案。 当您重命名变量时，您脚本的许多别处地方也可能需要更新。例如，当一个变量是函数参数时，所有调用该函数的地方都得修改它们的参数名。","text":"适用于 PowerShell ISE 3 或更高版本 以下是一个简单的变量重命名函数，您可以在 PowerShell 3.0 及以上版本的 ISE 编辑器中使用它 它将识别某个变量的所有实例，然后将它重命名为一个新的名字。 function Rename-Variable { param ( [Parameter(Mandatory=$true)] $OldName, [Parameter(Mandatory=$true)] $NewName ) $InputText = $psise.CurrentFile.Editor.Text $token = $null $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseInput($InputText, [ref] $token, [ref] $errors) $token | Where-Object { $_.Kind -eq &apos;Variable&apos;} | Where-Object { $_.Name -eq $OldName } | Sort-Object { $_.Extent.StartOffset } -Descending | ForEach-Object { $start = $_.Extent.StartOffset + 1 $end = $_.Extent.EndOffset $InputText = $InputText.Remove($start, $end-$start).Insert($start, $NewName) } $psise.CurrentFile.Editor.Text = $InputText } 运行这个函数之后，您将得到一个名为 Rename-Variable 的新命令。 下一步，在 ISE 编辑器中打开一个脚本，然后在控制台面板中，键入以下内容（当然，需要将旧的变量名“oldVariableName”改为您当前所打开的 ISE 脚本中实际存在的变量名）。 PS&gt; Rename-Variable -OldName oldVariableName -NewName theNEWname 立刻，旧变量的所有出现的地方都被替换成新的变量名。 注意：这是一个非常简易的变量重命名函数。一定要记得备份您的脚本。它还不能算是一个能用在生产环境的重构方案。 当您重命名变量时，您脚本的许多别处地方也可能需要更新。例如，当一个变量是函数参数时，所有调用该函数的地方都得修改它们的参数名。 本文国际来源：Renaming Variables","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 格式化行尾符","slug":"normalizing-line-endings","date":"2014-10-03T03:00:00.000Z","updated":"2017-03-17T15:26:24.454Z","comments":true,"path":"2014/10/03/normalizing-line-endings/","link":"","permalink":"http://blog.vichamp.com/2014/10/03/normalizing-line-endings/","excerpt":"适用于 PowerShell 所有版本 当您从 Internet 中下载了文件之后，您也许会遇到文件无法在编辑器中正常打开的情况。最常见的是，由于非正常行尾符导致的。 以下是这个问题的一个例子。在前一个技能里我们演示了如何下载一份 MAC 地址的厂家清单。当下载完成后用记事本打开它时，换行都消失了： $url = &apos;http://standards.ieee.org/develop/regauth/oui/oui.txt&apos; $outfile = &quot;$home\\vendorlist.txt&quot; Invoke-WebRequest -Uri $url -OutFile $outfile Invoke-Item -Path $outfile 要修复这个文件，只需要使用这段代码： $OldFile = &quot;$home\\vendorlist.txt&quot; $NewFile = &quot;$home\\vendorlistGood.txt&quot; Get-Content $OldFile | Set-Content -Path $NewFile notepad $NewFile Get-Content 能够检测非标准的行尾符，所以结果是各行的字符串数组。当您将这些行写入一个新文件时，一切都会变正常，因为 Set-Content 会使用缺省的行尾符。","text":"适用于 PowerShell 所有版本 当您从 Internet 中下载了文件之后，您也许会遇到文件无法在编辑器中正常打开的情况。最常见的是，由于非正常行尾符导致的。 以下是这个问题的一个例子。在前一个技能里我们演示了如何下载一份 MAC 地址的厂家清单。当下载完成后用记事本打开它时，换行都消失了： $url = &apos;http://standards.ieee.org/develop/regauth/oui/oui.txt&apos; $outfile = &quot;$home\\vendorlist.txt&quot; Invoke-WebRequest -Uri $url -OutFile $outfile Invoke-Item -Path $outfile 要修复这个文件，只需要使用这段代码： $OldFile = &quot;$home\\vendorlist.txt&quot; $NewFile = &quot;$home\\vendorlistGood.txt&quot; Get-Content $OldFile | Set-Content -Path $NewFile notepad $NewFile Get-Content 能够检测非标准的行尾符，所以结果是各行的字符串数组。当您将这些行写入一个新文件时，一切都会变正常，因为 Set-Content 会使用缺省的行尾符。 本文国际来源：Normalizing Line Endings","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通过 MAC 地址识别网卡厂家","slug":"identifying-network-vendors-by-mac-address","date":"2014-10-02T03:00:00.000Z","updated":"2017-03-17T15:26:24.454Z","comments":true,"path":"2014/10/02/identifying-network-vendors-by-mac-address/","link":"","permalink":"http://blog.vichamp.com/2014/10/02/identifying-network-vendors-by-mac-address/","excerpt":"适用于 PowerShell 所有版本 每个 MAC 地址唯一标识了一个网络设备。MAC 地址是由网络设备厂家分配的。所以您可以通过任何一个 MAC 地址反查出厂家信息。 您所需的只是一份大约 2MB 大小的 IEEE 厂家清单。以下是下载该清单的脚本： $url = &apos;http://standards.ieee.org/develop/regauth/oui/oui.txt&apos; $outfile = &quot;$home\\vendorlist.txt&quot; Invoke-WebRequest -Uri $url -OutFile $outfile 下一步，您可以使用该清单来识别厂家信息。首先获取 MAC 地址，例如： PS&gt; getmac Physical Address Transport Name =================== ========================================================== 5C-51-4F-62-F2-7D \\Device\\Tcpip_{FF034A81-CBFE-4B11-9D81-FC8FC889A33C} 5C-51-4F-62-F2-81 Media disconnected 取 MAC 地址的前 3 个 8 进制字符，例如 5c-51-4f，然后用它在下载的文件中查询： PS&gt; Get-Content -Path $outfile | Select-String 5c-51-4f -Context 0,6 &gt; 5C-51-4F (hex) Intel Corporate 5C514F (base 16) Intel Corporate Lot 8, Jalan Hi-Tech 2/3 Kulim Hi-Tech Park Kulim Kedah 09000 MALAYSIA 您不仅可以获取厂家名称（这个例子中是 Intel），而且还可以获取厂家的地址和所在区域。","text":"适用于 PowerShell 所有版本 每个 MAC 地址唯一标识了一个网络设备。MAC 地址是由网络设备厂家分配的。所以您可以通过任何一个 MAC 地址反查出厂家信息。 您所需的只是一份大约 2MB 大小的 IEEE 厂家清单。以下是下载该清单的脚本： $url = &apos;http://standards.ieee.org/develop/regauth/oui/oui.txt&apos; $outfile = &quot;$home\\vendorlist.txt&quot; Invoke-WebRequest -Uri $url -OutFile $outfile 下一步，您可以使用该清单来识别厂家信息。首先获取 MAC 地址，例如： PS&gt; getmac Physical Address Transport Name =================== ========================================================== 5C-51-4F-62-F2-7D \\Device\\Tcpip_{FF034A81-CBFE-4B11-9D81-FC8FC889A33C} 5C-51-4F-62-F2-81 Media disconnected 取 MAC 地址的前 3 个 8 进制字符，例如 5c-51-4f，然后用它在下载的文件中查询： PS&gt; Get-Content -Path $outfile | Select-String 5c-51-4f -Context 0,6 &gt; 5C-51-4F (hex) Intel Corporate 5C514F (base 16) Intel Corporate Lot 8, Jalan Hi-Tech 2/3 Kulim Hi-Tech Park Kulim Kedah 09000 MALAYSIA 您不仅可以获取厂家名称（这个例子中是 Intel），而且还可以获取厂家的地址和所在区域。 本文国际来源：Identifying Network Vendors by MAC Address","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取 MAC 地址","slug":"getting-mac-addresses","date":"2014-10-01T03:00:00.000Z","updated":"2017-03-17T15:26:24.454Z","comments":true,"path":"2014/10/01/getting-mac-addresses/","link":"","permalink":"http://blog.vichamp.com/2014/10/01/getting-mac-addresses/","excerpt":"适用于 PowerShell 所有版本 在 PowerShell 中获取网卡的 MAC 地址十分简单。以下是众多方法中的一个： PS&gt; getmac /FO CSV | ConvertFrom-Csv Physical Address Transport Name ---------------- -------------- 5C-51-4F-62-F2-7D \\Device\\Tcpip_{FF034A81-CBFE-4B11-9D... 5C-51-4F-62-F2-81 Media disconnected 有挑战性的地方在于实际的列名是本地化的，不同语言文化的值差异很大。由于原始信息是来自于 getmac.exe 生成的 CSV 数据，所以有一个简单的技巧：跳过首行（包含 CSV 头部），然后传入自定义的统一列名，以达到对列重命名的效果。 getmac.exe /FO CSV | Select-Object -Skip 1 | ConvertFrom-Csv -Header MAC, Transport 这将总是产生“MAC”和“Transport”的列。 当然，也有面向对象的解决方案，例如通过 WMI 查询或者使用 Windows 8.1 或 Server 2012/2012 R2。不过，我们认为所演示的方法是一个有趣的选择并且展示了如何将原始的 CSV 数据转换为真正有用的和语言文化无关的信息。","text":"适用于 PowerShell 所有版本 在 PowerShell 中获取网卡的 MAC 地址十分简单。以下是众多方法中的一个： PS&gt; getmac /FO CSV | ConvertFrom-Csv Physical Address Transport Name ---------------- -------------- 5C-51-4F-62-F2-7D \\Device\\Tcpip_{FF034A81-CBFE-4B11-9D... 5C-51-4F-62-F2-81 Media disconnected 有挑战性的地方在于实际的列名是本地化的，不同语言文化的值差异很大。由于原始信息是来自于 getmac.exe 生成的 CSV 数据，所以有一个简单的技巧：跳过首行（包含 CSV 头部），然后传入自定义的统一列名，以达到对列重命名的效果。 getmac.exe /FO CSV | Select-Object -Skip 1 | ConvertFrom-Csv -Header MAC, Transport 这将总是产生“MAC”和“Transport”的列。 当然，也有面向对象的解决方案，例如通过 WMI 查询或者使用 Windows 8.1 或 Server 2012/2012 R2。不过，我们认为所演示的方法是一个有趣的选择并且展示了如何将原始的 CSV 数据转换为真正有用的和语言文化无关的信息。 本文国际来源：Getting MAC Addresses","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 高级文本分隔","slug":"advanced-text-splitting","date":"2014-09-30T03:00:00.000Z","updated":"2017-03-17T15:26:24.454Z","comments":true,"path":"2014/09/30/advanced-text-splitting/","link":"","permalink":"http://blog.vichamp.com/2014/09/30/advanced-text-splitting/","excerpt":"适用于 PowerShell 所有版本 当您用 -split 操作符来分隔文本时，分隔符本身会被忽略掉： PS&gt; &apos;Hello, this is a text, and it has commas&apos; -split &apos;,&apos; Hello this is a text and it has commas 如您所见，结果中的逗号被忽略掉了。 分隔符有可能多于一个字符。以下代码将以逗号 + 一个空格作为分隔符： PS&gt; &apos;Hello, this is a text, and it has commas&apos; -split &apos;, &apos; Hello this is a text and it has commas 由于 -split 接受的操作数是一个正则表达式，所以以下代码将以逗号 + 至少一个空格作为分隔符： PS&gt; &apos;Hello, this is a text, and it has commas&apos; -split &apos;,\\s{1,}&apos; Hello this is a text and it has commas 如果您需要的话，可以用 (?=…) 把分隔符包裹起来，以在结果中保留分隔符： PS&gt; &apos;Hello, this is a text, and it has commas&apos; -split &apos;(?=,\\s{1,})&apos; Hello , this is a text , and it has commas","text":"适用于 PowerShell 所有版本 当您用 -split 操作符来分隔文本时，分隔符本身会被忽略掉： PS&gt; &apos;Hello, this is a text, and it has commas&apos; -split &apos;,&apos; Hello this is a text and it has commas 如您所见，结果中的逗号被忽略掉了。 分隔符有可能多于一个字符。以下代码将以逗号 + 一个空格作为分隔符： PS&gt; &apos;Hello, this is a text, and it has commas&apos; -split &apos;, &apos; Hello this is a text and it has commas 由于 -split 接受的操作数是一个正则表达式，所以以下代码将以逗号 + 至少一个空格作为分隔符： PS&gt; &apos;Hello, this is a text, and it has commas&apos; -split &apos;,\\s{1,}&apos; Hello this is a text and it has commas 如果您需要的话，可以用 (?=…) 把分隔符包裹起来，以在结果中保留分隔符： PS&gt; &apos;Hello, this is a text, and it has commas&apos; -split &apos;(?=,\\s{1,})&apos; Hello , this is a text , and it has commas 本文国际来源：Advanced Text Splitting","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"快速选取百度云盘文件","slug":"quick-selection-on-baidu-pan","date":"2014-09-29T03:39:47.000Z","updated":"2017-03-17T15:26:24.438Z","comments":true,"path":"2014/09/29/quick-selection-on-baidu-pan/","link":"","permalink":"http://blog.vichamp.com/2014/09/29/quick-selection-on-baidu-pan/","excerpt":"","text":"网页版百度云盘一次性只能选取 100 个文件。如果我要对 500 个文件做批量操作就很困难了。 这时候我们可以在浏览器的地址栏内敲入这行代码，就自动帮您勾选前 100 个文件（夹）了： javascript:$(&quot;span[node-type=&apos;chk&apos;]:lt(101)&quot;).addClass(&quot;chked&quot;)","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/categories/javascript/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/categories/javascript/"}]},{"title":"PowerShell 技能连载 - 分隔文本","slug":"text-splitting","date":"2014-09-29T03:00:00.000Z","updated":"2017-03-17T15:26:24.438Z","comments":true,"path":"2014/09/29/text-splitting/","link":"","permalink":"http://blog.vichamp.com/2014/09/29/text-splitting/","excerpt":"适用于 PowerShell 所有版本 我们可以用 -split 操作符按指定的分隔符来分隔文本。这个操作符接受一个正则表达式作为操作数，所以如果您只是希望用纯文本的表达式来作为分隔的操作数，那么您需要将该纯文本转义一下。 以下是用反斜杠来分隔路径的例子： $originalText = &apos;c:\\windows\\test\\file.txt&apos; $splitText = [RegEx]::Escape(&apos;\\&apos;) $originalText -split $splitText 结果类似如下，并且它是一个数组： PS&gt; $originalText -split $splitText c: windows test file.txt 我们可以将它保存到一个变量中，然后存取单个的数组元素。 PS&gt; $parts = $originalText -split $splitText PS&gt; $parts[0] c: PS&gt; $parts[-1] file.txt","text":"适用于 PowerShell 所有版本 我们可以用 -split 操作符按指定的分隔符来分隔文本。这个操作符接受一个正则表达式作为操作数，所以如果您只是希望用纯文本的表达式来作为分隔的操作数，那么您需要将该纯文本转义一下。 以下是用反斜杠来分隔路径的例子： $originalText = &apos;c:\\windows\\test\\file.txt&apos; $splitText = [RegEx]::Escape(&apos;\\&apos;) $originalText -split $splitText 结果类似如下，并且它是一个数组： PS&gt; $originalText -split $splitText c: windows test file.txt 我们可以将它保存到一个变量中，然后存取单个的数组元素。 PS&gt; $parts = $originalText -split $splitText PS&gt; $parts[0] c: PS&gt; $parts[-1] file.txt 本文国际来源：Text Splitting","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 下载 imooc.com 的视频教程","slug":"download-videos-from-imooc-com-by-powershell","date":"2014-09-26T09:39:12.000Z","updated":"2017-03-17T15:26:24.423Z","comments":true,"path":"2014/09/26/download-videos-from-imooc-com-by-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/09/26/download-videos-from-imooc-com-by-powershell/","excerpt":"这是一个从 http://www.imooc.com 教学网站批量下载视频的 PowerShell 脚本。默认下载的是最高清晰度的视频。 按课程专辑 URL 下载您可以传入课程专辑的 URL 作为下载参数： .\\Download-Imooc.ps1 http://www.imooc.com/learn/197 按课程专辑 ID 下载可以一口气传入多个课程专辑的 ID 作为参数： .\\Download-Imooc.ps1 75,197 自动续传如果不传任何参数的话，将在当前文件夹中搜索已下载的课程，并自动续传。 .\\Download-Imooc.ps1 自动合并视频如果希望自动合并所有视频，请使用 -Combine 参数。该参数可以和其它参数同时使用。 .\\Download-Imooc.ps1 -Combine 关于代码中用到了参数分组、-WhatIf 处理等技术，供参考。 以下是源代码：","text":"这是一个从 http://www.imooc.com 教学网站批量下载视频的 PowerShell 脚本。默认下载的是最高清晰度的视频。 按课程专辑 URL 下载您可以传入课程专辑的 URL 作为下载参数： .\\Download-Imooc.ps1 http://www.imooc.com/learn/197 按课程专辑 ID 下载可以一口气传入多个课程专辑的 ID 作为参数： .\\Download-Imooc.ps1 75,197 自动续传如果不传任何参数的话，将在当前文件夹中搜索已下载的课程，并自动续传。 .\\Download-Imooc.ps1 自动合并视频如果希望自动合并所有视频，请使用 -Combine 参数。该参数可以和其它参数同时使用。 .\\Download-Imooc.ps1 -Combine 关于代码中用到了参数分组、-WhatIf 处理等技术，供参考。 以下是源代码： # Require PowerShell 3.0 or higher. [CmdletBinding(DefaultParameterSetName=&apos;URI&apos;, SupportsShouldProcess=$true, ConfirmImpact=&apos;Medium&apos;)] Param ( [Parameter(ParameterSetName=&apos;URI&apos;,Position = 0)] [string] $Uri, # &apos;http://www.imooc.com/learn/197&apos; [Parameter(ParameterSetName=&apos;ID&apos;, Position = 0)] [int[]] $ID, # @(75, 197) [Switch] $Combine, # = $true [Switch] $RemoveOriginal ) # $DebugPreference = &apos;Continue&apos; # Continue, SilentlyContinue # $WhatIfPreference = $true # $true, $false # 修正文件名，将文件系统不支持的字符替换成“.” function Fix-FileName { Param ( $FileName ) [System.IO.Path]::GetInvalidFileNameChars() | ForEach-Object { $FileName = $FileName.Replace($_, &apos;.&apos;) } return $FileName } # 修正目录名，将文件系统不支持的字符替换成“.” function Fix-FolderName { Param ( $FolderName ) [System.IO.Path]::GetInvalidPathChars() | ForEach-Object { $FolderName = $FolderName.Replace($_, &apos;.&apos;) } return $FolderName } # 从专辑页面中分析标题和视频页面的 ID。 function Get-ID { Param ( $Uri ) $Uri = $Uri.Replace(&apos;/view/&apos;, &apos;/learn/&apos;) $Uri = $Uri.Replace(&apos;/qa/&apos;, &apos;/learn/&apos;) $Uri = $Uri.Replace(&apos;/note/&apos;, &apos;/learn/&apos;) $Uri = $Uri.Replace(&apos;/wiki/&apos;, &apos;/learn/&apos;) $response = Invoke-WebRequest $Uri $title = $response.ParsedHtml.title echo $title $links = $response.Links $links | ForEach-Object { if ($_.href -cmatch &apos;(?m)^/video/(\\d+)$&apos;) { return [PSCustomObject][Ordered]@{ Title = $_.InnerText; ID = $Matches[1] } } } } # 获取视频下载地址。 function Get-VideoUri { Param ( [Parameter(ValueFromPipeline=$true)] $ID ) $template = &apos;http://www.imooc.com/course/ajaxmediainfo/?mid={0}&amp;mode=flash&apos; $uri = $template -f $ID Write-Debug $uri $result = Invoke-RestMethod $uri if ($result.result -ne 0) { Write-Warning $result.result } $uri = $result.data.result.mpath.&apos;0&apos; # 取最高清晰度的版本。 $uri = $uri.Replace(&apos;L.flv&apos;, &apos;H.flv&apos;).Replace(&apos;M.flv&apos;, &apos;H.flv&apos;) return $uri } # 创建“.url”快捷方式。 function New-ShortCut { Param ( $Title, $Uri ) $shell = New-Object -ComObject &apos;wscript.shell&apos; $dir = pwd $path = Join-Path $dir &quot;$Title\\$Title.url&quot; $lnk = $shell.CreateShortcut($path) $lnk.TargetPath = $Uri $lnk.Save() } function Assert-PSVersion { if (($PSVersionTable.PSCompatibleVersions | Where-Object Major -ge 3).Count -eq 0) { Write-Error &apos;请安装 PowerShell 3.0 以上的版本。&apos; exit } } function Get-ExistingCourses { Get-ChildItem -Directory | ForEach-Object { $folder = $_ $expectedFilePath = (Join-Path $folder $folder.Name) + &apos;.url&apos; if (Test-Path -PathType Leaf $expectedFilePath) { $shell = New-Object -ComObject &apos;wscript.shell&apos; $lnk = $shell.CreateShortcut($expectedFilePath) $targetPath = $lnk.TargetPath if ($targetPath -cmatch &apos;(?m)\\A^http://www\\.imooc\\.com/\\w+/\\d+$\\z&apos;) { echo $targetPath } } } } # 下载课程。 function Download-Course { Param ( [string]$Uri ) Write-Progress -Activity &apos;下载视频&apos; -Status &apos;分析视频 ID&apos; $title, $ids = Get-ID -Uri $Uri Write-Output &quot;课程名称：$title&quot; Write-Debug $title $folderName = Fix-FolderName $title Write-Debug $folderName if (-not (Test-Path $folderName)) { $null = mkdir $folderName } New-ShortCut -Title $title -Uri $Uri $outputPathes = New-Object System.Collections.ArrayList $actualDownloadAny = $false #$ids = $ids | Select-Object -First 3 $ids | ForEach-Object { if ($_.Title -cnotmatch &apos;(?m)^\\d&apos;) { return } $title = $_.Title Write-Progress -Activity &apos;下载视频&apos; -Status &apos;获取视频地址&apos; $videoUrl = Get-VideoUri $_.ID $extension = ($videoUrl -split &apos;\\.&apos;)[-1] $title = Fix-FileName $title $outputPath = &quot;$folderName\\$title.$extension&quot; $null = $outputPathes.Add($outputPath) Write-Output $title Write-Debug $videoUrl Write-Debug $outputPath if (Test-Path $outputPath) { Write-Debug &quot;目标文件 $outputPath 已存在，自动跳过&quot; } else { Write-Progress -Activity &apos;下载视频&apos; -Status &quot;下载《$title》视频文件&quot; if ($PSCmdlet.ShouldProcess(&quot;$videoUrl&quot;, &apos;Invoke-WebRequest&apos;)) { Invoke-WebRequest -Uri $videoUrl -OutFile $outputPath $actualDownloadAny = $true } } } $targetFile = &quot;$folderName\\$folderName.flv&quot; #if ($Combine -and ($actualDownloadAny -or -not (Test-Path $targetFile))) { if ($Combine) { # -and ($actualDownloadAny -or -not (Test-Path $targetFile))) { if ($actualDownloadAny -or -not (Test-Path $targetFile) -or (Test-Path $targetFile) -and $PSCmdlet.ShouldProcess(&apos;分段视频&apos;, &apos;合并&apos;)) { Write-Progress -Activity &apos;下载视频&apos; -Status &apos;合并视频&apos; Write-Output (&quot;合并视频（共 {0:N0} 个）&quot; -f $outputPathes.Count) $outputPathes.Insert(0, $targetFile) $eap = $ErrorActionPreference $ErrorActionPreference = &quot;SilentlyContinue&quot; .\\FlvBind.exe $outputPathes.ToArray() $ErrorActionPreference = $eap &lt;# $outputPathes = $outputPathes | ForEach-Object { &quot;`&quot;$_`&quot;&quot; } Start-Process ` -WorkingDirectory (pwd) ` -FilePath .\\FlvBind.exe ` -ArgumentList $outputPathes ` -NoNewWindow ` -Wait ` -ErrorAction SilentlyContinue ` -WindowStyle Hidden #&gt; if ($?) { Write-Output &apos;视频合并成功&apos; if ($RemoveOriginal -and $PSCmdlet.ShouldProcess(&apos;分段视频&apos;, &apos;删除&apos;)) { $outputPathes.RemoveAt(0) $outputPathes | ForEach-Object { Remove-Item $_ } Write-Output &apos;原始视频删除完毕&apos; } } else { Write-Warning &apos;视频合并失败&apos; } } } } Assert-PSVersion # 判断参数集 $chosen= $PSCmdlet.ParameterSetName if ($chosen -eq &apos;URI&apos;) { if ($Uri) { Download-Course $Uri } else { Get-ExistingCourses | ForEach-Object { Download-Course $_ } } } if ($chosen -eq &apos;ID&apos;) { $template = &apos;http://www.imooc.com/learn/{0}&apos; $ID | ForEach-Object { $Uri = $template -f $_ Download-Course $Uri } } 您也可以从这里下载完整的代码。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"video","slug":"video","permalink":"http://blog.vichamp.com/tags/video/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 替换重复的空格","slug":"replacing-duplicate-spaces","date":"2014-09-26T03:00:00.000Z","updated":"2017-03-17T15:26:24.423Z","comments":true,"path":"2014/09/26/replacing-duplicate-spaces/","link":"","permalink":"http://blog.vichamp.com/2014/09/26/replacing-duplicate-spaces/","excerpt":"适用于 PowerShell 所有版本 要删除重复的空格，请使用这个正则表达式： PS&gt; &apos;[ Man, it works! ]&apos; -replace &apos;\\s{2,}&apos;, &apos; &apos; [ Man, it works! ] 您也可以用这种方式将固定宽度的文本表格转成 CSV 数据： PS&gt; (qprocess) -replace &apos;\\s{2,}&apos;, &apos;,&apos; &gt;tobias,console,1,3876,taskhostex.exe &gt;tobias,console,1,3844,explorer.exe &gt;tobias,console,1,4292,tabtip.exe 当得到 CSV 数据之后，您可以用 ConvertFrom-Csv 将文本数据转换为对象： PS&gt; (qprocess) -replace &apos;\\s{2,}&apos;, &apos;,&apos; | ConvertFrom-Csv -Header Name, Session, ID, Pid, Process Name : &gt;tobias Session : console ID : 1 Pid : 3876 Process : taskhostex.exe Name : &gt;tobias Session : console ID : 1 Pid : 3844 Process : explorer.exe Name : &gt;tobias Session : console ID : 1 Pid : 4292 Process : tabtip.exe (...)","text":"适用于 PowerShell 所有版本 要删除重复的空格，请使用这个正则表达式： PS&gt; &apos;[ Man, it works! ]&apos; -replace &apos;\\s{2,}&apos;, &apos; &apos; [ Man, it works! ] 您也可以用这种方式将固定宽度的文本表格转成 CSV 数据： PS&gt; (qprocess) -replace &apos;\\s{2,}&apos;, &apos;,&apos; &gt;tobias,console,1,3876,taskhostex.exe &gt;tobias,console,1,3844,explorer.exe &gt;tobias,console,1,4292,tabtip.exe 当得到 CSV 数据之后，您可以用 ConvertFrom-Csv 将文本数据转换为对象： PS&gt; (qprocess) -replace &apos;\\s{2,}&apos;, &apos;,&apos; | ConvertFrom-Csv -Header Name, Session, ID, Pid, Process Name : &gt;tobias Session : console ID : 1 Pid : 3876 Process : taskhostex.exe Name : &gt;tobias Session : console ID : 1 Pid : 3844 Process : explorer.exe Name : &gt;tobias Session : console ID : 1 Pid : 4292 Process : tabtip.exe (...) 本文国际来源：Replacing Duplicate Spaces","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建短网址","slug":"creating-tinyurls","date":"2014-09-25T03:00:00.000Z","updated":"2017-03-17T15:26:24.407Z","comments":true,"path":"2014/09/25/creating-tinyurls/","link":"","permalink":"http://blog.vichamp.com/2014/09/25/creating-tinyurls/","excerpt":"适用于 PowerShell 所有版本 您也许听说过长网址的缩短服务。有许多这类免费的服务。以下是一个将任何网址转化为短网址的脚本： $OriginalURL = &apos;http://www.powertheshell.com/isesteroids2&apos; $url = &quot;http://tinyurl.com/api-create.php?url=$OriginalURL&quot; $webclient = New-Object -TypeName System.Net.WebClient $webclient.DownloadString($url) 只需要将需要缩短的网址赋给 $OriginalURL，运行脚本。它将返回对应的短网址。","text":"适用于 PowerShell 所有版本 您也许听说过长网址的缩短服务。有许多这类免费的服务。以下是一个将任何网址转化为短网址的脚本： $OriginalURL = &apos;http://www.powertheshell.com/isesteroids2&apos; $url = &quot;http://tinyurl.com/api-create.php?url=$OriginalURL&quot; $webclient = New-Object -TypeName System.Net.WebClient $webclient.DownloadString($url) 只需要将需要缩短的网址赋给 $OriginalURL，运行脚本。它将返回对应的短网址。 本文国际来源：Creating TinyURLs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找 PowerShell 函数","slug":"finding-powershell-functions","date":"2014-09-24T03:00:00.000Z","updated":"2017-03-17T15:26:24.391Z","comments":true,"path":"2014/09/24/finding-powershell-functions/","link":"","permalink":"http://blog.vichamp.com/2014/09/24/finding-powershell-functions/","excerpt":"适用于 PowerShell 3.0 或更高版本 要快速扫描您的 PowerShell 脚本仓库并在其中查找某个函数，请使用以下过滤器： filter Find-Function { $path = $_.FullName $lastwrite = $_.LastWriteTime $text = Get-Content -Path $path if ($text.Length -gt 0) { $token = $null $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseInput($text, [ref] $token, [ref] $errors) $ast.FindAll({ $args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst] }, $true) | Select-Object -Property Name, Path, LastWriteTime | ForEach-Object { $_.Path = $path $_.LastWriteTime = $lastwrite $_ } } } 以下是扫描您的用户配置文件中所有定义了函数的 PowerShell 脚本的方法： PS&gt; dir $home -Filter .ps1 -Recurse -Exclude .ps1xml | Find-Function Name Path LastWriteTime ---- ---- ------------- Inject-LogonCredentials C:\\Users\\Tobias\\Desktop... 06.01.2014 02:43:00 Test-Command C:\\Users\\Tobias\\Desktop... 06.03.2014 10:17:02 Test C:\\Users\\Tobias\\Desktop... 30.01.2014 09:32:20 Get-WebPictureOriginal C:\\Users\\Tobias\\Desktop... 11.12.2013 11:37:53 Get-ConnectionString C:\\Users\\Tobias\\Documen... 23.05.2014 10:49:09 Convert-SID2User C:\\Users\\Tobias\\Documen... 23.05.2014 15:33:06 Lock-Screen C:\\Users\\Tobias\\Documen... 19.03.2014 12:51:54 Show-OpenFileDialog C:\\Users\\Tobias\\Documen... 16.05.2014 13:42:16 Show-UniversalData C:\\Users\\Tobias\\Documen... 16.05.2014 13:23:20 Start-TimebombMemory C:\\Users\\Tobias\\Documen... 23.05.2014 09:12:28 Stop-TimebombMemory C:\\Users\\Tobias\\Documen... 23.05.2014 09:12:28 (...) 只需要将结果通过管道输出到 Out-GridView 就能查看完整的信息。","text":"适用于 PowerShell 3.0 或更高版本 要快速扫描您的 PowerShell 脚本仓库并在其中查找某个函数，请使用以下过滤器： filter Find-Function { $path = $_.FullName $lastwrite = $_.LastWriteTime $text = Get-Content -Path $path if ($text.Length -gt 0) { $token = $null $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseInput($text, [ref] $token, [ref] $errors) $ast.FindAll({ $args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst] }, $true) | Select-Object -Property Name, Path, LastWriteTime | ForEach-Object { $_.Path = $path $_.LastWriteTime = $lastwrite $_ } } } 以下是扫描您的用户配置文件中所有定义了函数的 PowerShell 脚本的方法： PS&gt; dir $home -Filter .ps1 -Recurse -Exclude .ps1xml | Find-Function Name Path LastWriteTime ---- ---- ------------- Inject-LogonCredentials C:\\Users\\Tobias\\Desktop... 06.01.2014 02:43:00 Test-Command C:\\Users\\Tobias\\Desktop... 06.03.2014 10:17:02 Test C:\\Users\\Tobias\\Desktop... 30.01.2014 09:32:20 Get-WebPictureOriginal C:\\Users\\Tobias\\Desktop... 11.12.2013 11:37:53 Get-ConnectionString C:\\Users\\Tobias\\Documen... 23.05.2014 10:49:09 Convert-SID2User C:\\Users\\Tobias\\Documen... 23.05.2014 15:33:06 Lock-Screen C:\\Users\\Tobias\\Documen... 19.03.2014 12:51:54 Show-OpenFileDialog C:\\Users\\Tobias\\Documen... 16.05.2014 13:42:16 Show-UniversalData C:\\Users\\Tobias\\Documen... 16.05.2014 13:23:20 Start-TimebombMemory C:\\Users\\Tobias\\Documen... 23.05.2014 09:12:28 Stop-TimebombMemory C:\\Users\\Tobias\\Documen... 23.05.2014 09:12:28 (...) 只需要将结果通过管道输出到 Out-GridView 就能查看完整的信息。 本文国际来源：Finding PowerShell Functions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 电子书合集","slug":"powershell-ebooks-collection","date":"2014-09-24T02:36:29.000Z","updated":"2017-03-17T15:26:24.391Z","comments":true,"path":"2014/09/24/powershell-ebooks-collection/","link":"","permalink":"http://blog.vichamp.com/2014/09/24/powershell-ebooks-collection/","excerpt":"","text":"搜集到的所有 PowerShell 电子书 共享链接将来一旦有更新，就会自动同步、自动更新，再也不用为资料发愁了。如果您也有好料想一起分享，请在群里发个消息，我把读写权限给您。 最好在客户端的 文件夹 / 偏好设定 中的 搜索 DHT 网络 前打上勾，可以提高成功率 :)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"ebook","slug":"ebook","permalink":"http://blog.vichamp.com/tags/ebook/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 导出服务状态信息","slug":"dumping-service-state-information","date":"2014-09-23T03:00:00.000Z","updated":"2017-03-17T15:26:24.391Z","comments":true,"path":"2014/09/23/dumping-service-state-information/","link":"","permalink":"http://blog.vichamp.com/2014/09/23/dumping-service-state-information/","excerpt":"适用于 PowerShell 所有版本 如果您想将一个 PowerShell 命令的结果保存到磁盘上，以便传到另一台机器上，以下是简单的实现方法： $Path = &quot;$env:temp\\mylist.xml&quot; Get-Service | Add-Member -MemberType NoteProperty -Name ComputerName -Value $env:COMPUTERNAME -PassThru | Export-Clixml -Depth 1 -Path $Path explorer.exe &quot;/select,$Path&quot; 这段代码用 Get-Service 获取所有的服务。结果添加了一个“ComputerName”字段，用于保存生成的数据所在的计算机名。 然后，得到的结果被序列化成 XML 并保存到磁盘上。接着在目标文件夹打开资源管理器，并且选中创建的 XML 文件。这样您就可以方便地将它拷到 U 盘中随身带走。 要将结果反序列化成真实的对象，使用以下代码： $Path = &quot;$env:temp\\mylist.xml&quot; Import-Clixml -Path $Path","text":"适用于 PowerShell 所有版本 如果您想将一个 PowerShell 命令的结果保存到磁盘上，以便传到另一台机器上，以下是简单的实现方法： $Path = &quot;$env:temp\\mylist.xml&quot; Get-Service | Add-Member -MemberType NoteProperty -Name ComputerName -Value $env:COMPUTERNAME -PassThru | Export-Clixml -Depth 1 -Path $Path explorer.exe &quot;/select,$Path&quot; 这段代码用 Get-Service 获取所有的服务。结果添加了一个“ComputerName”字段，用于保存生成的数据所在的计算机名。 然后，得到的结果被序列化成 XML 并保存到磁盘上。接着在目标文件夹打开资源管理器，并且选中创建的 XML 文件。这样您就可以方便地将它拷到 U 盘中随身带走。 要将结果反序列化成真实的对象，使用以下代码： $Path = &quot;$env:temp\\mylist.xml&quot; Import-Clixml -Path $Path 本文国际来源：Dumping Service State Information","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 比较服务配置","slug":"comparing-service-configuration","date":"2014-09-22T03:00:00.000Z","updated":"2017-03-17T15:26:24.376Z","comments":true,"path":"2014/09/22/comparing-service-configuration/","link":"","permalink":"http://blog.vichamp.com/2014/09/22/comparing-service-configuration/","excerpt":"适用于 PowerShell 3.0 或更高版本 假设您在两台服务器上启用了 PowerShell 远程服务，那么下面这个简单的脚本演示了如何从每台服务器上获取所有服务的状态并且计算两台服务器之间的差异。 $Server1 = &apos;myServer1&apos; $Server2 = &apos;someOtherServer&apos; $services1 = Invoke-Command { Get-Service } -ComputerName $Server1 | Sort-Object -Property Name, Status $services2 = Invoke-Command { Get-Service } -ComputerName $Server2 | Sort-Object -Property Name, Status Compare-Object -ReferenceObject $services1 -DifferenceObject $services2 -Property Name, Status -PassThru | Sort-Object -Property Name 得到的结果是服务配置差异的清单。","text":"适用于 PowerShell 3.0 或更高版本 假设您在两台服务器上启用了 PowerShell 远程服务，那么下面这个简单的脚本演示了如何从每台服务器上获取所有服务的状态并且计算两台服务器之间的差异。 $Server1 = &apos;myServer1&apos; $Server2 = &apos;someOtherServer&apos; $services1 = Invoke-Command { Get-Service } -ComputerName $Server1 | Sort-Object -Property Name, Status $services2 = Invoke-Command { Get-Service } -ComputerName $Server2 | Sort-Object -Property Name, Status Compare-Object -ReferenceObject $services1 -DifferenceObject $services2 -Property Name, Status -PassThru | Sort-Object -Property Name 得到的结果是服务配置差异的清单。 本文国际来源：Comparing Service Configuration","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 下载 PowerShell 语言规范","slug":"download-powershell-language-specification","date":"2014-09-19T03:00:00.000Z","updated":"2017-03-17T15:26:24.375Z","comments":true,"path":"2014/09/19/download-powershell-language-specification/","link":"","permalink":"http://blog.vichamp.com/2014/09/19/download-powershell-language-specification/","excerpt":"适用于 PowerShell 所有版本 在 PowerShell 中，从 Internet 中下载文件十分方便。以下这段代码能够自动将 PowerShell 语言规范——包含 PowerShell 精华和内核知识的很棒的 Word 文档——下载到您的机器上。 $link = &apos;http://download.microsoft.com/download/3/2/6/326DF7A1-EE5B-491B-9130-F9AA9C23C29A/PowerShell%202%200%20Language%20Specification.docx&apos; $outfile = &quot;$env:temp\\languageref.docx&quot; Invoke-WebRequest -Uri $link -OutFile $outfile Invoke-Item -Path $outfile","text":"适用于 PowerShell 所有版本 在 PowerShell 中，从 Internet 中下载文件十分方便。以下这段代码能够自动将 PowerShell 语言规范——包含 PowerShell 精华和内核知识的很棒的 Word 文档——下载到您的机器上。 $link = &apos;http://download.microsoft.com/download/3/2/6/326DF7A1-EE5B-491B-9130-F9AA9C23C29A/PowerShell%202%200%20Language%20Specification.docx&apos; $outfile = &quot;$env:temp\\languageref.docx&quot; Invoke-WebRequest -Uri $link -OutFile $outfile Invoke-Item -Path $outfile 本文国际来源：Download PowerShell Language Specification","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 等待按键","slug":"waiting-for-a-keystroke","date":"2014-09-18T03:00:00.000Z","updated":"2017-03-17T15:26:24.354Z","comments":true,"path":"2014/09/18/waiting-for-a-keystroke/","link":"","permalink":"http://blog.vichamp.com/2014/09/18/waiting-for-a-keystroke/","excerpt":"适用于 PowerShell 所有版本，仅适用于 PowerShell 控制台 若希望脚本执行结束时，保持 PowerShell 控制台程序为打开状态，您也许希望增加一句“按任意键继续”语句。以下是实现方式： Write-Host &apos;Press Any Key!&apos; -NoNewline $null = [Console]::ReadKey(&apos;?&apos;) 这段代码仅适用于真实的 PowerShell 控制台。它在 ISE 编辑器或其它未使用真实互操作键盘缓冲区的控制台程序中并不适用。","text":"适用于 PowerShell 所有版本，仅适用于 PowerShell 控制台 若希望脚本执行结束时，保持 PowerShell 控制台程序为打开状态，您也许希望增加一句“按任意键继续”语句。以下是实现方式： Write-Host &apos;Press Any Key!&apos; -NoNewline $null = [Console]::ReadKey(&apos;?&apos;) 这段代码仅适用于真实的 PowerShell 控制台。它在 ISE 编辑器或其它未使用真实互操作键盘缓冲区的控制台程序中并不适用。 本文国际来源：Waiting for a Keystroke","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找脚本中的错误","slug":"finding-errors-in-scripts","date":"2014-09-17T03:00:00.000Z","updated":"2017-03-17T15:26:24.354Z","comments":true,"path":"2014/09/17/finding-errors-in-scripts/","link":"","permalink":"http://blog.vichamp.com/2014/09/17/finding-errors-in-scripts/","excerpt":"适用于 PowerShell 所有版本 没有比这种更简单的方法来查找脚本中的语法错误了。只需要用这个过滤器： filter Test-SyntaxError { $text = Get-Content -Path $_.FullName if ($text.Length -gt 0) { $err = $null $null = [System.Management.Automation.PSParser]::Tokenize($text, [ref] $err) if ($err) { $_ } } } 通过使用这个过滤器，您可以快速地扫描文件夹，甚至整台计算机，列出所有包含语法错误的 PowerShell 文件。 以下代码将在您的用户文件夹下遍历并查找所有的 PowerShell 脚本并列出包含语法错误的文件： PS&gt; dir $home -Filter *.ps1 -Recurse -Exclude *.ps1xml | Test-SyntaxError","text":"适用于 PowerShell 所有版本 没有比这种更简单的方法来查找脚本中的语法错误了。只需要用这个过滤器： filter Test-SyntaxError { $text = Get-Content -Path $_.FullName if ($text.Length -gt 0) { $err = $null $null = [System.Management.Automation.PSParser]::Tokenize($text, [ref] $err) if ($err) { $_ } } } 通过使用这个过滤器，您可以快速地扫描文件夹，甚至整台计算机，列出所有包含语法错误的 PowerShell 文件。 以下代码将在您的用户文件夹下遍历并查找所有的 PowerShell 脚本并列出包含语法错误的文件： PS&gt; dir $home -Filter *.ps1 -Recurse -Exclude *.ps1xml | Test-SyntaxError 本文国际来源：Finding Errors in Scripts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检测文本中是否含有大写字母","slug":"testing-whether-text-contains-upper-case","date":"2014-09-16T03:00:00.000Z","updated":"2017-03-17T15:26:24.354Z","comments":true,"path":"2014/09/16/testing-whether-text-contains-upper-case/","link":"","permalink":"http://blog.vichamp.com/2014/09/16/testing-whether-text-contains-upper-case/","excerpt":"适用于 PowerShell 任何版本 可以使用正则表达式来检测一个字符串是否包含至少一个大写字母： $text1 = &apos;this is all lower-case&apos; $text2 = &apos;this is NOT all lower-case&apos; $text1 -cmatch &apos;[A-Z]&apos; $text2 -cmatch &apos;[A-Z]&apos; 得到的结果分别是“Frue”和“False”。 要检测一段文本是否只包含小写字母，请试试这段代码： $text1 = &apos;this is all lower-case&apos; $text2 = &apos;this is NOT all lower-case&apos; $text1 -cmatch &apos;^[a-z\\s-]*$&apos; $text2 -cmatch &apos;^[A-Z\\s-]*$&apos; 得到的结果分别是“True”和“False”。 实际上检测起来会更麻烦，因为您需要包括所有合法的字符。在这个例子中，我选择了 a-z 的小写字母、空格和减号。 这些“合法”的字符被包含在“^”和“$”（行首符和行尾符）之间。星号是一个量词（任意数量个“合法的”字符）。","text":"适用于 PowerShell 任何版本 可以使用正则表达式来检测一个字符串是否包含至少一个大写字母： $text1 = &apos;this is all lower-case&apos; $text2 = &apos;this is NOT all lower-case&apos; $text1 -cmatch &apos;[A-Z]&apos; $text2 -cmatch &apos;[A-Z]&apos; 得到的结果分别是“Frue”和“False”。 要检测一段文本是否只包含小写字母，请试试这段代码： $text1 = &apos;this is all lower-case&apos; $text2 = &apos;this is NOT all lower-case&apos; $text1 -cmatch &apos;^[a-z\\s-]*$&apos; $text2 -cmatch &apos;^[A-Z\\s-]*$&apos; 得到的结果分别是“True”和“False”。 实际上检测起来会更麻烦，因为您需要包括所有合法的字符。在这个例子中，我选择了 a-z 的小写字母、空格和减号。 这些“合法”的字符被包含在“^”和“$”（行首符和行尾符）之间。星号是一个量词（任意数量个“合法的”字符）。 本文国际来源：Testing Whether Text Contains Upper Case","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取字符串的行数","slug":"getting-the-number-of-lines-in-a-string","date":"2014-09-15T03:00:00.000Z","updated":"2017-03-17T15:26:24.354Z","comments":true,"path":"2014/09/15/getting-the-number-of-lines-in-a-string/","link":"","permalink":"http://blog.vichamp.com/2014/09/15/getting-the-number-of-lines-in-a-string/","excerpt":"适用于 PowerShell 所有版本 Here is a clever trick how to find out how many lines a string (not a string array!) contains:以下是一个获取字符串（而不是字符串数组！）行数的技巧： $text = @&apos; This is some sample text Let&apos;s find out the number of lines. &apos;@ $text.Length - $text.Replace(&quot;`n&quot;,&apos;&apos;).Length + 1 技术上来说，这个例子用的是 here-string 来创建多行字符串，不过这只是一个例子。它对所有类型的字符串都有效，无论它的来源是什么。","text":"适用于 PowerShell 所有版本 Here is a clever trick how to find out how many lines a string (not a string array!) contains:以下是一个获取字符串（而不是字符串数组！）行数的技巧： $text = @&apos; This is some sample text Let&apos;s find out the number of lines. &apos;@ $text.Length - $text.Replace(&quot;`n&quot;,&apos;&apos;).Length + 1 技术上来说，这个例子用的是 here-string 来创建多行字符串，不过这只是一个例子。它对所有类型的字符串都有效，无论它的来源是什么。 本文国际来源：Getting the Number of Lines in a String","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 移除非法的路径字符","slug":"removing-illegal-pathcharacters","date":"2014-09-12T03:00:00.000Z","updated":"2017-03-17T15:26:24.338Z","comments":true,"path":"2014/09/12/removing-illegal-pathcharacters/","link":"","permalink":"http://blog.vichamp.com/2014/09/12/removing-illegal-pathcharacters/","excerpt":"适用于 PowerShell 所有版本 在路径名中，有些字符，例如冒号和双引号，都是非法的。如果您的脚本中的路径名称来自于外部信息，那么您可能希望最终的路径名是合法的。 以下是一个将路径中所有非法字符替换成下划线的函数： function Get-LegalPathName($Path) { $illegalChars = [System.IO.Path]::GetInvalidFileNameChars() foreach($illegalChar in $illegalChars) { $Path = $Path.Replace($illegalChar, &apos;_&apos;) } $Path } 这是结果看起来的样子： PS&gt; Get-LegalPathName &apos;some:&quot;illegal&quot;\\path&lt;chars&gt;.txt&apos; some__illegal__path_chars_.txt","text":"适用于 PowerShell 所有版本 在路径名中，有些字符，例如冒号和双引号，都是非法的。如果您的脚本中的路径名称来自于外部信息，那么您可能希望最终的路径名是合法的。 以下是一个将路径中所有非法字符替换成下划线的函数： function Get-LegalPathName($Path) { $illegalChars = [System.IO.Path]::GetInvalidFileNameChars() foreach($illegalChar in $illegalChars) { $Path = $Path.Replace($illegalChar, &apos;_&apos;) } $Path } 这是结果看起来的样子： PS&gt; Get-LegalPathName &apos;some:&quot;illegal&quot;\\path&lt;chars&gt;.txt&apos; some__illegal__path_chars_.txt 本文国际来源：Removing Illegal Path Characters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 忽略输出结果","slug":"discarding-results","date":"2014-09-11T03:00:00.000Z","updated":"2017-03-17T15:26:24.338Z","comments":true,"path":"2014/09/11/discarding-results/","link":"","permalink":"http://blog.vichamp.com/2014/09/11/discarding-results/","excerpt":"适用于 PowerShell 所有版本 由于 PowerShell 会将所有命令的执行结果返回，所以在 PowerShell 脚本中忽略掉所有不希望返回的结果是十分重要的。 有很多方法能实现这个目的，以下是最常见的两种。请注意每行都会尝试在您的 C: 创建一个新的文件夹。New-Item 命令将会返回一个新的文件夹对象，但是如果您只是希望创建一个新的文件夹，那么您很可能希望忽略掉返回的结果： 123$null = New-Item -Path c:\\newfolderA -ItemType DirectoryNew-Item -Path c:\\newfolderB -ItemType Directory | Out-Null 哪么那种方式更好呢？当然是第一种方式了。将不需要的结果通过管道传送给 Out-Null 的开销是很大的，能达到将近 40 倍的差别。只调用一次的差别并不明显，但如果在一个循环中的话，差异就很明显了。 So better get into the habit of using $null rather than Out-Null!所以最好养成习惯使用 $null 而不是 Out-Null！","text":"适用于 PowerShell 所有版本 由于 PowerShell 会将所有命令的执行结果返回，所以在 PowerShell 脚本中忽略掉所有不希望返回的结果是十分重要的。 有很多方法能实现这个目的，以下是最常见的两种。请注意每行都会尝试在您的 C: 创建一个新的文件夹。New-Item 命令将会返回一个新的文件夹对象，但是如果您只是希望创建一个新的文件夹，那么您很可能希望忽略掉返回的结果： 123$null = New-Item -Path c:\\newfolderA -ItemType DirectoryNew-Item -Path c:\\newfolderB -ItemType Directory | Out-Null 哪么那种方式更好呢？当然是第一种方式了。将不需要的结果通过管道传送给 Out-Null 的开销是很大的，能达到将近 40 倍的差别。只调用一次的差别并不明显，但如果在一个循环中的话，差异就很明显了。 So better get into the habit of using $null rather than Out-Null!所以最好养成习惯使用 $null 而不是 Out-Null！ 本文国际来源：Discarding Results","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 同时支持可选参数和必选参数","slug":"optional-and-mandatory-at-the-same-time","date":"2014-09-10T03:00:00.000Z","updated":"2017-03-17T15:26:24.322Z","comments":true,"path":"2014/09/10/optional-and-mandatory-at-the-same-time/","link":"","permalink":"http://blog.vichamp.com/2014/09/10/optional-and-mandatory-at-the-same-time/","excerpt":"适用于 PowerShell 所有版本 一个函数的参数是否能既为可选的，又为必选的呢？这是可以的，基于不同的上下文即可。 一个参数可以在当其它参数存在的时候为必选的，否则为可选的。 function Connect-Somewhere { [CmdletBinding(DefaultParameterSetName=&apos;A&apos;)] param ( [Parameter(ParameterSetName=&apos;A&apos;,Mandatory=$false)] [Parameter(ParameterSetName=&apos;B&apos;,Mandatory=$true)] $ComputerName, [Parameter(ParameterSetName=&apos;B&apos;,Mandatory=$false)] $Credential ) $chosen = $PSCmdlet.ParameterSetName &quot;You have chosen $chosen parameter set.&quot; } # -Computername is optional Connect-Somewhere # here, -Computername is mandatory Connect-Somewhere -Credential test","text":"适用于 PowerShell 所有版本 一个函数的参数是否能既为可选的，又为必选的呢？这是可以的，基于不同的上下文即可。 一个参数可以在当其它参数存在的时候为必选的，否则为可选的。 function Connect-Somewhere { [CmdletBinding(DefaultParameterSetName=&apos;A&apos;)] param ( [Parameter(ParameterSetName=&apos;A&apos;,Mandatory=$false)] [Parameter(ParameterSetName=&apos;B&apos;,Mandatory=$true)] $ComputerName, [Parameter(ParameterSetName=&apos;B&apos;,Mandatory=$false)] $Credential ) $chosen = $PSCmdlet.ParameterSetName &quot;You have chosen $chosen parameter set.&quot; } # -Computername is optional Connect-Somewhere # here, -Computername is mandatory Connect-Somewhere -Credential test 本文国际来源：Optional and Mandatory at the Same Time","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 重要的数学函数","slug":"important-math-functions","date":"2014-09-09T03:00:00.000Z","updated":"2017-03-17T15:26:24.322Z","comments":true,"path":"2014/09/09/important-math-functions/","link":"","permalink":"http://blog.vichamp.com/2014/09/09/important-math-functions/","excerpt":"适用于 PowerShell 不同版本 以下是管理脚本中最重要的 4 个数学函数： [Math]::Floor(4.9) [Math]::Ceiling(3.2) [Math]::Max(3,8) [Math]::Min(3,8)","text":"适用于 PowerShell 不同版本 以下是管理脚本中最重要的 4 个数学函数： [Math]::Floor(4.9) [Math]::Ceiling(3.2) [Math]::Max(3,8) [Math]::Min(3,8) 本文国际来源：Important Math Functions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 快速处理路径","slug":"useful-path-manipulation-shortcuts","date":"2014-09-08T03:00:00.000Z","updated":"2017-03-17T15:26:24.322Z","comments":true,"path":"2014/09/08/useful-path-manipulation-shortcuts/","link":"","permalink":"http://blog.vichamp.com/2014/09/08/useful-path-manipulation-shortcuts/","excerpt":"适用于 PowerShell 所有版本 以下是一系列有用的（并且易用的）用于处理文件路径的系统函数： [System.IO.Path]::GetFileNameWithoutExtension(&apos;file.ps1&apos;) [System.IO.Path]::GetExtension(&apos;file.ps1&apos;) [System.IO.Path]::ChangeExtension(&apos;file.ps1&apos;, &apos;.copy.ps1&apos;) [System.IO.Path]::GetFileNameWithoutExtension(&apos;c:\\test\\file.ps1&apos;) [System.IO.Path]::GetExtension(&apos;c:\\test\\file.ps1&apos;) [System.IO.Path]::ChangeExtension(&apos;c:\\test\\file.ps1&apos;, &apos;.bak&apos;) 所有这些方法都能接受文件名称或完整路径参数、能返回路径的不同部分，或改变其中的部分，例如扩展名。","text":"适用于 PowerShell 所有版本 以下是一系列有用的（并且易用的）用于处理文件路径的系统函数： [System.IO.Path]::GetFileNameWithoutExtension(&apos;file.ps1&apos;) [System.IO.Path]::GetExtension(&apos;file.ps1&apos;) [System.IO.Path]::ChangeExtension(&apos;file.ps1&apos;, &apos;.copy.ps1&apos;) [System.IO.Path]::GetFileNameWithoutExtension(&apos;c:\\test\\file.ps1&apos;) [System.IO.Path]::GetExtension(&apos;c:\\test\\file.ps1&apos;) [System.IO.Path]::ChangeExtension(&apos;c:\\test\\file.ps1&apos;, &apos;.bak&apos;) 所有这些方法都能接受文件名称或完整路径参数、能返回路径的不同部分，或改变其中的部分，例如扩展名。 本文国际来源：Useful Path Manipulation Shortcuts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找最大值和最小值","slug":"finding-minimum-and-maximum-values","date":"2014-09-05T03:00:00.000Z","updated":"2017-03-17T15:26:24.307Z","comments":true,"path":"2014/09/05/finding-minimum-and-maximum-values/","link":"","permalink":"http://blog.vichamp.com/2014/09/05/finding-minimum-and-maximum-values/","excerpt":"适用于 PowerShell 所有版本 要查找一系列数据中的最小值和最大值，请使用 Measure-Object 命令： $list = 1,4,3,1,3,12,990 $result = $list | Measure-Object -Minimum -Maximum $result.Minimum $result.Maximum 它对输入的任何数据类型都有效。以下是稍作修改的代码，可以返回 Windows 文件夹中最旧和最新的文件： $list = Get-ChildItem -Path C:\\windows $result = $list | Measure-Object -Property LastWriteTime -Minimum -Maximum $result.Minimum $result.Maximum 如果您的输入数据有多个属性，只需要加上 -Property 参数，并选择您想检测的属性即可。","text":"适用于 PowerShell 所有版本 要查找一系列数据中的最小值和最大值，请使用 Measure-Object 命令： $list = 1,4,3,1,3,12,990 $result = $list | Measure-Object -Minimum -Maximum $result.Minimum $result.Maximum 它对输入的任何数据类型都有效。以下是稍作修改的代码，可以返回 Windows 文件夹中最旧和最新的文件： $list = Get-ChildItem -Path C:\\windows $result = $list | Measure-Object -Property LastWriteTime -Minimum -Maximum $result.Minimum $result.Maximum 如果您的输入数据有多个属性，只需要加上 -Property 参数，并选择您想检测的属性即可。 本文国际来源：Finding Minimum and Maximum Values","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 合并执行结果","slug":"combining-results","date":"2014-09-04T03:00:00.000Z","updated":"2017-03-17T15:26:24.291Z","comments":true,"path":"2014/09/04/combining-results/","link":"","permalink":"http://blog.vichamp.com/2014/09/04/combining-results/","excerpt":"适用于 PowerShell 所有版本 假设您想检查可疑的服务状态，例如启动类型为“自动”而状态处于停止的，或检查服务的 ExitCode 为非正常值的。 以下是一些示例代码，演示如何查询这些场景并将执行结果合并为一个变量。 Sort-Object 确保您的结果在输出到 grid view 窗口之前是不重复的。 $list = @() $list += Get-WmiObject -Class Win32_Service -Filter &apos;State=&quot;Stopped&quot; and StartMode=&quot;Auto&quot; and ExitCode!=0&apos; | Select-Object -Property Name, DisplayName, ExitCode, Description, PathName, DesktopInteract $list += Get-WmiObject -Class Win32_Service -Filter &apos;ExitCode!=0 and ExitCode!=1077&apos; | Select-Object -Property Name, DisplayName, ExitCode, Description, PathName, DesktopInteract $list | # remove identical (-Unique) Sort-Object -Unique -Property Name | Out-GridView","text":"适用于 PowerShell 所有版本 假设您想检查可疑的服务状态，例如启动类型为“自动”而状态处于停止的，或检查服务的 ExitCode 为非正常值的。 以下是一些示例代码，演示如何查询这些场景并将执行结果合并为一个变量。 Sort-Object 确保您的结果在输出到 grid view 窗口之前是不重复的。 $list = @() $list += Get-WmiObject -Class Win32_Service -Filter &apos;State=&quot;Stopped&quot; and StartMode=&quot;Auto&quot; and ExitCode!=0&apos; | Select-Object -Property Name, DisplayName, ExitCode, Description, PathName, DesktopInteract $list += Get-WmiObject -Class Win32_Service -Filter &apos;ExitCode!=0 and ExitCode!=1077&apos; | Select-Object -Property Name, DisplayName, ExitCode, Description, PathName, DesktopInteract $list | # remove identical (-Unique) Sort-Object -Unique -Property Name | Out-GridView 本文国际来源：Combining Results","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 快速转义、反转义 URI","slug":"escape-unescape-uri","date":"2014-09-03T13:17:20.000Z","updated":"2017-03-17T15:26:24.291Z","comments":true,"path":"2014/09/03/escape-unescape-uri/","link":"","permalink":"http://blog.vichamp.com/2014/09/03/escape-unescape-uri/","excerpt":"","text":"有 PowerShell 在手，进行 URI 转义、反转义这点小事就不需要找别的工具了。 # 对 URI 进行转义 [System.Uri]::EscapeUriString(&apos;http://www.baidu.com/s?ie=UTF-8&amp;wd=中文&apos;) # http://www.baidu.com/s?ie=UTF-8&amp;wd=%E4%B8%AD%E6%96%87 # 对数据进行转义 [System.Uri]::EscapeDataString(&apos;http://www.baidu.com/s?ie=UTF-8&amp;wd=中文&apos;) # http%3A%2F%2Fwww.baidu.com%2Fs%3Fie%3DUTF-8%26wd%3D%E4%B8%AD%E6%96%87 # 对 HEX 数据进行反转义 [System.Uri]::UnescapeDataString(&apos;http://www.baidu.com/s?ie=UTF-8&amp;wd=%E4%B8%AD%E6%96%87&apos;) # http://www.baidu.com/s?ie=UTF-8&amp;wd=中文","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 计算倒计时小时数","slug":"countdown-hours","date":"2014-09-02T20:00:00.000Z","updated":"2017-03-17T15:26:24.291Z","comments":true,"path":"2014/09/03/countdown-hours/","link":"","permalink":"http://blog.vichamp.com/2014/09/03/countdown-hours/","excerpt":"适用于 PowerShell 所有版本 当遇到生日或重要的赛事时，您可能会想到用 PowerShell 来计算事件还有多少小时到来。以下是实现方法： $result = New-TimeSpan -End &apos;2014-12-25 06:45:00&apos; $hours = [Int]$result.TotalHours &apos;Another {0:n0} hours to go...&apos; -f $hours 这个例子计算距离 2014 年圣诞节还剩余的小时数。只需要替换代码中的日期，就可以得到距您期待的事件到来还有多少小时。","text":"适用于 PowerShell 所有版本 当遇到生日或重要的赛事时，您可能会想到用 PowerShell 来计算事件还有多少小时到来。以下是实现方法： $result = New-TimeSpan -End &apos;2014-12-25 06:45:00&apos; $hours = [Int]$result.TotalHours &apos;Another {0:n0} hours to go...&apos; -f $hours 这个例子计算距离 2014 年圣诞节还剩余的小时数。只需要替换代码中的日期，就可以得到距您期待的事件到来还有多少小时。 本文国际来源：Countdown Hours","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 -f 操作符合并字符串和数据","slug":"using-f-operator-to-combine-string-and-data","date":"2014-09-02T03:00:00.000Z","updated":"2017-03-17T15:26:24.291Z","comments":true,"path":"2014/09/02/using-f-operator-to-combine-string-and-data/","link":"","permalink":"http://blog.vichamp.com/2014/09/02/using-f-operator-to-combine-string-and-data/","excerpt":"适用于 PowerShell 所有版本 用双引号包围的字符串能够解析变量，所以类似这样的书写方式很常见： $name = $host.Name &quot;Your host is called $name.&quot; 然而，这种技术有一些限制。如果您想显示对象的属性而不只是变量，将会失败： PS&gt; &quot;Your host is called $host.Name.&quot; Your host is called System.Management.Automation.Internal.Host.InternalHost.Name. 这是因为 PowerShell 只会解析变量（在例子中是 $host），而不是代码中的剩余部分。 而且您也无法控制数字格式。这段代码可以工作，但是显示的小数位数太多，看起来不美观： # get available space in bytes for C: drive $freeSpace = ([WMI]&apos;Win32_LogicalDisk.DeviceID=&quot;C:&quot;&apos;).FreeSpace # convert to MB $freeSpaceMB = $freeSpace / 1MB # output &quot;Your C: drive has $freeSpaceMB MB space available.&quot; -f 操作符可以解决这两个问题。它的左侧是一个静态的文本模板，右侧是提供给模板用的值： # insert any data into the text template &apos;Your host is called {0}.&apos; -f $host.Name # calculate free space on C: in MB $freeSpace = ([WMI]&apos;Win32_LogicalDisk.DeviceID=&quot;C:&quot;&apos;).FreeSpace $freeSpaceMB = $freeSpace /1MB # output with just ONE digit after the comma &apos;Your C: drive has {0:n1} MB space available.&apos; -f $freeSpaceMB 如您所见，使用 -f 可以给您带来两个好处：占位符（花括号）指示 PowerShell 插入点的位置，并且占位符还可以接受格式化信息。“n1”代表小数点后 1 位。只需要调整数值就能满足您的需要。","text":"适用于 PowerShell 所有版本 用双引号包围的字符串能够解析变量，所以类似这样的书写方式很常见： $name = $host.Name &quot;Your host is called $name.&quot; 然而，这种技术有一些限制。如果您想显示对象的属性而不只是变量，将会失败： PS&gt; &quot;Your host is called $host.Name.&quot; Your host is called System.Management.Automation.Internal.Host.InternalHost.Name. 这是因为 PowerShell 只会解析变量（在例子中是 $host），而不是代码中的剩余部分。 而且您也无法控制数字格式。这段代码可以工作，但是显示的小数位数太多，看起来不美观： # get available space in bytes for C: drive $freeSpace = ([WMI]&apos;Win32_LogicalDisk.DeviceID=&quot;C:&quot;&apos;).FreeSpace # convert to MB $freeSpaceMB = $freeSpace / 1MB # output &quot;Your C: drive has $freeSpaceMB MB space available.&quot; -f 操作符可以解决这两个问题。它的左侧是一个静态的文本模板，右侧是提供给模板用的值： # insert any data into the text template &apos;Your host is called {0}.&apos; -f $host.Name # calculate free space on C: in MB $freeSpace = ([WMI]&apos;Win32_LogicalDisk.DeviceID=&quot;C:&quot;&apos;).FreeSpace $freeSpaceMB = $freeSpace /1MB # output with just ONE digit after the comma &apos;Your C: drive has {0:n1} MB space available.&apos; -f $freeSpaceMB 如您所见，使用 -f 可以给您带来两个好处：占位符（花括号）指示 PowerShell 插入点的位置，并且占位符还可以接受格式化信息。“n1”代表小数点后 1 位。只需要调整数值就能满足您的需要。 本文国际来源：Using -f Operator to Combine String and Data","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 播放 WAV 声音","slug":"playing-wav-sounds","date":"2014-09-01T03:00:00.000Z","updated":"2017-03-17T15:26:24.276Z","comments":true,"path":"2014/09/01/playing-wav-sounds/","link":"","permalink":"http://blog.vichamp.com/2014/09/01/playing-wav-sounds/","excerpt":"适用于 PowerShell 3.0 或以上版本 PowerShell 可以用内置的 SoundPlayer 类播放 WAV 背景声音。它可以接受一个 WAV 文件的路径参数，然后可以指定只播放一次还是循环播放。 以下代码将循环播放一段声音： $player = New-Object -TypeName System.Media.SoundPlayer $player.SoundLocation = &apos;C:\\Windows\\Media\\chimes.wav&apos; $player.Load() $player.PlayLooping() 当您的脚本执行完以后，可以通过这行代码停止播放： $player.Stop() 如果您想将自定义的声音文件和您的 PowerShell 脚本一块分发，只需要将它存放在脚本的同一个文件夹下，然后用 $PSScriptRoot 来引用脚本所在的文件夹。 这个例子将播放脚本目录下的 mySound.wav： $player = New-Object -TypeName System.Media.SoundPlayer $player.SoundLocation = &quot;$PSScriptRoot\\mySound.wav&quot; $player.Load() $player.PlayLooping() # do something... Start-Sleep -Seconds 5 $player.Stop() 请注意 $PSScriptRoot 需要 PowerShell 3.0 或以上版本。当然，它也需要您先将脚本保存到文件。","text":"适用于 PowerShell 3.0 或以上版本 PowerShell 可以用内置的 SoundPlayer 类播放 WAV 背景声音。它可以接受一个 WAV 文件的路径参数，然后可以指定只播放一次还是循环播放。 以下代码将循环播放一段声音： $player = New-Object -TypeName System.Media.SoundPlayer $player.SoundLocation = &apos;C:\\Windows\\Media\\chimes.wav&apos; $player.Load() $player.PlayLooping() 当您的脚本执行完以后，可以通过这行代码停止播放： $player.Stop() 如果您想将自定义的声音文件和您的 PowerShell 脚本一块分发，只需要将它存放在脚本的同一个文件夹下，然后用 $PSScriptRoot 来引用脚本所在的文件夹。 这个例子将播放脚本目录下的 mySound.wav： $player = New-Object -TypeName System.Media.SoundPlayer $player.SoundLocation = &quot;$PSScriptRoot\\mySound.wav&quot; $player.Load() $player.PlayLooping() # do something... Start-Sleep -Seconds 5 $player.Stop() 请注意 $PSScriptRoot 需要 PowerShell 3.0 或以上版本。当然，它也需要您先将脚本保存到文件。 本文国际来源：Playing WAV Sounds","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取系统开机时长","slug":"system-uptime","date":"2014-08-29T03:00:00.000Z","updated":"2017-03-17T15:26:24.254Z","comments":true,"path":"2014/08/29/system-uptime/","link":"","permalink":"http://blog.vichamp.com/2014/08/29/system-uptime/","excerpt":"适用于 PowerShell 所有版本 Windows 每次启动的时候，都启动一个高精度计数器，这个计数器将返回系统运行的毫秒数： $millisecondsUptime = [Environment]::TickCount &quot;I am up for $millisecondsUptime milliseconds!&quot; 由于您很难对毫秒有兴趣，所以请使用 New-TimeSpan 来将毫秒（顺便提一下，也可以是任何其它时间间隔）转换为有意义的单位： $millisecondsUptime = [Environment]::TickCount &quot;I am up for $millisecondsUptime milliseconds!&quot; $timespan = New-TimeSpan -Seconds ($millisecondsUptime/1000) $timespan 那么现在，您可以使用 TimeSpan 型的 $timespan 对象以您想要的任何格式来汇报启动的时间： $millisecondsUptime = [Environment]::TickCount &quot;I am up for $millisecondsUptime milliseconds!&quot; $timespan = New-TimeSpan -Seconds ($millisecondsUptime/1000) $hours = $timespan.TotalHours &quot;System is up for {0:n0} hours now.&quot; -f $hours 由于 New-TimeSpan 无法直接处理毫秒，所以需要做一个特殊处理。该脚本直接将毫秒数除以 1000，会引入一个小误差。 要将毫秒数转换为一个 TimeSpan 对象而不损失任何精度，请试试以下代码： $timespan = [Timespan]::FromMilliseconds($millisecondsUptime) 在这个例子中，它们没有区别。但是它在其它情况下可能很有用。例如，您还可以使用 FromTicks() 方法将时钟周期数（Windows 系统中的最小时间周期单位）转换为时间间隔。","text":"适用于 PowerShell 所有版本 Windows 每次启动的时候，都启动一个高精度计数器，这个计数器将返回系统运行的毫秒数： $millisecondsUptime = [Environment]::TickCount &quot;I am up for $millisecondsUptime milliseconds!&quot; 由于您很难对毫秒有兴趣，所以请使用 New-TimeSpan 来将毫秒（顺便提一下，也可以是任何其它时间间隔）转换为有意义的单位： $millisecondsUptime = [Environment]::TickCount &quot;I am up for $millisecondsUptime milliseconds!&quot; $timespan = New-TimeSpan -Seconds ($millisecondsUptime/1000) $timespan 那么现在，您可以使用 TimeSpan 型的 $timespan 对象以您想要的任何格式来汇报启动的时间： $millisecondsUptime = [Environment]::TickCount &quot;I am up for $millisecondsUptime milliseconds!&quot; $timespan = New-TimeSpan -Seconds ($millisecondsUptime/1000) $hours = $timespan.TotalHours &quot;System is up for {0:n0} hours now.&quot; -f $hours 由于 New-TimeSpan 无法直接处理毫秒，所以需要做一个特殊处理。该脚本直接将毫秒数除以 1000，会引入一个小误差。 要将毫秒数转换为一个 TimeSpan 对象而不损失任何精度，请试试以下代码： $timespan = [Timespan]::FromMilliseconds($millisecondsUptime) 在这个例子中，它们没有区别。但是它在其它情况下可能很有用。例如，您还可以使用 FromTicks() 方法将时钟周期数（Windows 系统中的最小时间周期单位）转换为时间间隔。 本文国际来源：System Uptime","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找插入的 U 盘","slug":"finding-attached-usb-sticks","date":"2014-08-28T03:00:00.000Z","updated":"2017-03-17T15:26:24.254Z","comments":true,"path":"2014/08/28/finding-attached-usb-sticks/","link":"","permalink":"http://blog.vichamp.com/2014/08/28/finding-attached-usb-sticks/","excerpt":"适用于 PowerShell 所有版本 如果您想知道是否有已插入电脑的 USB 存储设备，那么 WMI 可以做到： Get-WmiObject -Class Win32_PnPEntity | Where-Object { $_.DeviceID -like &apos;USBSTOR*&apos; } 这将返回所有“USBSTOR”类的即插即用设备。 如果您想用 WMI 查询语言（WQL），您还可以用命令过滤器来实现： Get-WmiObject -Query &apos;Select * From Win32_PnPEntity where DeviceID Like &quot;USBSTOR%&quot;&apos;","text":"适用于 PowerShell 所有版本 如果您想知道是否有已插入电脑的 USB 存储设备，那么 WMI 可以做到： Get-WmiObject -Class Win32_PnPEntity | Where-Object { $_.DeviceID -like &apos;USBSTOR*&apos; } 这将返回所有“USBSTOR”类的即插即用设备。 如果您想用 WMI 查询语言（WQL），您还可以用命令过滤器来实现： Get-WmiObject -Query &apos;Select * From Win32_PnPEntity where DeviceID Like &quot;USBSTOR%&quot;&apos; 本文国际来源：Finding Attached USB Sticks","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 测试服务的响应性","slug":"test-service-responsiveness","date":"2014-08-27T03:00:00.000Z","updated":"2017-03-17T15:26:24.238Z","comments":true,"path":"2014/08/27/test-service-responsiveness/","link":"","permalink":"http://blog.vichamp.com/2014/08/27/test-service-responsiveness/","excerpt":"适用于 PowerShell 所有版本 要测试某个服务是否仍然可响应，可以使用这个聪明的点子。首先，向 WMI 查询您想要检查的服务。WMI 将会开心地返回对应进程的 ID。 接下来，查询该进程。进程对象将会告知您该进程是冻结还是可响应的状态： function Test-ServiceResponding($ServiceName) { $service = Get-WmiObject -Class Win32_Service -Filter &quot;Name=&apos;$ServiceName&apos;&quot; $processID = $service.processID $process = Get-Process -Id $processID $process.Responding } 这个例子将会检测 Spooler 服务是否可响应： PS&gt; Test-ServiceResponding -ServiceName Spooler True 请注意，该示例代码假设服务正在运行。如果您想试试的话，您可以自己检测一下，排除非正在运行的服务。","text":"适用于 PowerShell 所有版本 要测试某个服务是否仍然可响应，可以使用这个聪明的点子。首先，向 WMI 查询您想要检查的服务。WMI 将会开心地返回对应进程的 ID。 接下来，查询该进程。进程对象将会告知您该进程是冻结还是可响应的状态： function Test-ServiceResponding($ServiceName) { $service = Get-WmiObject -Class Win32_Service -Filter &quot;Name=&apos;$ServiceName&apos;&quot; $processID = $service.processID $process = Get-Process -Id $processID $process.Responding } 这个例子将会检测 Spooler 服务是否可响应： PS&gt; Test-ServiceResponding -ServiceName Spooler True 请注意，该示例代码假设服务正在运行。如果您想试试的话，您可以自己检测一下，排除非正在运行的服务。 本文国际来源：Test Service Responsiveness","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取 WMI 设备清单","slug":"wmi-device-inventory","date":"2014-08-26T03:00:00.000Z","updated":"2017-03-17T15:26:24.238Z","comments":true,"path":"2014/08/26/wmi-device-inventory/","link":"","permalink":"http://blog.vichamp.com/2014/08/26/wmi-device-inventory/","excerpt":"适用于 PowerShell 所有版本 WMI 服务可以用来汇报许多关于计算机硬件的详细信息。通常，每种类型的硬件表现为一个对应的 WMI 类。不过，不太容易找出这些硬件的类。 由于所有硬件类都继承自相同的 WMI 根类（CIM_LogicalDevice），所以您可以使用这个根类来查找所有的硬件： Get-WmiObject -Class CIM_LogicalDevice | Out-GridView 这将返回一个基本的硬件清单。不过您还可以做更多的事情。通过一点额外的代码，您可以用 WMI 获取一个硬件的类名清单： Get-WmiObject -Class CIM_LogicalDevice | Select-Object -Property __Class, Description | Sort-Object -Property __Class -Unique | Out-GridView 您现在可以使用这些类名中的任意一个来查询某种特定的硬件，获取其详细信息： PS&gt; Get-WmiObject -Class Win32_SoundDevice Manufacturer Name Status StatusInfo ------------ ---- ------ ---------- Cirrus Logic, Inc. Cirrus Logic CS4... OK 3 Intel(R) Corpora... Intel(R) Display... OK 3","text":"适用于 PowerShell 所有版本 WMI 服务可以用来汇报许多关于计算机硬件的详细信息。通常，每种类型的硬件表现为一个对应的 WMI 类。不过，不太容易找出这些硬件的类。 由于所有硬件类都继承自相同的 WMI 根类（CIM_LogicalDevice），所以您可以使用这个根类来查找所有的硬件： Get-WmiObject -Class CIM_LogicalDevice | Out-GridView 这将返回一个基本的硬件清单。不过您还可以做更多的事情。通过一点额外的代码，您可以用 WMI 获取一个硬件的类名清单： Get-WmiObject -Class CIM_LogicalDevice | Select-Object -Property __Class, Description | Sort-Object -Property __Class -Unique | Out-GridView 您现在可以使用这些类名中的任意一个来查询某种特定的硬件，获取其详细信息： PS&gt; Get-WmiObject -Class Win32_SoundDevice Manufacturer Name Status StatusInfo ------------ ---- ------ ---------- Cirrus Logic, Inc. Cirrus Logic CS4... OK 3 Intel(R) Corpora... Intel(R) Display... OK 3 本文国际来源：WMI Device Inventory","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取睡眠或休眠的时间","slug":"get-sleep-and-hibernation-times","date":"2014-08-25T03:00:00.000Z","updated":"2017-03-17T15:26:24.223Z","comments":true,"path":"2014/08/25/get-sleep-and-hibernation-times/","link":"","permalink":"http://blog.vichamp.com/2014/08/25/get-sleep-and-hibernation-times/","excerpt":"适用于 PowerShell 所有版本 如果您希望确认某台机器是否频繁地进入睡眠或者休眠模式，以下是一个读取对应的日志并返回详细信息的函数。它能汇报计算机何时进入睡眠模式，以及它进入睡眠模式的时长： function Get-HibernationTime { # get hibernation events Get-EventLog -LogName system -InstanceId 1 -Source Microsoft-Windows-Power-TroubleShooter | ForEach-Object { # create new object for results $result = &apos;dummy&apos; | Select-Object -Property ComputerName, SleepTime, WakeTime, Duration # store details in new object, convert datatype where appropriate [DateTime]$result.Sleeptime = $_.ReplacementStrings[0] [DateTime]$result.WakeTime = $_.ReplacementStrings[1] $time = $result.WakeTime - $result.SleepTime $result.Duration = ([int]($time.TotalHours * 100))/100 $result.ComputerName = $_.MachineName # return result $result } }","text":"适用于 PowerShell 所有版本 如果您希望确认某台机器是否频繁地进入睡眠或者休眠模式，以下是一个读取对应的日志并返回详细信息的函数。它能汇报计算机何时进入睡眠模式，以及它进入睡眠模式的时长： function Get-HibernationTime { # get hibernation events Get-EventLog -LogName system -InstanceId 1 -Source Microsoft-Windows-Power-TroubleShooter | ForEach-Object { # create new object for results $result = &apos;dummy&apos; | Select-Object -Property ComputerName, SleepTime, WakeTime, Duration # store details in new object, convert datatype where appropriate [DateTime]$result.Sleeptime = $_.ReplacementStrings[0] [DateTime]$result.WakeTime = $_.ReplacementStrings[1] $time = $result.WakeTime - $result.SleepTime $result.Duration = ([int]($time.TotalHours * 100))/100 $result.ComputerName = $_.MachineName # return result $result } } 本文国际来源：Get Sleep and Hibernation Times","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 理解顺序过滤","slug":"understanding-sequential-filtering","date":"2014-08-22T03:00:00.000Z","updated":"2017-03-17T15:26:24.223Z","comments":true,"path":"2014/08/22/understanding-sequential-filtering/","link":"","permalink":"http://blog.vichamp.com/2014/08/22/understanding-sequential-filtering/","excerpt":"适用于 PowerShell 所有版本 当您在解析基于文本的日志文件时，或是需要过滤其它类型的信息时，往往需要使用 Where-Object 命令。以下是一些常见的场景，演示如何合并过滤器： # logical AND filter for ALL keywords Get-Content -Path C:\\windows\\WindowsUpdate.log | Where-Object { $_ -like &apos;*successfully installed*&apos; } | Where-Object { $_ -like &apos;*framework*&apos; } | Out-GridView # above example can also be written in one line # by using the -and operator # the resulting code is NOT faster, though, just harder to read Get-Content -Path C:\\windows\\WindowsUpdate.log | Where-Object { ($_ -like &apos;*successfully installed*&apos;) -and ($_ -like &apos;*framework*&apos;) } | Out-GridView # logical -or (either condition is met) can only be applied in one line Get-Content -Path C:\\windows\\WindowsUpdate.log | Where-Object { ($_ -like &apos;*successfully installed*&apos;) -or ($_ -like &apos;*framework*&apos;) } | Out-GridView","text":"适用于 PowerShell 所有版本 当您在解析基于文本的日志文件时，或是需要过滤其它类型的信息时，往往需要使用 Where-Object 命令。以下是一些常见的场景，演示如何合并过滤器： # logical AND filter for ALL keywords Get-Content -Path C:\\windows\\WindowsUpdate.log | Where-Object { $_ -like &apos;*successfully installed*&apos; } | Where-Object { $_ -like &apos;*framework*&apos; } | Out-GridView # above example can also be written in one line # by using the -and operator # the resulting code is NOT faster, though, just harder to read Get-Content -Path C:\\windows\\WindowsUpdate.log | Where-Object { ($_ -like &apos;*successfully installed*&apos;) -and ($_ -like &apos;*framework*&apos;) } | Out-GridView # logical -or (either condition is met) can only be applied in one line Get-Content -Path C:\\windows\\WindowsUpdate.log | Where-Object { ($_ -like &apos;*successfully installed*&apos;) -or ($_ -like &apos;*framework*&apos;) } | Out-GridView 本文国际来源：Understanding Sequential Filtering","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 过滤 Hotfix 信息","slug":"filtering-hotfix-information","date":"2014-08-21T03:00:00.000Z","updated":"2017-03-17T15:26:24.221Z","comments":true,"path":"2014/08/21/filtering-hotfix-information/","link":"","permalink":"http://blog.vichamp.com/2014/08/21/filtering-hotfix-information/","excerpt":"适用于 PowerShell 所有版本 Get-HotFix 是一个用于返回已安装的 hotfix 的 cmdlet。不过它没有可以过滤 hotfix 编号的参数。 通过一个 cmdlet 过滤器，您可以很方便地查看您关注的 hotfix。这个例子只返回编号为“KB25”开头的 hotfix： Get-HotFix | Where-Object { $_.HotfixID -like &apos;KB25*&apos; } 请注意 Get-HotFix 有一个 -ComputerName 参数，所以如果您拥有了合适的权限，那么您也可以从远程计算机中获取 hotfix 信息。","text":"适用于 PowerShell 所有版本 Get-HotFix 是一个用于返回已安装的 hotfix 的 cmdlet。不过它没有可以过滤 hotfix 编号的参数。 通过一个 cmdlet 过滤器，您可以很方便地查看您关注的 hotfix。这个例子只返回编号为“KB25”开头的 hotfix： Get-HotFix | Where-Object { $_.HotfixID -like &apos;KB25*&apos; } 请注意 Get-HotFix 有一个 -ComputerName 参数，所以如果您拥有了合适的权限，那么您也可以从远程计算机中获取 hotfix 信息。 本文国际来源：Filtering Hotfix Information","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取关机信息","slug":"getting-shutdown-information-testing","date":"2014-08-20T03:00:00.000Z","updated":"2017-03-17T15:26:24.214Z","comments":true,"path":"2014/08/20/getting-shutdown-information-testing/","link":"","permalink":"http://blog.vichamp.com/2014/08/20/getting-shutdown-information-testing/","excerpt":"适用于 PowerShell 所有版本 Windows 在系统事件日志中记录了所有的关机事件。您可以从那儿提取和分析信息。 以下是一个读取适当的事件日志记录、从 ReplacementStrings 数组中读取相关的信息，并以对象数组的方式返回关机信息的函数。 function Get-ShutdownInfo { Get-EventLog -LogName system -InstanceId 2147484722 -Source user32 | ForEach-Object { $result = &apos;dummy&apos; | Select-Object -Property ComputerName, TimeWritten, User, Reason, Action, Executable $result.TimeWritten = $_.TimeWritten $result.User = $_.ReplacementStrings[6] $result.Reason = $_.ReplacementStrings[2] $result.Action = $_.ReplacementStrings[4] $result.Executable = Split-Path -Path $_.ReplacementStrings[0] -Leaf $result.ComputerName = $_.MachineName $result } } 现在要检查关机问题就容易多了： PS&gt; Get-ShutdownInfo | Out-GridView","text":"适用于 PowerShell 所有版本 Windows 在系统事件日志中记录了所有的关机事件。您可以从那儿提取和分析信息。 以下是一个读取适当的事件日志记录、从 ReplacementStrings 数组中读取相关的信息，并以对象数组的方式返回关机信息的函数。 function Get-ShutdownInfo { Get-EventLog -LogName system -InstanceId 2147484722 -Source user32 | ForEach-Object { $result = &apos;dummy&apos; | Select-Object -Property ComputerName, TimeWritten, User, Reason, Action, Executable $result.TimeWritten = $_.TimeWritten $result.User = $_.ReplacementStrings[6] $result.Reason = $_.ReplacementStrings[2] $result.Action = $_.ReplacementStrings[4] $result.Executable = Split-Path -Path $_.ReplacementStrings[0] -Leaf $result.ComputerName = $_.MachineName $result } } 现在要检查关机问题就容易多了： PS&gt; Get-ShutdownInfo | Out-GridView 本文国际来源：Getting Shutdown Information","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"CDN 资源","slug":"cdn-guideline","date":"2014-08-20T02:57:48.000Z","updated":"2017-03-17T15:26:24.207Z","comments":true,"path":"2014/08/20/cdn-guideline/","link":"","permalink":"http://blog.vichamp.com/2014/08/20/cdn-guideline/","excerpt":"","text":"常用 CDN 列表 Make the Web Faster — Google Developers Microsoft Ajax Content Delivery Network - ASP.NET Ajax Library docs/cplat/libs - 百度开放云平台 Public Resources on SAE 开放静态文件 CDN cdnjs.com - the missing cdn for javascript and css 命令行由 开放静态文件 CDN 提供的： npm install -g sfile 详见 staticfile/cli 故障转移代码&lt;script type=&quot;text/javascript&quot; src=&quot;//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;!window.jQuery &amp;&amp; document.write(&apos;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/libs/jquery-2.0.3.min.js&quot;&gt;&lt;\\/script&gt;&apos;)&lt;/script&gt; 引用多个script&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.google.com/jsapi&quot;&gt;&lt;/script&gt; 引用 jQuery 时： google.load(&quot;jquery&quot;,&quot;1.3.2&quot;);","categories":[{"name":"web","slug":"web","permalink":"http://blog.vichamp.com/categories/web/"}],"tags":[{"name":"develop","slug":"develop","permalink":"http://blog.vichamp.com/tags/develop/"},{"name":"web","slug":"web","permalink":"http://blog.vichamp.com/tags/web/"},{"name":"cdn","slug":"cdn","permalink":"http://blog.vichamp.com/tags/cdn/"}],"keywords":[{"name":"web","slug":"web","permalink":"http://blog.vichamp.com/categories/web/"}]},{"title":"PowerShell 技能连载 - 复制命令行历史","slug":"testing","date":"2014-08-19T03:00:00.000Z","updated":"2017-03-17T15:26:24.204Z","comments":true,"path":"2014/08/19/testing/","link":"","permalink":"http://blog.vichamp.com/2014/08/19/testing/","excerpt":"适用于所有 PowerShell 版本 如果您操作了一阵子 PowerShell，然后突然意识到想保存刚才输入过的命令，那么请试试这行简单的代码： (Get-History).CommandLine | clip 这段代码将您的所有命令行历史复制到剪贴板中。您可以把它粘贴到任何您喜欢的编辑器中，然后将命令保存到文件中。 如果您将命令粘贴到 PowerShell ISE 编辑器中，那么这些命令将会成为一段 PowerShell 脚本。","text":"适用于所有 PowerShell 版本 如果您操作了一阵子 PowerShell，然后突然意识到想保存刚才输入过的命令，那么请试试这行简单的代码： (Get-History).CommandLine | clip 这段代码将您的所有命令行历史复制到剪贴板中。您可以把它粘贴到任何您喜欢的编辑器中，然后将命令保存到文件中。 如果您将命令粘贴到 PowerShell ISE 编辑器中，那么这些命令将会成为一段 PowerShell 脚本。 本文国际来源：Copying Command History","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 解析 eD2k 链接","slug":"use-powershell-to-exact-ed2k-link","date":"2014-08-18T09:24:38.000Z","updated":"2017-03-17T15:26:24.200Z","comments":true,"path":"2014/08/18/use-powershell-to-exact-ed2k-link/","link":"","permalink":"http://blog.vichamp.com/2014/08/18/use-powershell-to-exact-ed2k-link/","excerpt":"","text":"电骡的 eD2k 链接包含了丰富的信息。例如这个： ed2k://|file|BingPinyinSetup_1.5.24.02.exe|31485072|C8C9282E6112455E624EE82941E5BA00|p=79A822E1788353E0B289D2ADD5DA3BDE:FB9BB40DEDB1D2307E9D734A6416704B:0732B122C4ECF70065B181C92BF72400:437958DF590D764DE1694F91AC085225|h=HLXRQSANEO5MHIVOYNM5FNQOHJG3D5MP|s=http://blog.vichamp.com|s=http://www.baidu.com|/|sources,127.0.0.1:1234,192.168.1.1:8888|/ 这给我们的第一感觉是可以用正则表达式来解析。我们观察一下它的规律，发现它是用 | 分割的字符串： ed2k:// file BingPinyinSetup_1.5.24.02.exe 31485072 C8C9282E6112455E624EE82941E5BA00 p=79A822E1788353E0B289D2ADD5DA3BDE:FB9BB40DEDB1D2307E9D734A6416704B:0732B122C4ECF70065B181C92BF72400:437958DF590D764DE1694F91AC085225 h=HLXRQSANEO5MHIVOYNM5FNQOHJG3D5MP s=http://www.abc.com/def.zip s=http://www.vichamp.com/qq.zip / sources,127.0.0.1:1234,192.168.1.1:8888 / 还有一些规律： 从 p= 开始，后面的段都是可选的。 p=xxx、h=xxx、s=xxx看起来像键值对。 s= 可以有多个，sources 后面的 IP 和端口可以有多对。 根据这个规律，我们可以很容易地构造出正则表达式，并用 PowerShell 解析它。 function Get-Ed2kLink { Param( [string] [Parameter(Mandatory = $true, ValueFromPipeline = $true, HelpMessage = &apos;Enter an ed2k:// url&apos;)] $Link ) $regex = [regex]@&apos; (?x) \\bed2k:// \\|file\\|(?&lt;FILE_NAME&gt;[^|]+) \\|(?&lt;FILE_SIZE&gt;\\d+) \\|(?&lt;FILE_HASH&gt;[0-9a-fA-F]+) (?:\\|p=(?:(?&lt;HASH_SET&gt;[0-9a-fA-F]+):?)+)? (?:\\|h=(?&lt;ROOT_HASH&gt;[0-9a-zA-Z]+))? (?:\\|s=(?&lt;HTTP_SOURCE&gt;[^|]+))* \\|\\/ \\|sources(?:,(?&lt;SOURCES_HOST&gt;[0-9a-zA-Z.]+):(?&lt;SOURCES_PORT&gt;\\d+))* |\\/\\b &apos;@ $match = $regex.Match($Link) if ($match.Success) { $sourcesHost = $match.Groups[&apos;SOURCES_HOST&apos;].Captures | Select-Object -ExpandProperty Value $sourcesPort = $match.Groups[&apos;SOURCES_PORT&apos;].Captures | Select-Object -ExpandProperty Value $sources = @() for ($i = 0; $i -lt $sourcesHost.Length; $i++) { $sources += [PSCustomObject][Ordered]@{ Host = $sourcesHost[$i] Port = $sourcesPort[$i] } } $result = [PSCustomObject][Ordered]@{ File = $match.Groups[&apos;FILE_NAME&apos;].Value; FileSize = $match.Groups[&apos;FILE_SIZE&apos;].Value; FileHash = $match.Groups[&apos;FILE_HASH&apos;].Value; HashSet = $match.Groups[&apos;HASH_SET&apos;].Captures | Select-Object -ExpandProperty Value RootHash = $match.Groups[&apos;ROOT_HASH&apos;].Value; HttpSource = $match.Groups[&apos;HTTP_SOURCE&apos;].Captures | Select-Object -ExpandProperty Value Sources = $sources; } } else { $result = $null } return $result } Get-Ed2kLink &apos;ed2k://|file|BingPinyinSetup_1.5.24.02.exe|31485072|C8C9282E6112455E624EE82941E5BA00|p=79A822E1788353E0B289D2ADD5DA3BDE:FB9BB40DEDB1D2307E9D734A6416704B:0732B122C4ECF70065B181C92BF72400:437958DF590D764DE1694F91AC085225|h=HLXRQSANEO5MHIVOYNM5FNQOHJG3D5MP|s=http://www.abc.com/def.zip|s=http://www.vichamp.com/qq.zip|/|sources,127.0.0.1:1234,192.168.1.1:8888|/&apos; 执行结果如下： File : BingPinyinSetup_1.5.24.02.exe FileSize : 31485072 FileHash : C8C9282E6112455E624EE82941E5BA00 HashSet : {79A822E1788353E0B289D2ADD5DA3BDE, FB9BB40DEDB1D2307E9D734A6416704B, 0732B122C4ECF70065B181C92BF72400, 437958DF590D764DE1694F91AC085225} RootHash : HLXRQSANEO5MHIVOYNM5FNQOHJG3D5MP HttpSource : {http://www.abc.com/def.zip, http://www.vichamp.com/qq.zip} Sources : {@{Host=127.0.0.1; Port=1234}, @{Host=192.168.1.1; Port=8888}} 注意一下，由于 s= 和 sources 节包含循环体，所以不能直接用 PowerShell 的 -cmatch 表达式和 $Matches 变量，必须用 .NET 的 [regex] 类来处理。 参考材料： eD2k 連結 Link Creator - 用于生成 eD2k 链接。 您也可以在这里下载完整的源代码。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"regex","slug":"regex","permalink":"http://blog.vichamp.com/tags/regex/"},{"name":"text","slug":"text","permalink":"http://blog.vichamp.com/tags/text/"},{"name":"ed2k","slug":"ed2k","permalink":"http://blog.vichamp.com/tags/ed2k/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 用正则表达式搜索文件","slug":"searching-files-with-regular-expressions","date":"2014-08-18T03:00:00.000Z","updated":"2017-03-17T15:26:24.176Z","comments":true,"path":"2014/08/18/searching-files-with-regular-expressions/","link":"","permalink":"http://blog.vichamp.com/2014/08/18/searching-files-with-regular-expressions/","excerpt":"适用于 PowerShell 所有版本 Get-ChildItem 不支持高级的文件过滤。当您使用简单的通配符时，无法利用上正则表达式。 要用上正则表达式，需要增加一个过滤用的 cmdlet 和 -match 操作符。 这个例子将在 Windows 目录中查找所有文件名包含至少 2 位数字，且文件名不超过 8 个字符的文件： Get-ChildItem -Path $env:windir -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.BaseName -match &apos;\\d{2}&apos; -and $_.Name.Length -le 8 } 请注意 BaseName 属性的使用。它只返回主文件名（不包含扩展名）。通过这种方式，扩展名中的数字不会被包含在内。","text":"适用于 PowerShell 所有版本 Get-ChildItem 不支持高级的文件过滤。当您使用简单的通配符时，无法利用上正则表达式。 要用上正则表达式，需要增加一个过滤用的 cmdlet 和 -match 操作符。 这个例子将在 Windows 目录中查找所有文件名包含至少 2 位数字，且文件名不超过 8 个字符的文件： Get-ChildItem -Path $env:windir -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.BaseName -match &apos;\\d{2}&apos; -and $_.Name.Length -le 8 } 请注意 BaseName 属性的使用。它只返回主文件名（不包含扩展名）。通过这种方式，扩展名中的数字不会被包含在内。 本文国际来源：Searching Files with Regular Expressions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取指定扩展名的文件","slug":"getting-files-with-specific-extensions-only","date":"2014-08-15T03:00:00.000Z","updated":"2017-03-17T15:26:24.176Z","comments":true,"path":"2014/08/15/getting-files-with-specific-extensions-only/","link":"","permalink":"http://blog.vichamp.com/2014/08/15/getting-files-with-specific-extensions-only/","excerpt":"适用于 PowerShell 所有版本 当您使用 Get-ChildItem 来获取一个文件列表时，您可能会注意到 -Filter 参数有时候会导致返回比你预期的更多的文件。 以下是一个例子。这段代码并不只是返回“.ps1”扩展名的文件，而也会返回“.ps1xml”扩展名的文件： Get-ChildItem -Path C:\\windows -Recurse -ErrorAction SilentlyContinue -Filter *.ps1 要限制只返回您需要的扩展名的文件，请用一个 cmdlet 来过滤结果： Get-ChildItem -Path C:\\windows -Recurse -ErrorAction SilentlyContinue -Filter *.ps1 | Where-Object { $_.Extension -eq &apos;.ps1&apos; } 这将只返回您指定的扩展名的文件。","text":"适用于 PowerShell 所有版本 当您使用 Get-ChildItem 来获取一个文件列表时，您可能会注意到 -Filter 参数有时候会导致返回比你预期的更多的文件。 以下是一个例子。这段代码并不只是返回“.ps1”扩展名的文件，而也会返回“.ps1xml”扩展名的文件： Get-ChildItem -Path C:\\windows -Recurse -ErrorAction SilentlyContinue -Filter *.ps1 要限制只返回您需要的扩展名的文件，请用一个 cmdlet 来过滤结果： Get-ChildItem -Path C:\\windows -Recurse -ErrorAction SilentlyContinue -Filter *.ps1 | Where-Object { $_.Extension -eq &apos;.ps1&apos; } 这将只返回您指定的扩展名的文件。 本文国际来源：Getting Files with Specific Extensions Only","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"XAMPP 学习路线","slug":"xampp-guideline","date":"2014-08-14T03:10:16.000Z","updated":"2017-03-17T15:26:24.174Z","comments":true,"path":"2014/08/14/xampp-guideline/","link":"","permalink":"http://blog.vichamp.com/2014/08/14/xampp-guideline/","excerpt":"","text":"XAMPP = Apache + MySQL + PHP + Perl XAMPP是最流行的PHP开发环境 XAMPP是完全免费且易于安装的Apache发行版，其中包含MySQL、PHP和Perl。XAMPP开放源码包的设置让安装和使用出奇容易。 网站XAMPP 官方网站XAMPP - SourceForge 文件区别 安装版（适合小型服务器安装） xampp-win32-*-installer.exe - 有安装向导。 xampp-win32-*.zip - 解开是一个 xampp 目录，但可以随后注册服务等。 xampp-win32-*.7z - 和 .zip 版相同，压缩后体积更小。 便携版（适合开发测试。不包含 FileZilla FTP 和 Mercury Mail Server，不能安装服务） xampp-portable-win32-*-installer.exe xampp-portable-win32-*.zip xampp-portable-win32-*.7z 快速起步切勿自己摸索！因为不同的版本的步骤有所不同。请阅读 xampp\\readme_en.txt 中的 QUICK INSTALLATION 节。篇幅很短，不用担心 :) 潜在陷阱 必须安装（或解压到）根目录下。例如 D:\\xampp，或者 E:\\xampp。 注意缺省的 80 和 443 端口未被其它程序占用。netstat -ano |find &quot;80&quot;、netstat -ano |find &quot;443&quot; 如果用安装版的压缩包（.zip 或 .7z），并需要安装服务，请用提升权限的管理员账户打开 xampp-control.exe 进行安装。 如果要能让别的机器或外网访问，请注意配置防火墙。 通过 xampp-control.exe 启动，可能看不到完整的错误提示。请在命令行下启动 xampp_start.exe，可以看到更详细的错误提示。 如果遇到错误，可以根据 xampp-control.exe 面板上的各个 Logs 按钮找到相应的日志。另外，可以通过 Windows 的事件查看部分日志。","categories":[{"name":"server","slug":"server","permalink":"http://blog.vichamp.com/categories/server/"}],"tags":[{"name":"guideline","slug":"guideline","permalink":"http://blog.vichamp.com/tags/guideline/"},{"name":"link","slug":"link","permalink":"http://blog.vichamp.com/tags/link/"},{"name":"server","slug":"server","permalink":"http://blog.vichamp.com/tags/server/"},{"name":"xampp","slug":"xampp","permalink":"http://blog.vichamp.com/tags/xampp/"}],"keywords":[{"name":"server","slug":"server","permalink":"http://blog.vichamp.com/categories/server/"}]},{"title":"用 XAMPP 搭建反向代理服务器","slug":"reverse-proxy-with-xampp","date":"2014-08-14T03:05:05.000Z","updated":"2017-03-17T15:26:24.170Z","comments":true,"path":"2014/08/14/reverse-proxy-with-xampp/","link":"","permalink":"http://blog.vichamp.com/2014/08/14/reverse-proxy-with-xampp/","excerpt":"","text":"公网 IP 地址 + 80 端口是稀缺资源。在开发、测试阶段，我们常常需要在一个公网 IP 的 80 端口上，绑定多个 WEB 服务，这些服务可能部署在内网的多台异构服务器上（不同操作系统、不同服务器软件）。 用表格来表达就是： 外网访问 重定向到 http://home.test.com http://127.0.0.1:81 http://img.test.com http://127.0.0.1:82 http://js.test.com http://127.0.0.1:83 在 Linux 下，可以通过 vhost 程序来实现这个需求。在 Windows 下，我们有 XAMPP 和 IIS 两种选择。本文重点介绍 XAMPP 的实现方式。 分别搭建 3 个测试服务器可以采用这些小工具快速创建测试服务器： anywhere HFS ~ HTTP File Server 设置 hosts 以便测试首先要让 3 个域名都指向本机。我们可以直接修改本地 hosts 文件以便测试。这种方式立刻生效，免去申请域名的麻烦。 用提升权限的记事本打开 %windir%\\system32\\drivers\\etc\\hosts 文件，加入这段： 127.0.0.1 home.test.com 127.0.0.1 img.test.com 127.0.0.1 js.test.com 这里有个快捷的方法，参见：PowerShell 技能连载 - 编辑“hosts”文件。 搭建 XAMPP 环境请参见 XAMPP 学习路线。只需要其中的 Apache 模块即可。确保 XAMPP 能够正常启动，并能够通过 http://127.0.0.1 访问缺省页面。 设置 XAMPP编辑 xampp\\apache\\conf\\httpd.conf，将 LoadModule proxy_http_module modules/mod_proxy_http.so 前的 # 号去掉。 编辑 xampp\\apache\\conf\\extra\\httpd-vhosts.conf，在尾部添加： ProxyRequests Off &lt;Proxy *&gt; Order deny,allow Allow from all &lt;/Proxy&gt; &lt;VirtualHost *:80&gt; ServerName blog.test.com ProxyPass / http://127.0.0.1:81/ ProxyPassReverse / http://127.0.0.1:81/ &lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; ServerName img.test.com ProxyPass / http://127.0.0.1:82/ ProxyPassReverse / http://127.0.0.1:82/ &lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; ServerName js.test.com ProxyPass / http://127.0.0.1:83/ ProxyPassReverse / http://127.0.0.1:83/ &lt;/VirtualHost&gt; 重启 XAMPP 中的 Apache 组件 姊妹篇 - 用 IIS 搭建反向代理服务器用 IIS 也可以实现相同的功能。 IIS实现反向代理 - 爱做梦的鱼 - 博客园 iis7 配置反向代理justin新浪博客 注意有个坑： 用 %windir%\\System32\\inetsrv\\iis.msc 或通过“这台电脑 - 右键 - 计算机管理” 启动 IIS 管理器，可能看不到 ARR 组件；而通过 %windir%\\system32\\inetsrv\\InetMgr.exe 则可以看到。 鸣谢 XAMPP 方式，在网友 坎坎 的指导下实现。 IIS 方式，在网友 莫名 的指导下实现。 参考文章 XAMPP 反向代理配置 - 绿的日志 - 网易博客 - 里面的路径等稍有不对，所以本文重新整理。","categories":[{"name":"server","slug":"server","permalink":"http://blog.vichamp.com/categories/server/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"server","slug":"server","permalink":"http://blog.vichamp.com/tags/server/"},{"name":"xampp","slug":"xampp","permalink":"http://blog.vichamp.com/tags/xampp/"},{"name":"apache","slug":"apache","permalink":"http://blog.vichamp.com/tags/apache/"},{"name":"proxy","slug":"proxy","permalink":"http://blog.vichamp.com/tags/proxy/"}],"keywords":[{"name":"server","slug":"server","permalink":"http://blog.vichamp.com/categories/server/"}]},{"title":"PowerShell 技能连载 - 修正 ISE 的编码","slug":"correcting-ise-encoding","date":"2014-08-14T03:00:00.000Z","updated":"2017-03-17T15:26:24.153Z","comments":true,"path":"2014/08/14/correcting-ise-encoding/","link":"","permalink":"http://blog.vichamp.com/2014/08/14/correcting-ise-encoding/","excerpt":"适用于所有 PowerShell 版本 当您在 ISE 编辑器中运行一个控制台程序时，非标准字符，例如“ä”或“ß”将会显示不正常。要修正 ISE 和隐藏的控制台之间通信的编码，请使用这段代码： # Repair encoding. This REQUIRES a console app to run first because only # then will ISE actually create its hidden background console $null = cmd.exe /c echo [Console]::OutputEncoding = [System.Text.Encoding]::UTF8 # Now all is fine cmd.exe /c echo ÄÖÜäöüß","text":"适用于所有 PowerShell 版本 当您在 ISE 编辑器中运行一个控制台程序时，非标准字符，例如“ä”或“ß”将会显示不正常。要修正 ISE 和隐藏的控制台之间通信的编码，请使用这段代码： # Repair encoding. This REQUIRES a console app to run first because only # then will ISE actually create its hidden background console $null = cmd.exe /c echo [Console]::OutputEncoding = [System.Text.Encoding]::UTF8 # Now all is fine cmd.exe /c echo ÄÖÜäöüß 本文国际来源：Correcting ISE Encoding","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用“打开文件”对话框","slug":"using-the-openfile-dialog","date":"2014-08-13T03:00:00.000Z","updated":"2017-03-17T15:26:24.153Z","comments":true,"path":"2014/08/13/using-the-openfile-dialog/","link":"","permalink":"http://blog.vichamp.com/2014/08/13/using-the-openfile-dialog/","excerpt":"适用于 PowerShell 3.0 及以上版本 以下是一个快捷的函数，可以用在 ISE 编辑器和 PowerShell 控制台中（适用于 PowerShell 3.0 及以上版本）：Show-OpenFileDialog。 function Show-OpenFileDialog { param ( $StartFolder = [Environment]::GetFolderPath(&apos;MyDocuments&apos;), $Title = &apos;Open what?&apos;, $Filter = &apos;All|*.*|Scripts|*.ps1|Texts|*.txt|Logs|*.log&apos; ) Add-Type -AssemblyName PresentationFramework $dialog = New-Object -TypeName Microsoft.Win32.OpenFileDialog $dialog.Title = $Title $dialog.InitialDirectory = $StartFolder $dialog.Filter = $Filter $resultat = $dialog.ShowDialog() if ($resultat -eq $true) { $dialog.FileName } } 这个函数将打开一个“打开文件”对话框。用户可以选择一个文件，并且选择的文件对象将返回给 PowerShell。所以下次您的脚本需要打开一个 CSV 文件时，您可能就能用上。","text":"适用于 PowerShell 3.0 及以上版本 以下是一个快捷的函数，可以用在 ISE 编辑器和 PowerShell 控制台中（适用于 PowerShell 3.0 及以上版本）：Show-OpenFileDialog。 function Show-OpenFileDialog { param ( $StartFolder = [Environment]::GetFolderPath(&apos;MyDocuments&apos;), $Title = &apos;Open what?&apos;, $Filter = &apos;All|*.*|Scripts|*.ps1|Texts|*.txt|Logs|*.log&apos; ) Add-Type -AssemblyName PresentationFramework $dialog = New-Object -TypeName Microsoft.Win32.OpenFileDialog $dialog.Title = $Title $dialog.InitialDirectory = $StartFolder $dialog.Filter = $Filter $resultat = $dialog.ShowDialog() if ($resultat -eq $true) { $dialog.FileName } } 这个函数将打开一个“打开文件”对话框。用户可以选择一个文件，并且选择的文件对象将返回给 PowerShell。所以下次您的脚本需要打开一个 CSV 文件时，您可能就能用上。 本文国际来源：Using the OpenFile Dialog","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"JavaScript 学习路线","slug":"javascript-guideline","date":"2014-08-12T11:57:59.000Z","updated":"2017-03-17T15:26:24.134Z","comments":true,"path":"2014/08/12/javascript-guideline/","link":"","permalink":"http://blog.vichamp.com/2014/08/12/javascript-guideline/","excerpt":"","text":"入门 JavaScript 教程 - w3school JavaScript 秘密花园 高级Dmitry Soshnikov 的 ECMA-262 及中文翻译 ECMA-262 » JavaScript. The core. JavaScript核心 ECMA-262 » ECMA-262-3 in detail. Chapter 1. Execution Contexts. [JavaScript]ECMA-262-3 深入解析.第一章.执行上下文 - Justin - 博客园 goddyzhao • 执行上下文（Execution Context） ECMA-262 » ECMA-262-3 in detail. Chapter 2. Variable object. [JavaScript]ECMA-262-3 深入解析.第二章.变量对象 - Justin - 博客园 goddyzhao • 变量对象（Variable object） ECMA-262 » ECMA-262-3 in detail. Chapter 3. This. [JavaScript]ECMA-262-3 深入解析.第三章.this - Justin - 博客园 goddyzhao • this ECMA-262 » ECMA-262-3 in detail. Chapter 4. Scope chain. goddyzhao • 作用域链（Scope Chain） ECMA-262 » ECMA-262-3 in detail. Chapter 5. Functions. goddyzhao • 函数（Functions） ECMA-262 » ECMA-262-3 in detail. Chapter 6. Closures. ** goddyzhao • 闭包（Closures） ECMA-262 » ECMA-262-3 in detail. Chapter 7.1. OOP: The general theory. ECMA-262 » ECMA-262-3 in detail. Chapter 7.2. OOP: ECMAScript implementation. ECMA-262 » ECMA-262-3 in detail. Chapter 8. Evaluation strategy. ECMA-262 » The quiz 编码规范 Google JavaScript Style Guide Javascript编程风格 - 阮一峰的网络日志","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/categories/javascript/"}],"tags":[{"name":"guideline","slug":"guideline","permalink":"http://blog.vichamp.com/tags/guideline/"},{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://blog.vichamp.com/categories/javascript/"}]},{"title":"HTML CSS 学习路线","slug":"html-css-guideline","date":"2014-08-12T11:32:26.000Z","updated":"2017-03-17T15:26:24.107Z","comments":true,"path":"2014/08/12/html-css-guideline/","link":"","permalink":"http://blog.vichamp.com/2014/08/12/html-css-guideline/","excerpt":"","text":"入门网站 w3school 在线教程 MDN 教程 API 文档 Web API reference - Web technology reference - 来自 MDN HTML HTML5 - Web 开发者指南 CSS CSS3 - CSS 编码规范 Google HTML/CSS Style Guide - Google 版，需翻墙。中文版尚未发布，请关注 zh-google-styleguide/zh-google-styleguide CSS · Styleguide - GitHub 版本 编码规范 by @mdo - BootStrap 中文网。其中的“属性顺序”值得参考。 idiomatic-css/translations/zh-CN at master · necolas/idiomatic-css WordPress › CSS Coding Standards « Make WordPress Core - WordPress 版 CSS命名及书写规范 - WEB开发者 在线编辑器 RunJS - 在线编辑、展示、分享、交流你的 JavaScript 代码 - 开源中国提供，访问速度快，功能略简单。 CodePen - Front End Developer Playground &amp; Code Editor in the Browser - 功能最强，国外，访问慢。 JSFiddle - 国外，访问慢。 Pastebin.com - #1 paste tool since 2002! The World’s Most Powerful Browser-Based IDE - Codio - 国外，访问慢。 类 gist Gists codepad Ideone.com - Online Compiler and IDE &gt;&gt; C/C++, Java, PHP, Python, Perl and 40+ other compilers and interpreters","categories":[{"name":"web","slug":"web","permalink":"http://blog.vichamp.com/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://blog.vichamp.com/tags/css/"},{"name":"guideline","slug":"guideline","permalink":"http://blog.vichamp.com/tags/guideline/"},{"name":"web","slug":"web","permalink":"http://blog.vichamp.com/tags/web/"},{"name":"link","slug":"link","permalink":"http://blog.vichamp.com/tags/link/"},{"name":"html","slug":"html","permalink":"http://blog.vichamp.com/tags/html/"}],"keywords":[{"name":"web","slug":"web","permalink":"http://blog.vichamp.com/categories/web/"}]},{"title":"PowerShell 技能连载 - 用 Group-Object 来创建哈希表","slug":"use-group-object-to-create-hash-tables","date":"2014-08-12T03:00:00.000Z","updated":"2017-03-17T15:26:24.145Z","comments":true,"path":"2014/08/12/use-group-object-to-create-hash-tables/","link":"","permalink":"http://blog.vichamp.com/2014/08/12/use-group-object-to-create-hash-tables/","excerpt":"适用于所有 PowerShell 版本 Group-Object 能把对象输送到管道中，然后在一个管道中把属性相同的对象排在一起。 这个功能十分有用，特别是当您用 Group-Object 来返回哈希表时。它将生成一个按服务状态分组的哈希表： $hash = Get-Service | Group-Object -Property Status -AsHashTable -AsString 您现在可以通过这种方式获取所有正在运行（或已停止的）服务： $hash.Running $hash.Stopped 可以用任何想要的属性来分组。这个例子将用三个组来分组文件：一组为小文件，一个组为中等文件，另一个组位大文件。 $code = { if ($_.Length -gt 1MB) {&apos;huge&apos;} elseif ($_.Length -gt 10KB) {&apos;average&apos;} else {&apos;tiny&apos;} } $hash = Get-ChildItem -Path c:\\windows | Group-Object -Property $code -AsHashTable -AsString #$hash.Tiny $hash.Huge","text":"适用于所有 PowerShell 版本 Group-Object 能把对象输送到管道中，然后在一个管道中把属性相同的对象排在一起。 这个功能十分有用，特别是当您用 Group-Object 来返回哈希表时。它将生成一个按服务状态分组的哈希表： $hash = Get-Service | Group-Object -Property Status -AsHashTable -AsString 您现在可以通过这种方式获取所有正在运行（或已停止的）服务： $hash.Running $hash.Stopped 可以用任何想要的属性来分组。这个例子将用三个组来分组文件：一组为小文件，一个组为中等文件，另一个组位大文件。 $code = { if ($_.Length -gt 1MB) {&apos;huge&apos;} elseif ($_.Length -gt 10KB) {&apos;average&apos;} else {&apos;tiny&apos;} } $hash = Get-ChildItem -Path c:\\windows | Group-Object -Property $code -AsHashTable -AsString #$hash.Tiny $hash.Huge 本文国际来源：Use Group-Object to Create Hash Tables","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 PowerShell 来励志","slug":"have-powershell-cheer-you-up","date":"2014-08-10T20:00:00.000Z","updated":"2017-03-17T15:26:24.107Z","comments":true,"path":"2014/08/11/have-powershell-cheer-you-up/","link":"","permalink":"http://blog.vichamp.com/2014/08/11/have-powershell-cheer-you-up/","excerpt":"适用于所有 PowerShell 版本 编写 PowerShell 代码是十分带劲的，但是某些时候会令人感到沮丧。这是一个用 PowerShell 来励志的函数。只需要打开音箱，PowerShell 会在您执行每一条命令之后鼓励你。 function prompt { $text = &apos;You are great!&apos;, &apos;Hero!&apos;, &apos;What a checker you are.&apos;, &apos;Champ, well done!&apos;, &apos;Man, you are good!&apos;, &apos;Guru stuff I would say.&apos;, &apos;You are magic!&apos; &apos;PS&gt; &apos; $host.UI.RawUI.WindowTitle = Get-Location (New-Object -ComObject Sapi.SpVoice).Speak(($text | Get-Random)) }","text":"适用于所有 PowerShell 版本 编写 PowerShell 代码是十分带劲的，但是某些时候会令人感到沮丧。这是一个用 PowerShell 来励志的函数。只需要打开音箱，PowerShell 会在您执行每一条命令之后鼓励你。 function prompt { $text = &apos;You are great!&apos;, &apos;Hero!&apos;, &apos;What a checker you are.&apos;, &apos;Champ, well done!&apos;, &apos;Man, you are good!&apos;, &apos;Guru stuff I would say.&apos;, &apos;You are magic!&apos; &apos;PS&gt; &apos; $host.UI.RawUI.WindowTitle = Get-Location (New-Object -ComObject Sapi.SpVoice).Speak(($text | Get-Random)) } 本文国际来源：Have PowerShell Cheer You Up!","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 记录脚本做了什么事","slug":"logging-what-a-script-does","date":"2014-08-08T03:00:00.000Z","updated":"2017-03-17T15:26:24.107Z","comments":true,"path":"2014/08/08/logging-what-a-script-does/","link":"","permalink":"http://blog.vichamp.com/2014/08/08/logging-what-a-script-does/","excerpt":"适用于所有 PowerShell 版本 您应该知道在 PowerShell 控制台（不是 ISE 编辑器）中，您可以打开记录功能： PS&gt; Start-Transcript 这将会把所有键入的命令以及所有的命令执行结果都记录到一个文件中。不幸的是，当您运行一个脚本的时候，作用就受限了，因为您无法看到实际的脚本命令。 以下是一个激进的技巧，能够记录包括所有脚本中执行的命令。在您尝试这个技巧之前，请注意这将增加您的日志文件大小并且会导致脚本执行变慢，因为在循环体中，每一次循环都会被记录下来。 只要执行这行代码就可以打开脚本命令记录了： PS&gt; Set-PSDebug -Trace 1","text":"适用于所有 PowerShell 版本 您应该知道在 PowerShell 控制台（不是 ISE 编辑器）中，您可以打开记录功能： PS&gt; Start-Transcript 这将会把所有键入的命令以及所有的命令执行结果都记录到一个文件中。不幸的是，当您运行一个脚本的时候，作用就受限了，因为您无法看到实际的脚本命令。 以下是一个激进的技巧，能够记录包括所有脚本中执行的命令。在您尝试这个技巧之前，请注意这将增加您的日志文件大小并且会导致脚本执行变慢，因为在循环体中，每一次循环都会被记录下来。 只要执行这行代码就可以打开脚本命令记录了： PS&gt; Set-PSDebug -Trace 1 本文国际来源：Logging What a Script Does","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 生成随机身份信息","slug":"generate-random-identity-with-powershell","date":"2014-08-07T06:28:58.000Z","updated":"2017-03-17T15:26:24.091Z","comments":true,"path":"2014/08/07/generate-random-identity-with-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/08/07/generate-random-identity-with-powershell/","excerpt":"","text":"在开发、运维等工作中，我们常常需要生成一些随机的身份信息，例如“张三”、“李四”……等。实际中不光需要姓名，最好还有邮箱、QQ、联系电话、身份证号等。我们可以一劳永逸地写一个 PowerShell 脚本，随时优雅地生成一大串随机身份信息，取之不尽用之不竭。使用效果如下（当然也可以用 Export-Csv 轻松导出到 Excel 或者用 ConvertTo-Html 生成网页）： 根据 *PowerShell 技术交流 QQ 群今天的讨论，以及 shrekz 的 powershell 生成随机用户信息，我做了一些改进。增加了生日、性别、身份证号等。设计要点如下： QQ 号和邮箱须对应。身份证号的第 1-6 位是地区号码，应符合 G​B​T​2​2​6​0​—​1​9​9​9 规范。 身份证号的第 7-13 位是生日号码，不能和同一个人的生日号码矛盾。 身份证号的第 17 位，对于男性是奇数，对于女性是偶数，不能和同一个人的性别矛盾。 身份证号的第 18 位是校验位，根据 ISO 7064:1983.MOD 11-2 规范计算。 生成身份证号时，既可以指定生日号码和性别，也可以随机生成。 以下是一个可重用的模块 Get-Identity.psm1，可以把它保存在 %PSModulePath% 目录中，随时调用： $firstNames = (@&apos; 赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢邹喻柏水窦章 云苏潘葛奚范彭郎鲁韦昌马苗凤花方俞任袁柳酆鲍史唐费廉岑薛雷贺倪汤滕殷罗毕郝邬安常 乐于时傅皮卞齐康伍余元卜顾孟平黄和穆萧尹 &apos;@.Split((&quot;`n&quot;, &quot;`r&quot;)) -join $null).ToCharArray() $secondNames = (@&apos; 一丁三专世业丝中丰临丹丽举乃义乐乔书云亘亮人仁今仙令仪伟伯伶佑作佩佳侠侬俊俏俐信 修倩健偲儿允元兆光兰兴其典军冠冬冰凌凝凡凯刚初利力勃勇勋化北千卉华卓博卫卿厚原友 双发叡可叶司合吉同名向君吟听启周和咏咸品哲唱善喆喜嗣嘉囡国圣坚基堂墨壁夏多天奇奕 奥好如妃妍妙妞妮姗姝姣娅娇娜娟娥娴婉婧婵婷媚媛嫒嫔嫚子存孟季学宁宇安宜宝实宣宵家 宸容宾密寒寰寻寿小尘尚尹展山岑岚峯峰峻巍州工巧布帅帆希干平年广庆康庸延建弘强弼彤 彦彩彬彭影微德心志忠念忻怀思怡恩恬恺悟悦情惜惠愉意慈慕慧懋懿成才扬承抒拔振捷掣敏 教文斌斯新方施旎旭旻昂昊昌明易昕星春昶晋晓晔晖晤晨景晴晶智暄暖暮曜曦曲曼曾月朋朔 朗望朝木本朵杉杏材杰松林枝枫柏柔柳栋树格桃桐梅梓梦棠森楚楠欢欣歆歌正武毅民水永江 池沈沉沙沛河泉波泰泽洁洛津洮洲流济浓浦浩海涉涛润涵淑淳淼清渊温湃湉湘源溥溪滢滨漪 漫澄澍澹濮濯瀚灵灿炎炳烁烨焕焱然煜煦熙熠燕爽牧献玄玉玑玛玟玲珉珊珍珑珠珺琅琇琛琦 琨琪琲琳琴琼瑜瑞瑶瑾璇璞瓃甜用甫田甲男画畅略白皎益盼真睿知石碧磊礼祖祥祯祺禄福禧 禾秀秉秋程穆空立章童端竹笑笛筠简箫籁米精素红纬纳纵纶经绢绣绮维罗罡美羡羽翎翔翠翮 翰翼耀聪胜能自致舒舟航良艳艺艾芃芊芝芦芬花芳芸苑苗若英茂范茉茗茜茵荌荣荫莉莎莘莲 莹菁菊菡菱菲萌萍萝萧萱蒙蓉蓓蓝蔓蔚蕊蕙蕴蕾薄薇藉藻虎虹蝶行衣裕西言誉许识诗诚语诺 谊谧谷豪贝贞贤资赋赐赡赫超越跃路轩载辉辰达迈运进远迪逸邈邵郁郎采金鑫铃铄锋锐锦长 闲闵阳阵陶隽雄雅雨雪雯雰霁霓霖霞露青靓靖静韦音韵韶顺颀颖颜飇风飙飞香馨驰驹骄高魁 魄鲲鲸鸣鸾鸿鹍鹏麦默黛齐龙 &apos;@.Split((&quot;`n&quot;, &quot;`r&quot;)) -join $null).ToCharArray() $mobilePrefixes = @&apos; 134 135 136 137 138 139 147 150 151 152 157 158 159 182 187 188 147 157 188 130 131 132 155 156 185 186 186 133 153 180 189 189 200 133 150 151 152 153 155 156 157 158 159 130 131 132 133 134 135 136 137 138 139 180 182 185 186 187 188 189 170 &apos;@.Split((&quot;`n&quot;, &quot;`r&quot;, &quot; &quot;), &apos;RemoveEmptyEntries&apos;) $cityCodes = @&apos; 410701 341101 130901 130601 331001 230501 370601 659001 450301 120221 620701 341001 210201 510101 130501 320901 520401 510701 623001 450401 650201 420901 360701 620401 510501 542521 620501 232701 530401 611001 340401 321301 520101 320401 430501 653101 460101 220301 640201 610801 440501 450701 533421 429004 522401 532901 532801 130101 652101 445301 320601 410301 140201 530501 632121 511301 210501 152921 140901 330701 410101 350501 621101 350901 652801 652201 210801 440801 341801 500101 371401 411301 341501 141101 371301 440301 522201 231101 510901 330601 450201 350301 150201 220101 440901 411601 371101 320101 632221 330301 622901 130201 140101 131001 430301 610701 640101 450801 360601 131101 650101 440101 210301 632801 360401 231001 320801 530601 610201 210701 632321 360501 440201 512001 542621 370901 320201 220501 230801 220401 110228 430401 451201 340701 542301 130401 360201 410901 620601 150301 150801 140401 451001 532501 370101 440601 321001 411701 321101 654002 451401 410501 220801 350401 330201 522301 130701 420301 445101 420701 421301 211201 511701 420601 &apos;@.Split((&quot;`n&quot;, &quot;`r&quot;, &quot; &quot;), &apos;RemoveEmptyEntries&apos;) function Get-RandomName { return ($firstNames|Get-Random) + (($secondNames|Get-Random -Count ((1,2)|Get-Random)) -join $null) } function Get-RandomQQ { return [string](Get-Random -Minimum 100000 -Maximum 9999999999) } function Get-RandomEMail ($QQ) { if ($QQ) { return &quot;$QQ@qq.com&quot; } else { return (Get-RandomQQ) + &apos;@qq.com&apos; } } function Get-RandomMobile { return ($mobilePrefixes | Get-Random) + ((0..9 | Get-Random -count 8) -join $null) } function Get-RandomSex { return (&apos;男&apos;, &apos;女&apos; | Get-Random) } function Get-RandomBirthday { return (Get-Date).AddDays(-(Get-Random -Maximum (365 * 110))).Date } function Get-RandomID ([DateTime]$Birthday, $Sex){ $cityCode = $cityCodes | Get-Random #$cityCode = (0..9 | Get-Random -Count 6) -join $null if (!$Birthday) { $Birthday = Get-RandomBirthday } $birthdayCode = &apos;{0:yyyyMMdd}&apos; -f $Birthday if ($Sex -eq &apos;男&apos; -or $Sex -eq $true) { $seq = (Get-Random -Minimum 0 -Maximum 49) * 2 + 1 } else { $seq = (Get-Random -Minimum 0 -Maximum 49) * 2 + 2 } $result = &apos;{0}{1}{2:D3}&apos; -f $cityCode, $birthdayCode, $seq $w = @(7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2) $total = 0 for ($i = 0; $i -lt 17; $i++) { $total += $w[$i] * [int]::parse($result[$i]) } $checkCode = [string]($total % 11) $checkCode = &apos;10X98765432&apos;[$checkCode] $result = $result + $checkCode return $result } function Get-RandomIdentity { $qq = Get-RandomQQ $birthday = Get-RandomBirthday $sex = Get-RandomSex return [pscustomobject][ordered]@{ Name = Get-RandomName; QQ = $qq; EMail = Get-RandomEMail -QQ $qq; Mobile = Get-RandomMobile; Birthday = &apos;{0:yyyy/MM/dd}&apos; -f $birthday Sex = $sex ID = Get-RandomID -Birthday $birthday -Sex $sex } } Export-ModuleMember * 测试代码 Test-GetIdentity.ps1： if (Get-Module Get-Identity) { Remove-Module Get-Identity } Import-Module .\\Get-Identity.psm1 Get-RandomName # 生成随机的姓名 Get-RandomQQ # 生成随机的 QQ 号 Get-RandomEMail # 生成随机的 e-mail Get-RandomMobile # 生成随机的手机号 &apos;{0:yyyy/MM/dd}&apos; -f (Get-RandomBirthday) # 生成随机的生日 Get-RandomSex # 生成随机的性别 Get-RandomID # 生成随机的身份证号 Get-RandomIdentity # 生成随机的身份信息 # 批量生成 20 个完整的身份信息 1..20 | % { Get-RandomIdentity } | Out-GridView -Title 随机身份信息 输出结果： 孔懿 9903344437 7351437013@qq.com 15248325719 1950/02/24 男 450301200801030764 Name : 方盼 QQ : 8679192225 EMail : 8679192225@qq.com Mobile : 13923186497 Birthday : 2005/11/09 Sex : 男 ID : 130101200511090819 以及文章开头显示的那个图形化列表。 您也可以下载完整的 源代码 和 测试脚本。 另外如果您对如何提取区域代码感兴趣的话，还可以下载国标行政区划数据 GBT2260-1999.xml 和对应的解析程序 GBT2260.ps1 来研究。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 有趣的声音提示","slug":"a-fun-beeping-prompt","date":"2014-08-07T03:00:00.000Z","updated":"2017-03-17T15:26:24.091Z","comments":true,"path":"2014/08/07/a-fun-beeping-prompt/","link":"","permalink":"http://blog.vichamp.com/2014/08/07/a-fun-beeping-prompt/","excerpt":"适用于所有 PowerShell 版本 如果您的计算机装有声卡，那么这段代码可以让您的同事们吓一跳： function prompt { 1..3 | ForEach-Object { $frequency = Get-Random -Minimum 400 -Maximum 10000 $duration = Get-Random -Minimum 100 -Maximum 400 [Console]::Beep($frequency, $duration) } &apos;PS&gt; &apos; $host.ui.RawUI.WindowTitle = Get-Location } 这段代码将会缩短您的 PowerShell 提示符，并且在标题栏上显示当前的路径。这还算是有益的功能。搞破坏的部分是每次执行一条命令，都会发出随机频率的刺耳的三连音:)。","text":"适用于所有 PowerShell 版本 如果您的计算机装有声卡，那么这段代码可以让您的同事们吓一跳： function prompt { 1..3 | ForEach-Object { $frequency = Get-Random -Minimum 400 -Maximum 10000 $duration = Get-Random -Minimum 100 -Maximum 400 [Console]::Beep($frequency, $duration) } &apos;PS&gt; &apos; $host.ui.RawUI.WindowTitle = Get-Location } 这段代码将会缩短您的 PowerShell 提示符，并且在标题栏上显示当前的路径。这还算是有益的功能。搞破坏的部分是每次执行一条命令，都会发出随机频率的刺耳的三连音:)。 本文国际来源：A Fun Beeping Prompt","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 产生多个返回值","slug":"returning-more-than-one-value","date":"2014-08-06T03:00:00.000Z","updated":"2017-03-17T15:26:24.076Z","comments":true,"path":"2014/08/06/returning-more-than-one-value/","link":"","permalink":"http://blog.vichamp.com/2014/08/06/returning-more-than-one-value/","excerpt":"适用于所有 PowerShell 版本 如果一个 PowerShell 函数需要产生多个返回信息，最佳的实践方式是返回多个对象，然后将信息分别存储在对象的各个属性中。 以下是一个有趣的例外情况，它在某些场景中较为适用。尽管返回多个信息就可以了，并且要确保将结果赋值给多个变量： function Get-MultipleData { Get-Date &apos;Hello&apos; 1+4 } $date, $text, $result = Get-MultipleData &quot;The date is $date&quot; &quot;The text was $text&quot; &quot;The result is $result&quot; 这个测试函数产生 3 段信息，然后将结果存储在 3 个不同的变量中。","text":"适用于所有 PowerShell 版本 如果一个 PowerShell 函数需要产生多个返回信息，最佳的实践方式是返回多个对象，然后将信息分别存储在对象的各个属性中。 以下是一个有趣的例外情况，它在某些场景中较为适用。尽管返回多个信息就可以了，并且要确保将结果赋值给多个变量： function Get-MultipleData { Get-Date &apos;Hello&apos; 1+4 } $date, $text, $result = Get-MultipleData &quot;The date is $date&quot; &quot;The text was $text&quot; &quot;The result is $result&quot; 这个测试函数产生 3 段信息，然后将结果存储在 3 个不同的变量中。 本文国际来源：Returning More Than One Value","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"Excel 列号和数字互相转换","slug":"conversion-between-number-and-excel-column","date":"2014-08-05T09:08:51.000Z","updated":"2017-03-17T15:26:24.076Z","comments":true,"path":"2014/08/05/conversion-between-number-and-excel-column/","link":"","permalink":"http://blog.vichamp.com/2014/08/05/conversion-between-number-and-excel-column/","excerpt":"","text":"Excel 的列号是采用“A”、“B”……“Z”、“AA”、“AB”……的方式编号。但是我们在自动化操作中，往往希望用数字作为列号。我们可以用 PowerShell 来实现 Excel 的列号和数字之间的互相转换。 需求归纳Excel 列号 -&gt; 数字 A 1 AB 28 AC 29 数字 -&gt; Excel 列号 1 A 2 B 24 Y 26 Z 27 AA 28 AB 算法分析 Excel 列号 -&gt; 数字 用 ASCII 编码对输入的字符串解码，得到一个数字型数组。 用 26 进制对数组进行处理（逐位 *= 26，然后累加）。 数字 -&gt; Excel 列号 用 26 进制对数字进行处理（不断地 /= 26，取余数），得到数字型数组。 将数字型数组顺序颠倒。 用 ASCII 编码对数字型数组编码，得到 Excel 风格的列号。 源代码转换函数： function ConvertFrom-ExcelColumn ($column) { $result = 0 $ids = [System.Text.Encoding]::ASCII.GetBytes($column) | foreach { $result = $result * 26 + $_ - 64 } return $result } function ConvertTo-ExcelColumn ($number) { $ids = while ($number -gt 0) { ($number - 1) % 26 + 1 + 64 $number = [math]::Truncate(($number - 1) / 26) } [array]::Reverse($ids) return [System.Text.Encoding]::ASCII.GetString([array]$ids) } 测试代码： echo &quot;A`t$(ConvertFrom-ExcelColumn A)&quot; echo &quot;AB`t$(ConvertFrom-ExcelColumn AB)&quot; echo &quot;AC`t$(ConvertFrom-ExcelColumn AC)&quot; echo &apos;&apos; @(1..2) + @(25..28) | foreach { echo &quot;$_`t$(ConvertTo-ExcelColumn $_)&quot; } 执行结果： A 1 AB 28 AC 29 1 A 2 B 25 Y 26 Z 27 AA 28 AB 您也可以在这里下载完整的脚本。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"office","slug":"powershell/office","permalink":"http://blog.vichamp.com/categories/powershell/office/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"excel","slug":"excel","permalink":"http://blog.vichamp.com/tags/excel/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"office","slug":"powershell/office","permalink":"http://blog.vichamp.com/categories/powershell/office/"}]},{"title":"用 PowerShell 快速查看 PATH 环境变量","slug":"quick-examine-path-env-variable-with-powershell","date":"2014-08-05T06:24:24.000Z","updated":"2017-03-17T15:26:24.076Z","comments":true,"path":"2014/08/05/quick-examine-path-env-variable-with-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/08/05/quick-examine-path-env-variable-with-powershell/","excerpt":"","text":"我们常常需要查看 PATH 环境变量里是否有我们需要的路径。通常的做法是： 依次打开 系统属性 / 高级 / 环境变量。 分别在“用户变量”和“系统变量”列表框中双击 PATH 条目。 在“变量值”窄小的文本框中检视 PATH 变量的值。 往往不得不把变量值复制粘贴到记事本中，再利用搜索功能来查找。 利用 PowerShell，可以告别以上笨拙的步骤： PS &gt; (type env:path) -split &apos;;&apos; 这样就可以看到一个完美分割过的列表了。当然，利用 PowerShell 强大的查询功能，还可以进一步节省眼力。例如我们要查询所有包含“bin”的路径： PS &gt; (type env:path) -split &apos;;&apos; | sls bin C:\\PROGRAM FILES (X86)\\JAVA\\JDK1.7.0_45\\JRE\\BIN C:\\PROGRAM FILES (X86)\\INTEL\\OPENCL SDK\\2.0\\BIN\\X86 C:\\PROGRAM FILES (X86)\\INTEL\\OPENCL SDK\\2.0\\BIN\\X64 C:\\PROGRAM FILES\\MICROSOFT SQL SERVER\\110\\TOOLS\\BINN\\ D:\\greensoft\\UnxUtils\\usr\\local\\wbin\\ C:\\Program Files\\Microsoft SQL Server\\120\\Tools\\Binn\\ C:\\Program Files\\TortoiseGit\\bin C:\\Chocolatey\\bin c:\\Program Files\\MongoDB 2.6 Standard\\bin","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 编辑“hosts”文件","slug":"edit-network-hosts-file","date":"2014-08-05T03:00:00.000Z","updated":"2017-03-17T15:26:24.076Z","comments":true,"path":"2014/08/05/edit-network-hosts-file/","link":"","permalink":"http://blog.vichamp.com/2014/08/05/edit-network-hosts-file/","excerpt":"适用于所有 PowerShell 版本 如果您常常需要修改“hosts”文件，那么手工用提升权限的记事本实例来打开文件是相当乏味的事情。这是因为该文件只能被 Administrators 用户修改，所以普通的记事本实例无法修改它。 以下是一段您可以直接使用，或者调整一下用来打开任何需要提升权限的程序的脚本。 function Show-HostsFile { $Path = &quot;$env:windir\\system32\\drivers\\etc\\hosts&quot; Start-Process -FilePath notepad -ArgumentList $Path -Verb runas }","text":"适用于所有 PowerShell 版本 如果您常常需要修改“hosts”文件，那么手工用提升权限的记事本实例来打开文件是相当乏味的事情。这是因为该文件只能被 Administrators 用户修改，所以普通的记事本实例无法修改它。 以下是一段您可以直接使用，或者调整一下用来打开任何需要提升权限的程序的脚本。 function Show-HostsFile { $Path = &quot;$env:windir\\system32\\drivers\\etc\\hosts&quot; Start-Process -FilePath notepad -ArgumentList $Path -Verb runas } 本文国际来源：Edit Network “hosts” File","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"打包 node 应用程序为单一文件可执行程序","slug":"packeting-node-app","date":"2014-08-04T12:58:00.000Z","updated":"2017-03-17T15:26:24.057Z","comments":true,"path":"2014/08/04/packeting-node-app/","link":"","permalink":"http://blog.vichamp.com/2014/08/04/packeting-node-app/","excerpt":"","text":"解决方案 crcn/nexe - create a single executable out of your node.js apps。支持多个平台，似乎靠谱。 areve/node2exe - 只支持 Windows，用 copy /b 合并多个文件。 appjs/appjs - 已过期，被 node-webkit 替代。 rogerwang/node-webkit - Call all Node.js modules directly from DOM and enable a new way of writing applications with all Web technologies. 带图形界面的不二选择。 creationix/topcube - Gives node developers a way to have a desktop GUI to their node servers using HTML5 + CSS3 as the GUI platform. 讨论 javascript - Packaging a node.js webapp as a normal desktop app - Stack Overflow javascript - Make exe files from node.js app - Stack Overflow","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.vichamp.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.vichamp.com/tags/nodejs/"}],"keywords":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.vichamp.com/categories/nodejs/"}]},{"title":"Hexo 博客学习路线","slug":"hexo-guideline","date":"2014-08-04T12:20:37.000Z","updated":"2017-03-17T15:26:24.039Z","comments":true,"path":"2014/08/04/hexo-guideline/","link":"","permalink":"http://blog.vichamp.com/2014/08/04/hexo-guideline/","excerpt":"","text":"Hexo 是一个快速、便捷、强大的博客框架，通过 Node.js 技术构建。 如果你对默认配置满意，只需几个命令便可秒搭一个hexo。 如果你跟我一样喜欢折腾下，30分钟也足够个性化。 如果你过于喜欢折腾，可以折腾个把星期，尽情的玩。 官方链接 Hexo - 官方网站 hexojs/hexo - github 教程 hexo你的博客 - 推酷 - 系统，精炼，推荐。 Zippera’s blog 的 hexo 分类 hexo系列教程：（一）hexo介绍 hexo系列教程：（二）搭建hexo博客 hexo系列教程：（三）hexo博客的配置、使用 hexo系列教程：（四）hexo博客的优化技巧 hexo系列教程：（五）hexo博客的优化技巧续 hexo 主题优化 怎样在博文中嵌入图片、音乐、视频？ 把flickr相册嵌入网页 云空间 将hexo博客部署到bae - 不能以 github API 的方式部署。 托管博客到STDYUN 托管博客到gitcafe - 推荐使用，和 github 的 API 一致。 工具我制作了一系列脚本，用于整理博客文章、抓取外部图片、批处理生成发布等，请参见 victorwoo/victorwoo - GitCafe。","categories":[{"name":"network","slug":"network","permalink":"http://blog.vichamp.com/categories/network/"}],"tags":[{"name":"guideline","slug":"guideline","permalink":"http://blog.vichamp.com/tags/guideline/"},{"name":"link","slug":"link","permalink":"http://blog.vichamp.com/tags/link/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.vichamp.com/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://blog.vichamp.com/tags/blog/"},{"name":"nodejs","slug":"nodejs","permalink":"http://blog.vichamp.com/tags/nodejs/"}],"keywords":[{"name":"network","slug":"network","permalink":"http://blog.vichamp.com/categories/network/"}]},{"title":"PowerShell 技能连载 - 请注意 UNC 路径！","slug":"watch-out-with-unc-paths","date":"2014-08-04T03:00:00.000Z","updated":"2017-03-17T15:26:24.057Z","comments":true,"path":"2014/08/04/watch-out-with-unc-paths/","link":"","permalink":"http://blog.vichamp.com/2014/08/04/watch-out-with-unc-paths/","excerpt":"适用于所有 PowerShell 版本 许多 cmdlet 可以处理 UNC 路径，但是使用 UNC 路径会导致很多古怪的情况。请看以下： PS&gt; Test-Path -Path \\\\127.0.0.1\\c$ True 这段代码返回了 true，该 UNC 路径存在。现在将当前驱动器变为一个非文件系统驱动器，然后再次实验： PS&gt; cd hkcu:\\ PS&gt; Test-Path -Path \\\\127.0.0.1\\c$ False 同样的路径现在返回了 false。这是因为 UNC 路径并不包含驱动器号，而 PowerShell 需要驱动器号来指定正确的提供器。如果一个路径不包含驱动器号，那么 PowerShell 假设使用当前驱动器的提供器。所以如果您将当前的目录改为注册表，PowerShell 尝试在那儿查找 UNC 路径，那么就会失败。 更糟糕的是，出于某些未知的原因，但您用 net use 来映射驱动器时，PowerShell 在使用 cmdlet 来访问驱动器时可能会也可能不会产生混淆。 解决方案十分简单：当您用 cmdlet 访问 UNC 时，始终在 UNC 路径前面加上正确的提供器名称。这将消除该问题： PS&gt; Test-Path -Path FileSystem::\\\\127.0.0.1\\c$ True PS&gt; cd hkcu:\\ PS&gt; Test-Path -Path \\\\127.0.0.1\\c$ False PS&gt; Test-Path -Path FileSystem::\\\\127.0.0.1\\c$ True 如果您遇到了 net use 产生的问题，也可以使用同样的办法，在路径前面加上 “FileSystem::。该问题可以立刻得到解决。","text":"适用于所有 PowerShell 版本 许多 cmdlet 可以处理 UNC 路径，但是使用 UNC 路径会导致很多古怪的情况。请看以下： PS&gt; Test-Path -Path \\\\127.0.0.1\\c$ True 这段代码返回了 true，该 UNC 路径存在。现在将当前驱动器变为一个非文件系统驱动器，然后再次实验： PS&gt; cd hkcu:\\ PS&gt; Test-Path -Path \\\\127.0.0.1\\c$ False 同样的路径现在返回了 false。这是因为 UNC 路径并不包含驱动器号，而 PowerShell 需要驱动器号来指定正确的提供器。如果一个路径不包含驱动器号，那么 PowerShell 假设使用当前驱动器的提供器。所以如果您将当前的目录改为注册表，PowerShell 尝试在那儿查找 UNC 路径，那么就会失败。 更糟糕的是，出于某些未知的原因，但您用 net use 来映射驱动器时，PowerShell 在使用 cmdlet 来访问驱动器时可能会也可能不会产生混淆。 解决方案十分简单：当您用 cmdlet 访问 UNC 时，始终在 UNC 路径前面加上正确的提供器名称。这将消除该问题： PS&gt; Test-Path -Path FileSystem::\\\\127.0.0.1\\c$ True PS&gt; cd hkcu:\\ PS&gt; Test-Path -Path \\\\127.0.0.1\\c$ False PS&gt; Test-Path -Path FileSystem::\\\\127.0.0.1\\c$ True 如果您遇到了 net use 产生的问题，也可以使用同样的办法，在路径前面加上 “FileSystem::。该问题可以立刻得到解决。 本文国际来源：Watch Out With UNC Paths!","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 创建一个 HTTP 服务器","slug":"create-http-server-using-powershell","date":"2014-08-03T13:36:14.000Z","updated":"2017-03-17T15:26:24.023Z","comments":true,"path":"2014/08/03/create-http-server-using-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/08/03/create-http-server-using-powershell/","excerpt":"","text":"用 PowerShell 创建一个 HTTP 服务器其实非常简单，只要 0.8 KB 的代码就搞定了。只要将以下代码保存成 httpd.ps1 并在您的 www 资源目录里执行即可： param($Root=&quot;.&quot;, $Port=8080, $HostName=&quot;localhost&quot;) pushd $Root $Root = pwd $listener = New-Object System.Net.HttpListener $listener.Prefixes.Add(&quot;http://$HostName`:$Port/&quot;) $listener.Start() echo (&quot;Start {0} at `&quot;$Root`&quot;&quot; -f ($listener.Prefixes | select -f 1)) echo &quot;Enter Ctrl + C to stop.&quot; while ($true) { $context = $listener.GetContext() $url = $context.Request.Url.LocalPath.TrimStart(&apos;/&apos;) $res = $context.Response $path = Join-Path $Root ($url -replace &quot;/&quot;,&quot;\\&quot;) echo $path if ((Test-Path $path -PathType Leaf) -eq $true) { $content = [IO.File]::ReadAllBytes($path) $res.OutputStream.Write($content, 0, $content.Length) } else { $res.StatusCode = 404 } $res.Close() } 您也可以从这儿下载完整的文件。 这是从一个开源项目中看到的：MarkdownPresenter/httpd.ps1 at master · jsakamoto/MarkdownPresenter","categories":[],"tags":[],"keywords":[]},{"title":"从命令行运行 PowerShell","slug":"run-powershell-from-cmd","date":"2014-08-03T13:31:42.000Z","updated":"2017-03-17T15:26:24.039Z","comments":true,"path":"2014/08/03/run-powershell-from-cmd/","link":"","permalink":"http://blog.vichamp.com/2014/08/03/run-powershell-from-cmd/","excerpt":"","text":"从命令行运行 PowerShell 命令最精炼的代码： @powershell -nop -ex unrestricted -c &quot;Get-ChildItem&quot; 最后一个参数可以换成别的命令。另外，从命令行运行 .ps1 脚本的方式是： @powershell -nop -ex unrestricted .\\something.ps1","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"markdown 学习路线","slug":"markdown-guideline","date":"2014-08-03T08:14:02.000Z","updated":"2017-03-17T15:26:24.039Z","comments":true,"path":"2014/08/03/markdown-guideline/","link":"","permalink":"http://blog.vichamp.com/2014/08/03/markdown-guideline/","excerpt":"","text":"Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 介绍 Markdown - 维基百科，自由的百科全书 规范Markdown 的基本语法较为简单，所以多家衍生出不同的扩展版本。其中由于 GitHub 网站的流行，导致 Markdown 的 GitHub 扩展版本（简称 GFM）较为流行。 以下是基本语法和各个扩展版本的语法文档原始链接： Markdown 快速入门(简体中文版) Markdown 语法说明(简体中文版) Daring Fireball: Markdown Syntax Documentation Michel Fortin – PHP Markdown Extra Markdown Editing Help - Stack Overflow GitHub Flavored Markdown · GitHub Help - 简称 GFM，是目前较为通用的标准。 编辑器 MarkdownPad - The Markdown Editor for Windows 基于 .NET 开发，只用于 Windows，功能较齐全。GFM 风格离线编辑要收费。 Sublime Text + Markdown Editing 插件，是我目前在用的，支持在浏览器中预览等功能。参见 sublime装配markdown插件 - 开源软件 Cmd Markdown 编辑阅读器 - 作业部落出品 - 在线编辑器 文化 拷贝为Markdown - 将你在页面中选中的HTML格式转化为Markdown格式 dcurtis/markdown-mark - markdown 图标 jeffa00/posh-markdown - PowerShell Cmdlet to convert Markdown to HTML. Uses MarkdownSharp DLL 用 Markdown 来生成 HTML 幻灯片 jdan/cleaver - 简易，可换皮肤。 gnab/remark - 略麻烦一点。 jsakamoto/MarkdownPresenter - 不好用。 用 Markdown 来写书 GitBook","categories":[{"name":"markdown","slug":"markdown","permalink":"http://blog.vichamp.com/categories/markdown/"}],"tags":[{"name":"guideline","slug":"guideline","permalink":"http://blog.vichamp.com/tags/guideline/"},{"name":"text","slug":"text","permalink":"http://blog.vichamp.com/tags/text/"},{"name":"markdown","slug":"markdown","permalink":"http://blog.vichamp.com/tags/markdown/"}],"keywords":[{"name":"markdown","slug":"markdown","permalink":"http://blog.vichamp.com/categories/markdown/"}]},{"title":"mongoose 学习路线","slug":"mongoose-guideline","date":"2014-08-02T09:51:38.000Z","updated":"2017-03-17T15:26:24.023Z","comments":true,"path":"2014/08/02/mongoose-guideline/","link":"","permalink":"http://blog.vichamp.com/2014/08/02/mongoose-guideline/","excerpt":"","text":"mongoose 是 mongodb 的一个对象模型工具，可以工作于异步环境下。 入门文章 Mongoose学习参考文档——基础篇 - CNode Express + Mongoose 极简入门 nodejs学习7：express+mongoose - 前端博客 &lt;贴板&gt; Mongoose - 让NodeJS更容易操作Mongodb数据库 - CSSer","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://blog.vichamp.com/categories/mongoose/"}],"tags":[{"name":"guideline","slug":"guideline","permalink":"http://blog.vichamp.com/tags/guideline/"},{"name":"link","slug":"link","permalink":"http://blog.vichamp.com/tags/link/"},{"name":"mongodb","slug":"mongodb","permalink":"http://blog.vichamp.com/tags/mongodb/"},{"name":"nosql","slug":"nosql","permalink":"http://blog.vichamp.com/tags/nosql/"},{"name":"database","slug":"database","permalink":"http://blog.vichamp.com/tags/database/"},{"name":"mongoose","slug":"mongoose","permalink":"http://blog.vichamp.com/tags/mongoose/"}],"keywords":[{"name":"mongoose","slug":"mongoose","permalink":"http://blog.vichamp.com/categories/mongoose/"}]},{"title":"mongodb 学习路线","slug":"mongodb-guideline","date":"2014-08-02T09:51:38.000Z","updated":"2017-03-17T15:26:24.023Z","comments":true,"path":"2014/08/02/mongodb-guideline/","link":"","permalink":"http://blog.vichamp.com/2014/08/02/mongodb-guideline/","excerpt":"","text":"MongoDB 是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 入门文章 什么是MongoDB - WEB开发者 - 解答什么是 mongodb。 电子书籍 the-little-mongodb-book/mongodb.markdown at master · geminiyellow/the-little-mongodb-book - 中文版《The Little MongoDB Book》 工具 Robomongo — shell-centric MongoDB management tool (MongoDB Admin UI) - 免费，跨平台，免安装，体验好。 MongoVUE - 收费，Windows，体验略次。 纸质书籍 MongoDB权威指南","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://blog.vichamp.com/categories/mongoose/"}],"tags":[{"name":"guideline","slug":"guideline","permalink":"http://blog.vichamp.com/tags/guideline/"},{"name":"link","slug":"link","permalink":"http://blog.vichamp.com/tags/link/"},{"name":"mongodb","slug":"mongodb","permalink":"http://blog.vichamp.com/tags/mongodb/"},{"name":"nosql","slug":"nosql","permalink":"http://blog.vichamp.com/tags/nosql/"},{"name":"database","slug":"database","permalink":"http://blog.vichamp.com/tags/database/"}],"keywords":[{"name":"mongoose","slug":"mongoose","permalink":"http://blog.vichamp.com/categories/mongoose/"}]},{"title":"AngularJS 学习路线","slug":"angularjs-guideline","date":"2014-08-02T06:09:28.000Z","updated":"2017-03-17T15:26:24.008Z","comments":true,"path":"2014/08/02/angularjs-guideline/","link":"","permalink":"http://blog.vichamp.com/2014/08/02/angularjs-guideline/","excerpt":"","text":"AngularJS 是Google开源的一款JavaScript MVC框架，弥补了HTML在构建应用方面的不足，诞生以来吸引了大量的目光，也迅速成为了Web开发领域的新宠。 网站 AngularJS — Superheroic JavaScript MVW Framework - 官方网站 angular/angular.js - github 使用超动感HTML &amp; JS开发WEB应用! - 中文社区 首页 - AngularJS Nice Things - AngularJS学习和经验分享平台。 Angular Tips - 博客型英文网站 博客 破狼 - 博客园 入门官方使用指南 AngularJS: Tutorial: Tutorial AngularJS中文网 图灵社区: 合集 : AngularJS入门教程 - AngularJS.org官方使用指南的翻译 AngularJS 入门教程 - 也是AngularJS.org官方使用指南的翻译 w3school AngularJS 教程 链接合集请展开看以下链接内容* 2013年度最强AngularJS资源合集-CSDN.NET - 本文整理了2013年度一些非常有价值的AngularJS相关教程和资源。 AngularJS-Learning/ZH-CN.md at master · jmcunningham/AngularJS-Learning - 这是一个AngularJS Guide的中文分支版本，提供关于AngularJS的视频、入门、使用与论坛等中文互联网内容，这里的分类并没有完全参照英文版，也并不固定，如果你有发现新的内容需要添加新类别，直接加吧。 DEMO 项目 AngularJS • TodoMVC AngularJS 实例 - w3school Angular范例程序 - 中文组件库 参考手册 AngularJS 参考手册 - w3school 视频教程 课程学习-分享：使用AngularJS开发下一代Web应用 - 大漠穷秋的现场视频，总共不到一个小时。 课程学习-系列：AngularJS实战 - 大漠穷秋的课程，推荐。 课程学习-分享：阿里懒懒交流会AngularJS专场 - 经验专题现场交流。 纸质书籍 用AngularJS开发下一代Web应用 - 中文的目前只有这一本。仍然是大漠穷秋翻译的。 图表 一张图告诉你Angular的内核结构 指令收藏（Directives） jirikavi/AngularJS-Toaster - AngularJS Toaster is a customized version of “toastr” non-blocking notification javascript library.","categories":[{"name":"angularjs","slug":"angularjs","permalink":"http://blog.vichamp.com/categories/angularjs/"}],"tags":[{"name":"guideline","slug":"guideline","permalink":"http://blog.vichamp.com/tags/guideline/"},{"name":"angularjs","slug":"angularjs","permalink":"http://blog.vichamp.com/tags/angularjs/"},{"name":"link","slug":"link","permalink":"http://blog.vichamp.com/tags/link/"}],"keywords":[{"name":"angularjs","slug":"angularjs","permalink":"http://blog.vichamp.com/categories/angularjs/"}]},{"title":"用 PowerShell 批量分割 QQ 聊天记录","slug":"split-qq-msg-with-powershell","date":"2014-08-01T08:42:00.000Z","updated":"2017-03-17T15:26:24.008Z","comments":true,"path":"2014/08/01/split-qq-msg-with-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/08/01/split-qq-msg-with-powershell/","excerpt":"纯文本文件有诸多的好处： 通用 易于管理 易于搜索 易于迁移 接下来我们用 PoewrShell 来处理 QQ 的聊天记录。目的是将所有的聊天记录按照“组名/对象名.txt”来分别保存每个好友、每个 QQ 群等的聊天记录。 我现在用的是 QQ 6.1 (11905) 版本。依次打开 QQ / 工具 / 消息管理器，点击右上角的倒三角按钮可以看到“导出全部消息记录”菜单项。我们在接下来的对话框里的保存类型中选择“文本文件(*.txt,不支持导入)”，并用默认的“全部消息记录.txt”文件名保存。保存之后的文件内容大概是如下格式： 消息记录（此消息记录为文本格式，不支持重新导入） ================================================================ 消息分组:我的好友 ================================================================ 消息对象:Victor.Woo ================================================================ 2010-01-06 16:57:28 Victor.Woo http://pic4.nipic.com/20090728/1684061_175750076_2.jpg 2010-05-27 12:29:35 Victor.Woo 6块钱包月55 8000/月 中心端，用户端 ================================================================ 消息分组:技术.关注 ================================================================ 消息对象:*PowerShell技术交流 ================================================================ 2013-06-23 15:52:32 此消彼长，云过有痕&lt;qq_g@163.com&gt; http://yun.baidu.com/buy/center?tag=4#FAQ02 百度亮了，自己找亮点 2013-06-23 18:42:35 Victor.Woo&lt;victorwoo@gmail.com&gt; [表情] 观察它的规律： 以 ================================================================ 作为每一段的元数据开始。 接下来依次是消息分组、分隔符、消息对象。 以 ================================================================ 作为元数据的结束。 元数据之后，是正文部分，直到下一个元数据开始。 文件头部还有两行无关内容。 文件尺寸巨大，不适合整体用正则表达式来提取，只能一行一行解析。 我们的目标是生成 我的好友/Victor.Woo.txt 和 技术.关注/.PowerShell技术交流.txt 根据这个规律，我们可以用类似“状态机”的思想来设计 PowerShell 脚本。在遍历源文件的所有行时，用一个 $status 变量来表示当前的状态，各个状态的含义如下： 状态 含义 INIT 初始状态 ENTER_BLOCK 进入一个元数据块 ENTER_GROUP “消息分组”解析完成 ENTER_SPLITTER 元数据中间的分隔符解析完成 ENTER_TARGET “消息对象”解析完成 LEAVE_BLOCK 元数据块解析完成 CONTENT 当前行是正文内容 然后用一个 switch 语句让 $status 变量在这些状态之间来回跳转，就能解析出一个一个独立的消息文件了。完整代码如下：","text":"纯文本文件有诸多的好处： 通用 易于管理 易于搜索 易于迁移 接下来我们用 PoewrShell 来处理 QQ 的聊天记录。目的是将所有的聊天记录按照“组名/对象名.txt”来分别保存每个好友、每个 QQ 群等的聊天记录。 我现在用的是 QQ 6.1 (11905) 版本。依次打开 QQ / 工具 / 消息管理器，点击右上角的倒三角按钮可以看到“导出全部消息记录”菜单项。我们在接下来的对话框里的保存类型中选择“文本文件(*.txt,不支持导入)”，并用默认的“全部消息记录.txt”文件名保存。保存之后的文件内容大概是如下格式： 消息记录（此消息记录为文本格式，不支持重新导入） ================================================================ 消息分组:我的好友 ================================================================ 消息对象:Victor.Woo ================================================================ 2010-01-06 16:57:28 Victor.Woo http://pic4.nipic.com/20090728/1684061_175750076_2.jpg 2010-05-27 12:29:35 Victor.Woo 6块钱包月55 8000/月 中心端，用户端 ================================================================ 消息分组:技术.关注 ================================================================ 消息对象:*PowerShell技术交流 ================================================================ 2013-06-23 15:52:32 此消彼长，云过有痕&lt;qq_g@163.com&gt; http://yun.baidu.com/buy/center?tag=4#FAQ02 百度亮了，自己找亮点 2013-06-23 18:42:35 Victor.Woo&lt;victorwoo@gmail.com&gt; [表情] 观察它的规律： 以 ================================================================ 作为每一段的元数据开始。 接下来依次是消息分组、分隔符、消息对象。 以 ================================================================ 作为元数据的结束。 元数据之后，是正文部分，直到下一个元数据开始。 文件头部还有两行无关内容。 文件尺寸巨大，不适合整体用正则表达式来提取，只能一行一行解析。 我们的目标是生成 我的好友/Victor.Woo.txt 和 技术.关注/.PowerShell技术交流.txt 根据这个规律，我们可以用类似“状态机”的思想来设计 PowerShell 脚本。在遍历源文件的所有行时，用一个 $status 变量来表示当前的状态，各个状态的含义如下： 状态 含义 INIT 初始状态 ENTER_BLOCK 进入一个元数据块 ENTER_GROUP “消息分组”解析完成 ENTER_SPLITTER 元数据中间的分隔符解析完成 ENTER_TARGET “消息对象”解析完成 LEAVE_BLOCK 元数据块解析完成 CONTENT 当前行是正文内容 然后用一个 switch 语句让 $status 变量在这些状态之间来回跳转，就能解析出一个一个独立的消息文件了。完整代码如下： function Get-Status($status, $textLine, $lineNumber, $block) { $splitter = &apos;================================================================&apos; switch ($status) { &apos;INIT&apos; { if ($textLine -eq $splitter) { $status = &apos;ENTER_BLOCK&apos; } } &apos;ENTER_BLOCK&apos; { if ($textLine -cmatch &apos;消息分组:(.*)&apos;) { $block.Group = $matches[1] $block.Target = $null $status = &apos;ENTER_GROUP&apos; break } else { Write-Error &quot;[$lineNumber] [$status] $textLine&quot; exit } } &apos;ENTER_GROUP&apos; { if ($textLine -eq $splitter) { $status = &apos;ENTER_SPLITTER&apos; break } else { Write-Error &quot;[$lineNumber] [$status] $textLine&quot; exit } } &apos;ENTER_SPLITTER&apos; { if ($textLine -cmatch &apos;消息对象:(.*)&apos;) { $block.Target = $matches[1] $status = &apos;ENTER_TARGET&apos; break } else { Write-Error &quot;[$lineNumber] [$status] $textLine&quot; exit } } &apos;ENTER_TARGET&apos; { if ($textLine -eq $splitter) { $status = &apos;LEAVE_BLOCK&apos; break } else { Write-Error &quot;[$lineNumber] [$status] $textLine&quot; exit } } &apos;LEAVE_BLOCK&apos; { if ($textLine -eq $splitter) { $status = &apos;ENTER_BLOCK&apos; break } else { $status = &apos;CONTENT&apos; } } &apos;CONTENT&apos; { if ($textLine -eq $splitter) { $status = &apos;ENTER_BLOCK&apos; break } else { $status = &apos;CONTENT&apos; } } } return $status } $status = &apos;INIT&apos; $lineNumber = 0 $block = @{} $targetPath = $null cat 全部消息记录.txt -Encoding UTF8 | foreach { $textLine = $_ $lineNumber++ $status = Get-Status $status $textLine $lineNumber $block switch ($status) { &apos;LEAVE_BLOCK&apos; { if ($block.Target -eq &apos;最近联系人&apos;) { break } $dirName = $block.Group.Replace(&apos;*&apos;, &apos;.&apos;) if (!(Test-Path $dirName)) { md $dirName | Out-Null } $fileName = $block.Target.Replace(&apos;*&apos;, &apos;.&apos;) $targetPath = (Join-Path $dirName $fileName) + &apos;.txt&apos; if (Test-Path $targetPath) { del $targetPath } echo $targetPath } &apos;CONTENT&apos; { #echo $textLine if ($block.Target -eq &apos;最近联系人&apos;) { break } Out-File -InputObject $textLine -Encoding utf8 -LiteralPath $targetPath -Append } } } 您也可以在这里下载完成后的版本。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"text","slug":"text","permalink":"http://blog.vichamp.com/tags/text/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}]},{"title":"PowerShell 技能连载 - 查找 AD 用户","slug":"finding-ad-users","date":"2014-08-01T03:00:00.000Z","updated":"2017-03-17T15:26:24.004Z","comments":true,"path":"2014/08/01/finding-ad-users/","link":"","permalink":"http://blog.vichamp.com/2014/08/01/finding-ad-users/","excerpt":"适用于所有 PowerShell 版本 假如您已登录到了一个活动目录域中，那么只需要执行一些简单的命令就可以搜索活动目录。在前一个技巧中我们演示了最基本的脚本。以下是一个扩展，它能够定义一个搜索的根（搜索的起点），就像一个扁平的搜索一样（相对于在容器中递归而言）。 它也演示了如何将活动目录的搜索结果转换成实际的用户对象： $SAMAccountName = &apos;tobias&apos; $SearchRoot = &apos;LDAP://OU=customer,DC=company,DC=com&apos; $SearchScope = &apos;OneLevel&apos; $ldap = &quot;(&amp;(objectClass=user)(samAccountName=*$SAMAccountName*))&quot; $searcher = [adsisearcher]$ldap $searcher.SearchRoot = $SearchRoot $searcher.PageSize = 999 $searcher.SearchScope = $SearchScope $searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property *","text":"适用于所有 PowerShell 版本 假如您已登录到了一个活动目录域中，那么只需要执行一些简单的命令就可以搜索活动目录。在前一个技巧中我们演示了最基本的脚本。以下是一个扩展，它能够定义一个搜索的根（搜索的起点），就像一个扁平的搜索一样（相对于在容器中递归而言）。 它也演示了如何将活动目录的搜索结果转换成实际的用户对象： $SAMAccountName = &apos;tobias&apos; $SearchRoot = &apos;LDAP://OU=customer,DC=company,DC=com&apos; $SearchScope = &apos;OneLevel&apos; $ldap = &quot;(&amp;(objectClass=user)(samAccountName=*$SAMAccountName*))&quot; $searcher = [adsisearcher]$ldap $searcher.SearchRoot = $SearchRoot $searcher.PageSize = 999 $searcher.SearchScope = $SearchScope $searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property * 本文国际来源：Finding AD Users","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找并提取注册表键的路径","slug":"finding-and-dumping-registry-key-paths","date":"2014-07-31T03:00:00.000Z","updated":"2017-03-17T15:26:24.000Z","comments":true,"path":"2014/07/31/finding-and-dumping-registry-key-paths/","link":"","permalink":"http://blog.vichamp.com/2014/07/31/finding-and-dumping-registry-key-paths/","excerpt":"适用于所有 PowerShell 版本 在前一个技巧中，我们演示了如何将一个 PowerShell 内部的路径格式转换为一个真实的路径。以下是一个用力。这段代码递归地搜索 _HKEY_CURRENTUSER 键，并且找出所有包含单词“powershell”的注册表键（您可以将搜索关键字换成任何别的）： Get-ChildItem -Path HKCU:\\ -Include *PowerShell* -Recurse -ErrorAction SilentlyContinue | Select-Object -Property *Path* | Out-GridView 这段代码输出所有名称中包含“Path”的属性。如您所见，注册表键中有两个属性包含该关键字：PSPath 和 PSParentPath。两者都是 PowerShell 内置的路径格式。 要提取所有满足搜索条件的注册表键的路径，请使用以下代码： Get-ChildItem -Path HKCU:\\ -Include *PowerShell* -Recurse -ErrorAction SilentlyContinue | ForEach-Object { Convert-Path -Path $_.PSPath }","text":"适用于所有 PowerShell 版本 在前一个技巧中，我们演示了如何将一个 PowerShell 内部的路径格式转换为一个真实的路径。以下是一个用力。这段代码递归地搜索 _HKEY_CURRENTUSER 键，并且找出所有包含单词“powershell”的注册表键（您可以将搜索关键字换成任何别的）： Get-ChildItem -Path HKCU:\\ -Include *PowerShell* -Recurse -ErrorAction SilentlyContinue | Select-Object -Property *Path* | Out-GridView 这段代码输出所有名称中包含“Path”的属性。如您所见，注册表键中有两个属性包含该关键字：PSPath 和 PSParentPath。两者都是 PowerShell 内置的路径格式。 要提取所有满足搜索条件的注册表键的路径，请使用以下代码： Get-ChildItem -Path HKCU:\\ -Include *PowerShell* -Recurse -ErrorAction SilentlyContinue | ForEach-Object { Convert-Path -Path $_.PSPath } 本文国际来源：Finding and Dumping Registry Key Paths","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 修正 PowerShell 中的路径","slug":"correcting-powershell-paths","date":"2014-07-30T03:00:00.000Z","updated":"2017-03-17T15:26:23.992Z","comments":true,"path":"2014/07/30/correcting-powershell-paths/","link":"","permalink":"http://blog.vichamp.com/2014/07/30/correcting-powershell-paths/","excerpt":"适用于所有 PowerShell 版本 有些时候，您会为某些奇怪的路径格式感到困惑，比如这个： Microsoft.PowerShell.Core\\FileSystem::C:\\windows\\explorer.exe 这是一个完整的 PowerShell 路径名，路径中包含了了模块名和提供器名。要得到一个纯的路径名，请使用以下代码： Convert-Path -Path Microsoft.PowerShell.Core\\FileSystem::C:\\windows\\explorer.exe","text":"适用于所有 PowerShell 版本 有些时候，您会为某些奇怪的路径格式感到困惑，比如这个： Microsoft.PowerShell.Core\\FileSystem::C:\\windows\\explorer.exe 这是一个完整的 PowerShell 路径名，路径中包含了了模块名和提供器名。要得到一个纯的路径名，请使用以下代码： Convert-Path -Path Microsoft.PowerShell.Core\\FileSystem::C:\\windows\\explorer.exe 本文国际来源：Correcting PowerShell Paths","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 修正名单中的大小写","slug":"case-correct-name-lists","date":"2014-07-29T03:00:00.000Z","updated":"2017-03-17T15:26:23.975Z","comments":true,"path":"2014/07/29/case-correct-name-lists/","link":"","permalink":"http://blog.vichamp.com/2014/07/29/case-correct-name-lists/","excerpt":"适用于所有 PowerShell 版本 假设您的工作是更新一份名单。以下方法可以确保只有名字的第一个字母改成大写。这个方法对于姓-名的方式也是有效的： $names = &apos;some-wILD-casING&apos;,&apos;frank-PETER&apos;,&apos;fred&apos; Foreach ($name in $names) { $corrected = foreach ($part in $name.Split(&apos;-&apos;)) { $firstChar = $part.Substring(0,1).ToUpper() $remaining = $part.Substring(1).ToLower() &quot;$firstChar$remaining&quot; } $corrected -join &apos;-&apos; } Some-Wild-Casing Frank-Peter Fred","text":"适用于所有 PowerShell 版本 假设您的工作是更新一份名单。以下方法可以确保只有名字的第一个字母改成大写。这个方法对于姓-名的方式也是有效的： $names = &apos;some-wILD-casING&apos;,&apos;frank-PETER&apos;,&apos;fred&apos; Foreach ($name in $names) { $corrected = foreach ($part in $name.Split(&apos;-&apos;)) { $firstChar = $part.Substring(0,1).ToUpper() $remaining = $part.Substring(1).ToLower() &quot;$firstChar$remaining&quot; } $corrected -join &apos;-&apos; } Some-Wild-Casing Frank-Peter Fred 本文国际来源：Case-Correct Name Lists","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使系统休眠","slug":"hibernate-system","date":"2014-07-28T03:00:00.000Z","updated":"2017-03-17T15:26:23.975Z","comments":true,"path":"2014/07/28/hibernate-system/","link":"","permalink":"http://blog.vichamp.com/2014/07/28/hibernate-system/","excerpt":"适用于 PowerShell 所有版本 以下是一个简单的系统调用，可以使系统休眠（当然，前提是启用了休眠功能）： function Start-Hibernation { rundll32.exe PowrProf.dll, SetSuspendState 0,1,0 } 请注意这个函数调用是大小写敏感的！","text":"适用于 PowerShell 所有版本 以下是一个简单的系统调用，可以使系统休眠（当然，前提是启用了休眠功能）： function Start-Hibernation { rundll32.exe PowrProf.dll, SetSuspendState 0,1,0 } 请注意这个函数调用是大小写敏感的！ 本文国际来源：Hibernate System","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 指定递归深度","slug":"recursing-a-given-depth","date":"2014-07-25T03:00:00.000Z","updated":"2017-03-17T15:26:23.973Z","comments":true,"path":"2014/07/25/recursing-a-given-depth/","link":"","permalink":"http://blog.vichamp.com/2014/07/25/recursing-a-given-depth/","excerpt":"适用于 PowerShell 3.0 及更高版本 当使用 Get-ChildItem 来列出文件夹内容时，可以用 -Recurse 参数来对子目录进行递归。然而，这导致无法控制递归深度。Get-ChildItem 会在所有子目录中搜索，无限地递归下去。 Get-ChildItem -Path $env:windir -Filter *.log -Recurse -ErrorAction SilentlyContinue 有些时候，我们会见到一种类似这样的方法，来试图控制递归的深度： Get-ChildItem -Path $env:windir\\*\\*\\* -Filter *.log -ErrorAction SilentlyContinue 然而，这并不能限制只递归 3 层。实际上，它的作用是搜索 3 层及 3 层以上的文件夹。它不会搜索 1 层或 2 层的文件夹。 限制递归深度的唯一办法是自己实现递归算法： function Get-MyChildItem { param ( [Parameter(Mandatory = $true)] $Path, $Filter = &apos;*&apos;, [System.Int32] $MaxDepth = 3, [System.Int32] $Depth = 0 ) $Depth++ Get-ChildItem -Path $Path -Filter $Filter -File if ($Depth -le $MaxDepth) { Get-ChildItem -Path $Path -Directory | ForEach-Object { Get-MyChildItem -Path $_.FullName -Filter $Filter -Depth $Depth -MaxDepth $MaxDepth} } } Get-MyChildItem -Path c:\\windows -Filter *.log -MaxDepth 2 -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName 这段代码将获取您 Windows 文件夹中深度在 2 层以内的 *.log 文件。","text":"适用于 PowerShell 3.0 及更高版本 当使用 Get-ChildItem 来列出文件夹内容时，可以用 -Recurse 参数来对子目录进行递归。然而，这导致无法控制递归深度。Get-ChildItem 会在所有子目录中搜索，无限地递归下去。 Get-ChildItem -Path $env:windir -Filter *.log -Recurse -ErrorAction SilentlyContinue 有些时候，我们会见到一种类似这样的方法，来试图控制递归的深度： Get-ChildItem -Path $env:windir\\*\\*\\* -Filter *.log -ErrorAction SilentlyContinue 然而，这并不能限制只递归 3 层。实际上，它的作用是搜索 3 层及 3 层以上的文件夹。它不会搜索 1 层或 2 层的文件夹。 限制递归深度的唯一办法是自己实现递归算法： function Get-MyChildItem { param ( [Parameter(Mandatory = $true)] $Path, $Filter = &apos;*&apos;, [System.Int32] $MaxDepth = 3, [System.Int32] $Depth = 0 ) $Depth++ Get-ChildItem -Path $Path -Filter $Filter -File if ($Depth -le $MaxDepth) { Get-ChildItem -Path $Path -Directory | ForEach-Object { Get-MyChildItem -Path $_.FullName -Filter $Filter -Depth $Depth -MaxDepth $MaxDepth} } } Get-MyChildItem -Path c:\\windows -Filter *.log -MaxDepth 2 -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName 这段代码将获取您 Windows 文件夹中深度在 2 层以内的 *.log 文件。 本文国际来源：Recursing a Given Depth","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 以底层的方式管理打印机","slug":"managing-printers-low-level","date":"2014-07-24T03:00:00.000Z","updated":"2017-03-17T15:26:23.953Z","comments":true,"path":"2014/07/24/managing-printers-low-level/","link":"","permalink":"http://blog.vichamp.com/2014/07/24/managing-printers-low-level/","excerpt":"适用于所有 PowerShell 版本 新版本的 Windows 操作系统，例如 Windows 8 和 Windows Server 2012 对打印机支持得很好，不过如果您在运行旧版的 Windows，那么这段代码可能有所帮助： PS&gt; rundll32.exe PRINTUI.DLL,PrintUIEntry PS&gt; 请注意这段代码是大小写敏感的！请不要加空格，也不要改变大小写。 这段代码将打开一个帮助窗口，列出了许多东西，包括演示如何安装、删除和复制打印机驱动的例子。这个工具也可以远程使用，假设您通过合适的组策略允许远程操作。","text":"适用于所有 PowerShell 版本 新版本的 Windows 操作系统，例如 Windows 8 和 Windows Server 2012 对打印机支持得很好，不过如果您在运行旧版的 Windows，那么这段代码可能有所帮助： PS&gt; rundll32.exe PRINTUI.DLL,PrintUIEntry PS&gt; 请注意这段代码是大小写敏感的！请不要加空格，也不要改变大小写。 这段代码将打开一个帮助窗口，列出了许多东西，包括演示如何安装、删除和复制打印机驱动的例子。这个工具也可以远程使用，假设您通过合适的组策略允许远程操作。 本文国际来源：Managing Printers Low-Level","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 别名有可能带来风险","slug":"aliases-can-be-dangerous","date":"2014-07-23T03:00:00.000Z","updated":"2017-03-17T15:26:23.953Z","comments":true,"path":"2014/07/23/aliases-can-be-dangerous/","link":"","permalink":"http://blog.vichamp.com/2014/07/23/aliases-can-be-dangerous/","excerpt":"适用于所有 PowerShell 版本 在 PowerShell 中执行命令时，别名享有最高的优先权，所以如果遇到了有歧义的命令，PowerShell 将会优先执行别名命令。 这样可能很危险：如果您允许别人更改您的 PowerShell 环境，并且私下添加了您不知道的别名，那么您的脚本执行起来的效果可能完全不同。 Here is a simple call that adds the alias Get-ChildItem and lets it point to ping.exe:以下是一个简单的例子，创建了一个名为 Get-ChildItem 的别名，并指向 ping.exe： Set-Alias -Name Get-ChildItem -Value ping 这将导致一切都改变了：Get-ChildItem 不再列出文件夹内容了，而是变为 ping 的行为。甚至，所有的别名（例如 dir 和 ls）现在都指向 ping。我们假想一下如果别名指向了 format.exe，那么您的脚本会做什么？","text":"适用于所有 PowerShell 版本 在 PowerShell 中执行命令时，别名享有最高的优先权，所以如果遇到了有歧义的命令，PowerShell 将会优先执行别名命令。 这样可能很危险：如果您允许别人更改您的 PowerShell 环境，并且私下添加了您不知道的别名，那么您的脚本执行起来的效果可能完全不同。 Here is a simple call that adds the alias Get-ChildItem and lets it point to ping.exe:以下是一个简单的例子，创建了一个名为 Get-ChildItem 的别名，并指向 ping.exe： Set-Alias -Name Get-ChildItem -Value ping 这将导致一切都改变了：Get-ChildItem 不再列出文件夹内容了，而是变为 ping 的行为。甚至，所有的别名（例如 dir 和 ls）现在都指向 ping。我们假想一下如果别名指向了 format.exe，那么您的脚本会做什么？ 本文国际来源：Aliases Can Be Dangerous","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 转换特殊字符（第二部分）","slug":"converting-special-characters-part-2","date":"2014-07-22T03:00:00.000Z","updated":"2017-03-17T15:26:23.938Z","comments":true,"path":"2014/07/22/converting-special-characters-part-2/","link":"","permalink":"http://blog.vichamp.com/2014/07/22/converting-special-characters-part-2/","excerpt":"适用于所有 PowerShell 版本 在前一个技巧中我们演示了如何替换一段文本中的特殊字符。以下是另一种方法，虽然慢一点，但是更容易维护。它也演示了一个大小写敏感的哈希表： function ConvertTo-PrettyText($Text) { $hash = New-Object -TypeName HashTable $hash.&apos;ä&apos; = &apos;ae&apos; $hash.&apos;ö&apos; = &apos;oe&apos; $hash.&apos;ü&apos; = &apos;ue&apos; $hash.&apos;ß&apos; = &apos;ss&apos; $hash.&apos;Ä&apos; = &apos;Ae&apos; $hash.&apos;Ö&apos; = &apos;Oe&apos; $Hash.&apos;Ü&apos; = &apos;Ue&apos; Foreach ($key in $hash.Keys) { $Text = $text.Replace($key, $hash.$key) } $Text } 请注意该函数并不是以 @{} 的方式定义一个哈希表，而是构造了一个 HashTable 对象。由于 PowerShell 所带的哈希表是大小写不敏感的，而这个函数创建的哈希表是大小写敏感的。这一点非常重要，因为该函数期望对大小写字母作区分。 PS&gt; ConvertTo-PrettyText -Text &apos;Mr. Össterßlim&apos; Mr. Oesstersslim PS&gt; 如果您想要指定 ASCII 码，以下是一个用 ASCII 码作为键的变体： function ConvertTo-PrettyText($Text) { $hash = @{ 228 = &apos;ae&apos; 246 = &apos;oe&apos; 252 = &apos;ue&apos; 223 = &apos;ss&apos; 196 = &apos;Ae&apos; 214 = &apos;Oe&apos; 220 = &apos;Ue&apos; } foreach($key in $hash.Keys) { $Text = $text.Replace([String][Char]$key, $hash.$key) } $Text }","text":"适用于所有 PowerShell 版本 在前一个技巧中我们演示了如何替换一段文本中的特殊字符。以下是另一种方法，虽然慢一点，但是更容易维护。它也演示了一个大小写敏感的哈希表： function ConvertTo-PrettyText($Text) { $hash = New-Object -TypeName HashTable $hash.&apos;ä&apos; = &apos;ae&apos; $hash.&apos;ö&apos; = &apos;oe&apos; $hash.&apos;ü&apos; = &apos;ue&apos; $hash.&apos;ß&apos; = &apos;ss&apos; $hash.&apos;Ä&apos; = &apos;Ae&apos; $hash.&apos;Ö&apos; = &apos;Oe&apos; $Hash.&apos;Ü&apos; = &apos;Ue&apos; Foreach ($key in $hash.Keys) { $Text = $text.Replace($key, $hash.$key) } $Text } 请注意该函数并不是以 @{} 的方式定义一个哈希表，而是构造了一个 HashTable 对象。由于 PowerShell 所带的哈希表是大小写不敏感的，而这个函数创建的哈希表是大小写敏感的。这一点非常重要，因为该函数期望对大小写字母作区分。 PS&gt; ConvertTo-PrettyText -Text &apos;Mr. Össterßlim&apos; Mr. Oesstersslim PS&gt; 如果您想要指定 ASCII 码，以下是一个用 ASCII 码作为键的变体： function ConvertTo-PrettyText($Text) { $hash = @{ 228 = &apos;ae&apos; 246 = &apos;oe&apos; 252 = &apos;ue&apos; 223 = &apos;ss&apos; 196 = &apos;Ae&apos; 214 = &apos;Oe&apos; 220 = &apos;Ue&apos; } foreach($key in $hash.Keys) { $Text = $text.Replace([String][Char]$key, $hash.$key) } $Text } 本文国际来源：Converting Special Characters, Part 2","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 输出中文到剪贴板","slug":"forward-chinese-text-into-clipboard","date":"2014-07-21T10:30:27.000Z","updated":"2017-03-17T15:26:23.938Z","comments":true,"path":"2014/07/21/forward-chinese-text-into-clipboard/","link":"","permalink":"http://blog.vichamp.com/2014/07/21/forward-chinese-text-into-clipboard/","excerpt":"","text":"方法一 通过 clip.exe用 PowerShell 将字符串输出到剪贴板的最简单方式是： &apos;abc&apos; | clip.exe 不过直接这么使用的话，如果待输出的字符串是包含中文的，那么剪贴板里的内容会出现“乱码”： &apos;abc中文def&apos; | clip.exe 剪贴板里的内容变成： abc??def 这是因为为了兼容旧程序，管道操作缺省将字符串采用 ASCII 编码，因此对于中文字符，被转换成了“??”。解决方案如下： $OutputEncoding = [Console]::OutputEncoding &apos;abc中文def&apos; | clip.exe 方法二 通过 WPF 方法以 -sta 参数启动 PowerShell 后，执行以下代码： Add-Type -Assembly PresentationCore [Windows.Clipboard]::SetText(&apos;abc中文def&apos;) PowerShell 2.0 的控制台，缺省设置是 MTA；PowerShell 3.0 的控制台，缺省设置是 STA。 关于 -sta 的知识，请参见PowerShell中的 STA和MTA。 参考材料： $OutputEncoding to the rescue Powershell能否将文件列表写入剪切板 PowerShell中的 STA和MTA PowerShell.exe Command-Line Help QQ 群 *PowerShell技术交流（271143343） 2014-07-01 的讨论","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"text","slug":"text","permalink":"http://blog.vichamp.com/tags/text/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}]},{"title":"PowerShell 技能连载 - 转换特殊字符（第一部分）","slug":"converting-special-characters-part-1","date":"2014-07-21T03:00:00.000Z","updated":"2017-03-17T15:26:23.922Z","comments":true,"path":"2014/07/21/converting-special-characters-part-1/","link":"","permalink":"http://blog.vichamp.com/2014/07/21/converting-special-characters-part-1/","excerpt":"适用于所有 PowerShell 版本 有些时候我们需要将特殊字符转换为其它字符。以下是一个实现该功能的小函数： function ConvertTo-PrettyText($Text) { $Text.Replace(&apos;ü&apos;,&apos;ue&apos;).Replace(&apos;ö&apos;,&apos;oe&apos;).Replace(&apos;ä&apos;, &apos;ae&apos; ).Replace(&apos;Ü&apos;,&apos;Ue&apos;).Replace(&apos;Ö&apos;,&apos;Oe&apos;).Replace(&apos;Ä&apos;, &apos;Ae&apos;).Replace(&apos;ß&apos;, &apos;ss&apos;) } 只要根据需要添加 Replace() 调用来处理文本即可。请注意 Replace() 是大小写敏感的，这样比较好：您可以针对大小写来做替换。 PS&gt; ConvertTo-PrettyText -Text &apos;Mr. Össterßlim&apos; Mr. Oesstersslim","text":"适用于所有 PowerShell 版本 有些时候我们需要将特殊字符转换为其它字符。以下是一个实现该功能的小函数： function ConvertTo-PrettyText($Text) { $Text.Replace(&apos;ü&apos;,&apos;ue&apos;).Replace(&apos;ö&apos;,&apos;oe&apos;).Replace(&apos;ä&apos;, &apos;ae&apos; ).Replace(&apos;Ü&apos;,&apos;Ue&apos;).Replace(&apos;Ö&apos;,&apos;Oe&apos;).Replace(&apos;Ä&apos;, &apos;Ae&apos;).Replace(&apos;ß&apos;, &apos;ss&apos;) } 只要根据需要添加 Replace() 调用来处理文本即可。请注意 Replace() 是大小写敏感的，这样比较好：您可以针对大小写来做替换。 PS&gt; ConvertTo-PrettyText -Text &apos;Mr. Össterßlim&apos; Mr. Oesstersslim 本文国际来源：Converting Special Characters, Part 1","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 测试不带别名的脚本","slug":"test-driving-scripts-without-aliases","date":"2014-07-18T03:00:00.000Z","updated":"2017-03-17T15:26:23.922Z","comments":true,"path":"2014/07/18/test-driving-scripts-without-aliases/","link":"","permalink":"http://blog.vichamp.com/2014/07/18/test-driving-scripts-without-aliases/","excerpt":"适用于所有 PowerShell 版本 别名在交互式 PowerShell 控制台中用起来很酷，但是不应在脚本中使用它们。在脚本中，请使用基础的命令（所以请使用 Get-ChidItem 而不是 dir 或 ls）。 要测试一个脚本，您可以删除所有的别名然后试试脚本是否任然能运行。以下是如何删除特定 PowerShell 会话中的所有别名的方法（它不会影响其它 PowerShell 会话，并且不会永久地删除内置的别名）： PS&gt; Get-Alias | ForEach-Object { Remove-Item -Path (&quot;Alias:\\&quot; + $_.Name) -Force } PS&gt; dir dir : The term &apos;dir&apos; is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again. At line:1 char:1 + dir + ~~~ + CategoryInfo : ObjectNotFound: (dir:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException PS&gt; Get-Alias 如您所见，所有别名都清空了。现在如果一个脚本使用了别名，它将会抛出一个异常。而关闭并重启 PowerShell 之后，所有内置的别名都恢复了。","text":"适用于所有 PowerShell 版本 别名在交互式 PowerShell 控制台中用起来很酷，但是不应在脚本中使用它们。在脚本中，请使用基础的命令（所以请使用 Get-ChidItem 而不是 dir 或 ls）。 要测试一个脚本，您可以删除所有的别名然后试试脚本是否任然能运行。以下是如何删除特定 PowerShell 会话中的所有别名的方法（它不会影响其它 PowerShell 会话，并且不会永久地删除内置的别名）： PS&gt; Get-Alias | ForEach-Object { Remove-Item -Path (&quot;Alias:\\&quot; + $_.Name) -Force } PS&gt; dir dir : The term &apos;dir&apos; is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again. At line:1 char:1 + dir + ~~~ + CategoryInfo : ObjectNotFound: (dir:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException PS&gt; Get-Alias 如您所见，所有别名都清空了。现在如果一个脚本使用了别名，它将会抛出一个异常。而关闭并重启 PowerShell 之后，所有内置的别名都恢复了。 本文国际来源：Test-Driving Scripts without Aliases","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 删除别名","slug":"delete-aliases","date":"2014-07-17T03:00:00.000Z","updated":"2017-03-17T15:26:23.906Z","comments":true,"path":"2014/07/17/delete-aliases/","link":"","permalink":"http://blog.vichamp.com/2014/07/17/delete-aliases/","excerpt":"适用于所有 PowerShell 版本 虽然您可以轻松地用 New-Alias 和 Set-Alias 来创建新的别名，但是没有一个 cmdlet 可以删除别名。 PS&gt; Set-Alias -Name devicemanager -Value devmgmt.msc PS&gt; devicemanager PS&gt; 要删除一个别名，您通常需要重启动您的 PowerShell。或者您可以通过 Alias: 虚拟驱动器删除它们： PS&gt; del Alias:\\devicemanager PS&gt;","text":"适用于所有 PowerShell 版本 虽然您可以轻松地用 New-Alias 和 Set-Alias 来创建新的别名，但是没有一个 cmdlet 可以删除别名。 PS&gt; Set-Alias -Name devicemanager -Value devmgmt.msc PS&gt; devicemanager PS&gt; 要删除一个别名，您通常需要重启动您的 PowerShell。或者您可以通过 Alias: 虚拟驱动器删除它们： PS&gt; del Alias:\\devicemanager PS&gt; 本文国际来源：Delete Aliases","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 模块开发流程","slug":"powershell-module-develop-workflow","date":"2014-07-16T15:56:19.000Z","updated":"2017-03-17T15:26:23.906Z","comments":true,"path":"2014/07/16/powershell-module-develop-workflow/","link":"","permalink":"http://blog.vichamp.com/2014/07/16/powershell-module-develop-workflow/","excerpt":"","text":"我们希望使用 ISE 编辑器开发 PowerShell 的 .psm1 模块时，能够享受和开发 .ps1 脚本一样的体验： 能够在 ISE 中按 F5 键运行并观察执行效果。 能够在 ISE 中设置断点并进行调试。 编辑脚本并保存后，能够使修改处即时生效。 如果直接用 ISE 打开 .psm1 模块文件，是无法直接运行的。我和史瑞克朋友探讨了这个问题，现将他的经验整理如下： 先直接以 .ps1 的方式开发和调试（将模块代码和测试代码写在同一个 .ps1 文件中）。 注意在这种方式下，Export-Member 是不能用的，可以暂时注释掉。 基本开发、调试完以后，将 .ps1 后缀改为 .psm1，并取消 Export-Member 的注释。 同时打开 .psm1 和 .ps1（前者是可复用的模块，后者是最终的应用脚本），即可在 .psm1 中设置断点进行调试。 请注意，如果将模块文件放在 %PSModulePath% 目录下，宿主只会在启动时自动加载一次模块的内容。如果在宿主启动之后编辑了 .psm1 文件，那么已经启动的宿主是不会感知到的，仍然执行的是旧的模块文件代码。 如果要让 .psm1 中的更改即时生效，需要在 .ps1 脚本的头部加上这段代码，显式加载模块： if (gmo Test-Module) { rmo Test-Module } ipmo Test-Module Test-Module # 实际的业务 这样，每次重新运行 .ps1 脚本时，都会重新加载新的 .psm1 文件。待调试完之后，可以把头两行注释掉。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 快速查找 AD 账户","slug":"finding-ad-accounts-easily","date":"2014-07-15T20:00:00.000Z","updated":"2017-03-17T15:26:23.906Z","comments":true,"path":"2014/07/16/finding-ad-accounts-easily/","link":"","permalink":"http://blog.vichamp.com/2014/07/16/finding-ad-accounts-easily/","excerpt":"适用于所有 PowerShell 版本 您不必使用额外的 cmdlet 就能在您的活动目录中搜索用户账户或计算机。假设您已登录了一个域，只需要使用这段代码： $ldap = &apos;(&amp;(objectClass=computer)(samAccountName=dc*))&apos; $searcher = [adsisearcher]$ldap $searcher.FindAll() 这段代码将查找所有以“dc”开头的计算机账户。$ldap 可以是任何合法的 LDAP 查询语句。要查找用户，请将“computer”替换为“user”。","text":"适用于所有 PowerShell 版本 您不必使用额外的 cmdlet 就能在您的活动目录中搜索用户账户或计算机。假设您已登录了一个域，只需要使用这段代码： $ldap = &apos;(&amp;(objectClass=computer)(samAccountName=dc*))&apos; $searcher = [adsisearcher]$ldap $searcher.FindAll() 这段代码将查找所有以“dc”开头的计算机账户。$ldap 可以是任何合法的 LDAP 查询语句。要查找用户，请将“computer”替换为“user”。 本文国际来源：Finding AD Accounts Easily","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从独立的文件中加载函数","slug":"loading-functions-from-separate-file","date":"2014-07-14T20:00:00.000Z","updated":"2017-03-17T15:26:23.891Z","comments":true,"path":"2014/07/15/loading-functions-from-separate-file/","link":"","permalink":"http://blog.vichamp.com/2014/07/15/loading-functions-from-separate-file/","excerpt":"适用于 PowerShell 3.0 及以上版本 为了让事情简化一些，您可能希望将 PowerShell 函数存放在一个独立的文件中。要将这些函数加载到您的业务脚本中，您可以使用这个简单的方法： 请确保包含 PowerShell 函数的脚本文件和业务脚本存放在同一个文件夹下。然后，在您的业务脚本中使用这行简单的代码： . &quot;$PSScriptRoot\\library1.ps1&quot; 这行代码将会从当前脚本存放的文件夹中加载一个称为“library1.ps1”的脚本。不要漏了前面的 . 和空格：“点加文件名”的方式执行一个文件，能够确保该文件中的所有变量和函数都在调用者的上下文中定义，并且当脚本执行完以后不会被清除掉。 请注意 $PSScriptRoot 总是指向脚本所在文件夹的路径（从 PowerShell 3.0 开始）。请确保已经保存了您的脚本，因为只有保存过的脚本才有父文件夹。","text":"适用于 PowerShell 3.0 及以上版本 为了让事情简化一些，您可能希望将 PowerShell 函数存放在一个独立的文件中。要将这些函数加载到您的业务脚本中，您可以使用这个简单的方法： 请确保包含 PowerShell 函数的脚本文件和业务脚本存放在同一个文件夹下。然后，在您的业务脚本中使用这行简单的代码： . &quot;$PSScriptRoot\\library1.ps1&quot; 这行代码将会从当前脚本存放的文件夹中加载一个称为“library1.ps1”的脚本。不要漏了前面的 . 和空格：“点加文件名”的方式执行一个文件，能够确保该文件中的所有变量和函数都在调用者的上下文中定义，并且当脚本执行完以后不会被清除掉。 请注意 $PSScriptRoot 总是指向脚本所在文件夹的路径（从 PowerShell 3.0 开始）。请确保已经保存了您的脚本，因为只有保存过的脚本才有父文件夹。 本文国际来源：Loading Functions from Separate File","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建优越的报告","slug":"creating-great-reports","date":"2014-07-14T03:00:00.000Z","updated":"2017-03-17T15:26:23.891Z","comments":true,"path":"2014/07/14/creating-great-reports/","link":"","permalink":"http://blog.vichamp.com/2014/07/14/creating-great-reports/","excerpt":"当您克隆对象时，您可以修改它们的所有属性。克隆对象时可以导致原始对象“分离”，这是一个不错的主意。当您克隆了对象，您可以对该对象做任意的操作，例如修改或调整它的属性。 只需要用 Select-Object 命令就可以克隆对象。 这个例子列出文件夹中的内容，然后通过 Select-Object 处理，然后将其中的一些数据格式修饰一下。 Get-ChildItem -Path c:\\windows | # clone the objects and keep the properties you want/add new properties (like &quot;age...&quot;) Select-Object -Property LastWriteTime, &apos;Age(days)&apos;, Length, Name, PSIsContainer | # change the properties of the cloned object as you like ForEach-Object { # calculate the file/folder age in days $_.&apos;Age(days)&apos; = (New-Timespan -Start $_.LastWriteTime).Days # if it is a file, change size in bytes to size in MB if ($_.PSisContainer -eq $false) { $_.Length = (&apos;{0:N1} MB&apos; -f ($_.Length / 1MB)) } # do not forget to return the adjusted object so the next one gets it $_ } | # finally, select the properties you want in your report: Select-Object -Property LastWriteTime, &apos;Age(days)&apos;, Length, Name | # sort them as you like: Sort-Object -Property LastWriteTime -Descending | Out-GridView 该例子的结果以 MB 而不是字节为单位显示文件的大小，并且添加了一个称为“Age(days)”的列表示文件和文件夹创建以来的天数。","text":"当您克隆对象时，您可以修改它们的所有属性。克隆对象时可以导致原始对象“分离”，这是一个不错的主意。当您克隆了对象，您可以对该对象做任意的操作，例如修改或调整它的属性。 只需要用 Select-Object 命令就可以克隆对象。 这个例子列出文件夹中的内容，然后通过 Select-Object 处理，然后将其中的一些数据格式修饰一下。 Get-ChildItem -Path c:\\windows | # clone the objects and keep the properties you want/add new properties (like &quot;age...&quot;) Select-Object -Property LastWriteTime, &apos;Age(days)&apos;, Length, Name, PSIsContainer | # change the properties of the cloned object as you like ForEach-Object { # calculate the file/folder age in days $_.&apos;Age(days)&apos; = (New-Timespan -Start $_.LastWriteTime).Days # if it is a file, change size in bytes to size in MB if ($_.PSisContainer -eq $false) { $_.Length = (&apos;{0:N1} MB&apos; -f ($_.Length / 1MB)) } # do not forget to return the adjusted object so the next one gets it $_ } | # finally, select the properties you want in your report: Select-Object -Property LastWriteTime, &apos;Age(days)&apos;, Length, Name | # sort them as you like: Sort-Object -Property LastWriteTime -Descending | Out-GridView 该例子的结果以 MB 而不是字节为单位显示文件的大小，并且添加了一个称为“Age(days)”的列表示文件和文件夹创建以来的天数。 本文国际来源：Creating Great Reports","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"如何简洁地汇报 bug","slug":"report-bug-compactly","date":"2014-07-10T16:00:00.000Z","updated":"2017-03-17T15:26:23.875Z","comments":true,"path":"2014/07/11/report-bug-compactly/","link":"","permalink":"http://blog.vichamp.com/2014/07/11/report-bug-compactly/","excerpt":"","text":"英文： Given input X I would expect output Y, but your app gives me Z instead. 中文： 我输入了 X，期望输出结果是 Y，而您的程序输出了 Z。","categories":[{"name":"software-engineering","slug":"software-engineering","permalink":"http://blog.vichamp.com/categories/software-engineering/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"bug","slug":"bug","permalink":"http://blog.vichamp.com/tags/bug/"}],"keywords":[{"name":"software-engineering","slug":"software-engineering","permalink":"http://blog.vichamp.com/categories/software-engineering/"}]},{"title":"PowerShell 技能连载 - 接受多重输入","slug":"accepting-multiple-input","date":"2014-07-10T16:00:00.000Z","updated":"2017-03-17T15:26:23.875Z","comments":true,"path":"2014/07/11/accepting-multiple-input/","link":"","permalink":"http://blog.vichamp.com/2014/07/11/accepting-multiple-input/","excerpt":"当您创建 PowerShell 函数时，以下是一个定义了既能够从参数中获取值，又能从管道中获取值的多功能 InputObject 参数的代码模板： function Get-Something { param ( [Parameter(Mandatory=$true,ValueFromPipeline=$true)] [Object[]] $InputObject ) process { $InputObject | ForEach-Object { $element = $_ &quot;processing $element&quot; } } } 这是该函数的使用效果： PS&gt; Get-Something -InputObject 1,2,3,4 processing 1 processing 2 processing 3 processing 4 PS&gt; 1,2,3,4 | Get-Something processing 1 processing 2 processing 3 processing 4 请注意这个参数被定义成对象数组（所以它可以接收多个值）。然后，该参数值被送到 ForEach-Object 命令，将值一个一个取出来。这是针对第一个例子的调用方式。 要能够从管道中接收多个值，请确保对接收管道输入的参数设置了 ValueFromPipeline 属性。下一步，在函数中添加一段 Process 脚本块。这段代码充当循环的作用，和 ForEach-Object 十分相似，并且作用于管道送过来的每一个对象上。","text":"当您创建 PowerShell 函数时，以下是一个定义了既能够从参数中获取值，又能从管道中获取值的多功能 InputObject 参数的代码模板： function Get-Something { param ( [Parameter(Mandatory=$true,ValueFromPipeline=$true)] [Object[]] $InputObject ) process { $InputObject | ForEach-Object { $element = $_ &quot;processing $element&quot; } } } 这是该函数的使用效果： PS&gt; Get-Something -InputObject 1,2,3,4 processing 1 processing 2 processing 3 processing 4 PS&gt; 1,2,3,4 | Get-Something processing 1 processing 2 processing 3 processing 4 请注意这个参数被定义成对象数组（所以它可以接收多个值）。然后，该参数值被送到 ForEach-Object 命令，将值一个一个取出来。这是针对第一个例子的调用方式。 要能够从管道中接收多个值，请确保对接收管道输入的参数设置了 ValueFromPipeline 属性。下一步，在函数中添加一段 Process 脚本块。这段代码充当循环的作用，和 ForEach-Object 十分相似，并且作用于管道送过来的每一个对象上。 本文国际来源：Accepting Multiple Input","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 简单地读取注册表值","slug":"reading-registry-values-easily","date":"2014-07-09T16:00:00.000Z","updated":"2017-03-17T15:26:23.873Z","comments":true,"path":"2014/07/10/reading-registry-values-easily/","link":"","permalink":"http://blog.vichamp.com/2014/07/10/reading-registry-values-easily/","excerpt":"以下是最简单的读取注册表值的方法： $Key = &apos;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&apos; $Name = &apos;RegisteredOwner&apos; $result = (Get-ItemProperty -Path &quot;Registry::$Key&quot; -ErrorAction Stop).$Name &quot;Registered Windows Owner: $result&quot; 只需要将 $Key 替换成注册表项，将 $Name 替换成注册表键，就能读取它的值。","text":"以下是最简单的读取注册表值的方法： $Key = &apos;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&apos; $Name = &apos;RegisteredOwner&apos; $result = (Get-ItemProperty -Path &quot;Registry::$Key&quot; -ErrorAction Stop).$Name &quot;Registered Windows Owner: $result&quot; 只需要将 $Key 替换成注册表项，将 $Name 替换成注册表键，就能读取它的值。 本文国际来源：Reading Registry Values Easily","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 复制命令行历史的工具函数","slug":"copying-command-history-as-a-tool","date":"2014-07-08T16:00:00.000Z","updated":"2017-03-17T15:26:23.866Z","comments":true,"path":"2014/07/09/copying-command-history-as-a-tool/","link":"","permalink":"http://blog.vichamp.com/2014/07/09/copying-command-history-as-a-tool/","excerpt":"在前一个技能中我们演示了如何将之前键入的交互式 PowerShell 命令复制到您喜欢的脚本编辑器中。以下是一个能让操作更加简化的函数。如果您喜欢它，您可以将它加入您的配置脚本，那么就可以随时调用它： function Get-MyGeniusInput { param ( $Count, $Minute = 10000 ) $cutoff = (Get-Date).AddMinutes(-$Minute) $null = $PSBoundParameters.Remove(&apos;Minute&apos;) $result = Get-History @PSBoundParameters | Where-Object { $_.StartExecutionTime -gt $cutoff } | Select-Object -ExpandProperty CommandLine $count = $result.Count $result | clip.exe Write-Warning &quot;Copied $count command lines to the clipboard!&quot; } Get-MyGeniusInput 默认将所有命令行历史都复制到剪贴板。通过 -Count 参数，您可以指定复制的条数，例如最后 5 条命令。而通过 -Minute 参数，您可以指定复制多少分钟之内的历史记录。 PS&gt; Get-MyGeniusInput -Minute 25 WARNING: Copied 32 command lines to the clipboard! PS&gt; Get-MyGeniusInput -Minute 25 -Count 5 WARNING: Copied 5 command lines to the clipboard! PS&gt;","text":"在前一个技能中我们演示了如何将之前键入的交互式 PowerShell 命令复制到您喜欢的脚本编辑器中。以下是一个能让操作更加简化的函数。如果您喜欢它，您可以将它加入您的配置脚本，那么就可以随时调用它： function Get-MyGeniusInput { param ( $Count, $Minute = 10000 ) $cutoff = (Get-Date).AddMinutes(-$Minute) $null = $PSBoundParameters.Remove(&apos;Minute&apos;) $result = Get-History @PSBoundParameters | Where-Object { $_.StartExecutionTime -gt $cutoff } | Select-Object -ExpandProperty CommandLine $count = $result.Count $result | clip.exe Write-Warning &quot;Copied $count command lines to the clipboard!&quot; } Get-MyGeniusInput 默认将所有命令行历史都复制到剪贴板。通过 -Count 参数，您可以指定复制的条数，例如最后 5 条命令。而通过 -Minute 参数，您可以指定复制多少分钟之内的历史记录。 PS&gt; Get-MyGeniusInput -Minute 25 WARNING: Copied 32 command lines to the clipboard! PS&gt; Get-MyGeniusInput -Minute 25 -Count 5 WARNING: Copied 5 command lines to the clipboard! PS&gt; 本文国际来源：Copying Command History as a Tool","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 复制命令行历史记录","slug":"copying-command-history","date":"2014-07-07T16:00:00.000Z","updated":"2017-03-17T15:26:23.848Z","comments":true,"path":"2014/07/08/copying-command-history/","link":"","permalink":"http://blog.vichamp.com/2014/07/08/copying-command-history/","excerpt":"如果您在使用 PowerShell 的过程中突然发现刚才键入的某些代码起作用了，您接下来会想把这些代码复制并粘贴到一个脚本编辑器中，将它们保存起来，然后分享给朋友。 以下是操作方法： Get-History -Count 5 | Select-Object -ExpandProperty CommandLine | clip.exe 这将会把您最后键入的 5 条命令复制到剪贴板中。","text":"如果您在使用 PowerShell 的过程中突然发现刚才键入的某些代码起作用了，您接下来会想把这些代码复制并粘贴到一个脚本编辑器中，将它们保存起来，然后分享给朋友。 以下是操作方法： Get-History -Count 5 | Select-Object -ExpandProperty CommandLine | clip.exe 这将会把您最后键入的 5 条命令复制到剪贴板中。 本文国际来源：Copying Command History","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找两个日期之间的所有日子","slug":"finding-dates-between-two-dates","date":"2014-07-06T16:00:00.000Z","updated":"2017-03-17T15:26:23.848Z","comments":true,"path":"2014/07/07/finding-dates-between-two-dates/","link":"","permalink":"http://blog.vichamp.com/2014/07/07/finding-dates-between-two-dates/","excerpt":"如果您需要知道两个日期之间的间隔天数，那么可以用 New-TimeSpan 轻松地获得： $startdate = Get-Date $enddate = Get-Date -Date &apos;2014-09-12&apos; $difference = New-TimeSpan -Start $startdate -End $enddate $difference.Days 然而，如果您不仅想知道两者之间的间隔天数，而且还希望精确地获取每一天的日期对象，那么可以用这个方法： $startdate = Get-Date $enddate = Get-Date -Date &apos;2014-09-12&apos; $difference = New-TimeSpan -Start $startdate -End $enddate $days = [Math]::Ceiling($difference.TotalDays)+1 1..$days | ForEach-Object { $startdate $startdate = $startdate.AddDays(1) } 这一次，PowerShell 输出两个指定日期之间的所有日期对象。 当您了解了精确获取每个日期对象（而不仅是总天数）的方法之后，您可以过滤（例如以星期数），并查找距离您放假或退休之前还有多少个星期天或工作日。 以下代码是获取工作日用的： $startdate = Get-Date $enddate = Get-Date -Date &apos;2014-09-12&apos; $difference = New-TimeSpan -Start $startdate -End $enddate $difference.Days $days = [Math]::Ceiling($difference.TotalDays)+1 1..$days | ForEach-Object { $startdate $startdate = $startdate.AddDays(1) } | Where-Object { $_.DayOfWeek -gt 0 -and $_.DayOfWeek -lt 6} 这段代码时统计工作日天数用的： $startdate = Get-Date $enddate = Get-Date -Date &apos;2014-09-12&apos; $difference = New-TimeSpan -Start $startdate -End $enddate &quot;Days in all: &quot; + $difference.Days $days = [Math]::Ceiling($difference.TotalDays)+1 $workdays = 1..$days | ForEach-Object { $startdate $startdate = $startdate.AddDays(1) } | Where-Object { $_.DayOfWeek -gt 0 -and $_.DayOfWeek -lt 6} | Measure-Object | Select-Object -ExpandProperty Count &quot;Workdays: $workdays&quot;","text":"如果您需要知道两个日期之间的间隔天数，那么可以用 New-TimeSpan 轻松地获得： $startdate = Get-Date $enddate = Get-Date -Date &apos;2014-09-12&apos; $difference = New-TimeSpan -Start $startdate -End $enddate $difference.Days 然而，如果您不仅想知道两者之间的间隔天数，而且还希望精确地获取每一天的日期对象，那么可以用这个方法： $startdate = Get-Date $enddate = Get-Date -Date &apos;2014-09-12&apos; $difference = New-TimeSpan -Start $startdate -End $enddate $days = [Math]::Ceiling($difference.TotalDays)+1 1..$days | ForEach-Object { $startdate $startdate = $startdate.AddDays(1) } 这一次，PowerShell 输出两个指定日期之间的所有日期对象。 当您了解了精确获取每个日期对象（而不仅是总天数）的方法之后，您可以过滤（例如以星期数），并查找距离您放假或退休之前还有多少个星期天或工作日。 以下代码是获取工作日用的： $startdate = Get-Date $enddate = Get-Date -Date &apos;2014-09-12&apos; $difference = New-TimeSpan -Start $startdate -End $enddate $difference.Days $days = [Math]::Ceiling($difference.TotalDays)+1 1..$days | ForEach-Object { $startdate $startdate = $startdate.AddDays(1) } | Where-Object { $_.DayOfWeek -gt 0 -and $_.DayOfWeek -lt 6} 这段代码时统计工作日天数用的： $startdate = Get-Date $enddate = Get-Date -Date &apos;2014-09-12&apos; $difference = New-TimeSpan -Start $startdate -End $enddate &quot;Days in all: &quot; + $difference.Days $days = [Math]::Ceiling($difference.TotalDays)+1 $workdays = 1..$days | ForEach-Object { $startdate $startdate = $startdate.AddDays(1) } | Where-Object { $_.DayOfWeek -gt 0 -and $_.DayOfWeek -lt 6} | Measure-Object | Select-Object -ExpandProperty Count &quot;Workdays: $workdays&quot; 本文国际来源：Finding Dates Between Two Dates","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用缺省参数","slug":"using-default-parameters","date":"2014-07-03T16:00:00.000Z","updated":"2017-03-17T15:26:23.832Z","comments":true,"path":"2014/07/04/using-default-parameters/","link":"","permalink":"http://blog.vichamp.com/2014/07/04/using-default-parameters/","excerpt":"在 PowerShell 3.0 中，任意的 cmdlet 参数都可以定义一个缺省值。 例如这行代码，将设置所有 cmdlet 的 -Path 参数的缺省值为一个指定的路径： $PSDefaultParameterValues.Add(&apos;*:Path&apos;, &apos;c:\\Windows&apos;) 所以当您运行 Get-ChildItem 或任何其它包含 -Path 参数的 cmdlet 时，看起来好像您已经指定了这个参数。 除了 * 之外，您当然也可以指定 cmdlet 的名称。所以如果您希望将 Get-WmiObject 的 -ComputerName 参数设置为指定的远程主机，那么只需要这样做： $PSDefaultParameterValues.Add(&apos;Get-WmiObject:ComputerName&apos;, &apos;server12&apos;) 所有这些缺省值只在当前的 PowerShell 会话中有效。如果您想使它们始终有效，那么只需要在您的配置脚本中定义缺省值即可。 要移除所有的缺省值，请使用这行代码： $PSDefaultParameterValues.Clear()","text":"在 PowerShell 3.0 中，任意的 cmdlet 参数都可以定义一个缺省值。 例如这行代码，将设置所有 cmdlet 的 -Path 参数的缺省值为一个指定的路径： $PSDefaultParameterValues.Add(&apos;*:Path&apos;, &apos;c:\\Windows&apos;) 所以当您运行 Get-ChildItem 或任何其它包含 -Path 参数的 cmdlet 时，看起来好像您已经指定了这个参数。 除了 * 之外，您当然也可以指定 cmdlet 的名称。所以如果您希望将 Get-WmiObject 的 -ComputerName 参数设置为指定的远程主机，那么只需要这样做： $PSDefaultParameterValues.Add(&apos;Get-WmiObject:ComputerName&apos;, &apos;server12&apos;) 所有这些缺省值只在当前的 PowerShell 会话中有效。如果您想使它们始终有效，那么只需要在您的配置脚本中定义缺省值即可。 要移除所有的缺省值，请使用这行代码： $PSDefaultParameterValues.Clear() 本文国际来源：Using Default Parameters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通过 StringBuilder 加速脚本","slug":"speeding-up-scripts-with-stringbuilder","date":"2014-07-02T16:00:00.000Z","updated":"2017-03-17T15:26:23.817Z","comments":true,"path":"2014/07/03/speeding-up-scripts-with-stringbuilder/","link":"","permalink":"http://blog.vichamp.com/2014/07/03/speeding-up-scripts-with-stringbuilder/","excerpt":"我们的脚本常常需要向已有的文本中添加新的文本。以下是一段您可能很熟悉的代码： Measure-Command { $text = &quot;Hello&quot; for ($x=0; $x -lt 100000; $x++) { $text += &quot;status $x&quot; } $text } 这段代码运行起来非常慢，因为当您向字符串中添加文本时，整个字符串都需要重新构造。然而，有一个专用的对象，叫做 StringBuilder。它可以做相同的事情，但是速度飞快： Measure-Command { $sb = New-Object -TypeName System.Text.StringBuilder $null = $sb.Append(&quot;Hello&quot;) for ($x=0; $x -lt 100000; $x++) { $null = $sb.Append(&quot;status $x&quot;) } $sb.ToString() }","text":"我们的脚本常常需要向已有的文本中添加新的文本。以下是一段您可能很熟悉的代码： Measure-Command { $text = &quot;Hello&quot; for ($x=0; $x -lt 100000; $x++) { $text += &quot;status $x&quot; } $text } 这段代码运行起来非常慢，因为当您向字符串中添加文本时，整个字符串都需要重新构造。然而，有一个专用的对象，叫做 StringBuilder。它可以做相同的事情，但是速度飞快： Measure-Command { $sb = New-Object -TypeName System.Text.StringBuilder $null = $sb.Append(&quot;Hello&quot;) for ($x=0; $x -lt 100000; $x++) { $null = $sb.Append(&quot;status $x&quot;) } $sb.ToString() } 本文国际来源：Speeding Up Scripts with StringBuilder","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 列出工作日","slug":"finding-working-days","date":"2014-07-01T16:00:00.000Z","updated":"2017-03-17T15:26:23.817Z","comments":true,"path":"2014/07/02/finding-working-days/","link":"","permalink":"http://blog.vichamp.com/2014/07/02/finding-working-days/","excerpt":"以下单行代码可以列出指定月份的所有工作日： $month = 7 1..31 | ForEach-Object { Get-Date -Day $_ -Month $month } | Where-Object { $_.DayOfWeek -gt 0 -and $_.DayOfWeek -lt 6 } 只需要将月份赋值给 $month（例子中以 7 月为例）。 多添一些代码，就可以从管道中返回工作日的数量： $month = 7 1..31 | ForEach-Object { Get-Date -Day $_ -Month $month } | Where-Object { $_.DayOfWeek -gt 0 -and $_.DayOfWeek -lt 6 } | Measure-Object | Select-Object -ExpandProperty Count","text":"以下单行代码可以列出指定月份的所有工作日： $month = 7 1..31 | ForEach-Object { Get-Date -Day $_ -Month $month } | Where-Object { $_.DayOfWeek -gt 0 -and $_.DayOfWeek -lt 6 } 只需要将月份赋值给 $month（例子中以 7 月为例）。 多添一些代码，就可以从管道中返回工作日的数量： $month = 7 1..31 | ForEach-Object { Get-Date -Day $_ -Month $month } | Where-Object { $_.DayOfWeek -gt 0 -and $_.DayOfWeek -lt 6 } | Measure-Object | Select-Object -ExpandProperty Count 本文国际来源：Finding Working Days","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 为什么目录的大小为 1","slug":"why-directories-have-a-size-of-1","date":"2014-06-30T16:00:00.000Z","updated":"2017-03-17T15:26:23.817Z","comments":true,"path":"2014/07/01/why-directories-have-a-size-of-1/","link":"","permalink":"http://blog.vichamp.com/2014/07/01/why-directories-have-a-size-of-1/","excerpt":"你也许偶然注意到，文件夹的 Length 为 1 字节。这是从 PowerShell 3.0 开始的。在 PowerShell 2.0 中，Length 并没有任何值。 $folder = Get-Item c:\\Windows $folder.Length 这个结果是由另一个特性导致的。一个对象如果不包含“Count”或“Length”属性，它也会隐式地含有这两个属性，并且预设值为 1。 PS&gt; $host.length 1 PS&gt; $host.Count 1 PS&gt; (Get-Date).Length 1 PS&gt; (Get-Date).Count 1 PS&gt; $ConfirmPreference.Length 1 PS&gt; $ConfirmPreference.Count 1 在过去，通常只有数组才有 Length 或 Count 属性。所以当一个 cmdlet 或 函数仅返回 1 个对象（或 0 个对象）时，结果不会被包装成数组。而导致获取结果的数量时发生错误。 通过这个新“特性”，如果一个命令只返回一个对象，那么添加的“Count”属性总是返回“1”，意味着返回了 1 个元素。","text":"你也许偶然注意到，文件夹的 Length 为 1 字节。这是从 PowerShell 3.0 开始的。在 PowerShell 2.0 中，Length 并没有任何值。 $folder = Get-Item c:\\Windows $folder.Length 这个结果是由另一个特性导致的。一个对象如果不包含“Count”或“Length”属性，它也会隐式地含有这两个属性，并且预设值为 1。 PS&gt; $host.length 1 PS&gt; $host.Count 1 PS&gt; (Get-Date).Length 1 PS&gt; (Get-Date).Count 1 PS&gt; $ConfirmPreference.Length 1 PS&gt; $ConfirmPreference.Count 1 在过去，通常只有数组才有 Length 或 Count 属性。所以当一个 cmdlet 或 函数仅返回 1 个对象（或 0 个对象）时，结果不会被包装成数组。而导致获取结果的数量时发生错误。 通过这个新“特性”，如果一个命令只返回一个对象，那么添加的“Count”属性总是返回“1”，意味着返回了 1 个元素。 本文国际来源：Why Directories Have a Size of 1","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 加速后台任务","slug":"speeding-up-background-jobs","date":"2014-06-29T16:00:00.000Z","updated":"2017-03-17T15:26:23.801Z","comments":true,"path":"2014/06/30/speeding-up-background-jobs/","link":"","permalink":"http://blog.vichamp.com/2014/06/30/speeding-up-background-jobs/","excerpt":"后台任务可以大大提速脚本的执行，因为它们可以并行执行。然而，后台任务只适用于执行的代码不会产生大量的数据——因为通过 XML 序列化返回数据可能会消耗掉比串行操作节约出来的更多的时间。 幸运的是，您可以控制后台操作可以返回多少数据。让我们看看如何实现。 这段代码中有三个任务（$code1-3）并发执行。两个为后台任务，另一个操作 PowerShell 前台。 $start = Get-Date $code1 = { Get-Hotfix } $code2 = { Get-ChildItem $env:windir\\system32\\*.dll } $code3 = { Get-Content -Path C:\\Windows\\WindowsUpdate.log } $job1 = Start-Job -ScriptBlock $code1 $job2 = Start-Job -ScriptBlock $code2 $result3 = &amp; $code3 $alljobs = Wait-Job $job1, $job2 Remove-Job -Job $alljobs $result1, $result2 = Receive-Job $alljobs $end = Get-Date $timespan = $end - $start $seconds = $timespan.TotalSeconds Write-Host &quot;This took me $seconds seconds.&quot; 这将消耗大约半分钟时间。而当您顺序执行这三个任务，而不是用后台任务，它们只消耗 5 秒钟。 $start = Get-Date $result1 = Get-Hotfix $result2 = Get-ChildItem $env:windir\\system32\\*.dll $result3 = Get-Content -Path C:\\Windows\\WindowsUpdate.log $end = Get-Date $timespan = $end - $start $seconds = $timespan.TotalSeconds Write-Host &quot;This took me $seconds seconds.&quot; 所以后台任务不仅增加了代码的复杂度，并且还延长了脚本的执行时间。只有优化过的返回数据才有意义。传递越少数据越好。 $start = Get-Date $code1 = { Get-Hotfix | Select-Object -ExpandProperty HotfixID } $code2 = { Get-Content -Path C:\\Windows\\WindowsUpdate.log | Where-Object { $_ -like &apos;*successfully installed*&apos; }} $code3 = { Get-ChildItem $env:windir\\system32\\*.dll | Select-Object -ExpandProperty Name } $job1 = Start-Job -ScriptBlock $code1 $job2 = Start-Job -ScriptBlock $code2 $result3 = &amp; $code3 $alljobs = Wait-Job $job1, $job2 Remove-Job -Job $alljobs $result1, $result2 = Receive-Job $alljob 这一次，后台任务只返回必须的数据，大大提升了执行效率。 总的来说，后台任务适合于做一些简单的事情（例如配置）而不返回任何数据或只返回少量的数据。","text":"后台任务可以大大提速脚本的执行，因为它们可以并行执行。然而，后台任务只适用于执行的代码不会产生大量的数据——因为通过 XML 序列化返回数据可能会消耗掉比串行操作节约出来的更多的时间。 幸运的是，您可以控制后台操作可以返回多少数据。让我们看看如何实现。 这段代码中有三个任务（$code1-3）并发执行。两个为后台任务，另一个操作 PowerShell 前台。 $start = Get-Date $code1 = { Get-Hotfix } $code2 = { Get-ChildItem $env:windir\\system32\\*.dll } $code3 = { Get-Content -Path C:\\Windows\\WindowsUpdate.log } $job1 = Start-Job -ScriptBlock $code1 $job2 = Start-Job -ScriptBlock $code2 $result3 = &amp; $code3 $alljobs = Wait-Job $job1, $job2 Remove-Job -Job $alljobs $result1, $result2 = Receive-Job $alljobs $end = Get-Date $timespan = $end - $start $seconds = $timespan.TotalSeconds Write-Host &quot;This took me $seconds seconds.&quot; 这将消耗大约半分钟时间。而当您顺序执行这三个任务，而不是用后台任务，它们只消耗 5 秒钟。 $start = Get-Date $result1 = Get-Hotfix $result2 = Get-ChildItem $env:windir\\system32\\*.dll $result3 = Get-Content -Path C:\\Windows\\WindowsUpdate.log $end = Get-Date $timespan = $end - $start $seconds = $timespan.TotalSeconds Write-Host &quot;This took me $seconds seconds.&quot; 所以后台任务不仅增加了代码的复杂度，并且还延长了脚本的执行时间。只有优化过的返回数据才有意义。传递越少数据越好。 $start = Get-Date $code1 = { Get-Hotfix | Select-Object -ExpandProperty HotfixID } $code2 = { Get-Content -Path C:\\Windows\\WindowsUpdate.log | Where-Object { $_ -like &apos;*successfully installed*&apos; }} $code3 = { Get-ChildItem $env:windir\\system32\\*.dll | Select-Object -ExpandProperty Name } $job1 = Start-Job -ScriptBlock $code1 $job2 = Start-Job -ScriptBlock $code2 $result3 = &amp; $code3 $alljobs = Wait-Job $job1, $job2 Remove-Job -Job $alljobs $result1, $result2 = Receive-Job $alljob 这一次，后台任务只返回必须的数据，大大提升了执行效率。 总的来说，后台任务适合于做一些简单的事情（例如配置）而不返回任何数据或只返回少量的数据。 本文国际来源：Speeding Up Background Jobs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 理解 exit 语句","slug":"understanding-the-statement-quot-exit-quot","date":"2014-06-26T16:00:00.000Z","updated":"2017-03-17T15:26:23.801Z","comments":true,"path":"2014/06/27/understanding-the-statement-quot-exit-quot/","link":"","permalink":"http://blog.vichamp.com/2014/06/27/understanding-the-statement-quot-exit-quot/","excerpt":"PowerShell 支持基于作用域的 exit 关键字。它的工作方式也许和您想象的很不一样。 我们假设有这样一个函数： function test { &apos;A&apos; exit &apos;B&apos; } 当您将这个函数保存为一个脚本文件，然后执行这个脚本，将得到以下结果： PS&gt; C:\\Users\\Tobias\\Documents\\PowerShell\\test12343.ps1 A 这意味着 exit 使函数提前退出。然而，当您没有保存该脚本，或当您以交互式的方式调用该函数，您的整个 PowerShell 宿主将会关闭。 exit 将会导致调用者上下文退出，而不仅仅是所在的函数。所以如果您将脚本像这样保存，您也许会有意外发现： function test { &apos;A&apos; exit &apos;B&apos; } &apos;Start&apos; test &apos;Stop&apos; 现在的结果类似这样： PS&gt; C:\\Users\\Tobias\\Documents\\PowerShell\\test12343.ps1 Start A 如您所见，“Stop”语句不再能执行到。exit 使得函数和调用者作用域都退出了。这是为什么您以交互式执行该函数会导致您的 PowerShell 被关闭的原因（因为此时您的调用者作用域是宿主本身）。 那么 exit 应该怎么使用？当脚本执行结束的时候您可以用它来设置错误等级（error level）。该错误等级可以被调用者读取，所以如果您通过计划任务启动一个 PowerShell 脚本，或者用批处理文件通过 powershell.exe 来启动它，那么您通过 exit 指定的数值将会作为脚本的返回值，并赋值给批处理文件的 %ERRORLEVEL% 变量。","text":"PowerShell 支持基于作用域的 exit 关键字。它的工作方式也许和您想象的很不一样。 我们假设有这样一个函数： function test { &apos;A&apos; exit &apos;B&apos; } 当您将这个函数保存为一个脚本文件，然后执行这个脚本，将得到以下结果： PS&gt; C:\\Users\\Tobias\\Documents\\PowerShell\\test12343.ps1 A 这意味着 exit 使函数提前退出。然而，当您没有保存该脚本，或当您以交互式的方式调用该函数，您的整个 PowerShell 宿主将会关闭。 exit 将会导致调用者上下文退出，而不仅仅是所在的函数。所以如果您将脚本像这样保存，您也许会有意外发现： function test { &apos;A&apos; exit &apos;B&apos; } &apos;Start&apos; test &apos;Stop&apos; 现在的结果类似这样： PS&gt; C:\\Users\\Tobias\\Documents\\PowerShell\\test12343.ps1 Start A 如您所见，“Stop”语句不再能执行到。exit 使得函数和调用者作用域都退出了。这是为什么您以交互式执行该函数会导致您的 PowerShell 被关闭的原因（因为此时您的调用者作用域是宿主本身）。 那么 exit 应该怎么使用？当脚本执行结束的时候您可以用它来设置错误等级（error level）。该错误等级可以被调用者读取，所以如果您通过计划任务启动一个 PowerShell 脚本，或者用批处理文件通过 powershell.exe 来启动它，那么您通过 exit 指定的数值将会作为脚本的返回值，并赋值给批处理文件的 %ERRORLEVEL% 变量。 本文国际来源：Understanding the statement “exit”","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 break、continue 和 return 语句","slug":"using-break-continue-and-return","date":"2014-06-25T16:00:00.000Z","updated":"2017-03-17T15:26:23.801Z","comments":true,"path":"2014/06/26/using-break-continue-and-return/","link":"","permalink":"http://blog.vichamp.com/2014/06/26/using-break-continue-and-return/","excerpt":"在 PowerShell 的循环中，有两个特殊的关键字：break 和 continue。 使用 continue，循环继续执行，但是跳过剩下的代码。当您执行 break 时，循环提前结束并返回所有的结果。 另外，还有一个关键字 return。它将导致立即退出当前的作用域。所以当您在一个函数中执行 return，那么该函数将会退出；而如果您在一个脚本中执行 return，那么整个脚本将退出。","text":"在 PowerShell 的循环中，有两个特殊的关键字：break 和 continue。 使用 continue，循环继续执行，但是跳过剩下的代码。当您执行 break 时，循环提前结束并返回所有的结果。 另外，还有一个关键字 return。它将导致立即退出当前的作用域。所以当您在一个函数中执行 return，那么该函数将会退出；而如果您在一个脚本中执行 return，那么整个脚本将退出。 本文国际来源：Using break, continue, and return","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 处理环境变量","slug":"dealing-with-environment-variables","date":"2014-06-24T16:00:00.000Z","updated":"2017-03-17T15:26:23.801Z","comments":true,"path":"2014/06/25/dealing-with-environment-variables/","link":"","permalink":"http://blog.vichamp.com/2014/06/25/dealing-with-environment-variables/","excerpt":"要在 PowerShell 中读取 Windows 环境变量，只需要使用“env:”前缀： PS&gt; $env:windir C:\\Windows PS&gt; $env:USERNAME Tobias 实际上，“env:”是一个虚拟驱动器，所以您可以用它来查找所有（或一部分）环境变量。这段代码将列出所有名字中含有“user”的环境变量： PS&gt; dir env:\\*user* Name Value ---- ----- USERPROFILE C:\\Users\\Tobias USERNAME Tobias ALLUSERSPROFILE C:\\ProgramData USERDOMAIN TobiasAir1","text":"要在 PowerShell 中读取 Windows 环境变量，只需要使用“env:”前缀： PS&gt; $env:windir C:\\Windows PS&gt; $env:USERNAME Tobias 实际上，“env:”是一个虚拟驱动器，所以您可以用它来查找所有（或一部分）环境变量。这段代码将列出所有名字中含有“user”的环境变量： PS&gt; dir env:\\*user* Name Value ---- ----- USERPROFILE C:\\Users\\Tobias USERNAME Tobias ALLUSERSPROFILE C:\\ProgramData USERDOMAIN TobiasAir1 本文国际来源：Dealing with Environment Variables","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用嵌套的哈希表","slug":"using-nested-hash-tables","date":"2014-06-23T16:00:00.000Z","updated":"2017-03-17T15:26:23.801Z","comments":true,"path":"2014/06/24/using-nested-hash-tables/","link":"","permalink":"http://blog.vichamp.com/2014/06/24/using-nested-hash-tables/","excerpt":"嵌套的哈希表是代替多维数组的好方法。它能以易于管理的方式存储数据集合。让我们看一个例子： $person = @{} $person.Name = &apos;Weltner&apos; $person.Id = 12 $person.Address = @{} $person.Address.Street = &apos;Canyon Rim&apos; $person.Address.City = &apos;Folsom&apos; $person.Address.Details = @{} $person.Address.Details.Story = 4 $person.Address.Details.ScenicView = $false 这段代码定义了一个 person 变量。您可以这样查看 person 的内容： PS&gt; $person Name Value ---- ----- Name Weltner Id 12 Address {Street, Details, City} 您还可以这样方便地获取其中的一部分信息： PS&gt; $person Name Weltner PS&gt; $person.Address.City Folsom PS&gt; $person.Address.Details.ScenicView False","text":"嵌套的哈希表是代替多维数组的好方法。它能以易于管理的方式存储数据集合。让我们看一个例子： $person = @{} $person.Name = &apos;Weltner&apos; $person.Id = 12 $person.Address = @{} $person.Address.Street = &apos;Canyon Rim&apos; $person.Address.City = &apos;Folsom&apos; $person.Address.Details = @{} $person.Address.Details.Story = 4 $person.Address.Details.ScenicView = $false 这段代码定义了一个 person 变量。您可以这样查看 person 的内容： PS&gt; $person Name Value ---- ----- Name Weltner Id 12 Address {Street, Details, City} 您还可以这样方便地获取其中的一部分信息： PS&gt; $person Name Weltner PS&gt; $person.Address.City Folsom PS&gt; $person.Address.Details.ScenicView False 本文国际来源：Using Nested Hash Tables","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"显示、隐藏 PowerShell","slug":"show-powershell-hide-powershell","date":"2014-06-22T16:00:00.000Z","updated":"2017-03-17T15:26:23.785Z","comments":true,"path":"2014/06/23/show-powershell-hide-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/06/23/show-powershell-hide-powershell/","excerpt":"","text":"在 WPF 之周中，有个朋友希望有个最小化 PowerShell 窗口的例子。 以下是一个快速实现该需求的 module。只要将以下代码复制粘贴到 Documents\\WindowsPowerShell\\Packages\\PowerShell\\PowerShell.psm1 即可。 $script:showWindowAsync = Add-Type –memberDefinition @&quot; [DllImport(&quot;user32.dll&quot;)] public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow); &quot;@ -name &quot;Win32ShowWindowAsync&quot; -namespace Win32Functions –passThru function Show-PowerShell() { $null = $showWindowAsync::ShowWindowAsync((Get-Process –id $pid).MainWindowHandle, 10) } function Hide-PowerShell() { $null = $showWindowAsync::ShowWindowAsync((Get-Process –id $pid).MainWindowHandle, 2) } 现在，您可以用这段代码来显示或隐藏 PowerShell： Add-Module PowerShell # Minimize PowerShell Hide-PowerShell sleep 2 # Then Restore it Show-PowerShell 希望这篇文章有所帮助。James Brundage[MSFT] 译者注：ShowWindowAsync() 的第二个参数取值范围可以参照 API 文档 ShowWindow function本文国际来源","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"window","slug":"window","permalink":"http://blog.vichamp.com/tags/window/"},{"name":"module","slug":"module","permalink":"http://blog.vichamp.com/tags/module/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 加速数组操作","slug":"speeding-up-arrays","date":"2014-06-22T16:00:00.000Z","updated":"2017-03-17T15:26:23.785Z","comments":true,"path":"2014/06/23/speeding-up-arrays/","link":"","permalink":"http://blog.vichamp.com/2014/06/23/speeding-up-arrays/","excerpt":"当您频繁地向数组添加新元素时，您可能会遇到性能问题。以下是一个演示这个问题的反例，您应该避免这样使用： Measure-Command { $ar = @() for ($x=0; $x -lt 10000; $x++) { $ar += $x } } 在循环中，数组用“+=”运算符不断地添加新元素。这将消耗许多时间，因为每次改变数组的大小时，PowerShell 都需要创建一个新的数组。 以下是一个快许多倍的实现方式——用 ArrayList，它专门为大小变化的情况设计： Measure-Command { $ar = New-Object -TypeName System.Collections.ArrayList for ($x=0; $x -lt 10000; $x++) { $ar.Add($x) } } 两段代码实现相同的效果，但第二段效率要高得多。","text":"当您频繁地向数组添加新元素时，您可能会遇到性能问题。以下是一个演示这个问题的反例，您应该避免这样使用： Measure-Command { $ar = @() for ($x=0; $x -lt 10000; $x++) { $ar += $x } } 在循环中，数组用“+=”运算符不断地添加新元素。这将消耗许多时间，因为每次改变数组的大小时，PowerShell 都需要创建一个新的数组。 以下是一个快许多倍的实现方式——用 ArrayList，它专门为大小变化的情况设计： Measure-Command { $ar = New-Object -TypeName System.Collections.ArrayList for ($x=0; $x -lt 10000; $x++) { $ar.Add($x) } } 两段代码实现相同的效果，但第二段效率要高得多。 本文国际来源：Speeding Up Arrays","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用事件日志代替日志文件","slug":"using-event-logs-instead-of-log-files","date":"2014-06-19T16:00:00.000Z","updated":"2017-03-17T15:26:23.777Z","comments":true,"path":"2014/06/20/using-event-logs-instead-of-log-files/","link":"","permalink":"http://blog.vichamp.com/2014/06/20/using-event-logs-instead-of-log-files/","excerpt":"人们常常使用文件来记录日志。这样做并没有错，但是使用 Windows 内置的事件日志系统可能会简单得多。 如果您有管理员权限，您可以随时创建新的事件日志： New-EventLog -LogName myLog -Source JobDue, JobDone, Remark 这将创建一个名为“myLog”的新日志，它的来源为“JobDue”、“JobDone”和“Remark”。管理员权限只是用来创建事件日志用。剩下的操作任何普通用户都可以操作。现在您的日志可以记录到新的事件日志中。 Write-EventLog -LogName myLog -Source JobDue -EntryType Information -EventId 1 -Message &apos;This could be a job description.&apos; Write-EventLog -LogName myLog -Source JobDue -EntryType Information -EventId 1 -Message &apos;This could be another job description.&apos; 通过 Get-EventLog 命令，您可以轻松地解析您的日志并且查找信息： Get-EventLog -LogName myLog -Source JobDue -After 2014-05-10 通过 Limit-EventLog，您还可以配置您的日志，限制最大大小。","text":"人们常常使用文件来记录日志。这样做并没有错，但是使用 Windows 内置的事件日志系统可能会简单得多。 如果您有管理员权限，您可以随时创建新的事件日志： New-EventLog -LogName myLog -Source JobDue, JobDone, Remark 这将创建一个名为“myLog”的新日志，它的来源为“JobDue”、“JobDone”和“Remark”。管理员权限只是用来创建事件日志用。剩下的操作任何普通用户都可以操作。现在您的日志可以记录到新的事件日志中。 Write-EventLog -LogName myLog -Source JobDue -EntryType Information -EventId 1 -Message &apos;This could be a job description.&apos; Write-EventLog -LogName myLog -Source JobDue -EntryType Information -EventId 1 -Message &apos;This could be another job description.&apos; 通过 Get-EventLog 命令，您可以轻松地解析您的日志并且查找信息： Get-EventLog -LogName myLog -Source JobDue -After 2014-05-10 通过 Limit-EventLog，您还可以配置您的日志，限制最大大小。 本文国际来源：Using Event Logs Instead of Log Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 轻松读取注册表键值","slug":"reading-registry-values-the-easy-way","date":"2014-06-18T16:00:00.000Z","updated":"2017-03-17T15:26:23.773Z","comments":true,"path":"2014/06/19/reading-registry-values-the-easy-way/","link":"","permalink":"http://blog.vichamp.com/2014/06/19/reading-registry-values-the-easy-way/","excerpt":"使用 PowerShell 读取注册表是小菜一碟。以下是一段代码模板： $RegPath = &apos;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion&apos; $key = Get-ItemProperty -Path &quot;Registry::$RegPath&quot; 现在，只需要将 RegPath 替换成任意的注册表项路径。您还可以从 regedit.exe 中复制粘贴项路径。 当您运行完这段代码，$key 变量被赋值以后，只需键入 $key 以及 .，智能提示将列出该项下的所有键名，您可以简单地选取您希望读取的键。在控制台中，当您键入 . 之后按下 TAB 键可以显示所有可用的键名： $key.CommonFilesDir $key.MediaPathUnexpanded $key.ProgramW6432Dir","text":"使用 PowerShell 读取注册表是小菜一碟。以下是一段代码模板： $RegPath = &apos;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion&apos; $key = Get-ItemProperty -Path &quot;Registry::$RegPath&quot; 现在，只需要将 RegPath 替换成任意的注册表项路径。您还可以从 regedit.exe 中复制粘贴项路径。 当您运行完这段代码，$key 变量被赋值以后，只需键入 $key 以及 .，智能提示将列出该项下的所有键名，您可以简单地选取您希望读取的键。在控制台中，当您键入 . 之后按下 TAB 键可以显示所有可用的键名： $key.CommonFilesDir $key.MediaPathUnexpanded $key.ProgramW6432Dir 本文国际来源：Reading Registry Values the Easy Way","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 不中断处理 Cmdlet 中的错误","slug":"handling-cmdlet-errors-without-interruption","date":"2014-06-17T16:00:00.000Z","updated":"2017-03-17T15:26:23.753Z","comments":true,"path":"2014/06/18/handling-cmdlet-errors-without-interruption/","link":"","permalink":"http://blog.vichamp.com/2014/06/18/handling-cmdlet-errors-without-interruption/","excerpt":"当您想要错误处理器处理 cmdlet 内部产生的错误时，您只能将该 cmdlet 的 -ErrorAction 设为 Stop 才能捕获这类异常。否则，cmdlet 将在内部处理该错误。 这么做是有副作用的，因为将 -ErrorAction 设为 Stop 将会在发生第一个错误的时候停止该 cmdlet。 所以如果您希望不中断一个 cmdlet 并仍然能够获得该 cmdlet 产生的所有错误，那么请使用 -ErrorVariable。这段代码递归地获取您 Windows 文件夹中的所有 PowerShell 脚本（可能需要消耗一些时间）。错误不会导致停止执行，而是记录到一个变量中： Get-ChildItem -Path c:\\Windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable myErrors 当该 cmdlet 执行完成以后，您可以检测 $myErrors 变量。它包含了所有发生的错误信息。例如，这段代码可以获取所有 Get-ChildItem 无法进入的子文件夹列表： $myErrors.TargetObject 上面一段代码使用了自动展开特性（PowerShell 3.0 中引入）。所以在 PowerShell 2.0 中，您需要这么写： $myErrors | Select-Object -ExpandProperty TargetObject","text":"当您想要错误处理器处理 cmdlet 内部产生的错误时，您只能将该 cmdlet 的 -ErrorAction 设为 Stop 才能捕获这类异常。否则，cmdlet 将在内部处理该错误。 这么做是有副作用的，因为将 -ErrorAction 设为 Stop 将会在发生第一个错误的时候停止该 cmdlet。 所以如果您希望不中断一个 cmdlet 并仍然能够获得该 cmdlet 产生的所有错误，那么请使用 -ErrorVariable。这段代码递归地获取您 Windows 文件夹中的所有 PowerShell 脚本（可能需要消耗一些时间）。错误不会导致停止执行，而是记录到一个变量中： Get-ChildItem -Path c:\\Windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable myErrors 当该 cmdlet 执行完成以后，您可以检测 $myErrors 变量。它包含了所有发生的错误信息。例如，这段代码可以获取所有 Get-ChildItem 无法进入的子文件夹列表： $myErrors.TargetObject 上面一段代码使用了自动展开特性（PowerShell 3.0 中引入）。所以在 PowerShell 2.0 中，您需要这么写： $myErrors | Select-Object -ExpandProperty TargetObject 本文国际来源：Handling Cmdlet Errors without Interruption","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 有趣的路径名","slug":"fun-with-path-names","date":"2014-06-16T16:00:00.000Z","updated":"2017-03-17T15:26:23.753Z","comments":true,"path":"2014/06/17/fun-with-path-names/","link":"","permalink":"http://blog.vichamp.com/2014/06/17/fun-with-path-names/","excerpt":"您可以用 -split 运算符轻松地将一个路径分割成独立的部分。结果是一个数组。 只需要用比较运算符来排除您不需要的部分，或者对其中的一部分改名，然后用 -join 运算符将路径合并回来。 以下代码将排除掉某个路径下所有包含单词“test”的子文件夹： $path = &apos;C:\\folder\\test\\unit1\\testing\\results\\report.txt&apos; $path -split &apos;\\\\&apos; -notlike &apos;*test*&apos; -join &apos;\\&apos;","text":"您可以用 -split 运算符轻松地将一个路径分割成独立的部分。结果是一个数组。 只需要用比较运算符来排除您不需要的部分，或者对其中的一部分改名，然后用 -join 运算符将路径合并回来。 以下代码将排除掉某个路径下所有包含单词“test”的子文件夹： $path = &apos;C:\\folder\\test\\unit1\\testing\\results\\report.txt&apos; $path -split &apos;\\\\&apos; -notlike &apos;*test*&apos; -join &apos;\\&apos; 本文国际来源：Fun with Path Names","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通过按键跳过配置脚本","slug":"skipping-profile-on-keystroke","date":"2014-06-15T16:00:00.000Z","updated":"2017-03-17T15:26:23.737Z","comments":true,"path":"2014/06/16/skipping-profile-on-keystroke/","link":"","permalink":"http://blog.vichamp.com/2014/06/16/skipping-profile-on-keystroke/","excerpt":"有些时候您也许希望跳过配置文件中的某些部分。例如，在 ISE 编辑器中，只需要将这段代码加入您的配置脚本（配置脚本的路径可以在通过 $profile 变量查看，它也有可能还没有创建）： if([System.Windows.Input.Keyboard]::IsKeyDown(&apos;Ctrl&apos;)) { return } 如果您启动 ISE 编辑器时按住 CTRL 键，将跳过您配置脚本中的剩余部分。 或者，您可以这样使用： if([System.Windows.Input.Keyboard]::IsKeyDown(&apos;Ctrl&apos;) -eq $false) { Write-Warning &apos;You DID NOT press CTRL, so I could execute things here.&apos; } 这样写的话，仅当您启动 ISE 时没有按住 CTRL 键时，才会运行花括号内部的代码。 如果您希望这段代码也能用在 PowerShel 控制台中，那么需要加载对应的程序集。这段代码在所有的配置脚本中都通用： Add-Type -AssemblyName PresentationFramework if([System.Windows.Input.Keyboard]::IsKeyDown(&apos;Ctrl&apos;) -eq $false) { Write-Warning &apos;You DID NOT press CTRL, so I could execute things here.&apos; }","text":"有些时候您也许希望跳过配置文件中的某些部分。例如，在 ISE 编辑器中，只需要将这段代码加入您的配置脚本（配置脚本的路径可以在通过 $profile 变量查看，它也有可能还没有创建）： if([System.Windows.Input.Keyboard]::IsKeyDown(&apos;Ctrl&apos;)) { return } 如果您启动 ISE 编辑器时按住 CTRL 键，将跳过您配置脚本中的剩余部分。 或者，您可以这样使用： if([System.Windows.Input.Keyboard]::IsKeyDown(&apos;Ctrl&apos;) -eq $false) { Write-Warning &apos;You DID NOT press CTRL, so I could execute things here.&apos; } 这样写的话，仅当您启动 ISE 时没有按住 CTRL 键时，才会运行花括号内部的代码。 如果您希望这段代码也能用在 PowerShel 控制台中，那么需要加载对应的程序集。这段代码在所有的配置脚本中都通用： Add-Type -AssemblyName PresentationFramework if([System.Windows.Input.Keyboard]::IsKeyDown(&apos;Ctrl&apos;) -eq $false) { Write-Warning &apos;You DID NOT press CTRL, so I could execute things here.&apos; } 本文国际来源：Skipping Profile on Keystroke","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"自动生成 PowerShell 技能连载","slug":"generate-powershell-tips-automatically","date":"2014-06-13T16:00:00.000Z","updated":"2017-03-17T15:26:23.721Z","comments":true,"path":"2014/06/14/generate-powershell-tips-automatically/","link":"","permalink":"http://blog.vichamp.com/2014/06/14/generate-powershell-tips-automatically/","excerpt":"","text":"Tobias Weltner 博士每个工作日都在 www.powershell.com 发布一篇 PowerShell 技能。这个系列在 PowerShell 的技术社区里已是家喻户晓，成为关注 PowerShell 技术动态的一扇窗口。 这个套技能连载在中国有两个版本的翻译。一套是由荔非苔创立的 Powershell小技巧，现由荔非苔和 CodeCook 两人维护；另一套是本站的 PowerShell 技能连载。 本站是采用 JekyllBootstrap 系统搭建，使用 markdown 编辑文章，并使用 git 发布到 GitHub Pages 上。采用这些略带 geek 感的技术来做这个站点，是因为： 用 markdown 可以使我关注文案的内容，而不是格式。并且它十分适合编写技术文章。 git 很酷，可以多人协作，可以像写代码一样写文章。 可以自由地调整源代码，加入新奇的功能，甚至可以用脚本来做站点搬家。 GitHub Pages 可以为我们提供免费的服务器。 一切都是开源的，您可以查看到这个站点的一切源代码、文章源文件，甚至所有的维护脚本。 我本身是一个 geek。 我已翻译了PowerShell 技能连载的 200 多篇文章。与此同时，我也采用各种技术方法提升翻译工作的效率。翻译一篇文章所占用的时间已从最初的 30 分钟缩短到现在的 10 分钟。以下部分将演示我是如何做到的。翻译一篇文章，需要经历以下步骤： 从 www.powershell.com 搜集新文章。 创建新的 markdown 文件。文件名对应原文的 url 地址。 编辑文件头的元数据。 将英文的内容转换成 markdown 格式，贴到文件正文部分。 在文本编辑器中，将英文内容逐段翻译成中文，并将原文逐段删除。 处理文章中的图片。 将它下载到本地。 以文章的文件名作为前缀，并加上序号作为文件名。 修正文章中的图片地址。 在浏览器中打开原文，以供对照参考。 我们可以用 PowerShell 逐一解决这些问题： 搜集新文章获取更新列表浏览 www.powershell.com 的源代码，发现该网站有提供 PowerShell tips 的 RSS 订阅： &lt;link rel=&quot;alternate&quot; type=&quot;application/atom+xml&quot; title=&quot;Power Tips (Atom 1.0)&quot; href=&quot;http://powershell.com/cs/blogs/tips/atom.aspx&quot; /&gt; 通过 RSS 服务，我们就可以通过编程的方式，自动化地获取文章的内容。 $atomUrl = &apos;http://powershell.com/cs/blogs/tips/atom.aspx&apos; $feed = Invoke-RestMethod $atomUrl 获取到的 $feed 变量大概是这样的一个数组： title : Using Profile Scripts link : link id : /cs/blogs/tips/archive/2014/06/13/using-profile-scripts.aspx published : 2014-06-13T11:00:00Z updated : 2014-06-13T11:00:00Z content : content author : author title : Be Aware of Side Effects link : link id : /cs/blogs/tips/archive/2014/06/12/be-aware-of-side-effects.aspx published : 2014-06-12T11:00:00Z updated : 2014-06-12T11:00:00Z content : content author : author 其中 link、id、content 对我们有用。content 是 XmlElement 类型的对象，我们一会儿会用到。 从更新列表中提取文章信息由于 id 的变化部分是以 yyyy/mm/dd 开头的，所以我们可以放心地用 Sort-Object 直接进行字符串排序。这个 cmdlet 有个常用的别名，叫做 sort。 接下来用正则表达式提取 year、month、day、name 这几个元素。通过这些元素，我们就可以组织目标文件名： $feed | sort { $_.id } | foreach { $entry = $_ if ($entry.id -cmatch &apos;^/cs/blogs/tips/archive/(?&lt;year&gt;\\d{4})/(?&lt;month&gt;\\d{2})/(?&lt;day&gt;\\d{2})/(?&lt;name&gt;.+)\\.aspx$&apos;) { $year = $matches[&apos;year&apos;] $month = $matches[&apos;month&apos;] $day = $matches[&apos;day&apos;] $name = $matches[&apos;name&apos;] } $targetFile = Join-Path $folder &quot;$year-$month-$day-$name.md&quot; 跳过已有的文件由于 RSS 中返回的是最后 15 篇文章，也就是近 3 周来的文章列表，如果遇到已翻译过的文章，需要自动跳过： if (Test-Path $targetFile) { echo &quot;[文件已存在] $year-$month-$day-$name.md&quot; } else { 生成 markdown 文件模板方法每篇文章对应一个 markdown 文件。在文件的头部，有一段用 yaml 描述的元数据，也就是用两条 --- 分隔的部分： function Get-Post ($enty) { $postTemplate = @&apos; layout: post title: &quot;PowerShell 技能连载 - ___&quot; description: &quot;PowerTip of the Day - {0}&quot; categories: [powershell, tip] tags: [powershell, tip, powertip, series, translation] {1} &lt;!--more--&gt; 本文国际来源：[{2}]({3}) &apos;@ $entryUrl = &apos;http://powershell.com&apos; + $entry.link.href $htmlContent = $entry.content.&apos;#text&apos; $htmlDoc = Get-Document $htmlContent $htmlContent = $htmlDoc.documentElement.innerHTML $htmlDoc.Close() $markdown = Get-Markdown $htmlContent return $postTemplate -f $entry.title, $markdown, $entry.title, $entryUrl } 代码中的 $postTemplate 是一个用 here string 描述的文件模板，其中所有的变量都用 {x} 占位符来代替。而 title 部分的 ___ 是为中文名称预留的位置。由于程序无法自动填充中文名，所以这个位置需要在人工翻译阶段手动填充。 函数尾部的 $postTemplate -f $entry.title, $markdown, $entry.title, $entryUrl 是采用字符串的 -f 运算符进行格式化，将各个变量填充到 {x} 占位符处。-f 的本质是调用了 String 类的 Format() 静态方法。 解析 DOM 结构上述代码调用了一个 Get-Document 函数，将 $htmlContent 字符串转换为一个 DOM 对象。它的实现方法如下： function Get-Document($text) { $htmlDoc= New-Object -com &quot;HTMLFILE&quot; if ($htmlDoc.IHTMLDocument2_write) { $htmlDoc.IHTMLDocument2_write($text) } else { $htmlDoc.write($text) } return $htmlDoc } 这里采用了 HTMLFILE COM 对象的 IHTMLDocument2_write() 或 write() 方法，来返回一个 HtmlDocument 对象。因为我发现不同的机器上，存在不同的版本。很遗憾关于这块的 MSDN 文档不太好找，这是我自创的方式，有效果，不知有没有更好的方法实现。 拿到 HtmlDocument 以后，就可以进行 DOM 操作了。这里我们简单地获取 Document 对象的 innerHTML 属性，并且注意及时关闭 COM 对象以释放资源： $htmlContent = $htmlDoc.documentElement.innerHTML $htmlDoc.Close() 将 HTML 转换为 markdown编写 Node.js 程序在 PowerShell 和 .NET 的世界里，目前没有很理想的 HTML 转 markdown 库可用。不过 Node.js 中有一个不错的库 html2markdown。 由于 node.exe 传入太长的参数可能会有意想不到的问题，所以直接向 Node.js 程序传递 HTML 字符串不可靠。更可靠的方式是将 HTML 字符串保存到临时文件中，将临时文件的文件名传递给 Node.js 程序。 我们可以写一个 Node.js 的小程序，目的是让 PowerShell 以这种方式调用： node.exe index.js htmlFilePath markdownFilePath 其中 htmlFilePath 为输入的 HTML 文件路径，markdownFilePath 为输出的 markdown 文件路径。 接下来用 npm 快速创建一个 Node.js 工程（暂时也叫 html2markdown，虽然和库的名字相同，不过影响使用）： npm init html2markdown 对向导的提示一路回车即可。然后添加 html2markdown 库的引用： npm install html2markdown --save 生成好的 package.json 文件如下： { &quot;name&quot;: &quot;html2markdown&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;dependencies&quot;: { &quot;html2markdown&quot;: &quot;~1.1.0&quot; }, &quot;devDependencies&quot;: {}, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; } 接下来编写 index.js 脚本。这个脚本的原理是： 解析 node.exe 进程的参数，提取输入的 HTML 文件路径和输出的 markdown 文件路径 读入 HTML 文件内容 调用 html2markdown 将 HTML 转换为 markdown 写入 markdown 文件内容 index.js 脚本的内容如下： var html2markdown = require(&apos;html2markdown&apos;), fs = require(&apos;fs&apos;), args = process.argv.splice(2), htmlFile = args[0], markdownFile = args[1], html, markdown; html = fs.readFileSync(htmlFile, { encoding: &apos;utf8&apos; }); markdown = html2markdown(html, { inlineStyle: true }); fs.writeFileSync(markdownFile, markdown); 通过 PowerShell 调用 Node.js以下代码是生成 $htmlFile、$markdownFile 两个临时文件，然后通过 node .\\html2markdown\\index.js $htmlFile $markdownFile 调用 Node.js 程序。当 Node.js 程序执行完毕以后，通过 gc 命令从输出的临时文件中获取 markdown 内容字符串，然后删除所有临时文件。 代码的第一行用正则表达把 HTML 中的 Twitter 回访链接给清理掉： function Get-Markdown ($html) { $html = $html -creplace &apos;(?sm)^&lt;P&gt;&lt;A href=&quot;http://twitter\\.com/home/\\?status=.*$&apos;, &apos;&apos; $htmlFile = [System.IO.Path]::GetTempFileName() $markdownFile = [System.IO.Path]::GetTempFileName() sc $htmlFile $html node .\\html2markdown\\index.js $htmlFile $markdownFile $markdown = gc -Raw $markdownFile del $htmlFile del $markdownFile $markdown = $markdown.Trim() return $markdown } 到此为止，markdown 形式的文章内容已经生成好了。 下载文章中的图片到目前为止，文章中的图片都可以正常显示，不过它们都是位于 www.powershell.com 服务器上。从翻译的角度来说，图片最好保存一份到自己的服务器上，图片跟着文章走。这样就不会因为源网站服务器宕机或其它原因导致译文中的图片出问题。 markdown 中的图片是这样表示的： ![description](http://www.xxx.com/yyy.png) 我们假设文章的文件名是 aaa.md，那么需要做的事情是把 http://www.xxx.com/yyy.png 下载下来，保存在网站的 ..\\assets\\post_img 目录下，并且按 aaa-001.png、aaa-002.png 这样的方式重命名。这样就能很清楚地体现哪个图片是属于哪篇文章。 分析文章中的图片代码中采用这个正则表达式来提取图片的描述和 URL： [regex] &apos;!\\[(?&lt;desc&gt;.*?)\\]\\((?&lt;url&gt;.*?)\\)&apos; 这句代码是用来生成新的图片文件名： $targetPath = &quot;$fileBaseName-{0:d3}$extension&quot; -f $index++ 我们可以用一个泛型的哈希表（字典）来保存源路径和替换后的目标路径： [System.Collections.Generic.Dictionary[[string],[string]]] $dict = New-Object &apos;System.Collections.Generic.Dictionary[[string], [string]]&apos; 它等效于 C# 中的这行代码： var dict = new Dictionary&lt;string, string&gt;(); 这里的 PowerShell 代码就显得不如 C# 直观了。 以下是实现代码： function Get-Picture($file) { $index = 1 $fileBaseName = ([System.IO.FileInfo]$file).BaseName [System.Collections.Generic.Dictionary[[string],[string]]] $dict = New-Object &apos;System.Collections.Generic.Dictionary[[string], [string]]&apos; cat $file -Encoding UTF8 -Raw | % { $regex = [regex] &apos;!\\[(?&lt;desc&gt;.*?)\\]\\((?&lt;url&gt;.*?)\\)&apos; $matches = $regex.Matches($_) if ($matches.Count) { $matches.ForEach({ $fullMatch = $_.Value $desc = $_.Groups[&apos;desc&apos;].Value $url = $_.Groups[&apos;url&apos;].Value if ($url -like &apos;http*&apos;) { $extension = [System.IO.Path]::GetExtension($url) $targetPath = &quot;$fileBaseName-{0:d3}$extension&quot; -f $index++ $result = Download-Picture $url $targetPath if ($result) { $dict.Add($url, $targetPath) } } }) } } $newContent = cat $file -Encoding UTF8 -Raw | % { $line = $_ $dict.Keys | % { $url = $_ $newPath = $relateUrl + $dict[$url] $line = [string]$line.Replace($url, $newPath) } $line } $bytes = [System.Text.Encoding]::UTF8.GetBytes($newContent) sc $file $bytes -Encoding Byte #[IO.File]::WriteAllText($file, $newContent, [System.Text.Encoding]::UTF8) } 这里为什么用字典来保存源地址和目标地址呢？主要是因为我们不仅需要把每个匹配成功的结果替换成新的文本，还需要针对每个结果执行一段自定义的代码。利用字典先把匹配的结果保存起来，然后遍历字典项，对它们进行进一步的处理。 实际上有个更简单的办法。C# 中 Regex 对象的 Replace() 方法支持 lambda 表达式，对应的 PowerShell 方法支持用代码块的方式。MSDN 链接为 Regex.Replace 方法 (String, MatchEvaluator)。可以一边匹配一边做处理。 只是由于我先写出了文中的版本，所以没有去改进。 下载文章中的图片Invoke-WebRequest 可以方便地下载 HTTP 文件，这和 Linux 系统中的 wget 命令十分相似。实际上，Invoke-WebRequest 命令有个别名，就叫做 wget。下载图片的代码如下： function Download-Picture($url, $fileName) { echo &quot;downloading $url to $fileName&quot; $fullPath = Join-Path $downloadPath $fileName Invoke-WebRequest -Uri $url -OutFile $fullPath return $? } 综述到此为止，我已完整地介绍了《PowerShell 技能连载》翻译工作中采用脚本进行自动化的全部原理。相应的代码可以在 这里 找到。 读者也许会觉得为这些小小的功能用手工操作也可以完成。不过，简单计算一下就能够体现出产生的红利。目前已翻译了 200 多篇文章，按照每篇文章节约 3 分钟计算，自动化操作总共为我节约了 600 分钟，也就是节约了 10 个小时的机械劳动。用这宝贵的一个多工作日来开发脚本、撰写心得，做些动脑筋的事情，不亦是一种提升么？","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"regex","slug":"regex","permalink":"http://blog.vichamp.com/tags/regex/"},{"name":"node.js","slug":"node-js","permalink":"http://blog.vichamp.com/tags/node-js/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 使用配置脚本","slug":"using-profile-scripts","date":"2014-06-12T16:00:00.000Z","updated":"2017-03-17T15:26:23.721Z","comments":true,"path":"2014/06/13/using-profile-scripts/","link":"","permalink":"http://blog.vichamp.com/2014/06/13/using-profile-scripts/","excerpt":"您可能知道 PowerShell 支持配置脚本。只需要确保 $profile 所指定的文件存在即可。它是一个普通的脚本，每当 PowerShell 宿主启动的时候都会执行。 所以可以很方便地配置 PowerShell 环境、加载模块、增加 snap-in，以及做其它调整。这段代码将缩短您的 PowerShell 提示符，并且在标题栏显示当前路径： function prompt { &apos;PS&gt; &apos; $host.UI.RawUI.WindowTitle = Get-Location } 请注意 $profile 指定的配置脚本是和宿主有关的。每个宿主有独立的配置脚本（包括 PowerShell 控制台、ISE 编辑器以及所有的 PowerShell 宿主）。 要在所有宿主中自动执行代码，请使用这个文件： $profile.CurrentUserAllHosts 它们的路径基本上相同，除了后者文件名不含宿主名，而只是叫做“profile.ps1”。","text":"您可能知道 PowerShell 支持配置脚本。只需要确保 $profile 所指定的文件存在即可。它是一个普通的脚本，每当 PowerShell 宿主启动的时候都会执行。 所以可以很方便地配置 PowerShell 环境、加载模块、增加 snap-in，以及做其它调整。这段代码将缩短您的 PowerShell 提示符，并且在标题栏显示当前路径： function prompt { &apos;PS&gt; &apos; $host.UI.RawUI.WindowTitle = Get-Location } 请注意 $profile 指定的配置脚本是和宿主有关的。每个宿主有独立的配置脚本（包括 PowerShell 控制台、ISE 编辑器以及所有的 PowerShell 宿主）。 要在所有宿主中自动执行代码，请使用这个文件： $profile.CurrentUserAllHosts 它们的路径基本上相同，除了后者文件名不含宿主名，而只是叫做“profile.ps1”。 本文国际来源：Using Profile Scripts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 留意副作用","slug":"be-aware-of-side-effects","date":"2014-06-11T16:00:00.000Z","updated":"2017-03-17T15:26:23.721Z","comments":true,"path":"2014/06/12/be-aware-of-side-effects/","link":"","permalink":"http://blog.vichamp.com/2014/06/12/be-aware-of-side-effects/","excerpt":"PowerShell 可以使用许多底层的系统函数。例如这个，可以创建一个临时文件名： [System.IO.Path]::GetTempFileName() 然而，它不仅只做这一件事。它还真实地创建了那个文件。所以如果您使用这个函数来创建临时文件名，您可能最终会在文件系统中创建一堆孤立的文件。请在您的确需要创建一个临时文件的时候才使用它。","text":"PowerShell 可以使用许多底层的系统函数。例如这个，可以创建一个临时文件名： [System.IO.Path]::GetTempFileName() 然而，它不仅只做这一件事。它还真实地创建了那个文件。所以如果您使用这个函数来创建临时文件名，您可能最终会在文件系统中创建一堆孤立的文件。请在您的确需要创建一个临时文件的时候才使用它。 本文国际来源：Be Aware of Side Effects","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 批量重命名文件","slug":"bulk-file-renaming","date":"2014-06-10T16:00:00.000Z","updated":"2017-03-17T15:26:23.721Z","comments":true,"path":"2014/06/11/bulk-file-renaming/","link":"","permalink":"http://blog.vichamp.com/2014/06/11/bulk-file-renaming/","excerpt":"假设在一个文件夹中有一大堆脚本（或照片、日志等任意文件），并且您想要重命名所有的文件。比如新文件名的格式为固定前缀 + 自增的编号。 以下是实现方法。 这个例子将重命名指定文件夹中所有扩展名为 .ps1 的 PowerShell 脚本。新文件名为 powershellscriptX.ps1，其中“X”为自增的数字。 请注意脚本禁止了真正的重命名操作。如果要真正地重命名文件，请移除 -WhatIf 参数，但必须非常小心！如果您敲错一个变量或使用了错误的文件夹路径，那么您的脚本将会十分开心地重命名成千上万个错误的文件。 $Path = &apos;c:\\temp&apos; $Filter = &apos;*.ps1&apos; $Prefix = &apos;powershellscript&apos; $Counter = 1 Get-ChildItem -Path $Path -Filter $Filter -Recurse | Rename-Item -NewName { $extension = [System.IO.Path]::GetExtension($_.Name) &apos;{0}{1}.{2}&apos; -f $Prefix, $script:Counter, $extension $script:Counter++ } -WhatIf","text":"假设在一个文件夹中有一大堆脚本（或照片、日志等任意文件），并且您想要重命名所有的文件。比如新文件名的格式为固定前缀 + 自增的编号。 以下是实现方法。 这个例子将重命名指定文件夹中所有扩展名为 .ps1 的 PowerShell 脚本。新文件名为 powershellscriptX.ps1，其中“X”为自增的数字。 请注意脚本禁止了真正的重命名操作。如果要真正地重命名文件，请移除 -WhatIf 参数，但必须非常小心！如果您敲错一个变量或使用了错误的文件夹路径，那么您的脚本将会十分开心地重命名成千上万个错误的文件。 $Path = &apos;c:\\temp&apos; $Filter = &apos;*.ps1&apos; $Prefix = &apos;powershellscript&apos; $Counter = 1 Get-ChildItem -Path $Path -Filter $Filter -Recurse | Rename-Item -NewName { $extension = [System.IO.Path]::GetExtension($_.Name) &apos;{0}{1}.{2}&apos; -f $Prefix, $script:Counter, $extension $script:Counter++ } -WhatIf 本文国际来源：Bulk File Renaming","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从照片中读取拍摄日期","slug":"getting-datetaken-info-from-pictures","date":"2014-06-09T16:00:00.000Z","updated":"2017-03-17T15:26:23.706Z","comments":true,"path":"2014/06/10/getting-datetaken-info-from-pictures/","link":"","permalink":"http://blog.vichamp.com/2014/06/10/getting-datetaken-info-from-pictures/","excerpt":"如果您想重新整理您的照片库，以下这段代码能帮您从照片文件中读取拍摄日期信息。 这个例子使用了一个系统函数来查找“我的照片”的路径，然后递归搜索它的子文件夹。输出的结果通过管道传递给 Get-DataTaken，该函数返回照片的文件名、文件夹名，以及照片的拍摄时间。 function Get-DateTaken { param ( [Parameter(ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)] [Alias(&apos;FullName&apos;)] [String] $Path ) begin { $shell = New-Object -COMObject Shell.Application } process { $returnvalue = 1 | Select-Object -Property Name, DateTaken, Folder $returnvalue.Name = Split-Path $path -Leaf $returnvalue.Folder = Split-Path $path $shellfolder = $shell.Namespace($returnvalue.Folder) $shellfile = $shellfolder.ParseName($returnvalue.Name) $returnvalue.DateTaken = $shellfolder.GetDetailsOf($shellfile, 12) $returnvalue } } $picturePath = [System.Environment]::GetFolderPath(&apos;MyPictures&apos;) Get-ChildItem -Path $picturePath -Recurse -ErrorAction SilentlyContinue | Get-DateTaken","text":"如果您想重新整理您的照片库，以下这段代码能帮您从照片文件中读取拍摄日期信息。 这个例子使用了一个系统函数来查找“我的照片”的路径，然后递归搜索它的子文件夹。输出的结果通过管道传递给 Get-DataTaken，该函数返回照片的文件名、文件夹名，以及照片的拍摄时间。 function Get-DateTaken { param ( [Parameter(ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)] [Alias(&apos;FullName&apos;)] [String] $Path ) begin { $shell = New-Object -COMObject Shell.Application } process { $returnvalue = 1 | Select-Object -Property Name, DateTaken, Folder $returnvalue.Name = Split-Path $path -Leaf $returnvalue.Folder = Split-Path $path $shellfolder = $shell.Namespace($returnvalue.Folder) $shellfile = $shellfolder.ParseName($returnvalue.Name) $returnvalue.DateTaken = $shellfolder.GetDetailsOf($shellfile, 12) $returnvalue } } $picturePath = [System.Environment]::GetFolderPath(&apos;MyPictures&apos;) Get-ChildItem -Path $picturePath -Recurse -ErrorAction SilentlyContinue | Get-DateTaken 本文国际来源：Getting DateTaken Info from Pictures","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 远程读取已安装的软件","slug":"reading-installed-software-remotely","date":"2014-06-08T16:00:00.000Z","updated":"2017-03-17T15:26:23.706Z","comments":true,"path":"2014/06/09/reading-installed-software-remotely/","link":"","permalink":"http://blog.vichamp.com/2014/06/09/reading-installed-software-remotely/","excerpt":"大多数软件都会在注册表中登记自己。以下是一段从能从本地和远程的 32 位及 64 位注册表中读取已安装的软件列表的代码。它还是一个演示如何读取远程注册表的不错的例子。 # NOTE: RemoteRegistry Service needs to run on a target system! $Hive = &apos;LocalMachine&apos; # you can specify as many keys as you want as long as they are all in the same hive $Key = &apos;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall&apos;, &apos;SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall&apos; # you can specify as many value names as you want $Value = &apos;DisplayName&apos;, &apos;DisplayVersion&apos;, &apos;UninstallString&apos; # you can specify a remote computer name as long as the RemoteRegistry service runs on the target machine, # you have admin permissions on the target, and the firewall does not block you. Default is the local machine: $ComputerName = $env:COMPUTERNAME # add the value &quot;RegPath&quot; which will contain the actual Registry path the value came from (since you can specify more than one key) $Value = @($Value) + &apos;RegPath&apos; # now for each regkey you specified... $Key | ForEach-Object { # ...open the hive on the appropriate machine $RegHive = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($Hive, $ComputerName) # ...open the key in that hive... $RegKey = $RegHive.OpenSubKey($_) # ...find names of all subkeys... $RegKey.GetSubKeyNames() | ForEach-Object { # ...open subkeys... $SubKey = $RegKey.OpenSubKey($_) # ...and read all the requested values from each subkey # ...to store them, use Select-Object to create a simple new object $returnValue = 1 | Select-Object -Property $Value $Value | ForEach-Object { $returnValue.$_ = $subkey.GetValue($_) } # ...add the current regkey path name $returnValue.RegPath = $SubKey.Name # return the values: $returnValue # close the subkey $SubKey.Close() } # close the regkey $RegKey.Close() # close the hive $RegHive.Close() } | Out-GridView","text":"大多数软件都会在注册表中登记自己。以下是一段从能从本地和远程的 32 位及 64 位注册表中读取已安装的软件列表的代码。它还是一个演示如何读取远程注册表的不错的例子。 # NOTE: RemoteRegistry Service needs to run on a target system! $Hive = &apos;LocalMachine&apos; # you can specify as many keys as you want as long as they are all in the same hive $Key = &apos;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall&apos;, &apos;SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall&apos; # you can specify as many value names as you want $Value = &apos;DisplayName&apos;, &apos;DisplayVersion&apos;, &apos;UninstallString&apos; # you can specify a remote computer name as long as the RemoteRegistry service runs on the target machine, # you have admin permissions on the target, and the firewall does not block you. Default is the local machine: $ComputerName = $env:COMPUTERNAME # add the value &quot;RegPath&quot; which will contain the actual Registry path the value came from (since you can specify more than one key) $Value = @($Value) + &apos;RegPath&apos; # now for each regkey you specified... $Key | ForEach-Object { # ...open the hive on the appropriate machine $RegHive = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($Hive, $ComputerName) # ...open the key in that hive... $RegKey = $RegHive.OpenSubKey($_) # ...find names of all subkeys... $RegKey.GetSubKeyNames() | ForEach-Object { # ...open subkeys... $SubKey = $RegKey.OpenSubKey($_) # ...and read all the requested values from each subkey # ...to store them, use Select-Object to create a simple new object $returnValue = 1 | Select-Object -Property $Value $Value | ForEach-Object { $returnValue.$_ = $subkey.GetValue($_) } # ...add the current regkey path name $returnValue.RegPath = $SubKey.Name # return the values: $returnValue # close the subkey $SubKey.Close() } # close the regkey $RegKey.Close() # close the hive $RegHive.Close() } | Out-GridView 本文国际来源：Reading Installed Software Remotely","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 远程执行 gpupdate","slug":"gpupdate-on-remote-machines","date":"2014-06-05T16:00:00.000Z","updated":"2017-03-17T15:26:23.706Z","comments":true,"path":"2014/06/06/gpupdate-on-remote-machines/","link":"","permalink":"http://blog.vichamp.com/2014/06/06/gpupdate-on-remote-machines/","excerpt":"您可以用这样的一段脚本远程执行 gpupdate.exe： function Start-GPUpdate { param ( [String[]] $ComputerName ) $code = { $rv = 1 | Select-Object -Property ComputerName, ExitCode $null = gpupdate.exe /force $rv.Exitcode = $LASTEXITCODE $rv.ComputerName = $env:COMPUTERNAME $rv } Invoke-Command -ScriptBlock $code -ComputerName $ComputerName | Select-Object -Property ComputerName, ExitCode } Start-GPUpdate 接受一个或多个计算机名，然后对每台计算机运行 gpupdate.exe，并返回执行结果。 这段脚本利用了 PowerShell 远程管理技术，所以它需要目标计算机启用了 PowerShell 远程管理，并且您需要这些机器的本地管理员权限。","text":"您可以用这样的一段脚本远程执行 gpupdate.exe： function Start-GPUpdate { param ( [String[]] $ComputerName ) $code = { $rv = 1 | Select-Object -Property ComputerName, ExitCode $null = gpupdate.exe /force $rv.Exitcode = $LASTEXITCODE $rv.ComputerName = $env:COMPUTERNAME $rv } Invoke-Command -ScriptBlock $code -ComputerName $ComputerName | Select-Object -Property ComputerName, ExitCode } Start-GPUpdate 接受一个或多个计算机名，然后对每台计算机运行 gpupdate.exe，并返回执行结果。 这段脚本利用了 PowerShell 远程管理技术，所以它需要目标计算机启用了 PowerShell 远程管理，并且您需要这些机器的本地管理员权限。 本文国际来源：gpupdate on Remote Machines","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取数据库连接字符串","slug":"getting-database-connection-string","date":"2014-06-04T16:00:00.000Z","updated":"2017-03-17T15:26:23.690Z","comments":true,"path":"2014/06/05/getting-database-connection-string/","link":"","permalink":"http://blog.vichamp.com/2014/06/05/getting-database-connection-string/","excerpt":"您是否疑惑过一个数据库的连接字符串到底长什么样？当您从控制面板中创建一个数据源时，一个向导将指引您完成整个创建过程。以下是一个利用这个向导并获取生成的连接字符串的方法。 请注意该向导的选择要依赖于您机器上所安装的数据库驱动。 function Get-ConnectionString { $Path = Join-Path -Path $env:TEMP -ChildPath &apos;dummy.udl&apos; $null = New-Item -Path $Path -ItemType File -Force $CommandArg = &quot;&quot;&quot;$env:CommonProgramFiles\\System\\OLE DB\\oledb32.dll&quot;&quot;,OpenDSLFile &quot; + $Path Start-Process -FilePath Rundll32.exe -Argument $CommandArg -Wait $ConnectionString = Get-Content -Path $Path | Select-Object -Last 1 $ConnectionString | clip.exe Write-Warning &apos;Connection String is also available from clipboard&apos; $ConnectionString } 当您调用 Get-ConnectionString 方法时，将会创建一个临时的 udl 文件，并且用控制面板向导打开它。您可以通过向导完成配置。配置完成之后，PowerShell 将会检测临时文件并且返回连接字符串。 它的工作原理是 Get-Process 函数带了 -Wait 参数，它能够挂起脚本的执行，直到向导退出。在向导退出以后，脚本就可以安全地访问 udl 文件了。","text":"您是否疑惑过一个数据库的连接字符串到底长什么样？当您从控制面板中创建一个数据源时，一个向导将指引您完成整个创建过程。以下是一个利用这个向导并获取生成的连接字符串的方法。 请注意该向导的选择要依赖于您机器上所安装的数据库驱动。 function Get-ConnectionString { $Path = Join-Path -Path $env:TEMP -ChildPath &apos;dummy.udl&apos; $null = New-Item -Path $Path -ItemType File -Force $CommandArg = &quot;&quot;&quot;$env:CommonProgramFiles\\System\\OLE DB\\oledb32.dll&quot;&quot;,OpenDSLFile &quot; + $Path Start-Process -FilePath Rundll32.exe -Argument $CommandArg -Wait $ConnectionString = Get-Content -Path $Path | Select-Object -Last 1 $ConnectionString | clip.exe Write-Warning &apos;Connection String is also available from clipboard&apos; $ConnectionString } 当您调用 Get-ConnectionString 方法时，将会创建一个临时的 udl 文件，并且用控制面板向导打开它。您可以通过向导完成配置。配置完成之后，PowerShell 将会检测临时文件并且返回连接字符串。 它的工作原理是 Get-Process 函数带了 -Wait 参数，它能够挂起脚本的执行，直到向导退出。在向导退出以后，脚本就可以安全地访问 udl 文件了。 本文国际来源：Getting Database Connection String","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 Splatting 技术封装 WMI 调用","slug":"use-splatting-to-encapsulate-wmi-calls","date":"2014-06-03T16:00:00.000Z","updated":"2017-03-17T15:26:23.690Z","comments":true,"path":"2014/06/04/use-splatting-to-encapsulate-wmi-calls/","link":"","permalink":"http://blog.vichamp.com/2014/06/04/use-splatting-to-encapsulate-wmi-calls/","excerpt":"Splatting 是向 cmdlet 传递多个参数的好方法。以下例子演示了如何封装 WMI 调用，并且使它们支持不同的名称： function Get-BIOSInfo { param ( $ComputerName, $Credential, $SomethingElse ) $null = $PSBoundParameters.Remove(&apos;SomethingElse&apos;) Get-WmiObject -Class Win32_BIOS @PSBoundParameters } Get-BIOSInfo 通过 WMI 获取 BIOS 信息，并且它支持本地、远程以及通过证书的远程调用。这是因为用户向 Get-BIOSInfo 传递的实参实际上传递给了 Get-WmiObject 对应的参数。所以当一个用户没有传递 -Credential 参数，那么就不会向 Get-WmiObject 传递 -Credential 参数。 Splatting 技术通常使用一个自定义的哈希表，它的每个键代表一个形参，每个值代表一个实参。在这个例子中，使用了一个预定义的 $PSBoundParameters 哈希表。它事先插入了要传递给函数的参数。 请确保不要传给目标 cmdlet 它不知道的参数。举个例子，Get-BIOSInfo 函数定义了一个“SomethingElse”参数。而 Get-WmiObject 没有这个参数，所以您在 splat 之前，您必须先调用 Remove() 方法从哈希表中把这个键移掉。","text":"Splatting 是向 cmdlet 传递多个参数的好方法。以下例子演示了如何封装 WMI 调用，并且使它们支持不同的名称： function Get-BIOSInfo { param ( $ComputerName, $Credential, $SomethingElse ) $null = $PSBoundParameters.Remove(&apos;SomethingElse&apos;) Get-WmiObject -Class Win32_BIOS @PSBoundParameters } Get-BIOSInfo 通过 WMI 获取 BIOS 信息，并且它支持本地、远程以及通过证书的远程调用。这是因为用户向 Get-BIOSInfo 传递的实参实际上传递给了 Get-WmiObject 对应的参数。所以当一个用户没有传递 -Credential 参数，那么就不会向 Get-WmiObject 传递 -Credential 参数。 Splatting 技术通常使用一个自定义的哈希表，它的每个键代表一个形参，每个值代表一个实参。在这个例子中，使用了一个预定义的 $PSBoundParameters 哈希表。它事先插入了要传递给函数的参数。 请确保不要传给目标 cmdlet 它不知道的参数。举个例子，Get-BIOSInfo 函数定义了一个“SomethingElse”参数。而 Get-WmiObject 没有这个参数，所以您在 splat 之前，您必须先调用 Remove() 方法从哈希表中把这个键移掉。 本文国际来源：Use Splatting to Encapsulate WMI Calls","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 Splatting 技术提交参数","slug":"submitting-parameters-through-splatting","date":"2014-06-02T16:00:00.000Z","updated":"2017-03-17T15:26:23.675Z","comments":true,"path":"2014/06/03/submitting-parameters-through-splatting/","link":"","permalink":"http://blog.vichamp.com/2014/06/03/submitting-parameters-through-splatting/","excerpt":"Splatting 是 PowerShell 3.0 引入的概念，但是许多用户还没有听说这个概念。这是一种以可编程的方式将参数传给 cmdlet 的技术。请看： $infos = @{} $infos.Path = &apos;c:\\Windows&apos; $infos.Recurse = $true $infos.Filter = &apos;*.log&apos; $infos.ErrorAction = &apos;SilentlyContinue&apos; $infos.Remove(&apos;Recurse&apos;) dir @infos 这个例子定义了一个包含键值对的哈希表。每个键对应 dir 命令中的一个参数，并且每个值作为实参传递给对应的形参。 当您的代码需要决定哪些参数需要传给 cmdlet 时，Splatting 十分有用。您的代码可以只需要维护一个哈希表，然后选择性地将它传给 cmdlet。","text":"Splatting 是 PowerShell 3.0 引入的概念，但是许多用户还没有听说这个概念。这是一种以可编程的方式将参数传给 cmdlet 的技术。请看： $infos = @{} $infos.Path = &apos;c:\\Windows&apos; $infos.Recurse = $true $infos.Filter = &apos;*.log&apos; $infos.ErrorAction = &apos;SilentlyContinue&apos; $infos.Remove(&apos;Recurse&apos;) dir @infos 这个例子定义了一个包含键值对的哈希表。每个键对应 dir 命令中的一个参数，并且每个值作为实参传递给对应的形参。 当您的代码需要决定哪些参数需要传给 cmdlet 时，Splatting 十分有用。您的代码可以只需要维护一个哈希表，然后选择性地将它传给 cmdlet。 本文国际来源：Submitting Parameters through Splatting","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 快速获取成员身份","slug":"getting-group-membership-fast","date":"2014-06-01T16:00:00.000Z","updated":"2017-03-17T15:26:23.675Z","comments":true,"path":"2014/06/02/getting-group-membership-fast/","link":"","permalink":"http://blog.vichamp.com/2014/06/02/getting-group-membership-fast/","excerpt":"如果您需要了解您的用户账户所在的 Active Directory 组，通常需要查询 Active Directory，并且还需要查找嵌套的组成员身份。 以下是一种快速获取您所在的组（包括嵌套的以及本地组）成员身份的方法。这段脚本查看您的存取令牌（它管理了您的各种权限）然后从您的令牌中读取所有 SID 并将 SID 转换为真实名称。 请注意您只能对当前用户使用这种技术。它很适合用作登录脚本，用来做一些基于组成员身份的操作。 [System.Security.Principal.WindowsIdentity]::GetCurrent().Groups.Value | ForEach-Object { $sid = $_ $objSID = New-Object System.Security.Principal.SecurityIdentifier($sid) $objUser = $objSID.Translate( [System.Security.Principal.NTAccount]) $objUser.Value }","text":"如果您需要了解您的用户账户所在的 Active Directory 组，通常需要查询 Active Directory，并且还需要查找嵌套的组成员身份。 以下是一种快速获取您所在的组（包括嵌套的以及本地组）成员身份的方法。这段脚本查看您的存取令牌（它管理了您的各种权限）然后从您的令牌中读取所有 SID 并将 SID 转换为真实名称。 请注意您只能对当前用户使用这种技术。它很适合用作登录脚本，用来做一些基于组成员身份的操作。 [System.Security.Principal.WindowsIdentity]::GetCurrent().Groups.Value | ForEach-Object { $sid = $_ $objSID = New-Object System.Security.Principal.SecurityIdentifier($sid) $objUser = $objSID.Translate( [System.Security.Principal.NTAccount]) $objUser.Value } 本文国际来源：Getting Group Membership - Fast","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 设置注册表权限","slug":"setting-registry-permissions","date":"2014-05-29T16:00:00.000Z","updated":"2017-03-17T15:26:23.672Z","comments":true,"path":"2014/05/30/setting-registry-permissions/","link":"","permalink":"http://blog.vichamp.com/2014/05/30/setting-registry-permissions/","excerpt":"设置注册表项的权限并不是一件小事。不过通过一些技巧，并不是一件大事。 首先，运行 REGEDIT 并创建一个测试项。然后，右击该项并且使用图形界面设置您想要的权限。 然后，运行这段脚本（请将 -Path 值设为您刚才定义的注册表项）： $path = &apos;HKCU:\\software\\prototype&apos; $sd = Get-Acl -Path $Path $sd.Sddl | clip 这段代码将从您的注册表项中读取安全信息并将它复制到剪贴板中。 接下来，使用这段脚本为新创建的或已有的注册表项应用相同的安全设置。只需要将这段脚本中的 SDDL 定义替换成您刚创建的值： # replace the content of this variable with the SDDL you just created $sddl = &apos;O:BAG:S-1-5-21-1908806615-3936657230-2684137421-1001D:PAI(A;CI;KR;;;BA)(A;CI;KA;;;S-1-5-21-1907506615-3936657230-2684137421-1001)&apos; $Path = &apos;HKCU:\\software\\newkey&apos; $null = New-Item -Path $Path -ErrorAction SilentlyContinue $sd = Get-Acl -Path $Path $sd.SetSecurityDescriptorSddlForm($sddl) Set-Acl -Path $Path -AclObject $sd 您可能需要以完整 Administrator 权限来运行这段脚本。如您所见，第一段脚本和您的测试注册表项只是用来生成 SDDL 文本。当您得到 SSDL 文本之后，您只需要将它粘贴入第二段脚本中。第二段脚本不再需要用到那个测试注册表项。","text":"设置注册表项的权限并不是一件小事。不过通过一些技巧，并不是一件大事。 首先，运行 REGEDIT 并创建一个测试项。然后，右击该项并且使用图形界面设置您想要的权限。 然后，运行这段脚本（请将 -Path 值设为您刚才定义的注册表项）： $path = &apos;HKCU:\\software\\prototype&apos; $sd = Get-Acl -Path $Path $sd.Sddl | clip 这段代码将从您的注册表项中读取安全信息并将它复制到剪贴板中。 接下来，使用这段脚本为新创建的或已有的注册表项应用相同的安全设置。只需要将这段脚本中的 SDDL 定义替换成您刚创建的值： # replace the content of this variable with the SDDL you just created $sddl = &apos;O:BAG:S-1-5-21-1908806615-3936657230-2684137421-1001D:PAI(A;CI;KR;;;BA)(A;CI;KA;;;S-1-5-21-1907506615-3936657230-2684137421-1001)&apos; $Path = &apos;HKCU:\\software\\newkey&apos; $null = New-Item -Path $Path -ErrorAction SilentlyContinue $sd = Get-Acl -Path $Path $sd.SetSecurityDescriptorSddlForm($sddl) Set-Acl -Path $Path -AclObject $sd 您可能需要以完整 Administrator 权限来运行这段脚本。如您所见，第一段脚本和您的测试注册表项只是用来生成 SDDL 文本。当您得到 SSDL 文本之后，您只需要将它粘贴入第二段脚本中。第二段脚本不再需要用到那个测试注册表项。 本文国际来源：Setting Registry Permissions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 阻止非管理员权限运行脚本","slug":"blocking-administrator-scripts","date":"2014-05-28T16:00:00.000Z","updated":"2017-03-17T15:26:23.652Z","comments":true,"path":"2014/05/29/blocking-administrator-scripts/","link":"","permalink":"http://blog.vichamp.com/2014/05/29/blocking-administrator-scripts/","excerpt":"如果您明确知道您的脚本需要管理员权限，那么您必须在脚本的头部加上这行代码： #requires -runasadministrator 这行代码确保脚本只能在调用者用后本地管理员权限的情况下运行。这行代码不仅会试图提升脚本权限，而且会确保脚本不会启动后运行一半失败。","text":"如果您明确知道您的脚本需要管理员权限，那么您必须在脚本的头部加上这行代码： #requires -runasadministrator 这行代码确保脚本只能在调用者用后本地管理员权限的情况下运行。这行代码不仅会试图提升脚本权限，而且会确保脚本不会启动后运行一半失败。 本文国际来源：Blocking Administrator Scripts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 移除选定的 NTFS 权限","slug":"removing-selected-ntfs-permissions","date":"2014-05-27T16:00:00.000Z","updated":"2017-03-17T15:26:23.652Z","comments":true,"path":"2014/05/28/removing-selected-ntfs-permissions/","link":"","permalink":"http://blog.vichamp.com/2014/05/28/removing-selected-ntfs-permissions/","excerpt":"您也许需要从 NTFS 权限中移除某些权限。我们假设您希望移除某个用户的所有权限，因为他已经离开了这个部门。 请注意：您当然可以针对每个用户组来维护 NTFS 权限，并且为每个用户设置权限通常不是个好主意。但是，常常需要针对单个用户设置权限，以下示例脚本不仅可以移除这些权限，并且通过一些小修改还能成为查找这些权限的审计工具。 以下是一个简单的示例脚本。通过设置 $Path 和 $Filter，脚本可以扫描 $Path 文件夹以及它的所有子文件夹中所有访问控制项和 $Filter 字符串相匹配的项目。它只会处理非继承的访问控制项。 输出结果中将被删除的访问控制项标记为红色；如果所有访问控制项和过滤器都不匹配，则显示绿色。如果脚本没有返回任何东西，那么表示您扫描的文件夹中没有直接的访问控制项。 $Path = &apos;C:\\somefolder $Filter = &apos;S-1-5-*&apos; Get-ChildItem -Path C:\\Obfuscated -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $acl = Get-Acl -Path $Path $found = $false foreach($acc in $acl.access ) { if ($acc.IsInherited -eq $false) { $value = $acc.IdentityReference.Value if($value -like $Filter) { Write-Host &quot;Remove $Value from $Path &quot; -ForegroundColor Red $null = $ACL.RemoveAccessRule($acc) $found = $true } else { Write-Host &quot;Skipped $Value from $Path &quot; -ForegroundColor Green } } } if ($found) { # uncomment this to actually remove ACEs # Set-Acl -Path $Path -AclObject $acl -ErrorAction Stop } }","text":"您也许需要从 NTFS 权限中移除某些权限。我们假设您希望移除某个用户的所有权限，因为他已经离开了这个部门。 请注意：您当然可以针对每个用户组来维护 NTFS 权限，并且为每个用户设置权限通常不是个好主意。但是，常常需要针对单个用户设置权限，以下示例脚本不仅可以移除这些权限，并且通过一些小修改还能成为查找这些权限的审计工具。 以下是一个简单的示例脚本。通过设置 $Path 和 $Filter，脚本可以扫描 $Path 文件夹以及它的所有子文件夹中所有访问控制项和 $Filter 字符串相匹配的项目。它只会处理非继承的访问控制项。 输出结果中将被删除的访问控制项标记为红色；如果所有访问控制项和过滤器都不匹配，则显示绿色。如果脚本没有返回任何东西，那么表示您扫描的文件夹中没有直接的访问控制项。 $Path = &apos;C:\\somefolder $Filter = &apos;S-1-5-*&apos; Get-ChildItem -Path C:\\Obfuscated -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $acl = Get-Acl -Path $Path $found = $false foreach($acc in $acl.access ) { if ($acc.IsInherited -eq $false) { $value = $acc.IdentityReference.Value if($value -like $Filter) { Write-Host &quot;Remove $Value from $Path &quot; -ForegroundColor Red $null = $ACL.RemoveAccessRule($acc) $found = $true } else { Write-Host &quot;Skipped $Value from $Path &quot; -ForegroundColor Green } } } if ($found) { # uncomment this to actually remove ACEs # Set-Acl -Path $Path -AclObject $acl -ErrorAction Stop } } 本文国际来源：Removing Selected NTFS Permissions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - PowerShell 上帝模式","slug":"powershell-god-mode","date":"2014-05-26T16:00:00.000Z","updated":"2017-03-17T15:26:23.637Z","comments":true,"path":"2014/05/27/powershell-god-mode/","link":"","permalink":"http://blog.vichamp.com/2014/05/27/powershell-god-mode/","excerpt":"若您要运行一个 PowerShell 脚本，您必须通过执行策略的允许。通常您需要使用这行代码来允许脚本运行： 然而，如果组策略禁止了脚本执行，那么这行代码将不起作用。在这种情况下，您可以使用这段代码来重新启用允许脚本执行（单个 PowerShell 会话中有效）： $context = $executioncontext.GetType().GetField(&apos;_context&apos;,&apos;nonpublic,instance&apos;).GetValue($executioncontext) $field = $context.GetType().GetField(&apos;_authorizationManager&apos;,&apos;nonpublic,instance&apos;) $field.SetValue($context,(New-Object Management.Automation.AuthorizationManager &apos;Microsoft.PowerShell&apos;)) 请注意这是一种取巧的办法，它重设了认证管理器，不能保证是否有副作用。使用后果自负。 顺便说一下，这种技术不算是一个安全问题。执行策略通常不是一个安全边界。它并不是设计成用来把坏人挡在外面的。它只是为了保护您自己不做错事。所以无论您是通过 cmdlet 还是通过这段代码来启用脚本执行，您都是对自己执行 PowerShell 代码负责。","text":"若您要运行一个 PowerShell 脚本，您必须通过执行策略的允许。通常您需要使用这行代码来允许脚本运行： 然而，如果组策略禁止了脚本执行，那么这行代码将不起作用。在这种情况下，您可以使用这段代码来重新启用允许脚本执行（单个 PowerShell 会话中有效）： $context = $executioncontext.GetType().GetField(&apos;_context&apos;,&apos;nonpublic,instance&apos;).GetValue($executioncontext) $field = $context.GetType().GetField(&apos;_authorizationManager&apos;,&apos;nonpublic,instance&apos;) $field.SetValue($context,(New-Object Management.Automation.AuthorizationManager &apos;Microsoft.PowerShell&apos;)) 请注意这是一种取巧的办法，它重设了认证管理器，不能保证是否有副作用。使用后果自负。 顺便说一下，这种技术不算是一个安全问题。执行策略通常不是一个安全边界。它并不是设计成用来把坏人挡在外面的。它只是为了保护您自己不做错事。所以无论您是通过 cmdlet 还是通过这段代码来启用脚本执行，您都是对自己执行 PowerShell 代码负责。 本文国际来源：PowerShell God Mode","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检查 Windows 更新","slug":"checking-windows-updates","date":"2014-05-25T16:00:00.000Z","updated":"2017-03-17T15:26:23.621Z","comments":true,"path":"2014/05/26/checking-windows-updates/","link":"","permalink":"http://blog.vichamp.com/2014/05/26/checking-windows-updates/","excerpt":"要检查 Windows 中安装的所有更新，有一个 COM 库可以帮您完成这个任务。但是这个库用起来不是很直观，而且也不支持远程。 所以我们设计了一个 PowerShell 函数，叫做 Get-WindowsUpdate。它默认情况下获取本地安装的更新，但是您也可以指定一个或多个远程计算机，并且获取它们的更新。 远程操作是借助 PowerShell 远程操作来实现的，所以只有远程计算机的 PowerShell 远程操作启用以后（例如，Windows Server 2012 默认启用 PowerShell 远程操作）才能使用，并且您需要远程计算机上的本地 Administrator 权限。 function Get-WindowsUpdate { [CmdletBinding()] param ( [String[]] $ComputerName, $Title = &apos;*&apos;, $Description = &apos;*&apos;, $Operation = &apos;*&apos; ) $code = { param ( $Title, $Description ) $Type = @{ name=&apos;Operation&apos; expression={ switch($_.operation) { 1 {&apos;Installed&apos;} 2 {&apos;Uninstalled&apos;} 3 {&apos;Other&apos;} } } } $Session = New-Object -ComObject &apos;Microsoft.Update.Session&apos; $Searcher = $Session.CreateUpdateSearcher() $historyCount = $Searcher.GetTotalHistoryCount() $Searcher.QueryHistory(0, $historyCount) | Select-Object Title, Description, Date, $Type | Where-Object { $_.Title -like $Title } | Where-Object { $_.Description -like $Description } | Where-Object { $_.Operation -like $Operation } } $null = $PSBoundParameters.Remove(&apos;Title&apos;) $null = $PSBoundParameters.Remove(&apos;Description&apos;) $null = $PSBoundParameters.Remove(&apos;Operation&apos;) Invoke-Command -ScriptBlock $code @PSBoundParameters -ArgumentList $Title, $Description } 这个函数也支持过滤器，所以要获得所有已安装的 Office 更新，您只需要这样做：","text":"要检查 Windows 中安装的所有更新，有一个 COM 库可以帮您完成这个任务。但是这个库用起来不是很直观，而且也不支持远程。 所以我们设计了一个 PowerShell 函数，叫做 Get-WindowsUpdate。它默认情况下获取本地安装的更新，但是您也可以指定一个或多个远程计算机，并且获取它们的更新。 远程操作是借助 PowerShell 远程操作来实现的，所以只有远程计算机的 PowerShell 远程操作启用以后（例如，Windows Server 2012 默认启用 PowerShell 远程操作）才能使用，并且您需要远程计算机上的本地 Administrator 权限。 function Get-WindowsUpdate { [CmdletBinding()] param ( [String[]] $ComputerName, $Title = &apos;*&apos;, $Description = &apos;*&apos;, $Operation = &apos;*&apos; ) $code = { param ( $Title, $Description ) $Type = @{ name=&apos;Operation&apos; expression={ switch($_.operation) { 1 {&apos;Installed&apos;} 2 {&apos;Uninstalled&apos;} 3 {&apos;Other&apos;} } } } $Session = New-Object -ComObject &apos;Microsoft.Update.Session&apos; $Searcher = $Session.CreateUpdateSearcher() $historyCount = $Searcher.GetTotalHistoryCount() $Searcher.QueryHistory(0, $historyCount) | Select-Object Title, Description, Date, $Type | Where-Object { $_.Title -like $Title } | Where-Object { $_.Description -like $Description } | Where-Object { $_.Operation -like $Operation } } $null = $PSBoundParameters.Remove(&apos;Title&apos;) $null = $PSBoundParameters.Remove(&apos;Description&apos;) $null = $PSBoundParameters.Remove(&apos;Operation&apos;) Invoke-Command -ScriptBlock $code @PSBoundParameters -ArgumentList $Title, $Description } 这个函数也支持过滤器，所以要获得所有已安装的 Office 更新，您只需要这样做： 本文国际来源：Checking Windows Updates","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取免费的速查表","slug":"getting-free-cheat-sheets","date":"2014-05-22T16:00:00.000Z","updated":"2017-03-17T15:26:23.621Z","comments":true,"path":"2014/05/23/getting-free-cheat-sheets/","link":"","permalink":"http://blog.vichamp.com/2014/05/23/getting-free-cheat-sheets/","excerpt":"有两个很棒的 PowerShell 速查表版本。一个是由 powershellmagazine.com 创建的一系列速查表。它刚刚升级，现在覆盖了 PowerShell 4.0 并包括了一个期望状态配置（DSC）的速查表。您可以从 Microsoft 下载它： http://www.microsoft.com/en-us/download/details.aspx?id=42554 另外一个是我们的每月技巧文摘，地址如下： http://powershell.com/cs/media/28/default.aspx","text":"有两个很棒的 PowerShell 速查表版本。一个是由 powershellmagazine.com 创建的一系列速查表。它刚刚升级，现在覆盖了 PowerShell 4.0 并包括了一个期望状态配置（DSC）的速查表。您可以从 Microsoft 下载它： http://www.microsoft.com/en-us/download/details.aspx?id=42554 另外一个是我们的每月技巧文摘，地址如下： http://powershell.com/cs/media/28/default.aspx 本文国际来源：Getting Free Cheat Sheets","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 开始学习 DSC","slug":"start-to-look-at-dsc","date":"2014-05-21T16:00:00.000Z","updated":"2017-03-17T15:26:23.621Z","comments":true,"path":"2014/05/22/start-to-look-at-dsc/","link":"","permalink":"http://blog.vichamp.com/2014/05/22/start-to-look-at-dsc/","excerpt":"期望状态配置（DSC）是 PowerShell 4.0 中的一个新特性。通过 DSC，您可以编写简单的配置脚本并且将它们应用到本地或远程的机器上。以下是一个供您入门的示例脚本： Configuration MyConfig { # Parameters are optional param ($MachineName) # A Configuration block can have one or more Node blocks Node $MachineName { Registry RegistryExample { Ensure = &apos;Present&apos; # You can also set Ensure to &quot;Absent&quot; Key = &apos;HKEY_LOCAL_MACHINE\\SOFTWARE\\ExampleKey&apos; ValueName =&apos;TestValue&apos; ValueData =&apos;TestData&apos; } } } MyConfig -MachineName $env:computername -OutputPath c:\\dsc Start-DscConfiguration -Path c:\\dsc -Wait 配置项“MyConfig”使用了“Registry”资源来确保指定的注册表项存在。您可以在 DSC 脚本中使用更多的资源，例如增加（或删除）本地用户或文件，解压一个 MSI 包或 ZIP 文件，或启动/停止一个服务等等。 运行该配置只会创建一个 MOF 文件。要应用该 MOF 文件，请使用 Start-DSCConfiguration cmdlet。请使用 -Wait 来等待配置生效。否则，该配置将会在后台以任务的方式完成。","text":"期望状态配置（DSC）是 PowerShell 4.0 中的一个新特性。通过 DSC，您可以编写简单的配置脚本并且将它们应用到本地或远程的机器上。以下是一个供您入门的示例脚本： Configuration MyConfig { # Parameters are optional param ($MachineName) # A Configuration block can have one or more Node blocks Node $MachineName { Registry RegistryExample { Ensure = &apos;Present&apos; # You can also set Ensure to &quot;Absent&quot; Key = &apos;HKEY_LOCAL_MACHINE\\SOFTWARE\\ExampleKey&apos; ValueName =&apos;TestValue&apos; ValueData =&apos;TestData&apos; } } } MyConfig -MachineName $env:computername -OutputPath c:\\dsc Start-DscConfiguration -Path c:\\dsc -Wait 配置项“MyConfig”使用了“Registry”资源来确保指定的注册表项存在。您可以在 DSC 脚本中使用更多的资源，例如增加（或删除）本地用户或文件，解压一个 MSI 包或 ZIP 文件，或启动/停止一个服务等等。 运行该配置只会创建一个 MOF 文件。要应用该 MOF 文件，请使用 Start-DSCConfiguration cmdlet。请使用 -Wait 来等待配置生效。否则，该配置将会在后台以任务的方式完成。 本文国际来源：Start to Look at DSC","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 编译二进制 Cmdlet","slug":"compiling-binary-cmdlets","date":"2014-05-20T16:00:00.000Z","updated":"2017-03-17T15:26:23.606Z","comments":true,"path":"2014/05/21/compiling-binary-cmdlets/","link":"","permalink":"http://blog.vichamp.com/2014/05/21/compiling-binary-cmdlets/","excerpt":"PowerShell 的函数可以模拟一个真实二进制 cmdlet 的所有特性，但是 PowerShell 函数是 PowerShell 明文的代码，每个人都可以看到它的内容。 如果您是一个开发者并且有兴趣创开发二进制 cmdlet，以下是一个快速的入门。该入门演示如何用纯 PowerShell 创建并编译真正的 cmdlet： # C# definition for cmdlet $code = @&apos; using System; using System.Collections.Generic; using System.Collections.ObjectModel; using System.Linq; using System.Text; using System.Management.Automation; namespace CustomCmdlet { [Cmdlet(&quot;Get&quot;, &quot;Magic&quot;, SupportsTransactions = false)] public class test : PSCmdlet { private int _Age; [Alias(new string[] { &quot;HowOld&quot;, &quot;YourAge&quot; }), Parameter(Position = 0,ValueFromPipeline = true)] public int Age { get { return _Age; } set { _Age = value; } } private string _Name; [Parameter(Position = 1)] public string Name { get { return _Name; } set { _Name = value; } } protected override void BeginProcessing() { this.WriteObject(&quot;Good morning...&quot;); base.BeginProcessing(); } protected override void ProcessRecord() { this.WriteObject(&quot;Your name is &quot; + Name + &quot; and your age is &quot; + Age); base.ProcessRecord(); } protected override void EndProcessing() { this.WriteObject(&quot;That&apos;s it for now.&quot;); base.EndProcessing(); } } } &apos;@ # compile C# code to DLL # use a timestamp to create unique file names # while testing, when a DLL was imported before, it is in use until PowerShell closes # so to do repeated tests, use different DLL file names $datetime = Get-Date -Format yyyyMMddHHmmssffff $DLLPath = &quot;$env:temp\\myCmdlet($datetime).dll&quot; Add-Type -TypeDefinition $code -OutputAssembly $DLLPath # import a module Import-Module -Name $DLLPath -Verbose 现在您可以可以使用新创建的 Get-Magic cmdlet。它包含了一个 cmdlet 能实现的所有特性，包括参数、参数别名，甚至支持管道： 请注意例子中主要的 PowerShell 代码只是为了创建并编译 DLL。当 DLL 已经存在时，您需要的只是这行代码（例如，在分发的产品中）： Import-Module -Name $DLLPath 要开发复杂的二进制 cmdlet，您可能更希望在 C# 开发环境，例如 Visual Studio 中工作。您所需的只是添加 PowerShell 程序集的引用。PowerShell 程序集的路径可以用这行代码方便地获取到： 它将会把 PowerShell 程序集的路径输出到您的剪贴板中。 请注意只是编译 C# 代码并不会为您的知识资产带来更多的保护，因为它可以被反编译。所以不要用这种方式来“保护”秘密的信息，比如说密码。通过二进制 cmdlet，您可以有机会使用专业的防拷贝软件以及混淆器。额外的保护层并没有纯 PowerShell 代码的版本。","text":"PowerShell 的函数可以模拟一个真实二进制 cmdlet 的所有特性，但是 PowerShell 函数是 PowerShell 明文的代码，每个人都可以看到它的内容。 如果您是一个开发者并且有兴趣创开发二进制 cmdlet，以下是一个快速的入门。该入门演示如何用纯 PowerShell 创建并编译真正的 cmdlet： # C# definition for cmdlet $code = @&apos; using System; using System.Collections.Generic; using System.Collections.ObjectModel; using System.Linq; using System.Text; using System.Management.Automation; namespace CustomCmdlet { [Cmdlet(&quot;Get&quot;, &quot;Magic&quot;, SupportsTransactions = false)] public class test : PSCmdlet { private int _Age; [Alias(new string[] { &quot;HowOld&quot;, &quot;YourAge&quot; }), Parameter(Position = 0,ValueFromPipeline = true)] public int Age { get { return _Age; } set { _Age = value; } } private string _Name; [Parameter(Position = 1)] public string Name { get { return _Name; } set { _Name = value; } } protected override void BeginProcessing() { this.WriteObject(&quot;Good morning...&quot;); base.BeginProcessing(); } protected override void ProcessRecord() { this.WriteObject(&quot;Your name is &quot; + Name + &quot; and your age is &quot; + Age); base.ProcessRecord(); } protected override void EndProcessing() { this.WriteObject(&quot;That&apos;s it for now.&quot;); base.EndProcessing(); } } } &apos;@ # compile C# code to DLL # use a timestamp to create unique file names # while testing, when a DLL was imported before, it is in use until PowerShell closes # so to do repeated tests, use different DLL file names $datetime = Get-Date -Format yyyyMMddHHmmssffff $DLLPath = &quot;$env:temp\\myCmdlet($datetime).dll&quot; Add-Type -TypeDefinition $code -OutputAssembly $DLLPath # import a module Import-Module -Name $DLLPath -Verbose 现在您可以可以使用新创建的 Get-Magic cmdlet。它包含了一个 cmdlet 能实现的所有特性，包括参数、参数别名，甚至支持管道： 请注意例子中主要的 PowerShell 代码只是为了创建并编译 DLL。当 DLL 已经存在时，您需要的只是这行代码（例如，在分发的产品中）： Import-Module -Name $DLLPath 要开发复杂的二进制 cmdlet，您可能更希望在 C# 开发环境，例如 Visual Studio 中工作。您所需的只是添加 PowerShell 程序集的引用。PowerShell 程序集的路径可以用这行代码方便地获取到： 它将会把 PowerShell 程序集的路径输出到您的剪贴板中。 请注意只是编译 C# 代码并不会为您的知识资产带来更多的保护，因为它可以被反编译。所以不要用这种方式来“保护”秘密的信息，比如说密码。通过二进制 cmdlet，您可以有机会使用专业的防拷贝软件以及混淆器。额外的保护层并没有纯 PowerShell 代码的版本。 本文国际来源：Compiling Binary Cmdlets","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 添加或重置 NTFS 权限","slug":"adding-and-resetting-ntfs-permissions","date":"2014-05-19T16:00:00.000Z","updated":"2017-03-17T15:26:23.606Z","comments":true,"path":"2014/05/20/adding-and-resetting-ntfs-permissions/","link":"","permalink":"http://blog.vichamp.com/2014/05/20/adding-and-resetting-ntfs-permissions/","excerpt":"当您需要为一个文件添加一个新的 NTFS 存取规则，或禁用继承并添加新的规则，以下是一个示例脚本，演示这个技巧并且为您提供一个模板。 这个脚本创建一个测试文件，然后以当前用户的身份定义一个新的存取规则。这个规则包含读取和写入权限。这个新规则被添加到已存在的安全描述符中。另外，将禁用继承。 # create a sample file to apply security rules to $Path = &quot;$env:temp\\examplefile.txt&quot; $null = New-Item -Path $Path -ItemType File -ErrorAction SilentlyContinue # use current user or replace with another user name $username = &quot;$env:USERDOMAIN\\$env:USERNAME&quot; # define the new access rights $colRights = [System.Security.AccessControl.FileSystemRights]&apos;Read, Write&apos; $InheritanceFlag = [System.Security.AccessControl.InheritanceFlags]::None $PropagationFlag = [System.Security.AccessControl.PropagationFlags]::None $objType =[System.Security.AccessControl.AccessControlType]::Allow $objUser = New-Object System.Security.Principal.NTAccount($username) # create new access control entry $objACE = New-Object System.Security.AccessControl.FileSystemAccessRule ` ($objUser, $colRights, $InheritanceFlag, $PropagationFlag, $objType) # get existing access control list for a file or folder $objACL = Get-Acl -Path $Path # add rule $objACL.AddAccessRule($objACE) # disable inheritance (if needed) $objACL.SetAccessRuleProtection($true, $false) # apply changed access control list to file Set-Acl -Path $Path -AclObject $objACL # show file in the File Explorer explorer.exe &quot;/SELECT,$Path&quot; 执行完成之后，该脚本在文件管理器中打开测试文件，并选中它。您可以右键单击该文件并选择 属性 &gt; 安全 来查看新的设置。 要查看有哪些存取权限可用，请在 ISE 编辑器中键入以下这行： 这将自动打开上下文菜单并列出所有可用的设置。","text":"当您需要为一个文件添加一个新的 NTFS 存取规则，或禁用继承并添加新的规则，以下是一个示例脚本，演示这个技巧并且为您提供一个模板。 这个脚本创建一个测试文件，然后以当前用户的身份定义一个新的存取规则。这个规则包含读取和写入权限。这个新规则被添加到已存在的安全描述符中。另外，将禁用继承。 # create a sample file to apply security rules to $Path = &quot;$env:temp\\examplefile.txt&quot; $null = New-Item -Path $Path -ItemType File -ErrorAction SilentlyContinue # use current user or replace with another user name $username = &quot;$env:USERDOMAIN\\$env:USERNAME&quot; # define the new access rights $colRights = [System.Security.AccessControl.FileSystemRights]&apos;Read, Write&apos; $InheritanceFlag = [System.Security.AccessControl.InheritanceFlags]::None $PropagationFlag = [System.Security.AccessControl.PropagationFlags]::None $objType =[System.Security.AccessControl.AccessControlType]::Allow $objUser = New-Object System.Security.Principal.NTAccount($username) # create new access control entry $objACE = New-Object System.Security.AccessControl.FileSystemAccessRule ` ($objUser, $colRights, $InheritanceFlag, $PropagationFlag, $objType) # get existing access control list for a file or folder $objACL = Get-Acl -Path $Path # add rule $objACL.AddAccessRule($objACE) # disable inheritance (if needed) $objACL.SetAccessRuleProtection($true, $false) # apply changed access control list to file Set-Acl -Path $Path -AclObject $objACL # show file in the File Explorer explorer.exe &quot;/SELECT,$Path&quot; 执行完成之后，该脚本在文件管理器中打开测试文件，并选中它。您可以右键单击该文件并选择 属性 &gt; 安全 来查看新的设置。 要查看有哪些存取权限可用，请在 ISE 编辑器中键入以下这行： 这将自动打开上下文菜单并列出所有可用的设置。 本文国际来源：Adding and Resetting NTFS Permissions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将文本数组转换为字符串","slug":"converting-text-arrays-to-string","date":"2014-05-18T16:00:00.000Z","updated":"2017-03-17T15:26:23.606Z","comments":true,"path":"2014/05/19/converting-text-arrays-to-string/","link":"","permalink":"http://blog.vichamp.com/2014/05/19/converting-text-arrays-to-string/","excerpt":"某些时候，文本文件中的文字内容需要由其它命令来读取和处理。通常，您需要用 Get-Content 命令来读取文本文件内容，然后将结果传递给其它命令。但这有可能会失败。 以下是注意点：请牢记 Get-Content 总是返回一个文本行的数组，而不是单个文本行。所以当使用一个接收字符串而不是接收一系列文本行（字符串数组）的命令时，您需要将这些文本行转换为文本。 从 PowerShell 3.0 开始，Get-Content 拥有一个新的开关变量 -Raw。它不仅提升了读取大量文本的速度，而且一次性返回原始文本文件的整个内容，而不是将其分割成文本行。 PS&gt; $info = Get-Content $env:windir\\windowsupdate.log PS&gt; $info -is [Array] True PS&gt; $info = Get-Content $env:windir\\windowsupdate.log -Raw PS&gt; $info -is [Array] False 如果您已经有文本数组并且希望将它们转换为一个单一的文本，请使用 Out-String： PS&gt; $info = &apos;One&apos;, &apos;Two&apos;, &apos;Three&apos; PS&gt; $info -is [Array] True PS&gt; $all = $info | Out-String PS&gt; $all -is [Array] False","text":"某些时候，文本文件中的文字内容需要由其它命令来读取和处理。通常，您需要用 Get-Content 命令来读取文本文件内容，然后将结果传递给其它命令。但这有可能会失败。 以下是注意点：请牢记 Get-Content 总是返回一个文本行的数组，而不是单个文本行。所以当使用一个接收字符串而不是接收一系列文本行（字符串数组）的命令时，您需要将这些文本行转换为文本。 从 PowerShell 3.0 开始，Get-Content 拥有一个新的开关变量 -Raw。它不仅提升了读取大量文本的速度，而且一次性返回原始文本文件的整个内容，而不是将其分割成文本行。 PS&gt; $info = Get-Content $env:windir\\windowsupdate.log PS&gt; $info -is [Array] True PS&gt; $info = Get-Content $env:windir\\windowsupdate.log -Raw PS&gt; $info -is [Array] False 如果您已经有文本数组并且希望将它们转换为一个单一的文本，请使用 Out-String： PS&gt; $info = &apos;One&apos;, &apos;Two&apos;, &apos;Three&apos; PS&gt; $info -is [Array] True PS&gt; $all = $info | Out-String PS&gt; $all -is [Array] False 本文国际来源：Converting Text Arrays to String","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 重新打包 0day appz","slug":"repack-0day-appz-by-powershell","date":"2014-05-15T16:00:00.000Z","updated":"2017-03-17T15:26:23.590Z","comments":true,"path":"2014/05/16/repack-0day-appz-by-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/05/16/repack-0day-appz-by-powershell/","excerpt":"","text":"从 0day 服务器下载下来的 appz 文件夹是这样的形态： 每个文件夹代表一个 appz 软件，打开是这个样子的： 里面是一系列 .zip 文件以及说明文件。这些 .zip 文件却不是使用 zip 的分卷压缩出来的，它们的内容如下： 要把这些 .zip 文件全部解压到同一个目录下，才可以得到一系列 rar 的分卷压缩文件。我们打开一个 .rar 文件，这才看到真正的内容： 软件数量大的时候，人工重复进行上述操作就不合适了。机械的劳动应该交给程序。我们可以设计一个 PowerShell 脚本，完成一系列功能： 遍历 0day appz 的下载目录。 解压所有 .zip 文件。 解压 .rar 文件。 将说明文件复制到一起。 将最终的文件重打包为 .zip 文件。 如果上述的解压有问题，则不打包，并输出错误日志。 清理临时文件。 清理成功的原始文件夹，保留失败的原始文件夹。 按照这个需求，我们可以编写如下 PowerShell 脚本： $DebugPreference = &apos;Continue&apos; $incoming = &apos;d:\\0day\\incoming&apos; $temp1 = &apos;d:\\0day\\temp1&apos; $temp2 = &apos;d:\\0day\\temp2&apos; $output = &apos;d:\\0day\\output&apos; if (Test-Path $temp1) { del $temp1 -r } if (Test-Path $temp2) { del $temp2 -r } $apps = dir $incoming -Directory $count = 0 $hasFailed = $false $apps | foreach { $name = $_.Name Write-Progress -Activity &apos;Repacking apps&apos; -PercentComplete ($count / $apps.Length * 100) -CurrentOperation $name echo &quot;Repacking $name&quot; md $temp1 | Out-Null md $temp2 | Out-Null # d:\\0day\\util\\7z x -o&quot;d:\\0day\\temp1&quot; &quot;d:\\0day\\incoming\\VanDyke.SecureCRT.v7.2.2.491.Incl.Patch.And.Keymaker-ZWT\\*.zip&quot; $arguments = &apos;x&apos;, &quot;-o&quot;&quot;$temp1&quot;&quot;&quot;, &apos;-y&apos;, (Join-Path $_.FullName *.zip) .\\7z $arguments | Out-Null if (!$?) { Write-Warning &quot;Repacking $name failed.&quot; echo &quot;$name&quot; &gt;&gt; &quot;$output\\fail.log&quot; del $temp1 -r del $temp2 -r $count++ $hasFailed = $true return } # d:\\0day\\util\\7z x -o&quot;d:\\0day\\temp2&quot; &quot;d:\\0day\\temp1\\*.rar&quot; -y $arguments = &apos;x&apos;, &quot;-o&quot;&quot;$temp2&quot;&quot;&quot;, &apos;-y&apos;, &quot;$temp1\\*.rar&quot; .\\7z $arguments | Out-Null if (!$?) { Write-Warning &quot;Repacking $name failed.&quot; echo &quot;$name&quot; &gt;&gt; &quot;$output\\fail.log&quot; del $temp1 -r del $temp2 -r $count++ $hasFailed = $true return } # copy d:\\0day\\temp1\\*.diz d:\\0day\\temp2 # copy d:\\0day\\temp1\\*.nfo d:\\0day\\temp2 dir $temp1 | where { $_.Extension -notmatch &apos;rar|r\\d*&apos; } | copy -Destination $temp2 #d:\\0day\\util\\7z a &quot;d:\\0day\\output\\VanDyke.SecureCRT.v7.2.2.491.Incl.Patch.And.Keymaker-ZWT.zip&quot; &quot;d:\\0day\\temp2\\*.*&quot; -r $arguments = &apos;a&apos;, &quot;$output\\$name.zip&quot;, &quot;$temp2\\*.*&quot;, &apos;-r&apos; .\\7z $arguments | Out-Null if (!$?) { Write-Warning &quot;Repacking $name failed.&quot; echo &quot;$name&quot; &gt;&gt; &quot;$output\\fail.log&quot; del $temp1 -r del $temp2 -r $count++ $hasFailed = $true return } del $temp1 -r del $temp2 -r Remove-Item -LiteralPath $_.FullName -r $count++ } if ($hasFailed) { echo &apos;&apos; &gt;&gt; &quot;$output\\fail.log&quot; } echo &apos;Press any key to continue...&apos; [Console]::ReadKey() | Out-Null # del &apos;d:\\0day\\output\\*.*&apos; -r 您也可以在这里下载写好的脚本，包括完整的目录结构和 7z 软件包。请解压到 d:\\ 中使用，或者自行调整脚本头部的路径。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"batch","slug":"batch","permalink":"http://blog.vichamp.com/tags/batch/"},{"name":"0day","slug":"0day","permalink":"http://blog.vichamp.com/tags/0day/"},{"name":"appz","slug":"appz","permalink":"http://blog.vichamp.com/tags/appz/"},{"name":"repack","slug":"repack","permalink":"http://blog.vichamp.com/tags/repack/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - ISE 的缺陷导致调试器阻塞","slug":"ise-bug-locks-debugger","date":"2014-05-15T16:00:00.000Z","updated":"2017-03-17T15:26:23.590Z","comments":true,"path":"2014/05/16/ise-bug-locks-debugger/","link":"","permalink":"http://blog.vichamp.com/2014/05/16/ise-bug-locks-debugger/","excerpt":"在 Powershell ISE 中，有一个模糊的缺陷，可能会导致调试器死锁。受影响的 PowerShell 版本有 3.0 和 4.0。 以下是一段测试脚本： $test = @&quot; Some lines of text &quot;@ $test 在 ISE 编辑器中将这段代码保存为脚本，然后在第一行中设置一个断点：单击第一行的任何地方，然后按下 F9 键。该行将会变成红色。 当您启动脚本时，调试器将会在断点处停下，然后您可以按 F10 键单步跟踪代码。这可以正常工作。 现在，在变量定义之前加入一些空格： $test = @&quot; Some lines of text &quot;@ $test 当您现在调用调试器的时候，它将会死锁，并且 ISE 不会恢复。您还可以保存未保存的脚本，但您再也无法停止 ISE 的运行空间。 这个缺陷在对通过 here string 定义的脚本变量缩进的时候暴露出来。","text":"在 Powershell ISE 中，有一个模糊的缺陷，可能会导致调试器死锁。受影响的 PowerShell 版本有 3.0 和 4.0。 以下是一段测试脚本： $test = @&quot; Some lines of text &quot;@ $test 在 ISE 编辑器中将这段代码保存为脚本，然后在第一行中设置一个断点：单击第一行的任何地方，然后按下 F9 键。该行将会变成红色。 当您启动脚本时，调试器将会在断点处停下，然后您可以按 F10 键单步跟踪代码。这可以正常工作。 现在，在变量定义之前加入一些空格： $test = @&quot; Some lines of text &quot;@ $test 当您现在调用调试器的时候，它将会死锁，并且 ISE 不会恢复。您还可以保存未保存的脚本，但您再也无法停止 ISE 的运行空间。 这个缺陷在对通过 here string 定义的脚本变量缩进的时候暴露出来。 本文国际来源：ISE Bug Locks Debugger","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 批量重命名对象的属性","slug":"bulk-renaming-object-properties","date":"2014-05-14T16:00:00.000Z","updated":"2017-03-17T15:26:23.574Z","comments":true,"path":"2014/05/15/bulk-renaming-object-properties/","link":"","permalink":"http://blog.vichamp.com/2014/05/15/bulk-renaming-object-properties/","excerpt":"有些时候，我们需要批量重命名对象的属性来更好地创建报表。例如，假设您获取了进程对象，你需要您可能需要以新的的列名来创建报表。 以下是一个称为 Rename-Property 的过滤器，可以用于重命名任何属性。在例子中，生成了一个进程列表，然后重命名一些属性： filter Rename-Property ([Hashtable]$PropertyMapping) { Foreach ($key in $PropertyMapping.Keys) { $_ = $_ | Add-Member -MemberType AliasProperty -Name $PropertyMapping.$key -Value $key -PassThru } $_ } $newProps = @{ Company = &apos;Manufacturer&apos; Description = &apos;Purpose&apos; MainWindowTitle = &apos;TitlebarText&apos; } # get raw data Get-Process | # add alias properties as specified in $newProps Rename-Property $newProps | # select the properties you want to display # can be original properties and/or newly added alias properties Select-Object -Property Name, Manufacturer, Purpose, TitlebarText Rename-Property 自动加入了 $newProps 中指定的所有属性。结果对象中含有名为“Manufacturer”、“Purpose”和“TitlebarText”的新属性。您可以接着使用 Select-Object 来选择您想在报表中包含的属性。您可以从原先存在的属性中选择，也可以从新增加的别名属性中选择。 所以本质上上，属性并没有被改名（技术上不可能实现）。实际上，该过滤器以新的名字添加了别名属性，并指向原先的属性。","text":"有些时候，我们需要批量重命名对象的属性来更好地创建报表。例如，假设您获取了进程对象，你需要您可能需要以新的的列名来创建报表。 以下是一个称为 Rename-Property 的过滤器，可以用于重命名任何属性。在例子中，生成了一个进程列表，然后重命名一些属性： filter Rename-Property ([Hashtable]$PropertyMapping) { Foreach ($key in $PropertyMapping.Keys) { $_ = $_ | Add-Member -MemberType AliasProperty -Name $PropertyMapping.$key -Value $key -PassThru } $_ } $newProps = @{ Company = &apos;Manufacturer&apos; Description = &apos;Purpose&apos; MainWindowTitle = &apos;TitlebarText&apos; } # get raw data Get-Process | # add alias properties as specified in $newProps Rename-Property $newProps | # select the properties you want to display # can be original properties and/or newly added alias properties Select-Object -Property Name, Manufacturer, Purpose, TitlebarText Rename-Property 自动加入了 $newProps 中指定的所有属性。结果对象中含有名为“Manufacturer”、“Purpose”和“TitlebarText”的新属性。您可以接着使用 Select-Object 来选择您想在报表中包含的属性。您可以从原先存在的属性中选择，也可以从新增加的别名属性中选择。 所以本质上上，属性并没有被改名（技术上不可能实现）。实际上，该过滤器以新的名字添加了别名属性，并指向原先的属性。 本文国际来源：Bulk Renaming Object Properties","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 修正 Excel 报表中的显示","slug":"fixing-display-in-excel-reports","date":"2014-05-13T16:00:00.000Z","updated":"2017-03-17T15:26:23.574Z","comments":true,"path":"2014/05/14/fixing-display-in-excel-reports/","link":"","permalink":"http://blog.vichamp.com/2014/05/14/fixing-display-in-excel-reports/","excerpt":"当您发送信息到 Microsoft Excel 中时，它将被 .NET 内置的 ToString() 方法转化为文本。这个方法通常并不能正确地转化数组或非基本数据类型。 以下是一个例子演示这个问题。它创建了一个您系统事件日志中 10 个最近错误事件的报表： $Path = &quot;$env:temp\\$(Get-Random).csv&quot; Get-EventLog -LogName System -EntryType Error -Newest 10 | Select-Object EventID, MachineName, Data, Message, Source, ReplacementStrings, InstanceId, TimeGenerated | Export-Csv -Path $Path -Encoding UTF8 -NoTypeInformation -UseCulture Invoke-Item -Path $Path “Data”字段和“ReplacementStrings”无法使用。由于两个属性都包含数组，自动转换的结果只是简单显示数据的类型的名称。这是在从对象数据中创建 Excel 报表的常见现象。 要改进报表，您可以显式地使用 PowerShell 引擎将对象转化为文本，然后将多行文本转换为单行文本。 您可以对每个看起来不正确的字段运用这个方法。以下是上一个例子的解决方案，它能够改进 Message、Data 和 ReplacementStrings 字段的显示： $Path = &quot;$env:temp\\$(Get-Random).csv&quot; Get-EventLog -LogName System -EntryType Error -Newest 10 | Select-Object EventID, MachineName, Data, Message, Source, ReplacementStrings, InstanceId, TimeGenerated | ForEach-Object { $_.Message = ($_.Message | Out-String -Stream) -join &apos; &apos; $_.Data = ($_.Data | Out-String -Stream) -join &apos;, &apos; $_.ReplacementStrings = ($_.ReplacementStrings | Out-String -Stream) -join &apos;, &apos; $_ } | Export-Csv -Path $Path -Encoding UTF8 -NoTypeInformation -UseCulture Invoke-Item -Path $Path 现在所有字段都显示了正确的结果。请注意有问题的属性首先通过管道发送到 Out-String 命令（用 PowerShell 内部的机制将数据转换为有意义的文本），然后用 -join 将信息连接成单行文本。 还请注意“Message”属性是如何处理的。虽然这个属性看起来没问题，但是它实际上有可能是多行文本。多行信息在 Excel 中将只显示第一行，并以“…”结尾。我们将这些行通过空格连接之后，Excel 便可以显示完整信息了。","text":"当您发送信息到 Microsoft Excel 中时，它将被 .NET 内置的 ToString() 方法转化为文本。这个方法通常并不能正确地转化数组或非基本数据类型。 以下是一个例子演示这个问题。它创建了一个您系统事件日志中 10 个最近错误事件的报表： $Path = &quot;$env:temp\\$(Get-Random).csv&quot; Get-EventLog -LogName System -EntryType Error -Newest 10 | Select-Object EventID, MachineName, Data, Message, Source, ReplacementStrings, InstanceId, TimeGenerated | Export-Csv -Path $Path -Encoding UTF8 -NoTypeInformation -UseCulture Invoke-Item -Path $Path “Data”字段和“ReplacementStrings”无法使用。由于两个属性都包含数组，自动转换的结果只是简单显示数据的类型的名称。这是在从对象数据中创建 Excel 报表的常见现象。 要改进报表，您可以显式地使用 PowerShell 引擎将对象转化为文本，然后将多行文本转换为单行文本。 您可以对每个看起来不正确的字段运用这个方法。以下是上一个例子的解决方案，它能够改进 Message、Data 和 ReplacementStrings 字段的显示： $Path = &quot;$env:temp\\$(Get-Random).csv&quot; Get-EventLog -LogName System -EntryType Error -Newest 10 | Select-Object EventID, MachineName, Data, Message, Source, ReplacementStrings, InstanceId, TimeGenerated | ForEach-Object { $_.Message = ($_.Message | Out-String -Stream) -join &apos; &apos; $_.Data = ($_.Data | Out-String -Stream) -join &apos;, &apos; $_.ReplacementStrings = ($_.ReplacementStrings | Out-String -Stream) -join &apos;, &apos; $_ } | Export-Csv -Path $Path -Encoding UTF8 -NoTypeInformation -UseCulture Invoke-Item -Path $Path 现在所有字段都显示了正确的结果。请注意有问题的属性首先通过管道发送到 Out-String 命令（用 PowerShell 内部的机制将数据转换为有意义的文本），然后用 -join 将信息连接成单行文本。 还请注意“Message”属性是如何处理的。虽然这个属性看起来没问题，但是它实际上有可能是多行文本。多行信息在 Excel 中将只显示第一行，并以“…”结尾。我们将这些行通过空格连接之后，Excel 便可以显示完整信息了。 本文国际来源：Fixing Display in Excel Reports","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建 Excel 报表","slug":"creating-excel-reports","date":"2014-05-12T16:00:00.000Z","updated":"2017-03-17T15:26:23.573Z","comments":true,"path":"2014/05/13/creating-excel-reports/","link":"","permalink":"http://blog.vichamp.com/2014/05/13/creating-excel-reports/","excerpt":"PowerShell 对象可以很容易地通过 Microsoft Excel 打开。只需要将对象导出成 CSV，然后通过关联的应用程序打开 CSV 文件（如果装了 Excel，那么将用 Excel 打开）。 以下代码创建一个当前运行的进程报告，并用 Excel 打开： $Path = &quot;$env:temp\\$(Get-Random).csv&quot; $originalProperties = &apos;Name&apos;, &apos;Id&apos;, &apos;Company&apos;, &apos;Description&apos;, &apos;WindowTitle&apos; Get-Process | Select-Object -Property $originalProperties | Export-Csv -Path $Path -Encoding UTF8 -NoTypeInformation -UseCulture Invoke-Item -Path $Path 请注意 -UseCulture 如何根据您的区域设置自动选择正确的分隔符。","text":"PowerShell 对象可以很容易地通过 Microsoft Excel 打开。只需要将对象导出成 CSV，然后通过关联的应用程序打开 CSV 文件（如果装了 Excel，那么将用 Excel 打开）。 以下代码创建一个当前运行的进程报告，并用 Excel 打开： $Path = &quot;$env:temp\\$(Get-Random).csv&quot; $originalProperties = &apos;Name&apos;, &apos;Id&apos;, &apos;Company&apos;, &apos;Description&apos;, &apos;WindowTitle&apos; Get-Process | Select-Object -Property $originalProperties | Export-Csv -Path $Path -Encoding UTF8 -NoTypeInformation -UseCulture Invoke-Item -Path $Path 请注意 -UseCulture 如何根据您的区域设置自动选择正确的分隔符。 本文国际来源：Creating Excel Reports","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - PowerShell 不支持 JSON 数据类型","slug":"powershell-does-not-support-json-data-types","date":"2014-05-11T16:00:00.000Z","updated":"2017-03-17T15:26:23.555Z","comments":true,"path":"2014/05/12/powershell-does-not-support-json-data-types/","link":"","permalink":"http://blog.vichamp.com/2014/05/12/powershell-does-not-support-json-data-types/","excerpt":"缺省情况下，从 JSON 创建的对象使用 String 作为数据的类型： $json = @&quot; { &quot;Name&quot;: &quot;Weltner&quot;, &quot;ID&quot; : &quot;123&quot; } &quot;@ $info = ConvertFrom-Json -InputObject $json $info.Name $info.ID 但是，JSON 不支持数据类型，虽然 JSON 数据类型并不等价于 .NET 数据类型。请注意在以下代码中，“ID”被定义成“数字”型，并且它被赋予一个数值型的值，而不需要用双引号引起来。 $json = @&quot; { &quot;Name&quot;: &quot;Weltner&quot;, number: &quot;ID&quot; : 123 } &quot;@ $info = ConvertFrom-Json -InputObject $json $info.Name $info.ID 然而，当使用 ConvertFrom-Json 时，我们发现 PowerShell 并没有关心数据类型定义。它总是将值转换为 String 数据。","text":"缺省情况下，从 JSON 创建的对象使用 String 作为数据的类型： $json = @&quot; { &quot;Name&quot;: &quot;Weltner&quot;, &quot;ID&quot; : &quot;123&quot; } &quot;@ $info = ConvertFrom-Json -InputObject $json $info.Name $info.ID 但是，JSON 不支持数据类型，虽然 JSON 数据类型并不等价于 .NET 数据类型。请注意在以下代码中，“ID”被定义成“数字”型，并且它被赋予一个数值型的值，而不需要用双引号引起来。 $json = @&quot; { &quot;Name&quot;: &quot;Weltner&quot;, number: &quot;ID&quot; : 123 } &quot;@ $info = ConvertFrom-Json -InputObject $json $info.Name $info.ID 然而，当使用 ConvertFrom-Json 时，我们发现 PowerShell 并没有关心数据类型定义。它总是将值转换为 String 数据。 本文国际来源：PowerShell does not support JSON Data Types","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 JSON 来创建对象","slug":"use-json-to-create-objects","date":"2014-05-08T16:00:00.000Z","updated":"2017-03-17T15:26:23.540Z","comments":true,"path":"2014/05/09/use-json-to-create-objects/","link":"","permalink":"http://blog.vichamp.com/2014/05/09/use-json-to-create-objects/","excerpt":"JSON 用来描述对象的，类似 XML，但是 JSON 更简单得多.JSON 支持嵌套的对象属性，所以您可以从各种数据源中获取信息，然后将它们合并成一个自定义对象。 让我们来看看效果。以下代码创建一个清单条目，包含了电脑的许多详细信息： $json = @&quot; { &quot;ServerName&quot;: &quot;$env:ComputerName&quot;, &quot;UserName&quot;: &quot;$env:UserName&quot;, &quot;BIOS&quot;: { &quot;Manufacturer&quot; : &quot;$((Get-WmiObject -Class Win32_BIOS).Manufacturer)&quot;, &quot;Version&quot; : &quot;$((Get-WmiObject -Class Win32_BIOS).Version)&quot;, &quot;Serial&quot; : &quot;$((Get-WmiObject -Class Win32_BIOS).SerialNumber)&quot; }, &quot;OS&quot; : &quot;$([Environment]::OSVersion.VersionString)&quot; } &quot;@ $info = ConvertFrom-Json -InputObject $json $info.ServerName $info.BIOS.Version $info.OS 您接下来可以操作结果对象——获取信息，或增加、更新详细信息。 如果您对对象做了改动，可以用 ConvertTo-Json 将它序列化为 JSON 对象格式：","text":"JSON 用来描述对象的，类似 XML，但是 JSON 更简单得多.JSON 支持嵌套的对象属性，所以您可以从各种数据源中获取信息，然后将它们合并成一个自定义对象。 让我们来看看效果。以下代码创建一个清单条目，包含了电脑的许多详细信息： $json = @&quot; { &quot;ServerName&quot;: &quot;$env:ComputerName&quot;, &quot;UserName&quot;: &quot;$env:UserName&quot;, &quot;BIOS&quot;: { &quot;Manufacturer&quot; : &quot;$((Get-WmiObject -Class Win32_BIOS).Manufacturer)&quot;, &quot;Version&quot; : &quot;$((Get-WmiObject -Class Win32_BIOS).Version)&quot;, &quot;Serial&quot; : &quot;$((Get-WmiObject -Class Win32_BIOS).SerialNumber)&quot; }, &quot;OS&quot; : &quot;$([Environment]::OSVersion.VersionString)&quot; } &quot;@ $info = ConvertFrom-Json -InputObject $json $info.ServerName $info.BIOS.Version $info.OS 您接下来可以操作结果对象——获取信息，或增加、更新详细信息。 如果您对对象做了改动，可以用 ConvertTo-Json 将它序列化为 JSON 对象格式： 本文国际来源：Use JSON to Create Objects","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取父作用域中的变量值","slug":"getting-variable-value-in-parent-scope","date":"2014-05-07T16:00:00.000Z","updated":"2017-03-17T15:26:23.540Z","comments":true,"path":"2014/05/08/getting-variable-value-in-parent-scope/","link":"","permalink":"http://blog.vichamp.com/2014/05/08/getting-variable-value-in-parent-scope/","excerpt":"如果您在一个函数中定义了变量，那么这些变量只在函数作用域内有效。要查看在外层作用域的变量值，请使用带 -Scope 参数的 Get-Variable 命令： $a = 1 function test { $a = 2 $parentVariable = Get-Variable -Name a -Scope 1 $parentVariable.Value } test 当脚本调用“test”函数时，函数定义了一个 $a 并且将它的值设为 2。在调用者作用域中，变量 $a 的值是 1。通过 Get-Variable，函数内可以得到外层作用域中的变量值。","text":"如果您在一个函数中定义了变量，那么这些变量只在函数作用域内有效。要查看在外层作用域的变量值，请使用带 -Scope 参数的 Get-Variable 命令： $a = 1 function test { $a = 2 $parentVariable = Get-Variable -Name a -Scope 1 $parentVariable.Value } test 当脚本调用“test”函数时，函数定义了一个 $a 并且将它的值设为 2。在调用者作用域中，变量 $a 的值是 1。通过 Get-Variable，函数内可以得到外层作用域中的变量值。 本文国际来源：Getting Variable Value in Parent Scope","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 更新 Windows Defender 病毒定义","slug":"updating-windows-defender-signatures","date":"2014-05-06T16:00:00.000Z","updated":"2017-03-17T15:26:23.540Z","comments":true,"path":"2014/05/07/updating-windows-defender-signatures/","link":"","permalink":"http://blog.vichamp.com/2014/05/07/updating-windows-defender-signatures/","excerpt":"Windows 8.1 带来了一系列新的 cmdlet。其中一个可以自动下载并安装 Windows Defender 最新的反病毒定义。 Get-MpComputerStatus 返回当前病毒定义的信息。 这些 cmdlet 不是 PowerShell 的一部分，而是 Windows 8.1 的一部分，所以在早期版本的操作系统中，您会碰到找不到命令的错误信息。","text":"Windows 8.1 带来了一系列新的 cmdlet。其中一个可以自动下载并安装 Windows Defender 最新的反病毒定义。 Get-MpComputerStatus 返回当前病毒定义的信息。 这些 cmdlet 不是 PowerShell 的一部分，而是 Windows 8.1 的一部分，所以在早期版本的操作系统中，您会碰到找不到命令的错误信息。 本文国际来源：Updating Windows Defender Signatures","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 键盘鼠标自动化","slug":"automation-via-keystroke-and-mouse-click","date":"2014-05-05T16:00:00.000Z","updated":"2017-03-17T15:26:23.529Z","comments":true,"path":"2014/05/06/automation-via-keystroke-and-mouse-click/","link":"","permalink":"http://blog.vichamp.com/2014/05/06/automation-via-keystroke-and-mouse-click/","excerpt":"某些时候，唯一的自动化处理办法是向 UI 组件发送按键和鼠标点击消息。一个强大且免费的 PowerShell 扩展，叫做“WASP”，地址如下： http://wasp.codeplex.com/ 一旦您装好了这个模块（解压前别忘了解除 ZIP 文件锁定。方法是右键点击，属性，解锁），WASP 模块提供以下 cmdlet： 以下是一个简单的操作 Windows 计算器的例子： Import-Module WASP # launch Calculator $process = Start-Process -FilePath calc -PassThru $id = $process.Id Start-Sleep -Seconds 2 $window = Select-Window | Where-Object { $_.ProcessID -eq $id } # send keys $window | Send-Keys 123 $window | Send-Keys &apos;{+}&apos; $window | Send-Keys 999 $window | Send-Keys = # send CTRL+c $window | Send-Keys &apos;^c&apos; # Result is now available from clipboard 以下是附加说明： 启动一个进程之后，要等待 1-2 秒，待窗体创建号以后才可以用 WASP 找到该窗口。 参考 SendKeys API 发送按键。有些字符需要通过两边加花括号的方式转义。更多细节请参见这里：http://msdn.microsoft.com/en-us/library/system.windows.forms.sendkeys.send(v=vs.110).aspx/.aspx/) 当需要发送按键序列，例如 CTRL+C 时，请使用小写字母。“^c”代表发送 CTRL+c，而“^C”代表发送 CTRL+SHIFT+C。 只有 WinForm 窗口支持操作子控件，例如特定的文本框和按钮（Select-ChildWindow, Select-Control）。WPF 窗口也可以接收按键，但是 WPF 中在窗体的 UI 组件之上无法获得支持输入的控件。","text":"某些时候，唯一的自动化处理办法是向 UI 组件发送按键和鼠标点击消息。一个强大且免费的 PowerShell 扩展，叫做“WASP”，地址如下： http://wasp.codeplex.com/ 一旦您装好了这个模块（解压前别忘了解除 ZIP 文件锁定。方法是右键点击，属性，解锁），WASP 模块提供以下 cmdlet： 以下是一个简单的操作 Windows 计算器的例子： Import-Module WASP # launch Calculator $process = Start-Process -FilePath calc -PassThru $id = $process.Id Start-Sleep -Seconds 2 $window = Select-Window | Where-Object { $_.ProcessID -eq $id } # send keys $window | Send-Keys 123 $window | Send-Keys &apos;{+}&apos; $window | Send-Keys 999 $window | Send-Keys = # send CTRL+c $window | Send-Keys &apos;^c&apos; # Result is now available from clipboard 以下是附加说明： 启动一个进程之后，要等待 1-2 秒，待窗体创建号以后才可以用 WASP 找到该窗口。 参考 SendKeys API 发送按键。有些字符需要通过两边加花括号的方式转义。更多细节请参见这里：http://msdn.microsoft.com/en-us/library/system.windows.forms.sendkeys.send(v=vs.110).aspx/.aspx/) 当需要发送按键序列，例如 CTRL+C 时，请使用小写字母。“^c”代表发送 CTRL+c，而“^C”代表发送 CTRL+SHIFT+C。 只有 WinForm 窗口支持操作子控件，例如特定的文本框和按钮（Select-ChildWindow, Select-Control）。WPF 窗口也可以接收按键，但是 WPF 中在窗体的 UI 组件之上无法获得支持输入的控件。 本文国际来源：Automation via Keystroke and Mouse Click","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 显示 WPF 消息提示","slug":"showing-wpf-info-message","date":"2014-05-04T16:00:00.000Z","updated":"2017-03-17T15:26:23.521Z","comments":true,"path":"2014/05/05/showing-wpf-info-message/","link":"","permalink":"http://blog.vichamp.com/2014/05/05/showing-wpf-info-message/","excerpt":"WPF (Windows Presentation Foundation) 是一种创建窗体和对话框的技术。WPF 的好处是窗体设计和程序代码可以分离。 以下是一个显示醒目消息的例子。消息内容定义在 XAML 代码中，看起来类似 HTML （不过是区分大小写的）。您可以很容易地调整字体大小、文字、颜色等。不需要改任何程序代码： $xaml = @&quot; &lt;Window xmlns=&apos;http://schemas.microsoft.com/winfx/2006/xaml/presentation&apos;&gt; &lt;Border BorderThickness=&quot;20&quot; BorderBrush=&quot;Yellow&quot; CornerRadius=&quot;9&quot; Background=&apos;Red&apos;&gt; &lt;StackPanel&gt; &lt;Label FontSize=&quot;50&quot; FontFamily=&apos;Stencil&apos; Background=&apos;Red&apos; Foreground=&apos;White&apos; BorderThickness=&apos;0&apos;&gt; System will be rebooted in 15 minutes! &lt;/Label&gt; &lt;Label HorizontalAlignment=&quot;Center&quot; FontSize=&quot;15&quot; FontFamily=&apos;Consolas&apos; Background=&apos;Red&apos; Foreground=&apos;White&apos; BorderThickness=&apos;0&apos;&gt; Worried about losing data? Talk to your friendly help desk representative and freely share your concerns! &lt;/Label&gt; &lt;/StackPanel&gt; &lt;/Border&gt; &lt;/Window&gt; &quot;@ $reader = [System.XML.XMLReader]::Create([System.IO.StringReader] $xaml) $window = [System.Windows.Markup.XAMLReader]::Load($reader) $Window.AllowsTransparency = $True $window.SizeToContent = &apos;WidthAndHeight&apos; $window.ResizeMode = &apos;NoResize&apos; $Window.Opacity = .7 $window.Topmost = $true $window.WindowStartupLocation = &apos;CenterScreen&apos; $window.WindowStyle = &apos;None&apos; # show message for 5 seconds: $null = $window.Show() Start-Sleep -Seconds 5 $window.Close()","text":"WPF (Windows Presentation Foundation) 是一种创建窗体和对话框的技术。WPF 的好处是窗体设计和程序代码可以分离。 以下是一个显示醒目消息的例子。消息内容定义在 XAML 代码中，看起来类似 HTML （不过是区分大小写的）。您可以很容易地调整字体大小、文字、颜色等。不需要改任何程序代码： $xaml = @&quot; &lt;Window xmlns=&apos;http://schemas.microsoft.com/winfx/2006/xaml/presentation&apos;&gt; &lt;Border BorderThickness=&quot;20&quot; BorderBrush=&quot;Yellow&quot; CornerRadius=&quot;9&quot; Background=&apos;Red&apos;&gt; &lt;StackPanel&gt; &lt;Label FontSize=&quot;50&quot; FontFamily=&apos;Stencil&apos; Background=&apos;Red&apos; Foreground=&apos;White&apos; BorderThickness=&apos;0&apos;&gt; System will be rebooted in 15 minutes! &lt;/Label&gt; &lt;Label HorizontalAlignment=&quot;Center&quot; FontSize=&quot;15&quot; FontFamily=&apos;Consolas&apos; Background=&apos;Red&apos; Foreground=&apos;White&apos; BorderThickness=&apos;0&apos;&gt; Worried about losing data? Talk to your friendly help desk representative and freely share your concerns! &lt;/Label&gt; &lt;/StackPanel&gt; &lt;/Border&gt; &lt;/Window&gt; &quot;@ $reader = [System.XML.XMLReader]::Create([System.IO.StringReader] $xaml) $window = [System.Windows.Markup.XAMLReader]::Load($reader) $Window.AllowsTransparency = $True $window.SizeToContent = &apos;WidthAndHeight&apos; $window.ResizeMode = &apos;NoResize&apos; $Window.Opacity = .7 $window.Topmost = $true $window.WindowStartupLocation = &apos;CenterScreen&apos; $window.WindowStyle = &apos;None&apos; # show message for 5 seconds: $null = $window.Show() Start-Sleep -Seconds 5 $window.Close() 本文国际来源：Showing WPF Info Message","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通过 Outlook 发送电子邮件","slug":"sending-email-via-outlook","date":"2014-05-01T16:00:00.000Z","updated":"2017-03-17T15:26:23.505Z","comments":true,"path":"2014/05/02/sending-email-via-outlook/","link":"","permalink":"http://blog.vichamp.com/2014/05/02/sending-email-via-outlook/","excerpt":"您显然可以通过 Send-MailMessage 直接发送邮件。但如果您希望通过缺省的 MAPI 客户端发送电子邮件，也不会太麻烦： $subject = &apos;Sending via MAPI client&apos; $body = &apos;My Message&apos; $to = &apos;tobias@powertheshell.com&apos; $mail = &quot;mailto:$to&amp;subject=$subject&amp;body=$body&quot; Start-Process -FilePath $mail 这个脚本利用了 mailto: 语法。如果您已安装了一个 MAPI 客户端，这将打开一个电子邮件表单并且将脚本指定的内容填充进去。不过您需要手工发送邮件。","text":"您显然可以通过 Send-MailMessage 直接发送邮件。但如果您希望通过缺省的 MAPI 客户端发送电子邮件，也不会太麻烦： $subject = &apos;Sending via MAPI client&apos; $body = &apos;My Message&apos; $to = &apos;tobias@powertheshell.com&apos; $mail = &quot;mailto:$to&amp;subject=$subject&amp;body=$body&quot; Start-Process -FilePath $mail 这个脚本利用了 mailto: 语法。如果您已安装了一个 MAPI 客户端，这将打开一个电子邮件表单并且将脚本指定的内容填充进去。不过您需要手工发送邮件。 本文国际来源：Sending Email via Outlook","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找缺省的 MAPI 客户端","slug":"finding-default-mapi-client","date":"2014-04-30T16:00:00.000Z","updated":"2017-03-17T15:26:23.490Z","comments":true,"path":"2014/05/01/finding-default-mapi-client/","link":"","permalink":"http://blog.vichamp.com/2014/05/01/finding-default-mapi-client/","excerpt":"您机器上的 MAPI 客户端就是处理类似“mailto:” URL 的缺省电子邮件客户端。我们设计一个函数来查找是否有 MAPI 客户端，如果有的话，查看具体是哪一个。该函数从 Windows 注册表中获取这项信息： function Get-MAPIClient { function Remove-Argument { param ( $CommandLine ) $divider = &apos; &apos; if ($CommandLine.StartsWith(&apos;&quot;&apos;)) { $divider = &apos;&quot;&apos; $CommandLine = $CommandLine.SubString(1) } $CommandLine.Split($divider)[0] } $path = &apos;Registry::HKEY_CLASSES_ROOT\\mailto\\shell\\open\\command&apos; # create new object to return values $returnValue = 1 | Select-Object -Property HasMapiClient, Path, MailTo $returnValue.hasMAPIClient = Test-Path -Path $path if ($returnValue.hasMAPIClient) { $values = Get-ItemProperty -Path $path $returnValue.MailTo = $values.&apos;(default)&apos; $returnValue.Path = Remove-Argument $returnValue.MailTo if ((Test-Path -Path $returnValue.Path) -eq $false) { $returnValue.hasMAPIClient = $true } } $returnValue } Get-MAPIClient 以下是使用结果：","text":"您机器上的 MAPI 客户端就是处理类似“mailto:” URL 的缺省电子邮件客户端。我们设计一个函数来查找是否有 MAPI 客户端，如果有的话，查看具体是哪一个。该函数从 Windows 注册表中获取这项信息： function Get-MAPIClient { function Remove-Argument { param ( $CommandLine ) $divider = &apos; &apos; if ($CommandLine.StartsWith(&apos;&quot;&apos;)) { $divider = &apos;&quot;&apos; $CommandLine = $CommandLine.SubString(1) } $CommandLine.Split($divider)[0] } $path = &apos;Registry::HKEY_CLASSES_ROOT\\mailto\\shell\\open\\command&apos; # create new object to return values $returnValue = 1 | Select-Object -Property HasMapiClient, Path, MailTo $returnValue.hasMAPIClient = Test-Path -Path $path if ($returnValue.hasMAPIClient) { $values = Get-ItemProperty -Path $path $returnValue.MailTo = $values.&apos;(default)&apos; $returnValue.Path = Remove-Argument $returnValue.MailTo if ((Test-Path -Path $returnValue.Path) -eq $false) { $returnValue.hasMAPIClient = $true } } $returnValue } Get-MAPIClient 以下是使用结果： 本文国际来源：Finding Default MAPI Client","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从命令行获取参数","slug":"getting-arguments-from-command-line","date":"2014-04-29T16:00:00.000Z","updated":"2017-03-17T15:26:23.490Z","comments":true,"path":"2014/04/30/getting-arguments-from-command-line/","link":"","permalink":"http://blog.vichamp.com/2014/04/30/getting-arguments-from-command-line/","excerpt":"在前一个技巧中，我们演示了如何从命令行中提取命令名，并忽略所有参数。今天，您将学习到如何用一个函数同时获取到命令名和参数。该函数将命令行分割为实际的命令名和它的参数，并返回一个自定义对象： function Get-Argument { param ( $CommandLine ) $result = 1 | Select-Object -Property Command, Argument if ($CommandLine.StartsWith(&apos;&quot;&apos;)) { $index = $CommandLine.IndexOf(&apos;&quot;&apos;, 1) if ($index -gt 0) { $result.Command = $CommandLine.SubString(0, $index).Trim(&apos;&quot;&apos;) $result.Argument = $CommandLine.SubString($index+1).Trim() $result } } else { $index = $CommandLine.IndexOf(&apos; &apos;) if ($index -gt 0) { $result.Command = $CommandLine.SubString(0, $index) $result.Argument = $CommandLine.SubString($index+1).Trim() $result } } } Get-Argument -CommandLine &apos;notepad c:\\test&apos; Get-Argument -CommandLine &apos;&quot;notepad.exe&quot; c:\\test&apos; 结果如下： 这是一个实际应用中的例子：它获取所有运行中的进程，并返回每个进程的命令名和参数： Get-WmiObject -Class Win32_Process | Where-Object { $_.CommandLine } | ForEach-Object { Get-Argument -CommandLine $_.CommandLine } 以下是结果的样子： 既然命令和参数都分开了，您还可以像这样为信息分组： Get-WmiObject -Class Win32_Process | Where-Object { $_.CommandLine } | ForEach-Object { Get-Argument -CommandLine $_.CommandLine } | Group-Object -Property Command | Sort-Object -Property Count -Descending | Out-GridView","text":"在前一个技巧中，我们演示了如何从命令行中提取命令名，并忽略所有参数。今天，您将学习到如何用一个函数同时获取到命令名和参数。该函数将命令行分割为实际的命令名和它的参数，并返回一个自定义对象： function Get-Argument { param ( $CommandLine ) $result = 1 | Select-Object -Property Command, Argument if ($CommandLine.StartsWith(&apos;&quot;&apos;)) { $index = $CommandLine.IndexOf(&apos;&quot;&apos;, 1) if ($index -gt 0) { $result.Command = $CommandLine.SubString(0, $index).Trim(&apos;&quot;&apos;) $result.Argument = $CommandLine.SubString($index+1).Trim() $result } } else { $index = $CommandLine.IndexOf(&apos; &apos;) if ($index -gt 0) { $result.Command = $CommandLine.SubString(0, $index) $result.Argument = $CommandLine.SubString($index+1).Trim() $result } } } Get-Argument -CommandLine &apos;notepad c:\\test&apos; Get-Argument -CommandLine &apos;&quot;notepad.exe&quot; c:\\test&apos; 结果如下： 这是一个实际应用中的例子：它获取所有运行中的进程，并返回每个进程的命令名和参数： Get-WmiObject -Class Win32_Process | Where-Object { $_.CommandLine } | ForEach-Object { Get-Argument -CommandLine $_.CommandLine } 以下是结果的样子： 既然命令和参数都分开了，您还可以像这样为信息分组： Get-WmiObject -Class Win32_Process | Where-Object { $_.CommandLine } | ForEach-Object { Get-Argument -CommandLine $_.CommandLine } | Group-Object -Property Command | Sort-Object -Property Count -Descending | Out-GridView 本文国际来源：Getting Arguments from Command Line","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从命令行中提取可执行程序名","slug":"getting-executable-from-command-line","date":"2014-04-28T16:00:00.000Z","updated":"2017-03-17T15:26:23.474Z","comments":true,"path":"2014/04/29/getting-executable-from-command-line/","link":"","permalink":"http://blog.vichamp.com/2014/04/29/getting-executable-from-command-line/","excerpt":"有些时候我们需要从命令行提取命令名。以下是实现的方法： 代码如下： function Remove-Argument { param ( $CommandLine ) $divider = &apos; &apos; if ($CommandLine.StartsWith(&apos;&quot;&apos;)) { $divider = &apos;&quot;&apos; $CommandLine = $CommandLine.SubString(1) } $CommandLine.Split($divider)[0] }","text":"有些时候我们需要从命令行提取命令名。以下是实现的方法： 代码如下： function Remove-Argument { param ( $CommandLine ) $divider = &apos; &apos; if ($CommandLine.StartsWith(&apos;&quot;&apos;)) { $divider = &apos;&quot;&apos; $CommandLine = $CommandLine.SubString(1) } $CommandLine.Split($divider)[0] } 本文国际来源：Getting Executable from Command Line","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 弹出对话框时播放随机的音效","slug":"open-msgbox-with-random-sound","date":"2014-04-27T16:00:00.000Z","updated":"2017-03-17T15:26:23.465Z","comments":true,"path":"2014/04/28/open-msgbox-with-random-sound/","link":"","permalink":"http://blog.vichamp.com/2014/04/28/open-msgbox-with-random-sound/","excerpt":"您也许了解了如何用脚本打开一个 MsgBox 对话框。今天，您将学习如何用一段代码打开一个 MsgBox，同时播放一段随机的音效，吸引用户的注意力并增加趣味性。当用户操作 MsgBox 的时候，音效立即停止： # find random WAV file in your Windows folder $randomWAV = Get-ChildItem -Path C:\\Windows\\Media -Filter *.wav | Get-Random | Select-Object -ExpandProperty Fullname # load Forms assembly to get a MsgBox dialog Add-Type -AssemblyName System.Windows.Forms # play random sound until MsgBox is closed $player = New-Object Media.SoundPlayer $randomWAV $player.Load(); $player.PlayLooping() $result = [System.Windows.Forms.MessageBox]::Show(&quot;We will reboot your machine now. Ok?&quot;, &quot;PowerShell&quot;, &quot;YesNo&quot;, &quot;Exclamation&quot;) $player.Stop()","text":"您也许了解了如何用脚本打开一个 MsgBox 对话框。今天，您将学习如何用一段代码打开一个 MsgBox，同时播放一段随机的音效，吸引用户的注意力并增加趣味性。当用户操作 MsgBox 的时候，音效立即停止： # find random WAV file in your Windows folder $randomWAV = Get-ChildItem -Path C:\\Windows\\Media -Filter *.wav | Get-Random | Select-Object -ExpandProperty Fullname # load Forms assembly to get a MsgBox dialog Add-Type -AssemblyName System.Windows.Forms # play random sound until MsgBox is closed $player = New-Object Media.SoundPlayer $randomWAV $player.Load(); $player.PlayLooping() $result = [System.Windows.Forms.MessageBox]::Show(&quot;We will reboot your machine now. Ok?&quot;, &quot;PowerShell&quot;, &quot;YesNo&quot;, &quot;Exclamation&quot;) $player.Stop() 本文国际来源：Open MsgBox with Random Sound","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通过 Google 图片搜索自动下载图片","slug":"automatically-downloading-pictures-via-google-picture-search","date":"2014-04-24T16:00:00.000Z","updated":"2017-03-17T15:26:23.454Z","comments":true,"path":"2014/04/25/automatically-downloading-pictures-via-google-picture-search/","link":"","permalink":"http://blog.vichamp.com/2014/04/25/automatically-downloading-pictures-via-google-picture-search/","excerpt":"在前一个技巧中您学到了如何用 Invoke-WebRequest 从 Google 图片搜索中获取图片链接。Invoke-WebRequest 还可以做更多的东西。它可以获取图片 URL 并下载图片。 以下是具体做法： $SearchItem = &apos;PowerShell&apos; $TargetFolder = &apos;c:\\webpictures&apos; if ( (Test-Path -Path $TargetFolder) -eq $false) { md $TargetFolder } explorer.exe $TargetFolder $url = &quot;https://www.google.com/search?q=$SearchItem&amp;espv=210&amp;es_sm=93&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;tbm=isch&amp;tbs=isz:lt%2Cislt:2mp&quot; $browserAgent = &apos;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.146 Safari/537.36&apos; $page = Invoke-WebRequest -Uri $url -UserAgent $browserAgent $page.Links | Where-Object { $_.href -like &apos;*imgres*&apos; } | ForEach-Object { ($_.href -split &apos;imgurl=&apos;)[-1].Split(&apos;&amp;&apos;)[0]} | ForEach-Object { $file = Split-Path -Path $_ -Leaf $path = Join-Path -Path $TargetFolder -ChildPath $file Invoke-WebRequest -Uri $_ -OutFile $path } 您可以下载所有匹配关键字“PowerShell”的高分辨率的图片到您指定的 $TargetFolder 文件夹中。","text":"在前一个技巧中您学到了如何用 Invoke-WebRequest 从 Google 图片搜索中获取图片链接。Invoke-WebRequest 还可以做更多的东西。它可以获取图片 URL 并下载图片。 以下是具体做法： $SearchItem = &apos;PowerShell&apos; $TargetFolder = &apos;c:\\webpictures&apos; if ( (Test-Path -Path $TargetFolder) -eq $false) { md $TargetFolder } explorer.exe $TargetFolder $url = &quot;https://www.google.com/search?q=$SearchItem&amp;espv=210&amp;es_sm=93&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;tbm=isch&amp;tbs=isz:lt%2Cislt:2mp&quot; $browserAgent = &apos;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.146 Safari/537.36&apos; $page = Invoke-WebRequest -Uri $url -UserAgent $browserAgent $page.Links | Where-Object { $_.href -like &apos;*imgres*&apos; } | ForEach-Object { ($_.href -split &apos;imgurl=&apos;)[-1].Split(&apos;&amp;&apos;)[0]} | ForEach-Object { $file = Split-Path -Path $_ -Leaf $path = Join-Path -Path $TargetFolder -ChildPath $file Invoke-WebRequest -Uri $_ -OutFile $path } 您可以下载所有匹配关键字“PowerShell”的高分辨率的图片到您指定的 $TargetFolder 文件夹中。 本文国际来源：Automatically Downloading Pictures via Google Picture Search","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从 Google 图片搜索中获取图片 URL","slug":"getting-picture-urls-from-google-picture-search","date":"2014-04-23T16:00:00.000Z","updated":"2017-03-17T15:26:23.436Z","comments":true,"path":"2014/04/24/getting-picture-urls-from-google-picture-search/","link":"","permalink":"http://blog.vichamp.com/2014/04/24/getting-picture-urls-from-google-picture-search/","excerpt":"当您想从互联网下载信息时，Invoke-WebRequest 是您的好帮手。例如，您可以发送一个请求到 Google 并使用 PowerShell 检验它的结果。 Google 也知道您在这么做，所以当您从 PowerShell 发送一个查询时，Google 返回加密的链接。要获取真实的链接，您需要告诉 Google 您使用的不是 PowerShell 而是一个普通的浏览器。这可以通过设置浏览器代理字符串。 这段脚本输入一个关键字并返回所有符合搜索关键字，并且大于 2 兆像素的所有图片的原始地址： $SearchItem = &apos;PowerShell&apos; $url = &quot;https://www.google.com/search?q=$SearchItem&amp;espv=210&amp;es_sm=93&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;tbm=isch&amp;tbs=isz:lt%2Cislt:2mp&quot; $browserAgent = &apos;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.146 Safari/537.36&apos; $page = Invoke-WebRequest -Uri $url -UserAgent $browserAgent $page.Links | Where-Object { $_.href -like &apos;*imgres*&apos; } | ForEach-Object { ($_.href -split &apos;imgurl=&apos;)[-1].Split(&apos;&amp;&apos;)[0]}","text":"当您想从互联网下载信息时，Invoke-WebRequest 是您的好帮手。例如，您可以发送一个请求到 Google 并使用 PowerShell 检验它的结果。 Google 也知道您在这么做，所以当您从 PowerShell 发送一个查询时，Google 返回加密的链接。要获取真实的链接，您需要告诉 Google 您使用的不是 PowerShell 而是一个普通的浏览器。这可以通过设置浏览器代理字符串。 这段脚本输入一个关键字并返回所有符合搜索关键字，并且大于 2 兆像素的所有图片的原始地址： $SearchItem = &apos;PowerShell&apos; $url = &quot;https://www.google.com/search?q=$SearchItem&amp;espv=210&amp;es_sm=93&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;tbm=isch&amp;tbs=isz:lt%2Cislt:2mp&quot; $browserAgent = &apos;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.146 Safari/537.36&apos; $page = Invoke-WebRequest -Uri $url -UserAgent $browserAgent $page.Links | Where-Object { $_.href -like &apos;*imgres*&apos; } | ForEach-Object { ($_.href -split &apos;imgurl=&apos;)[-1].Split(&apos;&amp;&apos;)[0]} 本文国际来源：Getting Picture URLs from Google Picture Search","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找注册的事件源","slug":"finding-registered-event-sources","date":"2014-04-22T16:00:00.000Z","updated":"2017-03-17T15:26:23.436Z","comments":true,"path":"2014/04/23/finding-registered-event-sources/","link":"","permalink":"http://blog.vichamp.com/2014/04/23/finding-registered-event-sources/","excerpt":"每个 Windows 日志文件都有一个注册的事件源列表。要找出哪个事件源注册到哪个事件日志，您可以直接查询 Windows 注册表。 这段代码将列出所有注册到“System”事件日志的事件源： $LogName = &apos;System&apos; $path = &quot;HKLM:\\System\\CurrentControlSet\\services\\eventlog\\$LogName&quot; Get-ChildItem -Path $path -Name","text":"每个 Windows 日志文件都有一个注册的事件源列表。要找出哪个事件源注册到哪个事件日志，您可以直接查询 Windows 注册表。 这段代码将列出所有注册到“System”事件日志的事件源： $LogName = &apos;System&apos; $path = &quot;HKLM:\\System\\CurrentControlSet\\services\\eventlog\\$LogName&quot; Get-ChildItem -Path $path -Name 本文国际来源：Finding Registered Event Sources","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 智能感知显示变量的技巧","slug":"intellisense-trick-to-show-variables","date":"2014-04-21T16:00:00.000Z","updated":"2017-03-17T15:26:23.436Z","comments":true,"path":"2014/04/22/intellisense-trick-to-show-variables/","link":"","permalink":"http://blog.vichamp.com/2014/04/22/intellisense-trick-to-show-variables/","excerpt":"在 PowerShell ISE 编辑器中，当您键入一个美元符号，将弹出一个智能感知菜单列出当前定义的所有变量。此时当您键入更多字符时，您不仅看见以这些字符开头的变量，而且还能看见在名字任意位置包含这些字符的变量。 要想只看到以您键入的字符开头的变量，请按下 ESC 键关闭智能感知菜单，然后按下 CTRL+SPACE 重新打开它。现在，它将只显示以您键入的字符开头的变量。","text":"在 PowerShell ISE 编辑器中，当您键入一个美元符号，将弹出一个智能感知菜单列出当前定义的所有变量。此时当您键入更多字符时，您不仅看见以这些字符开头的变量，而且还能看见在名字任意位置包含这些字符的变量。 要想只看到以您键入的字符开头的变量，请按下 ESC 键关闭智能感知菜单，然后按下 CTRL+SPACE 重新打开它。现在，它将只显示以您键入的字符开头的变量。 本文国际来源：IntelliSense Trick to Show Variables","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将日志写入自定义的事件日志","slug":"writing-events-to-own-event-logs","date":"2014-04-20T16:00:00.000Z","updated":"2017-03-17T15:26:23.420Z","comments":true,"path":"2014/04/21/writing-events-to-own-event-logs/","link":"","permalink":"http://blog.vichamp.com/2014/04/21/writing-events-to-own-event-logs/","excerpt":"我们常常需要在脚本运行时记录一些信息。如果将日志信息写入文本文件，那么您需要自己维护和管理它们。您还可以使用 Windows 自带的日志系统，并享受它带来的各种便利性。 要达到这个目的，您只需要初始化一个您自己的日志。这只需要由管理员操作一次。操作方法是以管理员身份启动 PowerShell，然后输入一行代码： 这样就好了。您现在有了一个可以记录“LogonScript”、“MaintenanceScript”和“Miscellaneous”事件源的日志文件。接下来，您可能只需再进行一些配置，告诉日志系统日志文件的最大容量，以及容量达到最大值的时候需要做什么操作即可： 现在，您新的日志文件最大可增长到 500MB，并且记录在被新记录覆盖之前可以保持 30 天。 您现在可以关闭您的特权窗口。写日志文件并不需要特殊的权限，并且可以从任何普通的脚本或登录脚本中写入日志。所以打开一个普通的 PowerShell 控制台，然后输入以下代码： 现在记录事件十分简单了，您可以根据需要选择任意的事件编号或消息。唯一的前提是只能写入已注册的事件源。 使用 Get-EventLog，您可以很方便地分析机器中的脚本问题： 所以，既然您可以方便地使用工业级强度的 Windows 日志系统，何须费劲地将信息记在纯文本文件中呢？","text":"我们常常需要在脚本运行时记录一些信息。如果将日志信息写入文本文件，那么您需要自己维护和管理它们。您还可以使用 Windows 自带的日志系统，并享受它带来的各种便利性。 要达到这个目的，您只需要初始化一个您自己的日志。这只需要由管理员操作一次。操作方法是以管理员身份启动 PowerShell，然后输入一行代码： 这样就好了。您现在有了一个可以记录“LogonScript”、“MaintenanceScript”和“Miscellaneous”事件源的日志文件。接下来，您可能只需再进行一些配置，告诉日志系统日志文件的最大容量，以及容量达到最大值的时候需要做什么操作即可： 现在，您新的日志文件最大可增长到 500MB，并且记录在被新记录覆盖之前可以保持 30 天。 您现在可以关闭您的特权窗口。写日志文件并不需要特殊的权限，并且可以从任何普通的脚本或登录脚本中写入日志。所以打开一个普通的 PowerShell 控制台，然后输入以下代码： 现在记录事件十分简单了，您可以根据需要选择任意的事件编号或消息。唯一的前提是只能写入已注册的事件源。 使用 Get-EventLog，您可以很方便地分析机器中的脚本问题： 所以，既然您可以方便地使用工业级强度的 Windows 日志系统，何须费劲地将信息记在纯文本文件中呢？ 本文国际来源：Writing Events to Own Event Logs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 记录所有错误","slug":"logging-all-errors","date":"2014-04-17T16:00:00.000Z","updated":"2017-03-17T15:26:23.405Z","comments":true,"path":"2014/04/18/logging-all-errors/","link":"","permalink":"http://blog.vichamp.com/2014/04/18/logging-all-errors/","excerpt":"在上一个技巧中您学到了只有将 cmdlet 的 -ErrorAction 参数设为 &quot;Stop&quot;，才可以用异常处理器捕获 cmdlet 的错误。但使用这种方式改变了 cmdlet 的行为。它将导致 cmdlet 发生第一个错误的时候停止执行。 请看下一个例子：它将在 windows 文件夹中递归地扫描 PowerShell 脚本。如果您希望捕获错误（例如存取受保护的子文件夹），这将无法工作： try { Get-ChildItem -Path $env:windir -Filter *.ps1 -Recurse -ErrorAction Stop } catch { Write-Warning &quot;Error: $_&quot; } 以上代码将捕获第一个错误，但 cmdlet 将会停止执行，并且不会继续扫描剩下的子文件夹。 如果您只是需要隐藏错误提示信息，但需要完整的执行结果，而且异常处理器不会捕获到任何东西： try { Get-ChildItem -Path $env:windir -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue } catch { Write-Warning &quot;Error: $_&quot; } 所以如果您希望一个 cmdlet 运行时不会中断，并且任然能获取一个您有权限的文件夹的完整列表，那么请不要使用异常处理器。相反，使用 -ErrorVariable 并将错误信息静默地保存到一个变量中。 当该 cmdlet 执行结束时，您可以获取该变量的值并产生一个错误报告： Get-ChildItem -Path $env:windir -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable myErrors Foreach ($incidence in $myErrors) { Write-Warning (&quot;Unable to access &quot; + $incidence.CategoryInfo.TargetName) }","text":"在上一个技巧中您学到了只有将 cmdlet 的 -ErrorAction 参数设为 &quot;Stop&quot;，才可以用异常处理器捕获 cmdlet 的错误。但使用这种方式改变了 cmdlet 的行为。它将导致 cmdlet 发生第一个错误的时候停止执行。 请看下一个例子：它将在 windows 文件夹中递归地扫描 PowerShell 脚本。如果您希望捕获错误（例如存取受保护的子文件夹），这将无法工作： try { Get-ChildItem -Path $env:windir -Filter *.ps1 -Recurse -ErrorAction Stop } catch { Write-Warning &quot;Error: $_&quot; } 以上代码将捕获第一个错误，但 cmdlet 将会停止执行，并且不会继续扫描剩下的子文件夹。 如果您只是需要隐藏错误提示信息，但需要完整的执行结果，而且异常处理器不会捕获到任何东西： try { Get-ChildItem -Path $env:windir -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue } catch { Write-Warning &quot;Error: $_&quot; } 所以如果您希望一个 cmdlet 运行时不会中断，并且任然能获取一个您有权限的文件夹的完整列表，那么请不要使用异常处理器。相反，使用 -ErrorVariable 并将错误信息静默地保存到一个变量中。 当该 cmdlet 执行结束时，您可以获取该变量的值并产生一个错误报告： Get-ChildItem -Path $env:windir -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable myErrors Foreach ($incidence in $myErrors) { Write-Warning (&quot;Unable to access &quot; + $incidence.CategoryInfo.TargetName) } 本文国际来源：Logging All Errors","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 捕获非终止性错误","slug":"catching-non-terminating-errors","date":"2014-04-16T16:00:00.000Z","updated":"2017-03-17T15:26:23.405Z","comments":true,"path":"2014/04/17/catching-non-terminating-errors/","link":"","permalink":"http://blog.vichamp.com/2014/04/17/catching-non-terminating-errors/","excerpt":"非终止性错误是在 cmdlet 内部处理的错误。多数在 cmdlet 中产生的错误都是非终止性错误。 您无法用异常处理器来捕获这些错误。所以虽然在这个例子中有一个异常处理器，它也无法捕获 cmdlet 错误： try { Get-WmiObject -Class Win32_BIOS -ComputerName offlineIamafraid } catch { Write-Warning &quot;Oops, error: $_&quot; } 要捕获非终止性错误，您必须将它们转换为终止性错误。可以通过设置 -ErrorAction 参数为 &quot;Stop&quot; 来实现： try { Get-WmiObject -Class Win32_BIOS -ComputerName offlineIamafraid -ErrorAction Stop } catch { Write-Warning &quot;Oops, error: $_&quot; } 如果您不想一个一个为异常处理器中所有的 cmdlet 添加 -ErrorAction Stop 参数，您可以临时将 $ErrorActionPreference 变量设置为 &quot;Stop&quot;。该设置用于一个 cmdlet 没有显示地设置 -ErrorAction 的情况。","text":"非终止性错误是在 cmdlet 内部处理的错误。多数在 cmdlet 中产生的错误都是非终止性错误。 您无法用异常处理器来捕获这些错误。所以虽然在这个例子中有一个异常处理器，它也无法捕获 cmdlet 错误： try { Get-WmiObject -Class Win32_BIOS -ComputerName offlineIamafraid } catch { Write-Warning &quot;Oops, error: $_&quot; } 要捕获非终止性错误，您必须将它们转换为终止性错误。可以通过设置 -ErrorAction 参数为 &quot;Stop&quot; 来实现： try { Get-WmiObject -Class Win32_BIOS -ComputerName offlineIamafraid -ErrorAction Stop } catch { Write-Warning &quot;Oops, error: $_&quot; } 如果您不想一个一个为异常处理器中所有的 cmdlet 添加 -ErrorAction Stop 参数，您可以临时将 $ErrorActionPreference 变量设置为 &quot;Stop&quot;。该设置用于一个 cmdlet 没有显示地设置 -ErrorAction 的情况。 本文国际来源：Catching Non-Terminating Errors","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 屏蔽终止性错误","slug":"hiding-terminating-errors","date":"2014-04-15T16:00:00.000Z","updated":"2017-03-17T15:26:23.405Z","comments":true,"path":"2014/04/16/hiding-terminating-errors/","link":"","permalink":"http://blog.vichamp.com/2014/04/16/hiding-terminating-errors/","excerpt":"有时候，您会注意到虽然已经为 -ErrorAction 参数指定了 &quot;SilentlyContinue&quot; 值，cmdlet 还是会抛出错误。 -ErrorAction 参数只能隐藏非终止性错误（原本被 cmdlet 处理的错误）。不被 cmdlet 处理的错误称为“终止性错误”。这些错误通常是和安全相关的，并且不能被 -ErrorAction 屏蔽。 所以如果您是一个非管理员用户，虽然用 -ErrorAction 指定了屏蔽错误，以下调用将会抛出一个异常： 要屏蔽终止性错误，您必须使用异常处理器： try { Get-EventLog -LogName Security } catch {}","text":"有时候，您会注意到虽然已经为 -ErrorAction 参数指定了 &quot;SilentlyContinue&quot; 值，cmdlet 还是会抛出错误。 -ErrorAction 参数只能隐藏非终止性错误（原本被 cmdlet 处理的错误）。不被 cmdlet 处理的错误称为“终止性错误”。这些错误通常是和安全相关的，并且不能被 -ErrorAction 屏蔽。 所以如果您是一个非管理员用户，虽然用 -ErrorAction 指定了屏蔽错误，以下调用将会抛出一个异常： 要屏蔽终止性错误，您必须使用异常处理器： try { Get-EventLog -LogName Security } catch {} 本文国际来源：Hiding Terminating Errors","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从所有事件日志中获取全部事件","slug":"getting-events-from-all-event-logs","date":"2014-04-14T16:00:00.000Z","updated":"2017-03-17T15:26:23.389Z","comments":true,"path":"2014/04/15/getting-events-from-all-event-logs/","link":"","permalink":"http://blog.vichamp.com/2014/04/15/getting-events-from-all-event-logs/","excerpt":"最近，一个读者咨询如何从所有事件日志中获取全部事件，并且能将它们保存到文件中。 以下是一个可能的解决方案： # calculate start time (one hour before now) $Start = (Get-Date) - (New-Timespan -Hours 1) $Computername = $env:COMPUTERNAME # Getting all event logs Get-EventLog -AsString -ComputerName $Computername | ForEach-Object { # write status info Write-Progress -Activity &quot;Checking Eventlogs on \\\\$ComputerName&quot; -Status $_ # get event entries and add the name of the log this came from Get-EventLog -LogName $_ -EntryType Error, Warning -After $Start -ComputerName $ComputerName -ErrorAction SilentlyContinue | Add-Member NoteProperty EventLog $_ -PassThru } | # sort descending Sort-Object -Property TimeGenerated -Descending | # select the properties for the report Select-Object EventLog, TimeGenerated, EntryType, Source, Message | # output into grid view window Out-GridView -Title &quot;All Errors &amp; Warnings from \\\\$Computername&quot; 在这个脚本的顶部，您可以设置希望查询的远程主机，以及希望获取的最近小时数。 接下来，这个脚本获取该机器上所有可用的日志文件，然后用一个循环来获取指定时间区间中的错误和警告记录。要想知道哪个事件是来自哪个日志文件，脚本还用 Add-Member 为日志记录添加了一个新的“EventLog”属性。 脚本的执行结果是在一个网格视图的窗口中显示一小时之内的所有错误和警告事件。如果将 Out-GridView 改为 Out-File 或 Export-Csv 将可以把信息保存到磁盘。 请注意远程操作需要 Administrator 特权。远程操作可能需要额外的安全设置。另外，请注意如果以非 Administrator 身份运行该代码，将会收到红色的错误提示信息（因为某些日志，比如说“安全”需要特殊的操作权限）。","text":"最近，一个读者咨询如何从所有事件日志中获取全部事件，并且能将它们保存到文件中。 以下是一个可能的解决方案： # calculate start time (one hour before now) $Start = (Get-Date) - (New-Timespan -Hours 1) $Computername = $env:COMPUTERNAME # Getting all event logs Get-EventLog -AsString -ComputerName $Computername | ForEach-Object { # write status info Write-Progress -Activity &quot;Checking Eventlogs on \\\\$ComputerName&quot; -Status $_ # get event entries and add the name of the log this came from Get-EventLog -LogName $_ -EntryType Error, Warning -After $Start -ComputerName $ComputerName -ErrorAction SilentlyContinue | Add-Member NoteProperty EventLog $_ -PassThru } | # sort descending Sort-Object -Property TimeGenerated -Descending | # select the properties for the report Select-Object EventLog, TimeGenerated, EntryType, Source, Message | # output into grid view window Out-GridView -Title &quot;All Errors &amp; Warnings from \\\\$Computername&quot; 在这个脚本的顶部，您可以设置希望查询的远程主机，以及希望获取的最近小时数。 接下来，这个脚本获取该机器上所有可用的日志文件，然后用一个循环来获取指定时间区间中的错误和警告记录。要想知道哪个事件是来自哪个日志文件，脚本还用 Add-Member 为日志记录添加了一个新的“EventLog”属性。 脚本的执行结果是在一个网格视图的窗口中显示一小时之内的所有错误和警告事件。如果将 Out-GridView 改为 Out-File 或 Export-Csv 将可以把信息保存到磁盘。 请注意远程操作需要 Administrator 特权。远程操作可能需要额外的安全设置。另外，请注意如果以非 Administrator 身份运行该代码，将会收到红色的错误提示信息（因为某些日志，比如说“安全”需要特殊的操作权限）。 本文国际来源：Getting Events From All Event Logs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 高效运行后台任务","slug":"running-background-jobs-efficiently","date":"2014-04-13T16:00:00.000Z","updated":"2017-03-17T15:26:23.389Z","comments":true,"path":"2014/04/14/running-background-jobs-efficiently/","link":"","permalink":"http://blog.vichamp.com/2014/04/14/running-background-jobs-efficiently/","excerpt":"如前一个技巧所述，用后台任务来同步运行任务往往效率不高。当后台任务返回的数据量增加时，它的执行性能变得更差。 一个更高效的办法是用进程内任务。它们在同一个 PowerShell 实例内部的不同线程中独立运行，所以不需要将返回值序列化。 以下是一个用 PowerShell 线程功能，运行两个后台线程和一个前台线程的例子。为了使任务真正长时间运行，我们为每个任务在业务代码之外使用了 Start-Sleep 命令： $start = Get-Date $task1 = { Start-Sleep -Seconds 4; Get-Service } $task2 = { Start-Sleep -Seconds 5; Get-Service } $task3 = { Start-Sleep -Seconds 3; Get-Service } # run 2 in separate threads, 1 in the foreground $thread1 = [PowerShell]::Create() $job1 = $thread1.AddScript($task1).BeginInvoke() $thread2 = [PowerShell]::Create() $job2 = $thread2.AddScript($task2).BeginInvoke() $result3 = Invoke-Command -ScriptBlock $task3 do { Start-Sleep -Milliseconds 100 } until ($job1.IsCompleted -and $job2.IsCompleted) $result1 = $thread1.EndInvoke($job1) $result2 = $thread2.EndInvoke($job2) $thread1.Runspace.Close() $thread1.Dispose() $thread2.Runspace.Close() $thread2.Dispose() $end = Get-Date Write-Host -ForegroundColor Red ($end - $start).TotalSeconds 如果依次执行这三个任务，分别执行 Start-Sleep 语句将至少消耗 12 秒。事实上该脚本只消耗 5 秒多一点。处理结果分别为 $result1，$result2 和 $result3。相对后台任务而言，返回大量数据基本不会造成时间消耗。","text":"如前一个技巧所述，用后台任务来同步运行任务往往效率不高。当后台任务返回的数据量增加时，它的执行性能变得更差。 一个更高效的办法是用进程内任务。它们在同一个 PowerShell 实例内部的不同线程中独立运行，所以不需要将返回值序列化。 以下是一个用 PowerShell 线程功能，运行两个后台线程和一个前台线程的例子。为了使任务真正长时间运行，我们为每个任务在业务代码之外使用了 Start-Sleep 命令： $start = Get-Date $task1 = { Start-Sleep -Seconds 4; Get-Service } $task2 = { Start-Sleep -Seconds 5; Get-Service } $task3 = { Start-Sleep -Seconds 3; Get-Service } # run 2 in separate threads, 1 in the foreground $thread1 = [PowerShell]::Create() $job1 = $thread1.AddScript($task1).BeginInvoke() $thread2 = [PowerShell]::Create() $job2 = $thread2.AddScript($task2).BeginInvoke() $result3 = Invoke-Command -ScriptBlock $task3 do { Start-Sleep -Milliseconds 100 } until ($job1.IsCompleted -and $job2.IsCompleted) $result1 = $thread1.EndInvoke($job1) $result2 = $thread2.EndInvoke($job2) $thread1.Runspace.Close() $thread1.Dispose() $thread2.Runspace.Close() $thread2.Dispose() $end = Get-Date Write-Host -ForegroundColor Red ($end - $start).TotalSeconds 如果依次执行这三个任务，分别执行 Start-Sleep 语句将至少消耗 12 秒。事实上该脚本只消耗 5 秒多一点。处理结果分别为 $result1，$result2 和 $result3。相对后台任务而言，返回大量数据基本不会造成时间消耗。 本文国际来源：Running Background Jobs Efficiently","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - PowerShell 中的并行处理","slug":"parallel-processing-in-powershell","date":"2014-04-10T16:00:00.000Z","updated":"2017-03-17T15:26:23.389Z","comments":true,"path":"2014/04/11/parallel-processing-in-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/04/11/parallel-processing-in-powershell/","excerpt":"如果想提升一个脚本的执行速度，您也许会发现后台任务十分有用。它们适用于做大量并发处理的脚本。 PowerShell 是单线程的，一个时间只能处理一件事。使用后台任务时，后台会创建额外的 PowerShell 进程并且共享负荷。这只在任务彼此独立，并且后台任务不产生很多数据的情况下能很好地工作。从后台任务中发回数据是一个开销很大的过程，并且很有可能把节省出来的时间给消耗了，导致脚本执行起来反而更慢。 以下是三个可以并发执行的任务： $start = Get-Date # get all hotfixes $task1 = { Get-Hotfix } # get all scripts in your profile $task2 = { Get-Service | Where-Object Status -eq Running } # parse log file $task3 = { Get-Content -Path $env:windir\\windowsupdate.log | Where-Object { $_ -like &apos;*successfully installed*&apos; } } # run 2 tasks in the background, and 1 in the foreground task $job1 = Start-Job -ScriptBlock $task1 $job2 = Start-Job -ScriptBlock $task2 $result3 = Invoke-Command -ScriptBlock $task3 # wait for the remaining tasks to complete (if not done yet) $null = Wait-Job -Job $job1, $job2 # now they are done, get the results $result1 = Receive-Job -Job $job1 $result2 = Receive-Job -Job $job2 # discard the jobs Remove-Job -Job $job1, $job2 $end = Get-Date Write-Host -ForegroundColor Red ($end - $start).TotalSeconds 在一个测试环境中，执行所有三个任务消耗 5.9 秒。三个任务的结果分别保存到 $result1，$result2，$result3。 我们测试一下三个任务在前台顺序执行所消耗的时间： $start = Get-Date # get all hotfixes $task1 = { Get-Hotfix } # get all scripts in your profile $task2 = { Get-Service | Where-Object Status -eq Running } # parse log file $task3 = { Get-Content -Path $env:windir\\windowsupdate.log | Where-Object { $_ -like &apos;*successfully installed*&apos; } } # run them all in the foreground: $result1 = Invoke-Command -ScriptBlock $task1 $result2 = Invoke-Command -ScriptBlock $task2 $result3 = Invoke-Command -ScriptBlock $task3 $end = Get-Date Write-Host -ForegroundColor Red ($end - $start).TotalSeconds 这段代码仅仅执行了 5.05 秒。所以后台任务只对于长期运行并且各自占用差不多时间的任务比较有效。由于这三个测试任务返回了大量的数据，所以并发执行带来的好处差不多被将执行结果序列化并传回前台进程的过程给抵消掉了。","text":"如果想提升一个脚本的执行速度，您也许会发现后台任务十分有用。它们适用于做大量并发处理的脚本。 PowerShell 是单线程的，一个时间只能处理一件事。使用后台任务时，后台会创建额外的 PowerShell 进程并且共享负荷。这只在任务彼此独立，并且后台任务不产生很多数据的情况下能很好地工作。从后台任务中发回数据是一个开销很大的过程，并且很有可能把节省出来的时间给消耗了，导致脚本执行起来反而更慢。 以下是三个可以并发执行的任务： $start = Get-Date # get all hotfixes $task1 = { Get-Hotfix } # get all scripts in your profile $task2 = { Get-Service | Where-Object Status -eq Running } # parse log file $task3 = { Get-Content -Path $env:windir\\windowsupdate.log | Where-Object { $_ -like &apos;*successfully installed*&apos; } } # run 2 tasks in the background, and 1 in the foreground task $job1 = Start-Job -ScriptBlock $task1 $job2 = Start-Job -ScriptBlock $task2 $result3 = Invoke-Command -ScriptBlock $task3 # wait for the remaining tasks to complete (if not done yet) $null = Wait-Job -Job $job1, $job2 # now they are done, get the results $result1 = Receive-Job -Job $job1 $result2 = Receive-Job -Job $job2 # discard the jobs Remove-Job -Job $job1, $job2 $end = Get-Date Write-Host -ForegroundColor Red ($end - $start).TotalSeconds 在一个测试环境中，执行所有三个任务消耗 5.9 秒。三个任务的结果分别保存到 $result1，$result2，$result3。 我们测试一下三个任务在前台顺序执行所消耗的时间： $start = Get-Date # get all hotfixes $task1 = { Get-Hotfix } # get all scripts in your profile $task2 = { Get-Service | Where-Object Status -eq Running } # parse log file $task3 = { Get-Content -Path $env:windir\\windowsupdate.log | Where-Object { $_ -like &apos;*successfully installed*&apos; } } # run them all in the foreground: $result1 = Invoke-Command -ScriptBlock $task1 $result2 = Invoke-Command -ScriptBlock $task2 $result3 = Invoke-Command -ScriptBlock $task3 $end = Get-Date Write-Host -ForegroundColor Red ($end - $start).TotalSeconds 这段代码仅仅执行了 5.05 秒。所以后台任务只对于长期运行并且各自占用差不多时间的任务比较有效。由于这三个测试任务返回了大量的数据，所以并发执行带来的好处差不多被将执行结果序列化并传回前台进程的过程给抵消掉了。 本文国际来源：Parallel Processing in PowerShell","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将 Tick 转换为真实的日期","slug":"converting-ticks-into-real-date","date":"2014-04-09T16:00:00.000Z","updated":"2017-03-17T15:26:23.373Z","comments":true,"path":"2014/04/10/converting-ticks-into-real-date/","link":"","permalink":"http://blog.vichamp.com/2014/04/10/converting-ticks-into-real-date/","excerpt":"Active Directory 内部使用 tick （从 1601 年起的百纳秒数）来表示日期和时间。在以前，要将这个大数字转换为人类可读的日期和时间是很困难的。以下是一个很简单的办法： [DateTime]::FromFileTime(635312826377934727) 类似地，要将一个日期转换为 tick 数，使用以下方法：","text":"Active Directory 内部使用 tick （从 1601 年起的百纳秒数）来表示日期和时间。在以前，要将这个大数字转换为人类可读的日期和时间是很困难的。以下是一个很简单的办法： [DateTime]::FromFileTime(635312826377934727) 类似地，要将一个日期转换为 tick 数，使用以下方法： 本文国际来源：Converting Ticks into Real Date","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 记录脚本的运行时间","slug":"logging-script-runtime","date":"2014-04-08T16:00:00.000Z","updated":"2017-03-17T15:26:23.373Z","comments":true,"path":"2014/04/09/logging-script-runtime/","link":"","permalink":"http://blog.vichamp.com/2014/04/09/logging-script-runtime/","excerpt":"如果您想记录脚本的运行时间，您可以使用 Measure-Command，但是这个 cmdlet 仅适合诊断目的，并且没有计算输出时间。 另一种方法是创建两个快照，并且在结束时计算时间差。 这段代码将告诉您 Get-Hotfix cmdlet 的执行时间，包括输出数据的时间： $start = Get-Date Get-HotFix $end = Get-Date Write-Host -ForegroundColor Red (&apos;Total Runtime: &apos; + ($end - $start).TotalSeconds)","text":"如果您想记录脚本的运行时间，您可以使用 Measure-Command，但是这个 cmdlet 仅适合诊断目的，并且没有计算输出时间。 另一种方法是创建两个快照，并且在结束时计算时间差。 这段代码将告诉您 Get-Hotfix cmdlet 的执行时间，包括输出数据的时间： $start = Get-Date Get-HotFix $end = Get-Date Write-Host -ForegroundColor Red (&apos;Total Runtime: &apos; + ($end - $start).TotalSeconds) 本文国际来源：Logging Script Runtime","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 修正 Excel CSV 的编码","slug":"fixing-encoding-for-excel-csv","date":"2014-04-07T16:00:00.000Z","updated":"2017-03-17T15:26:23.373Z","comments":true,"path":"2014/04/08/fixing-encoding-for-excel-csv/","link":"","permalink":"http://blog.vichamp.com/2014/04/08/fixing-encoding-for-excel-csv/","excerpt":"当您将 Microsoft Excel 的数据保存为 CSV 格式时，很不幸的是保存的编码和 Import-Csv 的缺省编码并不匹配。所以当您将 CSV 文件导入 PowerShell 时，无论您指定哪种编码，特殊字符都会变成乱码。 以下是一个我从 Excel 导出的 list.csv 文件，它包含一些特殊字符。如果您使用缺省编码，特殊字符会变成乱码，并且如果您指定了 -Encoding 参数，无论您传什么值，特殊字符都不会显示回原来正常的状态： 当您模拟在这些场景中 Import-Csv 的行为时，它很意外地可以完美处理： 这说明要正确地读取 Excel CSV 文件，您必须显式地指定“缺省”编码（这引出了一个问题：当您未指定编码的时候，缺省使用的是什么编码）：","text":"当您将 Microsoft Excel 的数据保存为 CSV 格式时，很不幸的是保存的编码和 Import-Csv 的缺省编码并不匹配。所以当您将 CSV 文件导入 PowerShell 时，无论您指定哪种编码，特殊字符都会变成乱码。 以下是一个我从 Excel 导出的 list.csv 文件，它包含一些特殊字符。如果您使用缺省编码，特殊字符会变成乱码，并且如果您指定了 -Encoding 参数，无论您传什么值，特殊字符都不会显示回原来正常的状态： 当您模拟在这些场景中 Import-Csv 的行为时，它很意外地可以完美处理： 这说明要正确地读取 Excel CSV 文件，您必须显式地指定“缺省”编码（这引出了一个问题：当您未指定编码的时候，缺省使用的是什么编码）： 本文国际来源：Fixing Encoding for Excel CSV","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 读取整个文本文件","slug":"reading-all-text","date":"2014-04-06T16:00:00.000Z","updated":"2017-03-17T15:26:23.370Z","comments":true,"path":"2014/04/07/reading-all-text/","link":"","permalink":"http://blog.vichamp.com/2014/04/07/reading-all-text/","excerpt":"您可以用 Get-Content 来读入整个文本文件。但是，Get-Content 是逐行返回文件的内容，您得到的是一个 string 数组，并且换行符被去掉了。 要一次性读取整个文本文件，从 PowerShell 3.0 开始，您可以使用 -Raw 参数（它还有个好处，能够大大加快读取文件的速度）。 所以通过以下代码您可以获得一个字符串数组，每个元素是一行文本： Length 属性表示文件的行数。 以下代码一次性读取整个文本文件，返回单个字符串： 这回，Length 属性表示整个文件的字符数，并且读取文件的速度大大提高（虽然也更占内存了）。 那种方法更好？这取决于您要如何使用这些数据。","text":"您可以用 Get-Content 来读入整个文本文件。但是，Get-Content 是逐行返回文件的内容，您得到的是一个 string 数组，并且换行符被去掉了。 要一次性读取整个文本文件，从 PowerShell 3.0 开始，您可以使用 -Raw 参数（它还有个好处，能够大大加快读取文件的速度）。 所以通过以下代码您可以获得一个字符串数组，每个元素是一行文本： Length 属性表示文件的行数。 以下代码一次性读取整个文本文件，返回单个字符串： 这回，Length 属性表示整个文件的字符数，并且读取文件的速度大大提高（虽然也更占内存了）。 那种方法更好？这取决于您要如何使用这些数据。 本文国际来源：Reading All Text","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 存储秘密数据","slug":"storing-secret-data","date":"2014-04-03T16:00:00.000Z","updated":"2017-03-17T15:26:23.352Z","comments":true,"path":"2014/04/04/storing-secret-data/","link":"","permalink":"http://blog.vichamp.com/2014/04/04/storing-secret-data/","excerpt":"如果您想以只有您能获取的方式保存敏感数据，您可以使用这个有趣的方法：将明文转换成密文，需要时将密文转换回明文，并将它保存到磁盘中： $storage = &quot;$env:temp\\secretdata.txt&quot; $mysecret = &apos;Hello, I am safe.&apos; $mysecret | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString | Out-File -FilePath $storage 当您打开该文件的时候，它读起来像这个样子： 您的秘密被 Windows 自带的数据保护 API(DPAPI) 用您的身份和机器作为密钥加密。所以只有您（或任何以您的身份运行的进程）可以将该密文解密，而且只能在加密时所用的计算机上解密。 要得到明文，请使用这段代码： $storage = &quot;$env:temp\\secretdata.txt&quot; $secureString = Get-Content -Path $storage | ConvertTo-SecureString $ptr = [System.Runtime.InteropServices.Marshal]::SecureStringToGlobalAllocUnicode($secureString) $mysecret = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($ptr) $mysecret 它可以正常使用——您可以获得和加密前一模一样的文本。 现在，以其他人的身份试一下。您会发现其他人无法解密该加密文件。而且您在别的机器上也无法解密。","text":"如果您想以只有您能获取的方式保存敏感数据，您可以使用这个有趣的方法：将明文转换成密文，需要时将密文转换回明文，并将它保存到磁盘中： $storage = &quot;$env:temp\\secretdata.txt&quot; $mysecret = &apos;Hello, I am safe.&apos; $mysecret | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString | Out-File -FilePath $storage 当您打开该文件的时候，它读起来像这个样子： 您的秘密被 Windows 自带的数据保护 API(DPAPI) 用您的身份和机器作为密钥加密。所以只有您（或任何以您的身份运行的进程）可以将该密文解密，而且只能在加密时所用的计算机上解密。 要得到明文，请使用这段代码： $storage = &quot;$env:temp\\secretdata.txt&quot; $secureString = Get-Content -Path $storage | ConvertTo-SecureString $ptr = [System.Runtime.InteropServices.Marshal]::SecureStringToGlobalAllocUnicode($secureString) $mysecret = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($ptr) $mysecret 它可以正常使用——您可以获得和加密前一模一样的文本。 现在，以其他人的身份试一下。您会发现其他人无法解密该加密文件。而且您在别的机器上也无法解密。 本文国际来源：Storing Secret Data","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用加密文件系统（EFS）来保护密码","slug":"using-encrypting-file-system-efs-to-protect-passwords","date":"2014-04-02T16:00:00.000Z","updated":"2017-03-17T15:26:23.352Z","comments":true,"path":"2014/04/03/using-encrypting-file-system-efs-to-protect-passwords/","link":"","permalink":"http://blog.vichamp.com/2014/04/03/using-encrypting-file-system-efs-to-protect-passwords/","excerpt":"如果您必须在脚本中以硬编码的方式包含密码和其它隐私信息（正常情况下应避免使用），那么您还可以通过 EFS（加密文件系统）的方式来保障安全性。加密的脚本只能被加密者读取（和执行），所以只有您在自己的机器上能运行该脚本。 一下是加密一个 PowerShell 脚本的简单方法： # create some sample script # replace path with some real-world existing script if you want # and remove the line that creates the script $path = &quot;$env:temp\\test.ps1&quot; &quot;Write-Host &apos;I run only for my master.&apos;&quot; &gt; $path $file = Get-Item -Path $path $file.Encrypt() 当您运行这段脚本时，它将在您的临时文件夹中创建一个用 EFS 加密的新的 PowerShell 脚本（如果您见到一条错误提示信息，那么很有可能您机器上的 EFS 不可用或者被禁用了）。 加密之后，该文件在 Windows 资源管理器中呈现绿色，并且只有您能够运行它。别人无法看见源代码。 请注意在许多企业环境中，EFS 系统是通过恢复密钥部署的。指定的维护人员可以通过主密钥解密文件。如果没有主密钥，一旦您丢失了您的 EFS 证书，就连您也无法查看或运行加密的脚本。","text":"如果您必须在脚本中以硬编码的方式包含密码和其它隐私信息（正常情况下应避免使用），那么您还可以通过 EFS（加密文件系统）的方式来保障安全性。加密的脚本只能被加密者读取（和执行），所以只有您在自己的机器上能运行该脚本。 一下是加密一个 PowerShell 脚本的简单方法： # create some sample script # replace path with some real-world existing script if you want # and remove the line that creates the script $path = &quot;$env:temp\\test.ps1&quot; &quot;Write-Host &apos;I run only for my master.&apos;&quot; &gt; $path $file = Get-Item -Path $path $file.Encrypt() 当您运行这段脚本时，它将在您的临时文件夹中创建一个用 EFS 加密的新的 PowerShell 脚本（如果您见到一条错误提示信息，那么很有可能您机器上的 EFS 不可用或者被禁用了）。 加密之后，该文件在 Windows 资源管理器中呈现绿色，并且只有您能够运行它。别人无法看见源代码。 请注意在许多企业环境中，EFS 系统是通过恢复密钥部署的。指定的维护人员可以通过主密钥解密文件。如果没有主密钥，一旦您丢失了您的 EFS 证书，就连您也无法查看或运行加密的脚本。 本文国际来源：Using Encrypting File System (EFS) to Protect Passwords","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"[转] 浅谈Microsoft MVP","slug":"mvp","date":"2014-04-02T16:00:00.000Z","updated":"2017-03-17T15:26:23.352Z","comments":true,"path":"2014/04/03/mvp/","link":"","permalink":"http://blog.vichamp.com/2014/04/03/mvp/","excerpt":"微软MVP，这个自1993 年开始在社群上出现的计划(MVP Award Program)，目前在全球已经累积超过5,000 人，其中在台湾已经有一百多人了，包括我在内，这个计画现在已经成为以微软技术为主的技术社群(technology community) 中，最高等级的奖励计画，虽然它是由微软主办，但是它是以社群为主的一个计画，对于在社群中活跃​​但可能不知名的技术高手或是专家们，是一个很具吸引力的计画，因为它除了提供实质性，非金钱价值的奖励以外，还提供了出名的机会（出席研讨会，主持场次，与微软共同推广技术等），所以有很多走微软技术的人都很想拿到它。 不过，据我个人的观察，似乎很多人都 只想拿到它，但却忽略了它背后真正的意义 。","text":"微软MVP，这个自1993 年开始在社群上出现的计划(MVP Award Program)，目前在全球已经累积超过5,000 人，其中在台湾已经有一百多人了，包括我在内，这个计画现在已经成为以微软技术为主的技术社群(technology community) 中，最高等级的奖励计画，虽然它是由微软主办，但是它是以社群为主的一个计画，对于在社群中活跃​​但可能不知名的技术高手或是专家们，是一个很具吸引力的计画，因为它除了提供实质性，非金钱价值的奖励以外，还提供了出名的机会（出席研讨会，主持场次，与微软共同推广技术等），所以有很多走微软技术的人都很想拿到它。 不过，据我个人的观察，似乎很多人都 只想拿到它，但却忽略了它背后真正的意义 。 到底什么是MVP ? 微软将MVP 定义为： 微软最有价值专家是微软的一个年度奖项。MVP来自于各行各业，但是他们都有者两个共同点: 精通某一个微软产品或技术领域。 愿意与他人分享技术经验。 在微软，我们视MVP为 最有价值的合作伙伴 。透过奖励，肯定、跟支持这些优秀的技术人员，微软并且和这些重要伙伴保持紧密的联系。 对于社群来说，MVP是一种称号，也是一种地位的象征，它的地位来自于微软官方的认可，但它和MCP Program不同，它是由微软内部针对申请人提交的申请书审查，针对事实来做审核，不像MCP Program被人诟病说用考古题就可以考到一样，它比MCP更具事实上的说服力，而且 当选MVP 大多数的原因是解决问题的数量有一定程度 ，因此解决问题能力强的人，变成MVP的机率就会很高。这也就是为什么MVP会被当成解决问题的专家的原因，毕竟解决问题不像考试那样，考试是在一个给定且没有额外空间可以假设的情况下的解决问题，但在 社群中的问题，多半都和当时的环境相依，且没有固定的答案 ，只有顺利解决问题的才是正解，这和考试有标准答案是差很多的。 因此，MVP除了是一个奖项，称号与名声以外，它也是一种社群责任（community responsibility），针对MVP的主要技术(award technology)而言，MVP必须具备一定水准，且具有低错误率的回答（在社群中）与解决问题（社群与现实环境）的能力，而 这些能力全是厚植于自己的学识与经验，以及对技术的热情。 MVP 所需要的能力 微软在甄选MVP时，会以九种评价目标来评价申请人： 积极参与Microsoft Online Community 线上社群 回答的问题远超过发问的问题 杰出的线上社群表现 大量而精确的回答 在某一领域、产品或开发训练拥有广泛的知识 某一领域或特定产品中知名的专家或「长老」 对Microsoft 抱持中立或是正面的态度 资讯服务的支持者 亲切的客服技巧与态度 一般而言，被考虑授予Microsoft MVP地位的人员，在这九项甄选条件中至少要具备四项。特别要强调的是，这是一项目标，而不是标准。最后，Microsoft MVP能够就Microsoft技术在群组中展现重大成就并提供重大支援的候选人会优先列入考量。他们为所属社群(尤其是Microsoft新闻群组、网站、清单服务、留言板等线上存取的社群)增添了持续的品质，在了解他们所支援的技术及永远乐于与人分享热忱和专业方面，受到同侪的信任并且被视为领袖。 基于Microsoft的策略、预算限制及方案的公正性，被提名的候选人不可能全部都被授予Microsoft MVP 的身份。换言之，最可能获颁这项殊荣的被提名人，必须在支援社群的影响力方面以明确的评量标准，在「所有」这九项甄选条件中展现足够的实力：例如，在MSNEWS 新闻群组中回应的比例；他们自己主持的线上社群(如果有) 服务了多少人；他们去年发表演说的免费简报活动(如果有) 有几次、有多少人参与；他们志愿主持的使用者群组(如果有) 有哪些直接与间接的影响，等等。到了最后评鉴的时候，每一位候选人都会依据候选人各自的评量标准，以个案方式逐一审核并决定是否授予这项殊荣。这也是每两年一次由各MVP Leads及Microsoft MVP 专案经理与Microsoft 各产品群组及各分公司共同举行的评审程序的一部分。 最后要强调，「MVP方案」的主要目的， 是要透过严格的品质保证专业、公正性和专业精神，在Microsoft社群成员中挑选出「好手中的好手」并且授予这项地位 。 因此，MVP对于技术的要求，便是以能够让社群（不一定是指讨论区）的参与者，认为MVP的申请人是具有一定程度技术水准，并且将他视为技术领导者(technology leads )。除了 ​​技术以外，对于技术的热情也是评价条件之一，这也是MVP每年都要重新申请的关系，技术热情与水准如果能够一直延续甚至提升的话，那连选连任也是很正常的，MVP社群中也有连任十几届的。 如何成为MVP，以及MVP 奖励 如果你认为你具有前段所说的那些条件，那么你可以透过下列管道来报名： 毛遂自荐，在台湾微软的社群网站中申请报名表填写，并提交给台湾MVP团队申请。 由微软MVP团队主动发掘，因此如果你收到twmvp@microsoft.com寄来的邮件，可别删掉它，因为可能是MVP报名表（我第一次参与MVP甄选就是由这个管道参加的）。 由其他的MVP 推荐，或由所在的社群团队向微软推荐。 台湾微软每年会以季为单位来开放MVP 甄选的报名，通常是每个的1, 4, 7, 10 四个月，而在当季的MVP 录取名单公布时，随即开始下一季的报名程序，不论你是新科MVP 申请人，还是寻求连任MVP 的申请人，都需要在特定期间报名（连任者会由微软主动通知）。 当选MVP 的申请人，可以得到下列的非金钱价值的奖励： MSDN Premium with Visual Studio Professional或TechNet Plus一年期 免费订阅资格 （这个我想一定是最吸引人的条件，因为它的价值就已经有数十万元了） MVP 证书与奖品（每年都不同，且不论是新任或连任都有）。 MVP logo 的使用权，只有在MVP 当选有效期间才可用。 存取MVP 成员网站，以及MVP Connect Services 的权利。 MVP 具有Microsoft Company Store Online 的$150 美元奖品配额，可自由选择总价值为$150 美元的任何商品。 受邀参与MVP 活动，微软活动，以及每年会办的MVP Global Summit (全球年会)。 可能不定时会收到微软的不同奖项（例如Visual Studio Customer Feedback 贡献奖座等）。 与微软的合作机会，不过这要看你与微软当地子公司的员工的关系与互动。 另外，当选MVP 的申请人都必须要填写一份MVP Non-disclosure agreement (NDA)，以确保MVP 具有保密责任，因为微软会和MVP 交流一些未公开的技术情报，这些都是微软的机密，因此需要透过NDA 来建立微软与MVP 间自由沟通的桥梁。 MVP 迷思与责任 外界看MVP 很有名气，但事实上并非如此。 在社群上，MVP总是被外界投以关切的眼光，同时也被赋与较高的技术期望，外界会特别去要求MVP的解答水准，这在社群上很常见，而对于MVP本身而言，也会不自主的对自己的解答产生责任感，并且会不自觉的提升自己的解答水平，让社群可以更能应用解答的内容，来达成自己需要的东西或完成工作，但MVP也是人，也有不会的地方，因此 MVP不该被视为技术之神（真正的神是无所不知的，但MVP也有不会的地方，因此不能相提并论） ，也不该被赋与超出水准太多的期望。MVP本身则也应该要致力保持技术水准，或是扩大自己的涉猎领域，以整合各种技术来提高解答或解决问题的能力。 另一种很常见的错误认知是， MVP被当作微软的员工，其实MVP不是微软的员工 ，这群人是来自社会各个层面，各自拥有不同的专业技术，但都有相同的热情与对于技术的执着，被微软认可授予称号所组成的，我想有可能是因为MVP经常参与微软活动，论坛或是开课，而让外界对MVP有所误解，不过MVP真的不是微软的员工， MVP可没有进入微软公司的智慧卡，而且MVP去微软仍然要走8F的访客入口…。 我个人在MVP 社群中已经待了六年（2004-2009），时间虽然不够长，但也看了不少来申请MVP 的人们，有可以连任很多次的，但也只有一次就没了的，当然也有申请没被录取的，一样米养百样人，各式各样的人都有，而且每个人对MVP 的看法可能也都不相同，不过我个人认为在MVP 这个团体中，有几个共通点： 非常乐于经营技术社群，或是blog，并且分享技术心得，应用与概念等。 具有高度的技术热情，不是三分钟热度型的，这会反应在很多方面。 具有亲和力，不论是在社群中或是课堂中，不过这不代表MVP 会特别容忍小白行为。 乐于推广微软技术，并且运用微软技术发展出许多有趣的应用。 彼此会相互支援，除了问题解答外，也包括工作机会或是合作机会等，这些机会都是植基于 相互的信任 。 只是，在这六年之中，我也看过一些MVP 的害群之马，让MVP 的名声受到质疑或是备受批评等，不过这些人其实很少很少，但在社会总关注负面消息的氛围之下，负面的资讯总是容易被关注，所以通常99% 的MVP 贡献，都会被1% 的负面消息所掩盖… 另外，由于MVP的甄选条件使然， 有部份申请人会为了想在申请书上好看一点，便在社群中或是部落格中使用一些奇怪的旁门左道，来炒高自己的评价或是人气指数 ，或者是其他可以被微软认可的条件，然而，这 基本上已违反了MVP间不成文的职业道德规范 ，它也许会让你当选MVP，但本质上这是一种不正当手段，且很容易被MVP团体中的其他成员识破，反而会让自己陷入道德疑虑的泥淖中，想要获得其他MVP在相互支援上的协助的话，会变得非常困难，其中一个原因，便是对你的道德有所质疑。 而且，申请人应该要有一个观念，在微软公布你录取的名单的时候，MVP的责任就已经产生了，申请人在社群，课堂，著作，技术分享与解决问题的各项表现，都会被外界当成评价你，以及MVP团体水准的明确指标，所谓一粒老鼠屎坏了一锅粥，身为MVP团体中的成员之一，应该要有致力维持MVP团体名声以及评价的责任，而不是只想捞到好处，拍拍屁股就走人，甚至于把MVP的评价搞坏后被大家踢出这个团体，业界是很小的，基本的职业水准和职业道德是不可轻忽的。 外部来源（正体中文）","categories":[{"name":"mvp","slug":"mvp","permalink":"http://blog.vichamp.com/categories/mvp/"}],"tags":[{"name":"microsoft","slug":"microsoft","permalink":"http://blog.vichamp.com/tags/microsoft/"},{"name":"mvp","slug":"mvp","permalink":"http://blog.vichamp.com/tags/mvp/"}],"keywords":[{"name":"mvp","slug":"mvp","permalink":"http://blog.vichamp.com/categories/mvp/"}]},{"title":"PowerShell 技能连载 - 验证 UNC 路径","slug":"testing-unc-paths","date":"2014-04-01T16:00:00.000Z","updated":"2017-03-17T15:26:23.336Z","comments":true,"path":"2014/04/02/testing-unc-paths/","link":"","permalink":"http://blog.vichamp.com/2014/04/02/testing-unc-paths/","excerpt":"Test-Path 命令可以检测指定的文件或文件夹是否存在。它对于使用盘符的路径工作正常，但是对于纯 UNC 路径则不可用。 最简单的情况下，这应该返回 $true，并且它的确返回了 $true（假设您没有禁用管理员共享）： $path = &apos;\\\\127.0.0.1\\c$&apos; Test-Path -Path $path 现在，同样的代码却返回 $false： Set-Location -Path HKCU:\\ $path = &apos;\\\\127.0.0.1\\c$&apos; Test-Path -Path $path 如果路径不是使用一个盘符，PowerShell 将使用当前路径，如果该路径指向一个非文件系统位置，Test-Path 将在该 provider 的上下文中解析 UNC 路径。由于注册表中没有这个路径，Test-Path 返回 $false。 要让 Test-Path 在 UNC 路径下可靠地工作，请确保您在 UNC 路径之前添加了 FileSystem provider。现在，无论当前位于哪个驱动器路径，结果都是正确的： Set-Location -Path HKCU:\\ $path = &apos;filesystem::\\\\127.0.0.1\\c$&apos; Test-Path -Path $path","text":"Test-Path 命令可以检测指定的文件或文件夹是否存在。它对于使用盘符的路径工作正常，但是对于纯 UNC 路径则不可用。 最简单的情况下，这应该返回 $true，并且它的确返回了 $true（假设您没有禁用管理员共享）： $path = &apos;\\\\127.0.0.1\\c$&apos; Test-Path -Path $path 现在，同样的代码却返回 $false： Set-Location -Path HKCU:\\ $path = &apos;\\\\127.0.0.1\\c$&apos; Test-Path -Path $path 如果路径不是使用一个盘符，PowerShell 将使用当前路径，如果该路径指向一个非文件系统位置，Test-Path 将在该 provider 的上下文中解析 UNC 路径。由于注册表中没有这个路径，Test-Path 返回 $false。 要让 Test-Path 在 UNC 路径下可靠地工作，请确保您在 UNC 路径之前添加了 FileSystem provider。现在，无论当前位于哪个驱动器路径，结果都是正确的： Set-Location -Path HKCU:\\ $path = &apos;filesystem::\\\\127.0.0.1\\c$&apos; Test-Path -Path $path 本文国际来源：Testing UNC Paths","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 启用 PowerShell 远程管理","slug":"enabling-powershell-remoting","date":"2014-03-31T16:00:00.000Z","updated":"2017-03-17T15:26:23.336Z","comments":true,"path":"2014/04/01/enabling-powershell-remoting/","link":"","permalink":"http://blog.vichamp.com/2014/04/01/enabling-powershell-remoting/","excerpt":"如果您希望用 PowerShell 远程管理来执行另一台机器上的命令或脚本，那么您需要以完整管理员权限启用目标机器上的远程管理功能： 在客户端，当您在同一个域中并且使用同一个域用户登录时，您不需要做任何额外的事情。 如果您希望通过非 Kerberos 验证方式连接目标计算机时（目标计算机在另一个域中，或您希望使用 IP 地址或非完整限定 DNS 名来连接），那么您需要以管理员权限运行一次以下代码： 将信任的主机设置为“*”之后，PowerShell 将允许您连接任何 IP 或机器名，如果无法用 Kerberos 验证身份，将使用 NTLM 验证。所以该设置不影响哪些人可以和该主机通信（通过防火墙规则设置）。它只是告诉 PowerShell 您将在 Kerberos 不可用的时候使用（更不安全一些的）NTLM 验证方式。NTLM 更不安全一些，因为它无法知道目标计算机是否真的是您想要访问的计算机。Kerberos 认证有相互认证过程，而 NTLM 没有。您的凭据直接被发送到指定的计算机中。假如当一个攻击者有机会用他的机器替换掉目标机器，并且占据了它的 IP 地址，而您使用 NTLM 的话，不会得到任何通知。 注意：如果你打开了远程并设置了信任列表后想关闭远程请运行 Disable-PSRemoting，不禁用远程将可能被人利用。 当远程管理打开以后，您可以通过 Enter-PSSession 访问远程系统，并且您可以用 Invoke-Command 在这些机器上运行命令或脚本。","text":"如果您希望用 PowerShell 远程管理来执行另一台机器上的命令或脚本，那么您需要以完整管理员权限启用目标机器上的远程管理功能： 在客户端，当您在同一个域中并且使用同一个域用户登录时，您不需要做任何额外的事情。 如果您希望通过非 Kerberos 验证方式连接目标计算机时（目标计算机在另一个域中，或您希望使用 IP 地址或非完整限定 DNS 名来连接），那么您需要以管理员权限运行一次以下代码： 将信任的主机设置为“*”之后，PowerShell 将允许您连接任何 IP 或机器名，如果无法用 Kerberos 验证身份，将使用 NTLM 验证。所以该设置不影响哪些人可以和该主机通信（通过防火墙规则设置）。它只是告诉 PowerShell 您将在 Kerberos 不可用的时候使用（更不安全一些的）NTLM 验证方式。NTLM 更不安全一些，因为它无法知道目标计算机是否真的是您想要访问的计算机。Kerberos 认证有相互认证过程，而 NTLM 没有。您的凭据直接被发送到指定的计算机中。假如当一个攻击者有机会用他的机器替换掉目标机器，并且占据了它的 IP 地址，而您使用 NTLM 的话，不会得到任何通知。 注意：如果你打开了远程并设置了信任列表后想关闭远程请运行 Disable-PSRemoting，不禁用远程将可能被人利用。 当远程管理打开以后，您可以通过 Enter-PSSession 访问远程系统，并且您可以用 Invoke-Command 在这些机器上运行命令或脚本。 本文国际来源：Enabling PowerShell Remoting","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 启用传统远程控制","slug":"enabling-classic-remoting","date":"2014-03-30T16:00:00.000Z","updated":"2017-03-17T15:26:23.320Z","comments":true,"path":"2014/03/31/enabling-classic-remoting/","link":"","permalink":"http://blog.vichamp.com/2014/03/31/enabling-classic-remoting/","excerpt":"许多 cmdlet 有内置的远程功能，例如 Get-Service 和 Get-Process 都具有 -ComputerName 参数，同样的还有 Get-WmiObject。 然而，要真正地远程使用这些 cmdlet，还需要一些先决条件。多数使用传统远程技术的 cmdlet 需要在目标机器上启用“远程管理”防火墙规则。它允许 DCOM 通信。还有一些需要目标计算机运行远程注册表服务。 所以在多数场景中，当您拥有目标机器的管理员，并且运行以下命令，则管理员可以通过传统远程 cmdlet 访问目标机器： 注意新版的 Windows 中 netsh firewall 命令可能会被废弃，不过目前仍然可以用。该命令比新版的 netsh advfirewall 命令用起来更简单。","text":"许多 cmdlet 有内置的远程功能，例如 Get-Service 和 Get-Process 都具有 -ComputerName 参数，同样的还有 Get-WmiObject。 然而，要真正地远程使用这些 cmdlet，还需要一些先决条件。多数使用传统远程技术的 cmdlet 需要在目标机器上启用“远程管理”防火墙规则。它允许 DCOM 通信。还有一些需要目标计算机运行远程注册表服务。 所以在多数场景中，当您拥有目标机器的管理员，并且运行以下命令，则管理员可以通过传统远程 cmdlet 访问目标机器： 注意新版的 Windows 中 netsh firewall 命令可能会被废弃，不过目前仍然可以用。该命令比新版的 netsh advfirewall 命令用起来更简单。 本文国际来源：Enabling Classic Remoting","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 PowerShell 导入导出凭据","slug":"exporting-and-importing-credentials-in-powershell","date":"2014-03-27T16:00:00.000Z","updated":"2017-03-17T15:26:23.320Z","comments":true,"path":"2014/03/28/exporting-and-importing-credentials-in-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/03/28/exporting-and-importing-credentials-in-powershell/","excerpt":"凭据对象包含了用户名和密码。您可以用 Get-Credential 来创建它们，然后将该对象传递给任何包含 -Credential 参数的 cmdlet。 然而，您要怎么做才能不需要用户干预，并且确保安全呢？您不希望弹出一个凭据对话框，并且您不希望在脚本中保存密码信息的话。 以下是一个解决方案：使用 Export-Credential 函数将凭据保存到一个文件中： function Export-Credential { param ( [Parameter(Mandatory=$true)] $Path, [System.Management.Automation.Credential()] [Parameter(Mandatory=$true)] $Credential ) $CredentialCopy = $Credential | Select-Object * $CredentialCopy.Password = $CredentialCopy.Password | ConvertFrom-SecureString $CredentialCopy | Export-Clixml $Path } 这段代码将 tobias 用户的凭据保存到一个文件中： 请注意当您进行这步操作时，将弹出凭据对话框并以安全的方式询问您的密码。该输出的文件包含 XML，并且密码是加密的。 现在，当您需要凭据时，使用 Import-Credential 来从文件中取回它： function Import-Credential { param ( [Parameter(Mandatory=$true)] $Path ) $CredentialCopy = Import-Clixml $path $CredentialCopy.password = $CredentialCopy.Password | ConvertTo-SecureString New-Object system.Management.Automation.PSCredential($CredentialCopy.username, $CredentialCopy.password) } 使用方法如下： 加密解密的“奥秘”在于您的身份，所以只有您（导出凭据的用户）可以将它再次导入。无需在您的脚本中硬编码隐私信息。","text":"凭据对象包含了用户名和密码。您可以用 Get-Credential 来创建它们，然后将该对象传递给任何包含 -Credential 参数的 cmdlet。 然而，您要怎么做才能不需要用户干预，并且确保安全呢？您不希望弹出一个凭据对话框，并且您不希望在脚本中保存密码信息的话。 以下是一个解决方案：使用 Export-Credential 函数将凭据保存到一个文件中： function Export-Credential { param ( [Parameter(Mandatory=$true)] $Path, [System.Management.Automation.Credential()] [Parameter(Mandatory=$true)] $Credential ) $CredentialCopy = $Credential | Select-Object * $CredentialCopy.Password = $CredentialCopy.Password | ConvertFrom-SecureString $CredentialCopy | Export-Clixml $Path } 这段代码将 tobias 用户的凭据保存到一个文件中： 请注意当您进行这步操作时，将弹出凭据对话框并以安全的方式询问您的密码。该输出的文件包含 XML，并且密码是加密的。 现在，当您需要凭据时，使用 Import-Credential 来从文件中取回它： function Import-Credential { param ( [Parameter(Mandatory=$true)] $Path ) $CredentialCopy = Import-Clixml $path $CredentialCopy.password = $CredentialCopy.Password | ConvertTo-SecureString New-Object system.Management.Automation.PSCredential($CredentialCopy.username, $CredentialCopy.password) } 使用方法如下： 加密解密的“奥秘”在于您的身份，所以只有您（导出凭据的用户）可以将它再次导入。无需在您的脚本中硬编码隐私信息。 本文国际来源：Exporting and Importing Credentials in PowerShell","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找 U 盘信息","slug":"finding-usb-stick-information","date":"2014-03-26T16:00:00.000Z","updated":"2017-03-17T15:26:23.305Z","comments":true,"path":"2014/03/27/finding-usb-stick-information/","link":"","permalink":"http://blog.vichamp.com/2014/03/27/finding-usb-stick-information/","excerpt":"您知道吗，Windows 记录了您使用过的所有 U 盘信息。要从注册表中读取上述信息，只需要使用这个函数： function Get-USBInfo { param ( $FriendlyName = &apos;*&apos; ) Get-ItemProperty -Path &apos;Registry::HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\USBSTOR\\*\\*\\&apos; | Where-Object { $_.FriendlyName } | Where-Object { $_.FriendlyName -like $FriendlyName } | Select-Object -Property FriendlyName, Mfg | Sort-Object -Property FriendlyName } 以下是输出的例子： 您还可以按厂商来查询：","text":"您知道吗，Windows 记录了您使用过的所有 U 盘信息。要从注册表中读取上述信息，只需要使用这个函数： function Get-USBInfo { param ( $FriendlyName = &apos;*&apos; ) Get-ItemProperty -Path &apos;Registry::HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\USBSTOR\\*\\*\\&apos; | Where-Object { $_.FriendlyName } | Where-Object { $_.FriendlyName -like $FriendlyName } | Select-Object -Property FriendlyName, Mfg | Sort-Object -Property FriendlyName } 以下是输出的例子： 您还可以按厂商来查询： 本文国际来源：Finding USB Stick Information","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取时间服务器（以及读取所有注册表键值）","slug":"finding-time-servers-and-reading-all-regkey-values","date":"2014-03-25T16:00:00.000Z","updated":"2017-03-17T15:26:23.305Z","comments":true,"path":"2014/03/26/finding-time-servers-and-reading-all-regkey-values/","link":"","permalink":"http://blog.vichamp.com/2014/03/26/finding-time-servers-and-reading-all-regkey-values/","excerpt":"也许您希望从注册表数据库中获取已登记的时间服务器列表。他们您可能需要运行类似这样的代码： Get-ItemProperty -Path &apos;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\DateTime\\Servers&apos; $path = &apos;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\DateTime\\Servers&apos; $key = Get-Item -Path $path Foreach ($valuename in $key.GetValueNames()) { if ($valuename -ne &apos;&apos;) { $key.GetValue($valuename) } } 这段代码存取注册表键，然后使用它的方法来获取值的名称，然后取出值：","text":"也许您希望从注册表数据库中获取已登记的时间服务器列表。他们您可能需要运行类似这样的代码： Get-ItemProperty -Path &apos;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\DateTime\\Servers&apos; $path = &apos;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\DateTime\\Servers&apos; $key = Get-Item -Path $path Foreach ($valuename in $key.GetValueNames()) { if ($valuename -ne &apos;&apos;) { $key.GetValue($valuename) } } 这段代码存取注册表键，然后使用它的方法来获取值的名称，然后取出值： 本文国际来源：Finding Time Servers (And Reading All RegKey Values)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找过期的证书","slug":"finding-expired-certificates","date":"2014-03-24T16:00:00.000Z","updated":"2017-03-17T15:26:23.289Z","comments":true,"path":"2014/03/25/finding-expired-certificates/","link":"","permalink":"http://blog.vichamp.com/2014/03/25/finding-expired-certificates/","excerpt":"PowerShell 通过 cert: 驱动器来存取您的证书存储。 您可以根据指定的规则用这个驱动器来查找证书。以下代码将列出所有 NotAfter 字段中有值并在今日之前（意味着证书已过期）的证书： $today = Get-Date Get-ChildItem -Path cert:\\ -Recurse | Where-Object { $_.NotAfter -ne $null } | Where-Object { $_.NotAfter -lt $today } | Select-Object -Property FriendlyName, NotAfter, PSParentPath, Thumbprint | Out-GridView","text":"PowerShell 通过 cert: 驱动器来存取您的证书存储。 您可以根据指定的规则用这个驱动器来查找证书。以下代码将列出所有 NotAfter 字段中有值并在今日之前（意味着证书已过期）的证书： $today = Get-Date Get-ChildItem -Path cert:\\ -Recurse | Where-Object { $_.NotAfter -ne $null } | Where-Object { $_.NotAfter -lt $today } | Select-Object -Property FriendlyName, NotAfter, PSParentPath, Thumbprint | Out-GridView 本文国际来源：Finding Expired Certificates","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 传递参数给 EXE 文件","slug":"submitting-arguments-to-exe-files","date":"2014-03-23T16:00:00.000Z","updated":"2017-03-17T15:26:23.289Z","comments":true,"path":"2014/03/24/submitting-arguments-to-exe-files/","link":"","permalink":"http://blog.vichamp.com/2014/03/24/submitting-arguments-to-exe-files/","excerpt":"从 PowerShell 运行某些应用程序，例如 robocopy.exe 不是很方便。如何向 EXE 传递参数，并且确保通过 PowerShell 不会传错值呢？ 方法很简单：确保所有的参数是字符串（所以如果参数不是字符串或包含其它特殊字符，那么用双引号把它们包起来）。并且，确保针对每个参数提交一个字符串，而不是单个大字符串。 以下代码将从 PowerShell 执行 robocopy.exe 并且递归地从 Windows 文件夹中拷贝所有的 JPG 图片到另一个 c:\\jpegs 文件夹中，遇到错误不重试，并跳过 winsxs 文件夹。 $arguments = &quot;$env:windir\\&quot;, &apos;c:\\jpegs\\&apos;,&apos;*.jpg&apos;, &apos;/R:0&apos;, &apos;/S&apos;, &apos;/XD&apos;, &apos;*winsxs*&apos; Robocopy.exe $arguments 如您所见，所有的参数都是字符串，并且它们都以一个字符串数组的形式传递。 这种方法完美地运行于所有您希望通过 PowerShell 调用的 exe 程序。","text":"从 PowerShell 运行某些应用程序，例如 robocopy.exe 不是很方便。如何向 EXE 传递参数，并且确保通过 PowerShell 不会传错值呢？ 方法很简单：确保所有的参数是字符串（所以如果参数不是字符串或包含其它特殊字符，那么用双引号把它们包起来）。并且，确保针对每个参数提交一个字符串，而不是单个大字符串。 以下代码将从 PowerShell 执行 robocopy.exe 并且递归地从 Windows 文件夹中拷贝所有的 JPG 图片到另一个 c:\\jpegs 文件夹中，遇到错误不重试，并跳过 winsxs 文件夹。 $arguments = &quot;$env:windir\\&quot;, &apos;c:\\jpegs\\&apos;,&apos;*.jpg&apos;, &apos;/R:0&apos;, &apos;/S&apos;, &apos;/XD&apos;, &apos;*winsxs*&apos; Robocopy.exe $arguments 如您所见，所有的参数都是字符串，并且它们都以一个字符串数组的形式传递。 这种方法完美地运行于所有您希望通过 PowerShell 调用的 exe 程序。 本文国际来源：Submitting Arguments to EXE Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用一句话定义 PowerShell","slug":"define-powershell-in-thirty-words-or-less","date":"2014-03-22T16:00:00.000Z","updated":"2017-03-17T15:26:23.273Z","comments":true,"path":"2014/03/23/define-powershell-in-thirty-words-or-less/","link":"","permalink":"http://blog.vichamp.com/2014/03/23/define-powershell-in-thirty-words-or-less/","excerpt":"","text":"摘要：微软脚本小子 Ed Wilson，提供了对 Windows PowerShell 的一句话描述，并且证明了它不超过 30 个单词。 问：如何用一句话定义 Windows PowerShell？ 答：Windows PowerShell 是微软公司开发的下一代命令行和脚本语言，它在多数环境下可以替代 vbscript 和 cmd 命令行。 问：您如何确定这句话不超过 30 个单词？ 答：用以下代码： $a = &quot;Windows PowerShell is the next generation cmd prompt and scripting language from Microsoft. It can be a replacement for vbscript and for the cmd prompt in most circumstances.&quot; Measure-Object -InputObject $a -Word 原文： PowerTip: Define PowerShell in Thirty Words or LessSummary: Microsoft Scripting Guy, Ed Wilson, offers a quick thirty-word description of Windows PowerShell, and he proves it. Q: What is Windows PowerShell in thirty words or less? A: Windows PowerShell is the next generation cmd prompt and scripting language from Microsoft. It can be a replacement for vbscript and for the cmd prompt in most circumstances. Q: How can you be sure that was thirty words or less? A: By using the following code: $a = &quot;Windows PowerShell is the next generation cmd prompt and scripting language from Microsoft. It can be a replacement for vbscript and for the cmd prompt in most circumstances.&quot; Measure-Object -InputObject $a -Word 本文国际来源","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"language","slug":"language","permalink":"http://blog.vichamp.com/tags/language/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 应用 NTFS 存取权限","slug":"applying-ntfs-access-rules","date":"2014-03-20T16:00:00.000Z","updated":"2017-03-17T15:26:23.273Z","comments":true,"path":"2014/03/21/applying-ntfs-access-rules/","link":"","permalink":"http://blog.vichamp.com/2014/03/21/applying-ntfs-access-rules/","excerpt":"有很多方法可以增加或修改 NTFS 权限。其中一个方法是复用现成的工具，例如 icacls.exe。 这个函数将以缺省权限创建新的文件夹。该脚本使用 icacls.exe 来显式地为当前用户添加完全权限以及为本地管理员添加读取权限： function New-Folder { param ( [String] $path, [String] $username = &quot;$env:userdomain\\$env:username&quot; ) If ( (Test-Path -Path $path) -eq $false ) { New-Item $path -Type Directory | Out-Null } icacls $path /inheritance:r /grant &apos;*S-1-5-32-544:(OI)(CI)R&apos; (&apos;{0}:(OI)(CI)F&apos; -f $username) }","text":"有很多方法可以增加或修改 NTFS 权限。其中一个方法是复用现成的工具，例如 icacls.exe。 这个函数将以缺省权限创建新的文件夹。该脚本使用 icacls.exe 来显式地为当前用户添加完全权限以及为本地管理员添加读取权限： function New-Folder { param ( [String] $path, [String] $username = &quot;$env:userdomain\\$env:username&quot; ) If ( (Test-Path -Path $path) -eq $false ) { New-Item $path -Type Directory | Out-Null } icacls $path /inheritance:r /grant &apos;*S-1-5-32-544:(OI)(CI)R&apos; (&apos;{0}:(OI)(CI)F&apos; -f $username) } 本文国际来源：Applying NTFS Access Rules","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取系统信息","slug":"profiling-systems","date":"2014-03-19T16:00:00.000Z","updated":"2017-03-17T15:26:23.272Z","comments":true,"path":"2014/03/20/profiling-systems/","link":"","permalink":"http://blog.vichamp.com/2014/03/20/profiling-systems/","excerpt":"如果您只是需要获取本地系统或远程系统的常见配置信息，那么不必浪费时间去研究自己的解决方案。只需要使用 systeminfo.exe，然后将数据导入 PowerShell： function Get-SystemInfo { param($ComputerName = $env:COMPUTERNAME) $header = &apos;Hostname&apos;,&apos;OSName&apos;,&apos;OSVersion&apos;,&apos;OSManufacturer&apos;,&apos;OSConfiguration&apos;,&apos;OS Build Type&apos;,&apos;RegisteredOwner&apos;,&apos;RegisteredOrganization&apos;,&apos;Product ID&apos;,&apos;Original Install Date&apos;,&apos;System Boot Time&apos;,&apos;System Manufacturer&apos;,&apos;System Model&apos;,&apos;System Type&apos;,&apos;Processor(s)&apos;,&apos;BIOS Version&apos;,&apos;Windows Directory&apos;,&apos;System Directory&apos;,&apos;Boot Device&apos;,&apos;System Locale&apos;,&apos;Input Locale&apos;,&apos;Time Zone&apos;,&apos;Total Physical Memory&apos;,&apos;Available Physical Memory&apos;,&apos;Virtual Memory: Max Size&apos;,&apos;Virtual Memory: Available&apos;,&apos;Virtual Memory: In Use&apos;,&apos;Page File Location(s)&apos;,&apos;Domain&apos;,&apos;Logon Server&apos;,&apos;Hotfix(s)&apos;,&apos;Network Card(s)&apos; systeminfo.exe /FO CSV /S $ComputerName | Select-Object -Skip 1 | ConvertFrom-CSV -Header $header } 以下是结果： 如果把结果保存到一个变量，您可以很容易地独立存取里面的每一条信息： 如果您想用别的名字来获取信息，只需根据需要改变属性名列表。例如您不喜欢“System Boot Time”，那么只需要在脚本中将它重命名为“BootTime”。","text":"如果您只是需要获取本地系统或远程系统的常见配置信息，那么不必浪费时间去研究自己的解决方案。只需要使用 systeminfo.exe，然后将数据导入 PowerShell： function Get-SystemInfo { param($ComputerName = $env:COMPUTERNAME) $header = &apos;Hostname&apos;,&apos;OSName&apos;,&apos;OSVersion&apos;,&apos;OSManufacturer&apos;,&apos;OSConfiguration&apos;,&apos;OS Build Type&apos;,&apos;RegisteredOwner&apos;,&apos;RegisteredOrganization&apos;,&apos;Product ID&apos;,&apos;Original Install Date&apos;,&apos;System Boot Time&apos;,&apos;System Manufacturer&apos;,&apos;System Model&apos;,&apos;System Type&apos;,&apos;Processor(s)&apos;,&apos;BIOS Version&apos;,&apos;Windows Directory&apos;,&apos;System Directory&apos;,&apos;Boot Device&apos;,&apos;System Locale&apos;,&apos;Input Locale&apos;,&apos;Time Zone&apos;,&apos;Total Physical Memory&apos;,&apos;Available Physical Memory&apos;,&apos;Virtual Memory: Max Size&apos;,&apos;Virtual Memory: Available&apos;,&apos;Virtual Memory: In Use&apos;,&apos;Page File Location(s)&apos;,&apos;Domain&apos;,&apos;Logon Server&apos;,&apos;Hotfix(s)&apos;,&apos;Network Card(s)&apos; systeminfo.exe /FO CSV /S $ComputerName | Select-Object -Skip 1 | ConvertFrom-CSV -Header $header } 以下是结果： 如果把结果保存到一个变量，您可以很容易地独立存取里面的每一条信息： 如果您想用别的名字来获取信息，只需根据需要改变属性名列表。例如您不喜欢“System Boot Time”，那么只需要在脚本中将它重命名为“BootTime”。 本文国际来源：Profiling Systems","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 PowerShell 中提升命令权限","slug":"running-commands-elevated-in-powershell","date":"2014-03-18T16:00:00.000Z","updated":"2017-03-17T15:26:23.269Z","comments":true,"path":"2014/03/19/running-commands-elevated-in-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/03/19/running-commands-elevated-in-powershell/","excerpt":"有些时候，一个脚本需要运行一个需提升（管理员）权限的命令。 一种方法是将用管理员权限运行整个脚本，另一种方法是将独立的命令送到提升权限的 shell 中执行。 这段代码将重启 Spooler 服务（需要提升权限），并将命令发送到另一个 PowerShell 进程中。如果当前进程没有管理员权限，它将自动提升权限。 $command = &apos;Restart-Service -Name spooler&apos; Start-Process -FilePath powershell.exe -ArgumentList &quot;-noprofile -command $Command&quot; ` -Verb runas","text":"有些时候，一个脚本需要运行一个需提升（管理员）权限的命令。 一种方法是将用管理员权限运行整个脚本，另一种方法是将独立的命令送到提升权限的 shell 中执行。 这段代码将重启 Spooler 服务（需要提升权限），并将命令发送到另一个 PowerShell 进程中。如果当前进程没有管理员权限，它将自动提升权限。 $command = &apos;Restart-Service -Name spooler&apos; Start-Process -FilePath powershell.exe -ArgumentList &quot;-noprofile -command $Command&quot; ` -Verb runas 本文国际来源：Running Commands Elevated in PowerShell","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取无线网卡","slug":"get-wirelessadapter","date":"2014-03-17T16:00:00.000Z","updated":"2017-03-17T15:26:23.267Z","comments":true,"path":"2014/03/18/get-wirelessadapter/","link":"","permalink":"http://blog.vichamp.com/2014/03/18/get-wirelessadapter/","excerpt":"在上一个技巧中，我们演示了如何使用注册表信息来查找无线网卡。以下是一个可以返回您系统中所有无线网卡的 Get-WirelessAdapter 函数： function Get-WirelessAdapter { Get-ItemProperty -Path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Network\\*\\*\\Connection&apos; -ErrorAction SilentlyContinue | Select-Object -Property MediaSubType, PNPInstanceID | Where-Object { $_.MediaSubType -eq 2 -and $_.PnpInstanceID } | Select-Object -ExpandProperty PnpInstanceID | ForEach-Object { $wmipnpID = $_.Replace(&apos;\\&apos;, &apos;\\\\&apos;) Get-WmiObject -Class Win32_NetworkAdapter -Filter &quot;PNPDeviceID=&apos;$wmipnpID&apos;&quot; } } 只需要运行该函数： 由于该函数返回一个 WMI 对象，所以您可以获知该网卡当前是否是活动的，或者启用禁用它。 以下代码将取出网卡对象，然后禁用它，再启用它： $adapter = Get-WirelessAdapter $adapter.Disable().ReturnValue $adapter.Enable().ReturnValue 请注意返回值 5 意味着您没有足够的权限。请以管理员身份运行该脚本。","text":"在上一个技巧中，我们演示了如何使用注册表信息来查找无线网卡。以下是一个可以返回您系统中所有无线网卡的 Get-WirelessAdapter 函数： function Get-WirelessAdapter { Get-ItemProperty -Path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Network\\*\\*\\Connection&apos; -ErrorAction SilentlyContinue | Select-Object -Property MediaSubType, PNPInstanceID | Where-Object { $_.MediaSubType -eq 2 -and $_.PnpInstanceID } | Select-Object -ExpandProperty PnpInstanceID | ForEach-Object { $wmipnpID = $_.Replace(&apos;\\&apos;, &apos;\\\\&apos;) Get-WmiObject -Class Win32_NetworkAdapter -Filter &quot;PNPDeviceID=&apos;$wmipnpID&apos;&quot; } } 只需要运行该函数： 由于该函数返回一个 WMI 对象，所以您可以获知该网卡当前是否是活动的，或者启用禁用它。 以下代码将取出网卡对象，然后禁用它，再启用它： $adapter = Get-WirelessAdapter $adapter.Disable().ReturnValue $adapter.Enable().ReturnValue 请注意返回值 5 意味着您没有足够的权限。请以管理员身份运行该脚本。 本文国际来源：Get-WirelessAdapter","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找无线网卡","slug":"finding-wireless-network-adapters","date":"2014-03-16T16:00:00.000Z","updated":"2017-03-17T15:26:23.251Z","comments":true,"path":"2014/03/17/finding-wireless-network-adapters/","link":"","permalink":"http://blog.vichamp.com/2014/03/17/finding-wireless-network-adapters/","excerpt":"有很多方法可以查找网卡，但似乎没有办法识别活动的无线网卡。 您网卡的所有信息都可以在注册表中找到，以下是一个单行的代码，可以提供您想要的信息： 有趣的部分是 MediaSubType 值。无线网卡的 MediaSubType 值总是 2。 所以这行代码只返回无线网卡：","text":"有很多方法可以查找网卡，但似乎没有办法识别活动的无线网卡。 您网卡的所有信息都可以在注册表中找到，以下是一个单行的代码，可以提供您想要的信息： 有趣的部分是 MediaSubType 值。无线网卡的 MediaSubType 值总是 2。 所以这行代码只返回无线网卡： 本文国际来源：Finding Wireless Network Adapters","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 以 GB 和百分比的形式显示驱动器容量","slug":"drive-data-in-gb-and-percent","date":"2014-03-13T16:00:00.000Z","updated":"2017-03-17T15:26:23.251Z","comments":true,"path":"2014/03/14/drive-data-in-gb-and-percent/","link":"","permalink":"http://blog.vichamp.com/2014/03/14/drive-data-in-gb-and-percent/","excerpt":"当一个 cmdlet 返回原始数据时，您可能希望将数据转换为一个更好的格式。例如，WMI 可以汇报驱动器的剩余空间，但是是以字节为单位的。 您可以使用 Select-Object 并且传入一个哈希表来将原始数据转换为您希望的格式。这个例子演示了如何将剩余空间转换为以 GB 为单位，并且计算剩余空间的百分比： $Freespace = @{ Expression = {[int]($_.Freespace/1GB)} Name = &apos;Free Space (GB)&apos; } $PercentFree = @{ Expression = {[int]($_.Freespace*100/$_.Size)} Name = &apos;Free (%)&apos; } Get-WmiObject -Class Win32_LogicalDisk | Select-Object -Property DeviceID, VolumeName, $Freespace, $PercentFree 以下是不使用哈希表的结果： 这是使用了哈希表的结果：","text":"当一个 cmdlet 返回原始数据时，您可能希望将数据转换为一个更好的格式。例如，WMI 可以汇报驱动器的剩余空间，但是是以字节为单位的。 您可以使用 Select-Object 并且传入一个哈希表来将原始数据转换为您希望的格式。这个例子演示了如何将剩余空间转换为以 GB 为单位，并且计算剩余空间的百分比： $Freespace = @{ Expression = {[int]($_.Freespace/1GB)} Name = &apos;Free Space (GB)&apos; } $PercentFree = @{ Expression = {[int]($_.Freespace*100/$_.Size)} Name = &apos;Free (%)&apos; } Get-WmiObject -Class Win32_LogicalDisk | Select-Object -Property DeviceID, VolumeName, $Freespace, $PercentFree 以下是不使用哈希表的结果： 这是使用了哈希表的结果： 本文国际来源：Drive Data in GB and Percent","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找空闲容量低的硬盘驱动器","slug":"finding-hard-drives-running-low-on-storage","date":"2014-03-12T16:00:00.000Z","updated":"2017-03-17T15:26:23.236Z","comments":true,"path":"2014/03/13/finding-hard-drives-running-low-on-storage/","link":"","permalink":"http://blog.vichamp.com/2014/03/13/finding-hard-drives-running-low-on-storage/","excerpt":"可以通过 WMI 轻松地获取驱动器信息。以下代码可以从您的本地计算机中获取驱动器信息（用 -ComputerName 可以存取远程系统的信息）。 要限制结果只包含硬盘驱动器，并且只包含空闲容量低于指定值的硬盘驱动器，请试试以下代码： $limit = 80GB Get-WmiObject -Class Win32_LogicalDisk -Filter &quot;DriveType=3 and Freespace&lt;$limit&quot; | Select-Object -Property VolumeName, Freespace, DeviceID","text":"可以通过 WMI 轻松地获取驱动器信息。以下代码可以从您的本地计算机中获取驱动器信息（用 -ComputerName 可以存取远程系统的信息）。 要限制结果只包含硬盘驱动器，并且只包含空闲容量低于指定值的硬盘驱动器，请试试以下代码： $limit = 80GB Get-WmiObject -Class Win32_LogicalDisk -Filter &quot;DriveType=3 and Freespace&lt;$limit&quot; | Select-Object -Property VolumeName, Freespace, DeviceID 本文国际来源：Finding Hard Drives Running Low on Storage","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找昨天以来的错误","slug":"finding-errors-since-yesterday","date":"2014-03-11T16:00:00.000Z","updated":"2017-03-17T15:26:23.236Z","comments":true,"path":"2014/03/12/finding-errors-since-yesterday/","link":"","permalink":"http://blog.vichamp.com/2014/03/12/finding-errors-since-yesterday/","excerpt":"要获取一个时间段内的数据，相对日期的作用十分重要，它能避免硬编码日期和时间值。 这段代码将会从系统日志中获取昨天起（24 小时以内）的所有错误和警告事件： $today = Get-Date $1day = New-TimeSpan -Days 1 $yesterday = $today - $1day Get-EventLog -LogName system -EntryType Error, Warning -After $yesterday","text":"要获取一个时间段内的数据，相对日期的作用十分重要，它能避免硬编码日期和时间值。 这段代码将会从系统日志中获取昨天起（24 小时以内）的所有错误和警告事件： $today = Get-Date $1day = New-TimeSpan -Days 1 $yesterday = $today - $1day Get-EventLog -LogName system -EntryType Error, Warning -After $yesterday 本文国际来源：Finding Errors since Yesterday","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 导出数据到 Excel","slug":"exporting-data-to-excel","date":"2014-03-10T16:00:00.000Z","updated":"2017-03-17T15:26:23.225Z","comments":true,"path":"2014/03/11/exporting-data-to-excel/","link":"","permalink":"http://blog.vichamp.com/2014/03/11/exporting-data-to-excel/","excerpt":"您可以轻松地在 PowerShell 中将对象数据转化为 CSV 文件。以下代码生成当前进程的 CSV 报告： 要在 Microsoft Excel 中打开 CSV 文件，您可以使用 Invoke-Item 来打开文件，但是这仅当您的 CSV 文件扩展名确实关联到 Excel 应用程序的时候才有效。 以下代码将确保在 Microsoft Excel 中打开 CSV 文件。它展示了一种超出您 Excel 应用（假设它已经安装了，并且无须检测它是否存在）的方法： $report = &quot;$env:temp\\report.csv&quot; $ExcelPath = &apos;C:\\Program Files*\\Microsoft Office\\OFFICE*\\EXCEL.EXE&apos; $RealExcelPath = Resolve-Path -Path $ExcelPath | Select-Object -First 1 -ExpandProperty Path &amp; $RealExcelPath $report","text":"您可以轻松地在 PowerShell 中将对象数据转化为 CSV 文件。以下代码生成当前进程的 CSV 报告： 要在 Microsoft Excel 中打开 CSV 文件，您可以使用 Invoke-Item 来打开文件，但是这仅当您的 CSV 文件扩展名确实关联到 Excel 应用程序的时候才有效。 以下代码将确保在 Microsoft Excel 中打开 CSV 文件。它展示了一种超出您 Excel 应用（假设它已经安装了，并且无须检测它是否存在）的方法： $report = &quot;$env:temp\\report.csv&quot; $ExcelPath = &apos;C:\\Program Files*\\Microsoft Office\\OFFICE*\\EXCEL.EXE&apos; $RealExcelPath = Resolve-Path -Path $ExcelPath | Select-Object -First 1 -ExpandProperty Path &amp; $RealExcelPath $report 本文国际来源：Exporting Data to Excel","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找一个时间点附近的日志","slug":"finding-events-around-a-date","date":"2014-03-08T16:00:00.000Z","updated":"2017-03-17T15:26:23.225Z","comments":true,"path":"2014/03/09/finding-events-around-a-date/","link":"","permalink":"http://blog.vichamp.com/2014/03/09/finding-events-around-a-date/","excerpt":"经常地，您会需要浏览某个指定日期附近的所有系统事件。我们假设某台机器在 08:47 崩溃了，您需要查看该时间前后 2 分钟之内的事件。 以下是一个完成以上任务的脚本： $deltaminutes = 2 $delta = New-TimeSpan -Minutes $deltaminutes $time = Read-Host -Prompt &apos;Enter time of event (yyyy-MM-dd HH:mm:ss or HH:mm)&apos; $datetime = Get-Date -Date $time $start = $datetime - $delta $end = $datetime + $delta $result = @(Get-EventLog -LogName System -Before $end -After $start) $result += Get-EventLog -LogName Application -Before $end -After $start $result | Sort-Object -Property TimeGenerated -Descending | Out-GridView -Title &quot;Events +/− $deltaminutes minutes around $datetime&quot; 当您运行它时，它需要用户输入一个时间或日期 + 时间值。然后，您可以获得该时间点前后 2 分钟之内系统和应用程序日志中的所有事件。 如果您没有获取到任何数据，那么说明在这段时间段中没有任何事件。 这段代码示范了您可以获取一个时间段之内的事件，并且示范了如何查询多个事件日志。","text":"经常地，您会需要浏览某个指定日期附近的所有系统事件。我们假设某台机器在 08:47 崩溃了，您需要查看该时间前后 2 分钟之内的事件。 以下是一个完成以上任务的脚本： $deltaminutes = 2 $delta = New-TimeSpan -Minutes $deltaminutes $time = Read-Host -Prompt &apos;Enter time of event (yyyy-MM-dd HH:mm:ss or HH:mm)&apos; $datetime = Get-Date -Date $time $start = $datetime - $delta $end = $datetime + $delta $result = @(Get-EventLog -LogName System -Before $end -After $start) $result += Get-EventLog -LogName Application -Before $end -After $start $result | Sort-Object -Property TimeGenerated -Descending | Out-GridView -Title &quot;Events +/− $deltaminutes minutes around $datetime&quot; 当您运行它时，它需要用户输入一个时间或日期 + 时间值。然后，您可以获得该时间点前后 2 分钟之内系统和应用程序日志中的所有事件。 如果您没有获取到任何数据，那么说明在这段时间段中没有任何事件。 这段代码示范了您可以获取一个时间段之内的事件，并且示范了如何查询多个事件日志。 本文国际来源：Finding Events around A Date","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 自动连接到公共热点","slug":"auto-connecting-with-public-hotspot","date":"2014-03-06T16:00:00.000Z","updated":"2017-03-17T15:26:23.225Z","comments":true,"path":"2014/03/07/auto-connecting-with-public-hotspot/","link":"","permalink":"http://blog.vichamp.com/2014/03/07/auto-connecting-with-public-hotspot/","excerpt":"许多手机服务提供商在机场和公共场所提供公共热点。要连接热点，您往往需要浏览一个登录页面，然后手动输入您的凭据。 以下是一个自动做以上事情的脚本。它在 t-mobile.de 运营商环境下调是通过。但是您可以调整脚本以适应其它的运营商。 function Start-Hotspot { param ( [System.String] $Username = &apos;XYZ@t-mobile.de&apos;, [System.String] $Password = &apos;topsecret&apos; ) # change this to match your provider logon page URL $url = &apos;https://hotspot.t-mobile.net/wlan/start.do&apos; $r = Invoke-WebRequest -Uri $url -SessionVariable fb $form = $r.Forms[0] # change this to match the website form field names: $form.Fields[&apos;username&apos;] = $Username $form.Fields[&apos;password&apos;] = $Password # change this to match the form target URL $r = Invoke-WebRequest -Uri (&apos;https://hotspot.t-mobile.net&apos; + $form.Action) -WebSession $fb -Method POST -Body $form.Fields Write-Host &apos;Connected&apos; -ForegroundColor Green Start-Process &apos;http://www.google.de&apos; } 简而言之，Invoke-WebRequest 可以到导航到一个页面，填充表单数据，然后提交表单。要能提交正确的数据，您需要查看登录网页的的源代码（导航到该页面，在浏览器中右键单击选择显示 HTML 源代码）。 然后，识别出您希望填充的表单，然后将脚本代码中的表单名称和动作改为您从 HTML 代码中识别出来的值。","text":"许多手机服务提供商在机场和公共场所提供公共热点。要连接热点，您往往需要浏览一个登录页面，然后手动输入您的凭据。 以下是一个自动做以上事情的脚本。它在 t-mobile.de 运营商环境下调是通过。但是您可以调整脚本以适应其它的运营商。 function Start-Hotspot { param ( [System.String] $Username = &apos;XYZ@t-mobile.de&apos;, [System.String] $Password = &apos;topsecret&apos; ) # change this to match your provider logon page URL $url = &apos;https://hotspot.t-mobile.net/wlan/start.do&apos; $r = Invoke-WebRequest -Uri $url -SessionVariable fb $form = $r.Forms[0] # change this to match the website form field names: $form.Fields[&apos;username&apos;] = $Username $form.Fields[&apos;password&apos;] = $Password # change this to match the form target URL $r = Invoke-WebRequest -Uri (&apos;https://hotspot.t-mobile.net&apos; + $form.Action) -WebSession $fb -Method POST -Body $form.Fields Write-Host &apos;Connected&apos; -ForegroundColor Green Start-Process &apos;http://www.google.de&apos; } 简而言之，Invoke-WebRequest 可以到导航到一个页面，填充表单数据，然后提交表单。要能提交正确的数据，您需要查看登录网页的的源代码（导航到该页面，在浏览器中右键单击选择显示 HTML 源代码）。 然后，识别出您希望填充的表单，然后将脚本代码中的表单名称和动作改为您从 HTML 代码中识别出来的值。 本文国际来源：Auto-Connecting with Public Hotspot","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 字符串左右对齐","slug":"padding-strings-left-and-right","date":"2014-03-05T16:00:00.000Z","updated":"2017-03-17T15:26:23.204Z","comments":true,"path":"2014/03/06/padding-strings-left-and-right/","link":"","permalink":"http://blog.vichamp.com/2014/03/06/padding-strings-left-and-right/","excerpt":"如果您需要确保给定的字符串有一致的宽度，那么您可以使用 .NET 方法来适当地对齐字符串： $mytext = &apos;Test&apos; $paddedText = $mytext.PadLeft(15) &quot;Here is the text: &apos;$paddedText&apos;&quot; $paddedText = $mytext.PadRight(15) &quot;Here is the text: &apos;$paddedText&apos;&quot; 以下是结果： 您甚至可以自己指定补充的字符（如果您不想使用空格来补的话）：","text":"如果您需要确保给定的字符串有一致的宽度，那么您可以使用 .NET 方法来适当地对齐字符串： $mytext = &apos;Test&apos; $paddedText = $mytext.PadLeft(15) &quot;Here is the text: &apos;$paddedText&apos;&quot; $paddedText = $mytext.PadRight(15) &quot;Here is the text: &apos;$paddedText&apos;&quot; 以下是结果： 您甚至可以自己指定补充的字符（如果您不想使用空格来补的话）： 本文国际来源：Padding Strings Left and Right","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 轻松地格式化数字","slug":"formatting-numbers-easily","date":"2014-03-04T16:00:00.000Z","updated":"2017-03-17T15:26:23.204Z","comments":true,"path":"2014/03/05/formatting-numbers-easily/","link":"","permalink":"http://blog.vichamp.com/2014/03/05/formatting-numbers-easily/","excerpt":"用户常常需要格式化数字并且限制小数的位数，或者是在左侧补零。有一个简单标准的方法：使用操作符 -f ！ 以下代码的作用是左侧补零： $number = 68 &apos;{0:d7}&apos; -f $number 这段代码将生成一个左补零的 7 位数字。调整“d”后的数字可以控制位数。 要限制小数的位数，请使用“n”来代替“d”。这一次，“n”后的数字控制小数的位数： $number = 35553568.67826738 &apos;{0:n1}&apos; -f $number 类似地，用“p”来格式化百分比： $number = 0.32562176536 &apos;{0:p2}&apos; -f $number","text":"用户常常需要格式化数字并且限制小数的位数，或者是在左侧补零。有一个简单标准的方法：使用操作符 -f ！ 以下代码的作用是左侧补零： $number = 68 &apos;{0:d7}&apos; -f $number 这段代码将生成一个左补零的 7 位数字。调整“d”后的数字可以控制位数。 要限制小数的位数，请使用“n”来代替“d”。这一次，“n”后的数字控制小数的位数： $number = 35553568.67826738 &apos;{0:n1}&apos; -f $number 类似地，用“p”来格式化百分比： $number = 0.32562176536 &apos;{0:p2}&apos; -f $number 本文国际来源：Formatting Numbers Easily","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 消除重复","slug":"eliminating-duplicates","date":"2014-03-03T16:00:00.000Z","updated":"2017-03-17T15:26:23.189Z","comments":true,"path":"2014/03/04/eliminating-duplicates/","link":"","permalink":"http://blog.vichamp.com/2014/03/04/eliminating-duplicates/","excerpt":"Sort-Object 有一个很棒的特性：使用 -Unique 参数，您可以移除重复对象： 这也可以用于对象类型的结果。请看这个例子，它将从您的系统事件日志中获取最后的 40 条错误： 它的结果也许完全正确，但是您实际上可能得到很多重复的条目。 通过使用 -Unique 参数，您可以基于多个属性消除重复的结果： 这样，您再也看不到多于一条具有相同 InstanceID 和 消息的结果了。 您可以再次对结果排序，以使得结果按时间排序。 所以结论是：Sort-Objects 的 -Unique 参数可以一次性应用到多个属性上。","text":"Sort-Object 有一个很棒的特性：使用 -Unique 参数，您可以移除重复对象： 这也可以用于对象类型的结果。请看这个例子，它将从您的系统事件日志中获取最后的 40 条错误： 它的结果也许完全正确，但是您实际上可能得到很多重复的条目。 通过使用 -Unique 参数，您可以基于多个属性消除重复的结果： 这样，您再也看不到多于一条具有相同 InstanceID 和 消息的结果了。 您可以再次对结果排序，以使得结果按时间排序。 所以结论是：Sort-Objects 的 -Unique 参数可以一次性应用到多个属性上。 本文国际来源：Eliminating Duplicates","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 担心隐藏的输入密码请求","slug":"beware-of-hidden-password-requests","date":"2014-03-02T16:00:00.000Z","updated":"2017-03-17T15:26:23.189Z","comments":true,"path":"2014/03/03/beware-of-hidden-password-requests/","link":"","permalink":"http://blog.vichamp.com/2014/03/03/beware-of-hidden-password-requests/","excerpt":"您可以在任何主机上运行 PowerShell，powershell.exe 和 powershell_ise.exe 随着 Windows 发布。比起简单的 PowerShell 控制台，许多人更喜欢图形化的 ISE 编辑器。 一旦您开始使用控制台程序，您必须意识到 ISE 编辑器没有真实的控制台。在 ISE 编辑器中，任何时候一个控制台程序想要与您互动时，它将会运行失败。 所以 choice.exe 在控制台中工作正常，但是您在 ISE 编辑器中运行相同的命令时，却没有办法使 choice.exe 接收您的按键。 有些时候，这可能会导致意外的结果。当您在 ISE 编辑器中运行 driverquery.exe 加上 /S Servername 参数从远程系统中读取驱动器信息时，编辑器会假死。 当您在控制台中运行相同的命令时，您会知道原因：driverquery.exe 可能会显示一个提示并期望输入密码。ISE 编辑器无法处理这个提示和您的输入——由于它没有控制台缓冲区。 所以当您的脚本用到了控制台应用程序时，您最好在传统的 PowerShell 控制台中运行它们。","text":"您可以在任何主机上运行 PowerShell，powershell.exe 和 powershell_ise.exe 随着 Windows 发布。比起简单的 PowerShell 控制台，许多人更喜欢图形化的 ISE 编辑器。 一旦您开始使用控制台程序，您必须意识到 ISE 编辑器没有真实的控制台。在 ISE 编辑器中，任何时候一个控制台程序想要与您互动时，它将会运行失败。 所以 choice.exe 在控制台中工作正常，但是您在 ISE 编辑器中运行相同的命令时，却没有办法使 choice.exe 接收您的按键。 有些时候，这可能会导致意外的结果。当您在 ISE 编辑器中运行 driverquery.exe 加上 /S Servername 参数从远程系统中读取驱动器信息时，编辑器会假死。 当您在控制台中运行相同的命令时，您会知道原因：driverquery.exe 可能会显示一个提示并期望输入密码。ISE 编辑器无法处理这个提示和您的输入——由于它没有控制台缓冲区。 所以当您的脚本用到了控制台应用程序时，您最好在传统的 PowerShell 控制台中运行它们。 本文国际来源：Beware Of Hidden Password Requests","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 为对象增加信息","slug":"tag-your-objects-with-additional-information","date":"2014-02-27T16:00:00.000Z","updated":"2017-03-17T15:26:23.189Z","comments":true,"path":"2014/02/28/tag-your-objects-with-additional-information/","link":"","permalink":"http://blog.vichamp.com/2014/02/28/tag-your-objects-with-additional-information/","excerpt":"有时会遇到这样的需求：需要向命令的执行结果增加额外的信息。也许您从不同的机器获取信息，并且希望保存数据来源的引用。或者，您也许希望增加一个日期，以便知道数据是何时创建的。 向对象附加信息（增加额外的信息列）是很简单的。这段代码将为一个服务列表增加新的“SourceComputer”属性以及日期。 Get-Service | Add-Member -MemberType NoteProperty -Name SourceComputer -Value $env:COMPUTERNAME -PassThru | Add-Member -MemberType NoteProperty -Name Date -Value (Get-Date) -PassThru | Select-Object -Property Name, Status, SourceComputer, Date 请记着您新增的属性需要在使用 Select-Object 以及显式地要求显式它们的时候，才会在结果中显示出来。","text":"有时会遇到这样的需求：需要向命令的执行结果增加额外的信息。也许您从不同的机器获取信息，并且希望保存数据来源的引用。或者，您也许希望增加一个日期，以便知道数据是何时创建的。 向对象附加信息（增加额外的信息列）是很简单的。这段代码将为一个服务列表增加新的“SourceComputer”属性以及日期。 Get-Service | Add-Member -MemberType NoteProperty -Name SourceComputer -Value $env:COMPUTERNAME -PassThru | Add-Member -MemberType NoteProperty -Name Date -Value (Get-Date) -PassThru | Select-Object -Property Name, Status, SourceComputer, Date 请记着您新增的属性需要在使用 Select-Object 以及显式地要求显式它们的时候，才会在结果中显示出来。 本文国际来源：Tag Your Objects with Additional Information","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 Select-Object -First 节省时间！","slug":"save-time-with-select-object-first","date":"2014-02-26T16:00:00.000Z","updated":"2017-03-17T15:26:23.173Z","comments":true,"path":"2014/02/27/save-time-with-select-object-first/","link":"","permalink":"http://blog.vichamp.com/2014/02/27/save-time-with-select-object-first/","excerpt":"Select-Object 命令有一个 -First 参数，接受一个数字值。它将只返回前 x 个元素。听起来挺简单的，而且它的确就这么简单。 以下代码从您的 Windows 文件夹中获取前 4 个 PowerShell 脚本： 从 PowerShell 3.0 开始，-First 不仅选择指定数量的结果，而且它还通知管道的上游命令，告知它操作已完成，有效地中止管道操作。 所以如果您想得到某个命令一定数量的结果，那么您总是可以使用 Select-Object -First x ——在特定的场景里这可以显著地加速您的代码执行效率。 我们假设您需要在您的用户文件夹之下的某个地方找一个名为“test.txt”的文件，并且假设只有一个这个名字的文件。而您只是不知道它放在哪个位置，那么您可以使用 Get-ChildItem 和 -Recurse 来递归查找所有的文件夹： Get-ChildItem -Path $home -Filter test.txt -Recurse -ErrorAction SilentlyContinue 当您执行这段代码时，Get-ChildItem 最终将找到您的文件——并且继续搜索您的文件夹树，也许要持续几分钟才能找完。因为它不知道是否有其它的文件。 所以，您知道的，如果您事先确定结果的数量，那么试试以下的代码： Get-ChildItem -Path $home -Filter test.txt -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 这一次，Get-ChildItem 将会在找到一个文件后立即停止。","text":"Select-Object 命令有一个 -First 参数，接受一个数字值。它将只返回前 x 个元素。听起来挺简单的，而且它的确就这么简单。 以下代码从您的 Windows 文件夹中获取前 4 个 PowerShell 脚本： 从 PowerShell 3.0 开始，-First 不仅选择指定数量的结果，而且它还通知管道的上游命令，告知它操作已完成，有效地中止管道操作。 所以如果您想得到某个命令一定数量的结果，那么您总是可以使用 Select-Object -First x ——在特定的场景里这可以显著地加速您的代码执行效率。 我们假设您需要在您的用户文件夹之下的某个地方找一个名为“test.txt”的文件，并且假设只有一个这个名字的文件。而您只是不知道它放在哪个位置，那么您可以使用 Get-ChildItem 和 -Recurse 来递归查找所有的文件夹： Get-ChildItem -Path $home -Filter test.txt -Recurse -ErrorAction SilentlyContinue 当您执行这段代码时，Get-ChildItem 最终将找到您的文件——并且继续搜索您的文件夹树，也许要持续几分钟才能找完。因为它不知道是否有其它的文件。 所以，您知道的，如果您事先确定结果的数量，那么试试以下的代码： Get-ChildItem -Path $home -Filter test.txt -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 这一次，Get-ChildItem 将会在找到一个文件后立即停止。 本文国际来源：Save Time With Select-Object -First!","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 展开字符串中的变量","slug":"expanding-variables-in-strings","date":"2014-02-25T16:00:00.000Z","updated":"2017-03-17T15:26:23.173Z","comments":true,"path":"2014/02/26/expanding-variables-in-strings/","link":"","permalink":"http://blog.vichamp.com/2014/02/26/expanding-variables-in-strings/","excerpt":"要在一个字符串中插入一个变量，您也许已经知道可以使用如下的双引号方式： $domain = $env:USERDOMAIN $username = $env:USERNAME &quot;$domain\\$username&quot; 对于 PowerShell 来说这些变量的起止范围是没有歧义的。所以它可以工作正常。然而试试以下代码： $domain = $env:USERDOMAIN $username = $env:USERNAME &quot;$username: located in domain $domain&quot; 这段代码执行失败了，这是因为 PowerShell 在变量中添加了冒号（从语法彩色中也可以看出）。 您可以采用 PowerShell 的反引号来为特殊字符（比如说冒号）转义： $domain = $env:USERDOMAIN $username = $env:USERNAME &quot;$username`: located in domain $domain&quot; 如果问题不是由于特殊字符引起的，那么这种方法没有作用： &quot;Current Background Color: $host.UI.RawUI.BackgroundColor&quot; 语法高亮提示双引号引起来的字符串中只解析出了变量，而其它部分（变量名之后的部分，比如说对象的属性）并没有解析出来。 要解决这个问题，您需要使用以下的方法之一： &quot;Current Background Color: $($host.UI.RawUI.BackgroundColor)&quot; &apos;Current Background Color: &apos; + $host.UI.RawUI.BackgroundColor &apos;Current Background Color: {0}&apos; -f $host.UI.RawUI.BackgroundColor","text":"要在一个字符串中插入一个变量，您也许已经知道可以使用如下的双引号方式： $domain = $env:USERDOMAIN $username = $env:USERNAME &quot;$domain\\$username&quot; 对于 PowerShell 来说这些变量的起止范围是没有歧义的。所以它可以工作正常。然而试试以下代码： $domain = $env:USERDOMAIN $username = $env:USERNAME &quot;$username: located in domain $domain&quot; 这段代码执行失败了，这是因为 PowerShell 在变量中添加了冒号（从语法彩色中也可以看出）。 您可以采用 PowerShell 的反引号来为特殊字符（比如说冒号）转义： $domain = $env:USERDOMAIN $username = $env:USERNAME &quot;$username`: located in domain $domain&quot; 如果问题不是由于特殊字符引起的，那么这种方法没有作用： &quot;Current Background Color: $host.UI.RawUI.BackgroundColor&quot; 语法高亮提示双引号引起来的字符串中只解析出了变量，而其它部分（变量名之后的部分，比如说对象的属性）并没有解析出来。 要解决这个问题，您需要使用以下的方法之一： &quot;Current Background Color: $($host.UI.RawUI.BackgroundColor)&quot; &apos;Current Background Color: &apos; + $host.UI.RawUI.BackgroundColor &apos;Current Background Color: {0}&apos; -f $host.UI.RawUI.BackgroundColor 本文国际来源：Expanding Variables in Strings","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用别名来启动 Windows 组件","slug":"using-aliases-to-launch-windows-components","date":"2014-02-24T16:00:00.000Z","updated":"2017-03-17T15:26:23.171Z","comments":true,"path":"2014/02/25/using-aliases-to-launch-windows-components/","link":"","permalink":"http://blog.vichamp.com/2014/02/25/using-aliases-to-launch-windows-components/","excerpt":"PowerShell 不仅是一个自动化操作的语言，而且是另一个用户操作界面。如果您不喜欢图形界面，那么练习使用 PowerShell 通过简单的别名来启动您需要的工具。 例如，要打开设备管理器，您可以使用它的原始名称： 如果您不想记忆这个名称，那么使用别名： 如您所见，要打开设备管理器，您现在所要做的只是键入“DeviceManager”。您也可以只键入“Device”然后按下 TAB 键来使用自动完成功能。 当关闭 PowerShell 时，定义的别名将会消失。所以要保持您定义的别名有效，请将 Set-Alias 命令加入您的配置脚本。配置脚本的路径可以在 $profile 中找到。如果这个目录不存在，您可能需要事先创建这个文件（以及它所在的文件夹）。Test-Path 可以检测它是否已经存在。","text":"PowerShell 不仅是一个自动化操作的语言，而且是另一个用户操作界面。如果您不喜欢图形界面，那么练习使用 PowerShell 通过简单的别名来启动您需要的工具。 例如，要打开设备管理器，您可以使用它的原始名称： 如果您不想记忆这个名称，那么使用别名： 如您所见，要打开设备管理器，您现在所要做的只是键入“DeviceManager”。您也可以只键入“Device”然后按下 TAB 键来使用自动完成功能。 当关闭 PowerShell 时，定义的别名将会消失。所以要保持您定义的别名有效，请将 Set-Alias 命令加入您的配置脚本。配置脚本的路径可以在 $profile 中找到。如果这个目录不存在，您可能需要事先创建这个文件（以及它所在的文件夹）。Test-Path 可以检测它是否已经存在。 本文国际来源：Using Aliases to Launch Windows Components","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 过滤命令输出的文本","slug":"filtering-text-based-command-output","date":"2014-02-23T16:00:00.000Z","updated":"2017-03-17T15:26:23.151Z","comments":true,"path":"2014/02/24/filtering-text-based-command-output/","link":"","permalink":"http://blog.vichamp.com/2014/02/24/filtering-text-based-command-output/","excerpt":"比较操作符作用于数组时，它们的作用和过滤器相似。所以许多输出多行文本的控制台命令可以使用比较操作符。 以下例子将使用 netstat.exe 来获取已连接上的网络连接，然后过滤出连到名字包含“stor”的服务器的连接，最后用 ipconfig 来获取当前的 IPv4 地址： 这个技巧是将控制台命令用 @() 括起来，确保结果为一个数组。","text":"比较操作符作用于数组时，它们的作用和过滤器相似。所以许多输出多行文本的控制台命令可以使用比较操作符。 以下例子将使用 netstat.exe 来获取已连接上的网络连接，然后过滤出连到名字包含“stor”的服务器的连接，最后用 ipconfig 来获取当前的 IPv4 地址： 这个技巧是将控制台命令用 @() 括起来，确保结果为一个数组。 本文国际来源：Filtering Text-Based Command Output","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 持有一个进程的句柄","slug":"keeping-a-handle-to-a-process","date":"2014-02-20T16:00:00.000Z","updated":"2017-03-17T15:26:23.151Z","comments":true,"path":"2014/02/21/keeping-a-handle-to-a-process/","link":"","permalink":"http://blog.vichamp.com/2014/02/21/keeping-a-handle-to-a-process/","excerpt":"当您打开一个 EXE 文件时，PowerShell 将会开心地启动它，然后什么也不管： 如果您希望持有该进程的句柄，比如希望获得它的进程 ID，或者过一会儿检查该进程运行得如何，或者要中止它，请使用 Start-Process 和 –PassThru 参数。以下代码将返回一个进程对象：","text":"当您打开一个 EXE 文件时，PowerShell 将会开心地启动它，然后什么也不管： 如果您希望持有该进程的句柄，比如希望获得它的进程 ID，或者过一会儿检查该进程运行得如何，或者要中止它，请使用 Start-Process 和 –PassThru 参数。以下代码将返回一个进程对象： 本文国际来源：Keeping a Handle to a Process","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 $PSScriptRoot 加载资源","slug":"use-psscriptroot-to-load-resources","date":"2014-02-19T16:00:00.000Z","updated":"2017-03-17T15:26:23.135Z","comments":true,"path":"2014/02/20/use-psscriptroot-to-load-resources/","link":"","permalink":"http://blog.vichamp.com/2014/02/20/use-psscriptroot-to-load-resources/","excerpt":"从 PowerShell 3.0 开始，有一个称为 $PSScriptRoot 的变量可用。该变量之前只在模块中可用。它总是指向当前脚本所在的文件夹（所以它仅在您明确地保存了它以后才生效）。 您可以使用 $PSScriptRoot 来加载相对于您脚本位置的额外资源。例如，如果您打算将一些函数放在同一个文件夹中的一个独立的“library”脚本中，以下代码将加载该 library 脚本并且导入它包含的所有函数： # this loads the script &quot;library1.ps1&quot; if it is located in the very # same folder as this script. # Requires PowerShell 3.0 or better. . &quot;$PSScriptRoot\\library1.ps1&quot; 类似地，如果您希望将您的 library 脚本保存在一个子文件夹中，请试验以下脚本（假设库脚本放在您脚本所在文件夹中的“resources”子文件夹下）： # this loads the script &quot;library1.ps1&quot; if it is located in the subfolder # &quot;resources&quot; in the folder this script is in. # Requires PowerShell 3.0 or better. . &quot;$PSScriptRoot\\resources\\library1.ps1&quot;","text":"从 PowerShell 3.0 开始，有一个称为 $PSScriptRoot 的变量可用。该变量之前只在模块中可用。它总是指向当前脚本所在的文件夹（所以它仅在您明确地保存了它以后才生效）。 您可以使用 $PSScriptRoot 来加载相对于您脚本位置的额外资源。例如，如果您打算将一些函数放在同一个文件夹中的一个独立的“library”脚本中，以下代码将加载该 library 脚本并且导入它包含的所有函数： # this loads the script &quot;library1.ps1&quot; if it is located in the very # same folder as this script. # Requires PowerShell 3.0 or better. . &quot;$PSScriptRoot\\library1.ps1&quot; 类似地，如果您希望将您的 library 脚本保存在一个子文件夹中，请试验以下脚本（假设库脚本放在您脚本所在文件夹中的“resources”子文件夹下）： # this loads the script &quot;library1.ps1&quot; if it is located in the subfolder # &quot;resources&quot; in the folder this script is in. # Requires PowerShell 3.0 or better. . &quot;$PSScriptRoot\\resources\\library1.ps1&quot; 本文国际来源：Use $PSScriptRoot to Load Resources","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用 PowerShell 为 VBScript 文件签名","slug":"signing-vbscript-files-with-powershell","date":"2014-02-18T16:00:00.000Z","updated":"2017-03-17T15:26:23.135Z","comments":true,"path":"2014/02/19/signing-vbscript-files-with-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/02/19/signing-vbscript-files-with-powershell/","excerpt":"您很可能知道 Set-AuthenticodeSignature 可以用来为 PowerShell 脚本签名。但您是否知道这个 cmdlet 可以为任何支持目标接口包 (SIP) 的任何文件呢？ 这段代码可以从一个 PFX 文件中读取数字证书，然后从您的 home 文件夹中扫描 VBScript 文件，然后将数字签名应用到脚本文件上： # change path to point to your PFX file: $pfxpath = &apos;C:\\Users\\Tobias\\Documents\\PowerShell\\testcert.pfx&apos; # change password to the password needed to read the PFX file: # (this password was set when you exported the certificate to a PFX file) $password = &apos;topsecret&apos; # load certificate Add-Type -AssemblyName System.Security $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 $cert.Import($pfxpath, $password, &apos;Exportable&apos;) # apply signature to all VBScript files # REMOVE -WHATIF TO ACTUALLY SIGN Get-ChildItem -Path $home -Filter *.vbs -Recurse -ErrorAction SilentlyContinue | Set-AuthenticodeSignature -Certificate $cert -WhatIf","text":"您很可能知道 Set-AuthenticodeSignature 可以用来为 PowerShell 脚本签名。但您是否知道这个 cmdlet 可以为任何支持目标接口包 (SIP) 的任何文件呢？ 这段代码可以从一个 PFX 文件中读取数字证书，然后从您的 home 文件夹中扫描 VBScript 文件，然后将数字签名应用到脚本文件上： # change path to point to your PFX file: $pfxpath = &apos;C:\\Users\\Tobias\\Documents\\PowerShell\\testcert.pfx&apos; # change password to the password needed to read the PFX file: # (this password was set when you exported the certificate to a PFX file) $password = &apos;topsecret&apos; # load certificate Add-Type -AssemblyName System.Security $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 $cert.Import($pfxpath, $password, &apos;Exportable&apos;) # apply signature to all VBScript files # REMOVE -WHATIF TO ACTUALLY SIGN Get-ChildItem -Path $home -Filter *.vbs -Recurse -ErrorAction SilentlyContinue | Set-AuthenticodeSignature -Certificate $cert -WhatIf 本文国际来源：Signing VBScript Files with PowerShell","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 正确地按日期时间筛选","slug":"correctly-filtering-datetime","date":"2014-02-17T16:00:00.000Z","updated":"2017-03-17T15:26:23.120Z","comments":true,"path":"2014/02/18/correctly-filtering-datetime/","link":"","permalink":"http://blog.vichamp.com/2014/02/18/correctly-filtering-datetime/","excerpt":"当您使用 Where-Object 通过日期或时间来过滤信息时，它工作得很好——前提是您使用了正确的过滤格式。请不要使用输出结果中的格式。 要指定一个日期或时间，请永远使用中性文化的格式： “year-month-day hour:minute:second”，所以 2014 年 5 月 14 日应该表述成这样：“2014-05-12 12:30:00”。 或者换种方法处理：当您输出结果时，PowerShell 将根据您控制面板的设置来格式化日期和时间。当您输入信息（例如过滤规则）时，PowerShell 永远期望接收一个通用的日期和时间格式。这是有道理的：脚本须在任何文化环境中运行一致。而结果需要格式化成读者的语言文化格式。 所以要在您的 Windows 文件夹中查找所有自从 2012 年 4 月 30 日以来没有修改过的文件，请尝试以下代码：","text":"当您使用 Where-Object 通过日期或时间来过滤信息时，它工作得很好——前提是您使用了正确的过滤格式。请不要使用输出结果中的格式。 要指定一个日期或时间，请永远使用中性文化的格式： “year-month-day hour:minute:second”，所以 2014 年 5 月 14 日应该表述成这样：“2014-05-12 12:30:00”。 或者换种方法处理：当您输出结果时，PowerShell 将根据您控制面板的设置来格式化日期和时间。当您输入信息（例如过滤规则）时，PowerShell 永远期望接收一个通用的日期和时间格式。这是有道理的：脚本须在任何文化环境中运行一致。而结果需要格式化成读者的语言文化格式。 所以要在您的 Windows 文件夹中查找所有自从 2012 年 4 月 30 日以来没有修改过的文件，请尝试以下代码： 本文国际来源：Correctly Filtering DateTime","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 屏蔽腾讯 QQ 秀","slug":"block-qq-show-with-powershell","date":"2014-02-16T16:00:00.000Z","updated":"2017-03-17T15:26:23.104Z","comments":true,"path":"2014/02/17/block-qq-show-with-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/02/17/block-qq-show-with-powershell/","excerpt":"","text":"我们在 用 PowerShell 屏蔽腾讯 QQ 的广告 这篇文章中介绍过了如何屏蔽 QQ 聊天窗口的横幅广告，那么如何屏蔽 QQ 秀的广告呢？请参见 QQ2013 删除QQ秀广告。 但是其中的步骤有点繁琐。我们把整个流程用 PowerShell 写一遍，对于用户只要执行一下即可： $folder = &quot;${env:ProgramFiles}\\Tencent\\QQ\\Plugin\\Com.Tencent.QQShow\\&quot; $folder $rdbFile = Join-Path $folder &apos;Bundle.rdb&apos; $rdbDir = Join-Path $folder &apos;Bundle&apos; $xmlPath = Join-Path $folder &apos;Bundle\\I18N\\2052\\UrlBundle.xml&apos; if (Test-Path &quot;$rdbFile.bak&quot;) { Write-Warning &quot;$rdbFile.bak 文件已存在，请确认是否已经替换？&quot; Write-Warning &quot;程序退出。&quot; return } $rdbFile .\\RDB.exe &quot;&quot;&quot;$rdbFile&quot;&quot;&quot; move $rdbFile &quot;$rdbFile.bak&quot; .\\D4QQenc.exe (Join-Path $folder &apos;Bundle\\I18N\\2052\\UrlBundle.xml.enc&apos;) del (Join-Path $folder &apos;Bundle\\I18N\\2052\\UrlBundle.xml.enc&apos;) [xml]$urlBundle = Get-Content $xmlPath -Encoding UTF8 | where { $_ -ne &apos;&apos; } @(&apos;IDS_QQSHOW_MARKET&apos;, &apos;IDS_3DSHOW_MARKET&apos;, &apos;IDS_FLASHSHOW_MARKET&apos;) | foreach { $id = $_ ($urlBundle.StringBundle.String | where { $_.id -eq $id }).&quot;#text&quot; = &apos;&apos; } $urlBundle.OuterXml | Set-Content $xmlPath -Encoding UTF8 .\\RDB.exe &quot;&quot;&quot;$rdbDir&quot;&quot;&quot; 您也可以从这里 下载 写好的脚本，祝您使用愉快。本方法在 QQ2013（SP6） 上验证通过。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"qq","slug":"qq","permalink":"http://blog.vichamp.com/tags/qq/"},{"name":"ad","slug":"ad","permalink":"http://blog.vichamp.com/tags/ad/"},{"name":"block","slug":"block","permalink":"http://blog.vichamp.com/tags/block/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中创建干净的测试环境","slug":"use-fresh-testing-environment-in-powershell-ise","date":"2014-02-16T16:00:00.000Z","updated":"2017-03-17T15:26:23.120Z","comments":true,"path":"2014/02/17/use-fresh-testing-environment-in-powershell-ise/","link":"","permalink":"http://blog.vichamp.com/2014/02/17/use-fresh-testing-environment-in-powershell-ise/","excerpt":"当您在 PowerShell ISE 编辑器中开发 PowerShell 脚本时，您需要在一个干净的环境中运行最终的测试，确保不会被之前运行时残留的变量或者函数干扰。 创建一个干净的测试环境的最简单方法是：选择文件菜单，然后选择“新建 PowerShell 选项卡”。这将为您带来一个新的标签页，并且该页代表一个全新的 PowerShell 宿主。完美的测试环境！","text":"当您在 PowerShell ISE 编辑器中开发 PowerShell 脚本时，您需要在一个干净的环境中运行最终的测试，确保不会被之前运行时残留的变量或者函数干扰。 创建一个干净的测试环境的最简单方法是：选择文件菜单，然后选择“新建 PowerShell 选项卡”。这将为您带来一个新的标签页，并且该页代表一个全新的 PowerShell 宿主。完美的测试环境！ 本文国际来源：Use Fresh Testing Environment in PowerShell ISE","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 微软虚拟学院课程","slug":"powershell-mva-lessons","date":"2014-02-13T16:00:00.000Z","updated":"2017-03-17T15:26:23.104Z","comments":true,"path":"2014/02/14/powershell-mva-lessons/","link":"","permalink":"http://blog.vichamp.com/2014/02/14/powershell-mva-lessons/","excerpt":"","text":"快速入门 PowerShell 3.0 - 入门篇。密码 sja7 快速入门 : PowerShell 3.0 高级工具和脚本 - 提高篇。密码 djqe","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"microsoft","slug":"microsoft","permalink":"http://blog.vichamp.com/tags/microsoft/"},{"name":"lesson","slug":"lesson","permalink":"http://blog.vichamp.com/tags/lesson/"},{"name":"video","slug":"video","permalink":"http://blog.vichamp.com/tags/video/"},{"name":"study","slug":"study","permalink":"http://blog.vichamp.com/tags/study/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 从 PFX 文件中导入多个证书","slug":"importing-multiple-certificates-from-pfx-files","date":"2014-02-13T16:00:00.000Z","updated":"2017-03-17T15:26:23.089Z","comments":true,"path":"2014/02/14/importing-multiple-certificates-from-pfx-files/","link":"","permalink":"http://blog.vichamp.com/2014/02/14/importing-multiple-certificates-from-pfx-files/","excerpt":"Get-PfxCertificate 可以从 PFX 文件中导入数字证书。然而，他只能获取一个证书。所以如果您的 PFX 文件中包含多个证书，您无法使用这个 cmdlet 获取其它的证书。 若要从一个 PFX 文件中导入多个证书，只要使用以下代码： $pfxpath = &apos;C:\\PathToPfxFile\\testcert.pfx&apos; $password = &apos;topsecret&apos; Add-Type -AssemblyName System.Security $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2Collection $cert.Import($pfxpath, $password, &apos;Exportable&apos;) $cert","text":"Get-PfxCertificate 可以从 PFX 文件中导入数字证书。然而，他只能获取一个证书。所以如果您的 PFX 文件中包含多个证书，您无法使用这个 cmdlet 获取其它的证书。 若要从一个 PFX 文件中导入多个证书，只要使用以下代码： $pfxpath = &apos;C:\\PathToPfxFile\\testcert.pfx&apos; $password = &apos;topsecret&apos; Add-Type -AssemblyName System.Security $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2Collection $cert.Import($pfxpath, $password, &apos;Exportable&apos;) $cert 本文国际来源：Importing Multiple Certificates from PFX Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 Remoting 中使用完整限定名","slug":"using-fully-qualified-names-in-remoting","date":"2014-02-12T16:00:00.000Z","updated":"2017-03-17T15:26:23.089Z","comments":true,"path":"2014/02/13/using-fully-qualified-names-in-remoting/","link":"","permalink":"http://blog.vichamp.com/2014/02/13/using-fully-qualified-names-in-remoting/","excerpt":"当您尝试使用 PowerShell Remoting 时，您也许会因为您使用的机器名不是完整限定名而导致连接错误。Kerberos 验证可能需要也可能不需要使用完整限定名，这取决于您的 DNS 配置。 所以也许您使用如下方式连接的时候会发生错误： Enter-PSSession -ComputerName storage1 当发生错误的时候，请向 DNS 查询完整限定名： [System.Net.Dns]::GetHostByName(&apos;storage1&apos;).HostName 然后，用查出的名字来代替主机名。如果主机启用了 Remoting 并且正确地配置了，您现在应该可以连上了。","text":"当您尝试使用 PowerShell Remoting 时，您也许会因为您使用的机器名不是完整限定名而导致连接错误。Kerberos 验证可能需要也可能不需要使用完整限定名，这取决于您的 DNS 配置。 所以也许您使用如下方式连接的时候会发生错误： Enter-PSSession -ComputerName storage1 当发生错误的时候，请向 DNS 查询完整限定名： [System.Net.Dns]::GetHostByName(&apos;storage1&apos;).HostName 然后，用查出的名字来代替主机名。如果主机启用了 Remoting 并且正确地配置了，您现在应该可以连上了。 本文国际来源：Using Fully Qualified Names in Remoting","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 确保向后兼容","slug":"ensuring-backward-compatibility","date":"2014-02-11T16:00:00.000Z","updated":"2017-03-17T15:26:23.089Z","comments":true,"path":"2014/02/12/ensuring-backward-compatibility/","link":"","permalink":"http://blog.vichamp.com/2014/02/12/ensuring-backward-compatibility/","excerpt":"假设您创建了这个函数： function Test-Function { param ( [Parameter(Mandatory=$true)] $ServerPath ) &quot;You selected $ServerPath&quot; } 它现在可以正常工作，但是在半年之后的代码审查中，您的老板希望您使用标准的参数名称，将“ServerPath”改名为“ComputerName”。那么您对您的代码做出适当的修改： function Test-Function { param ( [Parameter(Mandatory=$true)] $ComputerName ) &quot;You selected $ComputerName&quot; } 然而，您不能很容易地控制哪些人调用了您的函数，而且他们使用了旧的参数。所以要确保向后兼容，请确保您的函数使用旧的参数名也可以工作： function Test-Function { param ( [Parameter(Mandatory=$true)] [Alias(&quot;ServerPath&quot;)] $ComputerName ) &quot;You selected $ComputerName&quot; } 旧的代码任然可以运行，并且新的代码（以及代码自动完成）将会使用新的名称：","text":"假设您创建了这个函数： function Test-Function { param ( [Parameter(Mandatory=$true)] $ServerPath ) &quot;You selected $ServerPath&quot; } 它现在可以正常工作，但是在半年之后的代码审查中，您的老板希望您使用标准的参数名称，将“ServerPath”改名为“ComputerName”。那么您对您的代码做出适当的修改： function Test-Function { param ( [Parameter(Mandatory=$true)] $ComputerName ) &quot;You selected $ComputerName&quot; } 然而，您不能很容易地控制哪些人调用了您的函数，而且他们使用了旧的参数。所以要确保向后兼容，请确保您的函数使用旧的参数名也可以工作： function Test-Function { param ( [Parameter(Mandatory=$true)] [Alias(&quot;ServerPath&quot;)] $ComputerName ) &quot;You selected $ComputerName&quot; } 旧的代码任然可以运行，并且新的代码（以及代码自动完成）将会使用新的名称： 本文国际来源：Ensuring Backward Compatibility","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从 PFX 文件中导入证书","slug":"importing-certificates-from-pfx-files","date":"2014-02-10T16:00:00.000Z","updated":"2017-03-17T15:26:23.073Z","comments":true,"path":"2014/02/11/importing-certificates-from-pfx-files/","link":"","permalink":"http://blog.vichamp.com/2014/02/11/importing-certificates-from-pfx-files/","excerpt":"您可以使用 Get-PfxCertificate 来从 PFX 文件中读取数字证书，然后用数字证书来为脚本文件签名，例如： $pfxpath = &apos;C:\\PathToPfxFile\\testcert.pfx&apos; $cert = Get-PfxCertificate -FilePath $pfxpath $cert Get-ChildItem -Path c:\\myscripts -Filter *.ps1 | Set-AuthenticodeSignature -Certificate $cert 然而，Get-PfxCertificate 将会交互式地询问您导出证书至 PFX 文件时所用的密码： 要静默地导入证书，请使用这段代码： $pfxpath = &apos;C:\\PathToPfxFile\\testcert.pfx&apos; $password = &apos;topsecret&apos; Add-Type -AssemblyName System.Security $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 $cert.Import($pfxpath, $password, &apos;Exportable&apos;) $cert","text":"您可以使用 Get-PfxCertificate 来从 PFX 文件中读取数字证书，然后用数字证书来为脚本文件签名，例如： $pfxpath = &apos;C:\\PathToPfxFile\\testcert.pfx&apos; $cert = Get-PfxCertificate -FilePath $pfxpath $cert Get-ChildItem -Path c:\\myscripts -Filter *.ps1 | Set-AuthenticodeSignature -Certificate $cert 然而，Get-PfxCertificate 将会交互式地询问您导出证书至 PFX 文件时所用的密码： 要静默地导入证书，请使用这段代码： $pfxpath = &apos;C:\\PathToPfxFile\\testcert.pfx&apos; $password = &apos;topsecret&apos; Add-Type -AssemblyName System.Security $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 $cert.Import($pfxpath, $password, &apos;Exportable&apos;) $cert 本文国际来源：Importing Certificates from PFX Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 读取注册表的可扩充字符串值","slug":"reading-stringexpand-registry-values","date":"2014-02-09T16:00:00.000Z","updated":"2017-03-17T15:26:23.073Z","comments":true,"path":"2014/02/10/reading-stringexpand-registry-values/","link":"","permalink":"http://blog.vichamp.com/2014/02/10/reading-stringexpand-registry-values/","excerpt":"当您读取一个“可扩充字符串”类型的注册表值时，它将自动展开文本中的所有环境变量值。 这个例子将从注册表中读取系统设备路径： $path = &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion&apos; $key = Get-ItemProperty -Path $path $key.DevicePath 该结果将是实际的路径。这问题不大，除非您希望获取原始（未展开的）注册表值。以下是读取原始值的例子： $path = &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion&apos; $key = Get-Item -Path $path $key.GetValue(&apos;DevicePath&apos;, &apos;&apos;, &apos;DoNotExpandEnvironmentNames&apos;) 通过这种方式存取注册表值可以提供额外的信息：您还可以获取该值的数据类型： $path = &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion&apos; $key = Get-Item -Path $path $key.GetValueKind(&apos;DevicePath&apos;)","text":"当您读取一个“可扩充字符串”类型的注册表值时，它将自动展开文本中的所有环境变量值。 这个例子将从注册表中读取系统设备路径： $path = &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion&apos; $key = Get-ItemProperty -Path $path $key.DevicePath 该结果将是实际的路径。这问题不大，除非您希望获取原始（未展开的）注册表值。以下是读取原始值的例子： $path = &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion&apos; $key = Get-Item -Path $path $key.GetValue(&apos;DevicePath&apos;, &apos;&apos;, &apos;DoNotExpandEnvironmentNames&apos;) 通过这种方式存取注册表值可以提供额外的信息：您还可以获取该值的数据类型： $path = &apos;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion&apos; $key = Get-Item -Path $path $key.GetValueKind(&apos;DevicePath&apos;) 本文国际来源：Reading StringExpand Registry Values","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 设置（及删除）环境变量","slug":"setting-and-deleting-environment-variables","date":"2014-02-06T16:00:00.000Z","updated":"2017-03-17T15:26:23.065Z","comments":true,"path":"2014/02/07/setting-and-deleting-environment-variables/","link":"","permalink":"http://blog.vichamp.com/2014/02/07/setting-and-deleting-environment-variables/","excerpt":"PowerShell 可以很容易地读取环境变量。以下代码返回当前的 Windows 文件夹： $env:windir 然而，如果您想永久地改变用户或机器的环境变量，您需要使用 .NET 的功能。以下是一个可以快速设置或删除环境变量的简单函数： function Set-EnvironmentVariable { param ( [Parameter(Mandatory=$true, HelpMessage=&apos;Help note&apos;)] $Name, [System.EnvironmentVariableTarget] $Target, $Value = $null ) [System.Environment]::SetEnvironmentVariable($Name, $Value, $Target ) } 要创建一个永久的环境变量，试试以下代码： PS&gt; Set-EnvironmentVariable -Name TestVar -Value 123 -Target User 请注意新的用户变量只对新运行的应用程序可见。已运行的应用程序将会保持它们的运行环境副本，除非它们显式地请求改变后的变量。 以下是删除该环境变量的代码： PS&gt; Set-EnvironmentVariable -Name TestVar -Value &apos;&apos; -Target User","text":"PowerShell 可以很容易地读取环境变量。以下代码返回当前的 Windows 文件夹： $env:windir 然而，如果您想永久地改变用户或机器的环境变量，您需要使用 .NET 的功能。以下是一个可以快速设置或删除环境变量的简单函数： function Set-EnvironmentVariable { param ( [Parameter(Mandatory=$true, HelpMessage=&apos;Help note&apos;)] $Name, [System.EnvironmentVariableTarget] $Target, $Value = $null ) [System.Environment]::SetEnvironmentVariable($Name, $Value, $Target ) } 要创建一个永久的环境变量，试试以下代码： PS&gt; Set-EnvironmentVariable -Name TestVar -Value 123 -Target User 请注意新的用户变量只对新运行的应用程序可见。已运行的应用程序将会保持它们的运行环境副本，除非它们显式地请求改变后的变量。 以下是删除该环境变量的代码： PS&gt; Set-EnvironmentVariable -Name TestVar -Value &apos;&apos; -Target User 本文国际来源：Setting (And Deleting) Environment Variables","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 更新 Oray 花生壳动态 IP","slug":"update-oray-ddns","date":"2014-02-06T16:00:00.000Z","updated":"2017-03-17T15:26:23.073Z","comments":true,"path":"2014/02/07/update-oray-ddns/","link":"","permalink":"http://blog.vichamp.com/2014/02/07/update-oray-ddns/","excerpt":"","text":"花生壳是 oray 公司提供的 DDNS 客户端。官方的客户端庞大臃肿： 不过好在花生壳开放了基于 http 的 API。这样我们可以很容易地用 PowerShell 实现更新动态 IP 的功能： param ( $UserName = &apos;xxx&apos;, $Password = &apos;yyy&apos;, $HostName, $IP ) function Get-ExternalIP { #(Invoke-WebRequest &apos;http://myip.dnsomatic.com&apos; -UseBasicParsing).Content ((Invoke-WebRequest &apos;http://ddns.oray.com/checkip&apos;).ParsedHtml.body.innerText -split &apos;:&apos;)[1].Trim() } function Update-OrayDdns { param ( [parameter(Mandatory = $true)] [string]$UserName, [parameter(Mandatory = $true)] [string]$Password, [parameter(HelpMessage = &apos;需要更新的域名，此域名必须是开通花生壳服务。多个域名使用,分隔，默认为空，则更新护照下所有激活的域名。&apos;)] [string]$HostName, [parameter(HelpMessage = &apos;需要更新的IP地址，可以不填。如果不指定，则由服务器获取到的IP地址为准。&apos;)] [string]$IP ) $request = &apos;http://ddns.oray.com/ph/update?hostname={0}&apos; -f ($HostName -join &apos;,&apos;) if ($IP) { $request = $request + &apos;&amp;myip=&apos; + $IP } $encoded = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($UserName+&quot;:&quot;+$Password )) $headers = @{Authorization = &quot;Basic &quot;+$encoded} $response = Invoke-WebRequest $request -Headers $headers -UseBasicParsing $codes = @{ good = &apos;更新成功，域名的IP地址已经更新。&apos; nochg = &apos;更新成功，但没有改变IP。一般这种情况为本次提交的IP跟上一次的一样。&apos; notfqdn = &apos;未有激活花生壳的域名。&apos; nohost = &apos;域名不存在或未激活花生壳。&apos; abuse = &apos;请求失败，频繁请求或验证失败时会出现。&apos; &apos;!donator&apos; = &apos;表示此功能需要付费用户才能使用，如https。&apos; 911 = &apos;系统错误&apos; } $code = ($response.Content -split &apos; &apos;)[0] $message = $codes[$code] if ($code -eq &apos;good&apos; -or $code -eq &apos;nochg&apos;) { Write-Output $message } elseif ($code -eq &apos;notfqdn&apos; -or $code -eq &apos;nohost&apos;) { Write-Warning $message } else { Write-Error $message } } Update-OrayDdns $UserName $Password $HostName 您也可以从这里 下载 写好的脚本。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"ddns","slug":"ddns","permalink":"http://blog.vichamp.com/tags/ddns/"},{"name":"ip","slug":"ip","permalink":"http://blog.vichamp.com/tags/ip/"},{"name":"oray","slug":"oray","permalink":"http://blog.vichamp.com/tags/oray/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 带对话框的必选参数","slug":"mandatory-parameter-with-a-dialog","date":"2014-02-05T16:00:00.000Z","updated":"2017-03-17T15:26:23.045Z","comments":true,"path":"2014/02/06/mandatory-parameter-with-a-dialog/","link":"","permalink":"http://blog.vichamp.com/2014/02/06/mandatory-parameter-with-a-dialog/","excerpt":"通常地，当您将一个函数参数标记为“必选的”，如果用户遗漏了这个参数，PowerShell 将提示用户： function Get-Something { param ( [Parameter(Mandatory=$true)] $Path ) &quot;You entered $Path&quot; } 结果如下所示： PS&gt; Get-Something cmdlet Get-Something at command pipeline position 1 Supply values for the following parameters: Path: 以下是另一种选择：如果用户遗漏了 -Path，该函数弹出一个打开文件对话框： function Get-Something { param ( $Path = $( Add-Type -AssemblyName System.Windows.Forms $dlg = New-Object -TypeName System.Windows.Forms.OpenFileDialog if ($dlg.ShowDialog() -eq &apos;OK&apos;) { $dlg.FileName } else { throw &apos;No Path submitted&apos;} ) ) &quot;You entered $Path&quot; }","text":"通常地，当您将一个函数参数标记为“必选的”，如果用户遗漏了这个参数，PowerShell 将提示用户： function Get-Something { param ( [Parameter(Mandatory=$true)] $Path ) &quot;You entered $Path&quot; } 结果如下所示： PS&gt; Get-Something cmdlet Get-Something at command pipeline position 1 Supply values for the following parameters: Path: 以下是另一种选择：如果用户遗漏了 -Path，该函数弹出一个打开文件对话框： function Get-Something { param ( $Path = $( Add-Type -AssemblyName System.Windows.Forms $dlg = New-Object -TypeName System.Windows.Forms.OpenFileDialog if ($dlg.ShowDialog() -eq &apos;OK&apos;) { $dlg.FileName } else { throw &apos;No Path submitted&apos;} ) ) &quot;You entered $Path&quot; } 本文国际来源：Mandatory Parameter with a Dialog","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 用逗号作为十进制数分隔符","slug":"using-comma-as-decimal-delimiter","date":"2014-02-04T16:00:00.000Z","updated":"2017-03-17T15:26:23.045Z","comments":true,"path":"2014/02/05/using-comma-as-decimal-delimiter/","link":"","permalink":"http://blog.vichamp.com/2014/02/05/using-comma-as-decimal-delimiter/","excerpt":"也许您还没有意识到，PowerShell 在输入输出时用的是不同的十进制分隔符——这也许会导致脚本用户产生混淆。 当您输入信息时，PowerShell 接受的是语言中性的格式（使用“.”作为十进制分隔符）。当输出信息时，它使用的是您的区域设置（所以在许多国家，使用的是“,”）。 请实践一下看看以下是否和您的文化相符： $a = 1.5 $a 1,5 这是一个良好的设计，因为使用语言中性的输入格式，脚本执行情况永远相同，无论区域设置如何。然而，如果您希望用户能使用逗号作为分隔符，请看以下脚本： function Multiply-LocalNumber { param ( [Parameter(Mandatory=$true)] $Number1, $Number2 = 10 ) [Double]$Number1 = ($Number1 -join &apos;.&apos;) [Double]$Number2 = ($Number2 -join &apos;.&apos;) $Number1 * $Number2 } 用户可以任选一种方式运行： PS&gt; Multiply-LocalNumber 1.5 9.223 13,8345 PS&gt; Multiply-LocalNumber 1,5 9,223 13,8345 当用户选择使用逗号，PowerShell 实际上将它解释成一个数组。这是为什么脚本将数组用“.”连接的原因，实际上是将数组转换为一个数字。-join 的执行结果是一个字符串，该字符串需要被转换成一个数字，所以一切正常。 当然，这是个有点黑客的技巧，它总比每次首先得指导您的用户必须使用“.”分隔符来得好。","text":"也许您还没有意识到，PowerShell 在输入输出时用的是不同的十进制分隔符——这也许会导致脚本用户产生混淆。 当您输入信息时，PowerShell 接受的是语言中性的格式（使用“.”作为十进制分隔符）。当输出信息时，它使用的是您的区域设置（所以在许多国家，使用的是“,”）。 请实践一下看看以下是否和您的文化相符： $a = 1.5 $a 1,5 这是一个良好的设计，因为使用语言中性的输入格式，脚本执行情况永远相同，无论区域设置如何。然而，如果您希望用户能使用逗号作为分隔符，请看以下脚本： function Multiply-LocalNumber { param ( [Parameter(Mandatory=$true)] $Number1, $Number2 = 10 ) [Double]$Number1 = ($Number1 -join &apos;.&apos;) [Double]$Number2 = ($Number2 -join &apos;.&apos;) $Number1 * $Number2 } 用户可以任选一种方式运行： PS&gt; Multiply-LocalNumber 1.5 9.223 13,8345 PS&gt; Multiply-LocalNumber 1,5 9,223 13,8345 当用户选择使用逗号，PowerShell 实际上将它解释成一个数组。这是为什么脚本将数组用“.”连接的原因，实际上是将数组转换为一个数字。-join 的执行结果是一个字符串，该字符串需要被转换成一个数字，所以一切正常。 当然，这是个有点黑客的技巧，它总比每次首先得指导您的用户必须使用“.”分隔符来得好。 本文国际来源：Using Comma as Decimal Delimiter","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检测合法的时间","slug":"testing-for-valid-date","date":"2014-02-03T16:00:00.000Z","updated":"2017-03-17T15:26:23.045Z","comments":true,"path":"2014/02/04/testing-for-valid-date/","link":"","permalink":"http://blog.vichamp.com/2014/02/04/testing-for-valid-date/","excerpt":"如果您想检测某个信息类似“是否是合法的日期”，以下是一个检测的函数： function Test-Date { param ( [Parameter(Mandatory=$true)] $Date ) (($Date -as [DateTime]) -ne $null) } 这段代码使用 -as 操作符尝试将输入数据转换为 DateTime 格式。如果转换失败，则结果为 $null，所以函数可以根据转换的结果返回 $true 或 $false。请注意，-as 操作符使用您的本地 DateTime 格式。","text":"如果您想检测某个信息类似“是否是合法的日期”，以下是一个检测的函数： function Test-Date { param ( [Parameter(Mandatory=$true)] $Date ) (($Date -as [DateTime]) -ne $null) } 这段代码使用 -as 操作符尝试将输入数据转换为 DateTime 格式。如果转换失败，则结果为 $null，所以函数可以根据转换的结果返回 $true 或 $false。请注意，-as 操作符使用您的本地 DateTime 格式。 本文国际来源：Testing for Valid Date","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 朗读英文和德文（以及西班牙文，或您指定的语言）","slug":"speaking-english-and-german-and-spanish-and-you-name-it","date":"2014-02-02T16:00:00.000Z","updated":"2017-03-17T15:26:23.030Z","comments":true,"path":"2014/02/03/speaking-english-and-german-and-spanish-and-you-name-it/","link":"","permalink":"http://blog.vichamp.com/2014/02/03/speaking-english-and-german-and-spanish-and-you-name-it/","excerpt":"Windows 8 是第一个完整支持本地化的文本到语音引擎的操作系统。所以您现在可以用 PowerShell 来朗读（以及咒骂）。 同时，操作系统永远有英文引擎，所以您的计算机拥有两种语言能力。 以下是一个用于德文系统的示例脚本（它可以很容易改为您的地域）。只需要修改语言 ID 即可（例如“de-de”代表德文），就可以让 Windows 说另一种语言。 请注意，在 Windows 8 之前，只附带了英文引擎。在 Windows 8 中，您可以使用您的本地语言。其它语言不可用。 $speaker = New-Object -ComObject SAPI.SpVoice $speaker.Voice = $speaker.GetVoices() | Where-Object { $_.ID -like &apos;*de-de*&apos;} $null = $speaker.Speak(&apos;Ich spreche Deutsch&apos;) $speaker.Voice = $speaker.GetVoices() | Where-Object { $_.ID -like &apos;*en-us*&apos;} $speaker.Speak(&apos;But I can of course also speak English.&apos;)","text":"Windows 8 是第一个完整支持本地化的文本到语音引擎的操作系统。所以您现在可以用 PowerShell 来朗读（以及咒骂）。 同时，操作系统永远有英文引擎，所以您的计算机拥有两种语言能力。 以下是一个用于德文系统的示例脚本（它可以很容易改为您的地域）。只需要修改语言 ID 即可（例如“de-de”代表德文），就可以让 Windows 说另一种语言。 请注意，在 Windows 8 之前，只附带了英文引擎。在 Windows 8 中，您可以使用您的本地语言。其它语言不可用。 $speaker = New-Object -ComObject SAPI.SpVoice $speaker.Voice = $speaker.GetVoices() | Where-Object { $_.ID -like &apos;*de-de*&apos;} $null = $speaker.Speak(&apos;Ich spreche Deutsch&apos;) $speaker.Voice = $speaker.GetVoices() | Where-Object { $_.ID -like &apos;*en-us*&apos;} $speaker.Speak(&apos;But I can of course also speak English.&apos;) 本文国际来源：Speaking English and German (and Spanish, and you name it)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 单行内为多个变量赋值","slug":"multiple-assignments-in-one-line","date":"2014-01-30T16:00:00.000Z","updated":"2017-03-17T15:26:23.030Z","comments":true,"path":"2014/01/31/multiple-assignments-in-one-line/","link":"","permalink":"http://blog.vichamp.com/2014/01/31/multiple-assignments-in-one-line/","excerpt":"当您将某个值赋给一个变量时，您可以用括号把表达式括起来。这个表达式还将返回该数值。我们看看它的样子： $a = Get-Service ($a = Get-Service) 见到它们的区别了吗？第二行不仅将 Get-Service 的结果赋值给一个变量，而且将把结果输出至控制台。 实际上您也可以利用上第二行的结果。请看如下代码： $b = ($a = Get-Service).Name $a $b 这将把所有的服务赋值给 $a，并把所有的服务名称赋值给 $b。 再次地，您可以将这个结果再用括号括起来，以供下次继续复用这个结果： $c = ($b = ($a = Get-Service).Name).ToUpper() $a $b $c 现在 $c 将包含所有大写形式的服务名。很另类的写法。","text":"当您将某个值赋给一个变量时，您可以用括号把表达式括起来。这个表达式还将返回该数值。我们看看它的样子： $a = Get-Service ($a = Get-Service) 见到它们的区别了吗？第二行不仅将 Get-Service 的结果赋值给一个变量，而且将把结果输出至控制台。 实际上您也可以利用上第二行的结果。请看如下代码： $b = ($a = Get-Service).Name $a $b 这将把所有的服务赋值给 $a，并把所有的服务名称赋值给 $b。 再次地，您可以将这个结果再用括号括起来，以供下次继续复用这个结果： $c = ($b = ($a = Get-Service).Name).ToUpper() $a $b $c 现在 $c 将包含所有大写形式的服务名。很另类的写法。 本文国际来源：Multiple Assignments in One Line","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - Ping 主机","slug":"pinging-computers","date":"2014-01-29T16:00:00.000Z","updated":"2017-03-17T15:26:23.030Z","comments":true,"path":"2014/01/30/pinging-computers/","link":"","permalink":"http://blog.vichamp.com/2014/01/30/pinging-computers/","excerpt":"有很多种方法可供您 ping 主机。以下是一个简单的将传统的 ping.exe 结合进您的脚本的方法： function Test-Ping { param([Parameter(ValueFromPipeline=$true)]$Name) process { $null = ping.exe $Name -n 1 -w 1000 if($LASTEXITCODE -eq 0) { $Name } } } Test-Ping 接受一个主机名或 IP 地址作为参数并且返回 ping 是否成功。通过这种方法，您可以传入一个大的主机或 IP 地址列表，然后获得在线的结果： &apos;??&apos;,&apos;127.0.0.1&apos;,&apos;localhost&apos;,&apos;notthere&apos;,$env:COMPUTERNAME | Test-Online","text":"有很多种方法可供您 ping 主机。以下是一个简单的将传统的 ping.exe 结合进您的脚本的方法： function Test-Ping { param([Parameter(ValueFromPipeline=$true)]$Name) process { $null = ping.exe $Name -n 1 -w 1000 if($LASTEXITCODE -eq 0) { $Name } } } Test-Ping 接受一个主机名或 IP 地址作为参数并且返回 ping 是否成功。通过这种方法，您可以传入一个大的主机或 IP 地址列表，然后获得在线的结果： &apos;??&apos;,&apos;127.0.0.1&apos;,&apos;localhost&apos;,&apos;notthere&apos;,$env:COMPUTERNAME | Test-Online 本文国际来源：Pinging Computers","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 当发生错误时播放一段声音","slug":"playing-a-sound-on-error","date":"2014-01-28T16:00:00.000Z","updated":"2017-03-17T15:26:23.014Z","comments":true,"path":"2014/01/29/playing-a-sound-on-error/","link":"","permalink":"http://blog.vichamp.com/2014/01/29/playing-a-sound-on-error/","excerpt":"为了吸引用户的注意力，您的脚本可以很容易地播放 WAV 声音文件。以下是一个简单的函数： function Play-Alarm { $path = &quot;$PSScriptRoot\\Alarm06.wav&quot; $playerStart = New-Object Media.SoundPlayer $path $playerStart.Load() $playerStart.PlaySync() } 这段脚本假设 WAV 文件存放在和脚本相同的目录。请注意 PowerShell 2.0 并不支持 $PSScriptRoot。 您只需要确保设置了 $path 变量并指向一个您希望的合法的 WAV 文件即可。 缺省情况下，PowerShell 将会等待直到声音播放完。如果您希望 PowerShell 继续执行而不是等待，请将 PlaySync() 替换成 Play()。","text":"为了吸引用户的注意力，您的脚本可以很容易地播放 WAV 声音文件。以下是一个简单的函数： function Play-Alarm { $path = &quot;$PSScriptRoot\\Alarm06.wav&quot; $playerStart = New-Object Media.SoundPlayer $path $playerStart.Load() $playerStart.PlaySync() } 这段脚本假设 WAV 文件存放在和脚本相同的目录。请注意 PowerShell 2.0 并不支持 $PSScriptRoot。 您只需要确保设置了 $path 变量并指向一个您希望的合法的 WAV 文件即可。 缺省情况下，PowerShell 将会等待直到声音播放完。如果您希望 PowerShell 继续执行而不是等待，请将 PlaySync() 替换成 Play()。 本文国际来源：Playing a Sound on Error","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 根据主机名获取 DNS IP 地址","slug":"getting-dns-ip-address-from-host-name","date":"2014-01-27T16:00:00.000Z","updated":"2017-03-17T15:26:23.014Z","comments":true,"path":"2014/01/28/getting-dns-ip-address-from-host-name/","link":"","permalink":"http://blog.vichamp.com/2014/01/28/getting-dns-ip-address-from-host-name/","excerpt":"有一个 GetHostByName() .NET 函数十分有用。它可以查询一个主机名并返回其当前的 IP 地址： [System.Net.DNS]::GetHostByName(&apos;someName&apos;) 通过一个简单的 PowerShell 包装，它可以转换成一个多功能的很棒的小函数： function Get-IPAddress { param ( [Parameter(ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)] [String[]] $Name ) process { $Name | ForEach-Object { try { [System.Net.DNS]::GetHostByName($_) } catch { } }} } 您现在可以直接使用这个函数（来获取您的 IP 地址）了。您可以传入一个或多个计算机名（逗号分隔）。您甚至可以通过 Get-ADComputer 或者 Get-QADComputer 管道传入数据。 Get-IPAddress Get-IPAddress -Name TobiasAir1 Get-IPAddress -Name TobiasAir1, Server12, Storage1 &apos;TobiasAir1&apos;, &apos;Server12&apos;, &apos;Storage1&apos; | Get-IPAddress Get-QADComputer | Get-IPAddress Get-ADComputer -Filter * | Get-IPAddress 这样做是可行的，因为这个函数包含管道绑定以及一个参数序列化器。 -Name 参数为 ForEach-Object 提供数据，所以无论用户传入多少个机器名，它们都能被正确处理。 -Name 参数既能以参数的方式，也能以值的方式从管道中接收数据。所以您可以传入任何包含“Name”属性的对象，也可以传入任何纯字符串的列表。 注意该函数有一个非常简易的错误处理器。如果您传入了一个无法解析的计算机名，那么什么事也不会发生。如果您需要处理错误信息，请在 catch 代码块中添加代码。","text":"有一个 GetHostByName() .NET 函数十分有用。它可以查询一个主机名并返回其当前的 IP 地址： [System.Net.DNS]::GetHostByName(&apos;someName&apos;) 通过一个简单的 PowerShell 包装，它可以转换成一个多功能的很棒的小函数： function Get-IPAddress { param ( [Parameter(ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)] [String[]] $Name ) process { $Name | ForEach-Object { try { [System.Net.DNS]::GetHostByName($_) } catch { } }} } 您现在可以直接使用这个函数（来获取您的 IP 地址）了。您可以传入一个或多个计算机名（逗号分隔）。您甚至可以通过 Get-ADComputer 或者 Get-QADComputer 管道传入数据。 Get-IPAddress Get-IPAddress -Name TobiasAir1 Get-IPAddress -Name TobiasAir1, Server12, Storage1 &apos;TobiasAir1&apos;, &apos;Server12&apos;, &apos;Storage1&apos; | Get-IPAddress Get-QADComputer | Get-IPAddress Get-ADComputer -Filter * | Get-IPAddress 这样做是可行的，因为这个函数包含管道绑定以及一个参数序列化器。 -Name 参数为 ForEach-Object 提供数据，所以无论用户传入多少个机器名，它们都能被正确处理。 -Name 参数既能以参数的方式，也能以值的方式从管道中接收数据。所以您可以传入任何包含“Name”属性的对象，也可以传入任何纯字符串的列表。 注意该函数有一个非常简易的错误处理器。如果您传入了一个无法解析的计算机名，那么什么事也不会发生。如果您需要处理错误信息，请在 catch 代码块中添加代码。 本文国际来源：Getting DNS IP Address from Host Name","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 读写 NTFS 流","slug":"reading-and-writing-ntfs-streams","date":"2014-01-26T16:00:00.000Z","updated":"2017-03-17T15:26:23.014Z","comments":true,"path":"2014/01/27/reading-and-writing-ntfs-streams/","link":"","permalink":"http://blog.vichamp.com/2014/01/27/reading-and-writing-ntfs-streams/","excerpt":"当一个文件存储在 NTFS 文件系统分区时，您可以向它附加数据流来存储隐藏信息。 以下是一个将 PowerShell 代码隐藏在 NTFS 流中的例子。当您运行这段代码时，它将在您的桌面上创建一个新的 PowerShell 脚本文件，然后在 ISE 编辑器中打开这个文件： $path = &quot;$home\\Desktop\\secret.ps1&quot; $secretCode = { Write-Host -ForegroundColor Red &apos;This is a miracle!&apos;; [System.Console]::Beep(4000,1000) } Set-Content -Path $path -Value &apos;(Invoke-Expression &apos;&apos;[ScriptBlock]::Create((Get-Content ($MyInvocation.MyCommand.Definition) -Stream SecretStream))&apos;&apos;).Invoke()&apos; Set-Content -Path $path -Stream SecretStream -Value $secretCode ise $path 这个新的文件将看上去只是包含以下代码： (Invoke-Expression &apos;[ScriptBlock]::Create((Get-Content ($MyInvocation.MyCommand.Definition) -Stream SecretStream))&apos;).Invoke() 而当您运行这个脚本文件时，它将显示一段红色的文本并且蜂鸣一秒钟。所以新创建的脚本实际上执行了嵌入在隐藏 NTFS 流中名为“SecretStream”的代码。 要向 NTFS 卷中的（任何）文件附加隐藏信息，请使用 Add-Content 或 Set-Content 命令以及 -Stream 参数。 要从一个流中读取隐藏信息，请使用 Get-Content 命令，并为 -Stream 参数指定存储数据时用的名字。","text":"当一个文件存储在 NTFS 文件系统分区时，您可以向它附加数据流来存储隐藏信息。 以下是一个将 PowerShell 代码隐藏在 NTFS 流中的例子。当您运行这段代码时，它将在您的桌面上创建一个新的 PowerShell 脚本文件，然后在 ISE 编辑器中打开这个文件： $path = &quot;$home\\Desktop\\secret.ps1&quot; $secretCode = { Write-Host -ForegroundColor Red &apos;This is a miracle!&apos;; [System.Console]::Beep(4000,1000) } Set-Content -Path $path -Value &apos;(Invoke-Expression &apos;&apos;[ScriptBlock]::Create((Get-Content ($MyInvocation.MyCommand.Definition) -Stream SecretStream))&apos;&apos;).Invoke()&apos; Set-Content -Path $path -Stream SecretStream -Value $secretCode ise $path 这个新的文件将看上去只是包含以下代码： (Invoke-Expression &apos;[ScriptBlock]::Create((Get-Content ($MyInvocation.MyCommand.Definition) -Stream SecretStream))&apos;).Invoke() 而当您运行这个脚本文件时，它将显示一段红色的文本并且蜂鸣一秒钟。所以新创建的脚本实际上执行了嵌入在隐藏 NTFS 流中名为“SecretStream”的代码。 要向 NTFS 卷中的（任何）文件附加隐藏信息，请使用 Add-Content 或 Set-Content 命令以及 -Stream 参数。 要从一个流中读取隐藏信息，请使用 Get-Content 命令，并为 -Stream 参数指定存储数据时用的名字。 本文国际来源：Reading and Writing NTFS Streams","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 快速创建新的本地管理员账户","slug":"create-new-local-admin-account-on-the-fly","date":"2014-01-23T16:00:00.000Z","updated":"2017-03-17T15:26:23.014Z","comments":true,"path":"2014/01/24/create-new-local-admin-account-on-the-fly/","link":"","permalink":"http://blog.vichamp.com/2014/01/24/create-new-local-admin-account-on-the-fly/","excerpt":"是否有为了测试而创建新的本地管理员账户的经历？假设您已经以 Administrator 账户登录，并且使用管理员特权开启 PowerShell，那么增加这样一个账户只需要几行代码就可以完成： $user = &apos;splitpersonality&apos; net user /add $user net localgroup Administrators /add $user 注意目标的组名是本地化的，所以在非英文系统中，您需要将 Administrators 替换成您的 Administrators 组的本地化名称。 译者注：我在中文操作系统上实验了一下，直接用 Administrators 也没有问题的。","text":"是否有为了测试而创建新的本地管理员账户的经历？假设您已经以 Administrator 账户登录，并且使用管理员特权开启 PowerShell，那么增加这样一个账户只需要几行代码就可以完成： $user = &apos;splitpersonality&apos; net user /add $user net localgroup Administrators /add $user 注意目标的组名是本地化的，所以在非英文系统中，您需要将 Administrators 替换成您的 Administrators 组的本地化名称。 译者注：我在中文操作系统上实验了一下，直接用 Administrators 也没有问题的。 本文国际来源：Create New Local Admin Account on the Fly","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 启动任何版本的 Excel","slug":"launching-any-excel-version","date":"2014-01-22T16:00:00.000Z","updated":"2017-03-17T15:26:22.998Z","comments":true,"path":"2014/01/23/launching-any-excel-version/","link":"","permalink":"http://blog.vichamp.com/2014/01/23/launching-any-excel-version/","excerpt":"Microsoft Excel 是一个不那么容易直接运行的程序的例子：Excel 的路径也许是各不相同的，取决于 Office 的版本以及平台的架构（32 位或 64 位）。 PowerShell 有一个十分智能的 cmdlet 来用于运行程序：Start-Process。通常您可以以这种方式用它来运行 Excel（或其它可执行程序）： PS&gt; Start-Process -FilePath &apos;C:\\Program Files (x86)\\Microsoft Office\\Office14\\EXCEL.EXE&apos; 而在您的系统中， Excel 的路径可能不同。这是为什么 Start-Process 设计成接受通配符的原因。只要将路径中所有“特定的”部分替换为一个通配符即可。 以下代码将会运行任何版本的 Excel，而不论是什么平台架构： PS&gt; Start-Process -FilePath &apos;C:\\Program*\\Microsoft Office\\Office*\\EXCEL.EXE&apos;","text":"Microsoft Excel 是一个不那么容易直接运行的程序的例子：Excel 的路径也许是各不相同的，取决于 Office 的版本以及平台的架构（32 位或 64 位）。 PowerShell 有一个十分智能的 cmdlet 来用于运行程序：Start-Process。通常您可以以这种方式用它来运行 Excel（或其它可执行程序）： PS&gt; Start-Process -FilePath &apos;C:\\Program Files (x86)\\Microsoft Office\\Office14\\EXCEL.EXE&apos; 而在您的系统中， Excel 的路径可能不同。这是为什么 Start-Process 设计成接受通配符的原因。只要将路径中所有“特定的”部分替换为一个通配符即可。 以下代码将会运行任何版本的 Excel，而不论是什么平台架构： PS&gt; Start-Process -FilePath &apos;C:\\Program*\\Microsoft Office\\Office*\\EXCEL.EXE&apos; 本文国际来源：Launching Any Excel Version","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 解锁下载的文件","slug":"unblocking-download-files","date":"2014-01-21T16:00:00.000Z","updated":"2017-03-17T15:26:22.983Z","comments":true,"path":"2014/01/22/unblocking-download-files/","link":"","permalink":"http://blog.vichamp.com/2014/01/22/unblocking-download-files/","excerpt":"任何从 Internet 下载的以及从邮件接收到的文件，都被 Windows 隐式地标记为不安全的。如果文件包含可执行文件或二进制文件，它们必须解锁以后才可以运行。 PowerShell 3.0 以及以上的版本可以检测到包含“下载标记”的文件： Get-ChildItem -Path $Home\\Downloads -Recurse | Get-Item -Stream Zone.Identifier -ErrorAction Ignore | Select-Object -ExpandProperty FileName | Get-Item 这段代码或许不会返回任何文件（当没有文件具有下载标记的情况下），或许会返回一大堆文件（这也许意味着您解压了一个下载的 ZIP 文件，但忘了先对它解锁）。 要解锁这些文件，请使用 Unblock-File cmdlet。这段代码将解锁您下载文件夹中当前被锁定的文件（不涉及到其它任何文件）： Get-ChildItem -Path $Home\\Downloads -Recurse | Get-Item -Stream Zone.Identifier -ErrorAction Ignore | Select-Object -ExpandProperty FileName | Get-Item | Unblock-File","text":"任何从 Internet 下载的以及从邮件接收到的文件，都被 Windows 隐式地标记为不安全的。如果文件包含可执行文件或二进制文件，它们必须解锁以后才可以运行。 PowerShell 3.0 以及以上的版本可以检测到包含“下载标记”的文件： Get-ChildItem -Path $Home\\Downloads -Recurse | Get-Item -Stream Zone.Identifier -ErrorAction Ignore | Select-Object -ExpandProperty FileName | Get-Item 这段代码或许不会返回任何文件（当没有文件具有下载标记的情况下），或许会返回一大堆文件（这也许意味着您解压了一个下载的 ZIP 文件，但忘了先对它解锁）。 要解锁这些文件，请使用 Unblock-File cmdlet。这段代码将解锁您下载文件夹中当前被锁定的文件（不涉及到其它任何文件）： Get-ChildItem -Path $Home\\Downloads -Recurse | Get-Item -Stream Zone.Identifier -ErrorAction Ignore | Select-Object -ExpandProperty FileName | Get-Item | Unblock-File 本文国际来源：Unblocking Download Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"Microsoft Visual Studio 2013 Update 1 离线安装包下载","slug":"visual-studio-2013-update-1-offline-package-download","date":"2014-01-21T16:00:00.000Z","updated":"2017-03-17T15:26:22.998Z","comments":true,"path":"2014/01/22/visual-studio-2013-update-1-offline-package-download/","link":"","permalink":"http://blog.vichamp.com/2014/01/22/visual-studio-2013-update-1-offline-package-download/","excerpt":"","text":"下载信息Visual Studio 2013 Update1 官网（微软下载中心） 本次更新是适用于 Visual Studio 2013 的一系列新增功能和 Bug 修复中的最新更新。 出版日期：2014/1/17 版本：30110.00 在线安装包（1.1 MB） CRC ：AD470B9E SHA-1：D3543BFE1F0DA6D7D63760C5C3A5A7166E2B6B42 离线安装包（光盘镜像）（245 MB） CRC ：B9C46697 SHA-1：51403CAF8E5E9799ACF1F3A0DA0E46390CD2FB16","categories":[{"name":"visualstudio","slug":"visualstudio","permalink":"http://blog.vichamp.com/categories/visualstudio/"}],"tags":[{"name":"download","slug":"download","permalink":"http://blog.vichamp.com/tags/download/"},{"name":"visualstudio","slug":"visualstudio","permalink":"http://blog.vichamp.com/tags/visualstudio/"},{"name":"microsoft","slug":"microsoft","permalink":"http://blog.vichamp.com/tags/microsoft/"},{"name":"iso","slug":"iso","permalink":"http://blog.vichamp.com/tags/iso/"},{"name":"release","slug":"release","permalink":"http://blog.vichamp.com/tags/release/"},{"name":"sp1","slug":"sp1","permalink":"http://blog.vichamp.com/tags/sp1/"},{"name":"update","slug":"update","permalink":"http://blog.vichamp.com/tags/update/"}],"keywords":[{"name":"visualstudio","slug":"visualstudio","permalink":"http://blog.vichamp.com/categories/visualstudio/"}]},{"title":"PowerShell 技能连载 - 删除空结果","slug":"eliminating-empty-results","date":"2014-01-20T16:00:00.000Z","updated":"2017-03-17T15:26:22.950Z","comments":true,"path":"2014/01/21/eliminating-empty-results/","link":"","permalink":"http://blog.vichamp.com/2014/01/21/eliminating-empty-results/","excerpt":"要排除某些包含空属性值的结果，您可以简单地使用 Where-Object 命令。例如，当您运行 Get-HotFix 时，假设您只希望查看 InstalledOn 属性包含时间值的补丁，以下是解决方案： PS&gt; Get-HotFix | Where-Object InstalledOn 类似地，要从 WMI 中获取分配了 IP 地址的网络适配器，请使用以下代码： PS&gt; Get-WmiObject -Class Win32_NetworkAdapterConfiguration | Where-Object IPAddress 请注意在 PowerShell 2.0 以及以下版本，您需要使用完整的语法，类似如下： PS&gt; Get-WmiObject -Class Win32_NetworkAdapterConfiguration | Where-Object { $_.IPAddress } Where-Object 将会排除您所选的属性包含以下任意一种情况的对象：null 值、空字符串，或者数字 0。因为这些值在转换为 Boolean 类型的时候将会被转换成 $false。","text":"要排除某些包含空属性值的结果，您可以简单地使用 Where-Object 命令。例如，当您运行 Get-HotFix 时，假设您只希望查看 InstalledOn 属性包含时间值的补丁，以下是解决方案： PS&gt; Get-HotFix | Where-Object InstalledOn 类似地，要从 WMI 中获取分配了 IP 地址的网络适配器，请使用以下代码： PS&gt; Get-WmiObject -Class Win32_NetworkAdapterConfiguration | Where-Object IPAddress 请注意在 PowerShell 2.0 以及以下版本，您需要使用完整的语法，类似如下： PS&gt; Get-WmiObject -Class Win32_NetworkAdapterConfiguration | Where-Object { $_.IPAddress } Where-Object 将会排除您所选的属性包含以下任意一种情况的对象：null 值、空字符串，或者数字 0。因为这些值在转换为 Boolean 类型的时候将会被转换成 $false。 本文国际来源：Eliminating Empty Results","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - PowerShell 4.0 中隐藏的数组扩展方法","slug":"hidden-array-extensions-in-powershell-4-0","date":"2014-01-19T16:00:00.000Z","updated":"2017-03-17T15:26:22.939Z","comments":true,"path":"2014/01/20/hidden-array-extensions-in-powershell-4-0/","link":"","permalink":"http://blog.vichamp.com/2014/01/20/hidden-array-extensions-in-powershell-4-0/","excerpt":"PowerShell 4.0 （Windows 8.1 自带）中的数组原生支持 Foreach 和 Where 操作。这是一个 geek 的写法，所以并不见得比传统的管道有明显的优势（除了也许性能有所提升之外）。 这行代码将从一个数字列表中过滤出奇数来： @(1..10).Where({$_ % 2}) 以下代码将获取正在运行中的服务： @(Get-Service).Where({$_.Status -eq &apos;Running&apos;}) 还有一些更多的（不在文档中）的东西。这行代码将获取大于 2 的前 4 个数字： @(1..10).Where({$_ -gt 2}, &apos;skipuntil&apos;, 4) 最后，以下代码将做类似的事情，但是将它们转换为 TimeSpan 对象： @(1..10).Where({$_ -gt 2}, &apos;skipuntil&apos;, 5).Foreach([Timespan])","text":"PowerShell 4.0 （Windows 8.1 自带）中的数组原生支持 Foreach 和 Where 操作。这是一个 geek 的写法，所以并不见得比传统的管道有明显的优势（除了也许性能有所提升之外）。 这行代码将从一个数字列表中过滤出奇数来： @(1..10).Where({$_ % 2}) 以下代码将获取正在运行中的服务： @(Get-Service).Where({$_.Status -eq &apos;Running&apos;}) 还有一些更多的（不在文档中）的东西。这行代码将获取大于 2 的前 4 个数字： @(1..10).Where({$_ -gt 2}, &apos;skipuntil&apos;, 4) 最后，以下代码将做类似的事情，但是将它们转换为 TimeSpan 对象： @(1..10).Where({$_ -gt 2}, &apos;skipuntil&apos;, 5).Foreach([Timespan]) 本文国际来源：Hidden Array Extensions in PowerShell 4.0","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 移除 Evernote 的广告","slug":"remove-evernote-ad-with-powershell","date":"2014-01-17T16:00:00.000Z","updated":"2017-03-17T15:26:22.919Z","comments":true,"path":"2014/01/18/remove-evernote-ad-with-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/01/18/remove-evernote-ad-with-powershell/","excerpt":"","text":"破解过程Evernote（印象笔记）免费用户的左下角有个正方形的广告，点击关闭按钮反而会出来一个对话框： 虽然破解 + 写脚本 + 写这篇博客花了一两个小时，但是如果能节约更多读者的时间，并且提高一点技术水平，也算有益了吧。 我们用 Visual Studio 中的 Spy++ 查看一下控件的窗口类名： 得到的结果是“ENAdBrowserCtrl”，从窗口类名来看，似乎是为了广告而设计的。出于保险起见，用 WinHex 搜索了一下，这个字符串只出现一次，并且是采用双字节编码的“45004E0041006400420072006F0077007300650072004300740072006C”。 我们尝试破坏这个字符串试试：用 WinHex 的“填充选块”功能，将这块区域替换成 00，然后保存运行，广告果然没有了。 但是手工修改毕竟比较麻烦，而且未来版本更新以后还要再次破解。所以简单写了个 PowerShell 脚本来自动完成破解。 PowerShell 自动化脚本请将以下代码保存成 Remove-EvernoteAD.ps1 并以管理员身份执行 :)脚本的思路是以二进制的方式搜索指定的模式（pattern），并替换成新的模式。涉及到一些字节操作和进制转换。 $pattern = &apos;45004E0041006400420072006F0077007300650072004300740072006C&apos; $replacement = $pattern -replace &apos;.&apos;, &apos;0&apos; function Replace-Pattern ($buffer, $pattern, $replacement) { $isPatternMatched = $false for ($offset = 6220000; $offset -lt $buffer.Length - $pattern.Length; $offset++) { $isByteMatched = $true for ($patternOffset = 0; $patternOffset -lt $pattern.Length; $patternOffset++) { if ($buffer[$offset + $patternOffset] -ne $pattern[$patternOffset]) { $isByteMatched = $false break } } if ($isByteMatched) { $isPatternMatched = $true break } } if ($isPatternMatched) { for ($index = 0; $index -lt $pattern.Length; $index++) { $buffer[$offset + $index] = [byte]0 } return $true } else { return $false } } function Convert-HexStringToByteArray { ################################################################ #.Synopsis # Convert a string of hex data into a System.Byte[] array. An # array is always returned, even if it contains only one byte. #.Parameter String # A string containing hex data in any of a variety of formats, # including strings like the following, with or without extra # tabs, spaces, quotes or other non-hex characters: # 0x41,0x42,0x43,0x44 # x41x42x43x44 # 41-42-43-44 # 41424344 # The string can be piped into the function too. ################################################################ [CmdletBinding()] Param ( [Parameter(Mandatory = $True, ValueFromPipeline = $True)] [String] $String ) #Clean out whitespaces and any other non-hex crud. $String = $String.ToLower() -replace &apos;[^a-f0-9\\\\\\,x\\-\\:]&apos;,&apos;&apos; #Try to put into canonical colon-delimited format. $String = $String -replace &apos;0x|\\\\x|\\-|,&apos;,&apos;:&apos; #Remove beginning and ending colons, and other detritus. $String = $String -replace &apos;^:+|:+$|x|\\\\&apos;,&apos;&apos; #Maybe there&apos;s nothing left over to convert... if ($String.Length -eq 0) { ,@() ; return } #Split string with or without colon delimiters. if ($String.Length -eq 1) { ,@([System.Convert]::ToByte($String,16)) } elseif (($String.Length % 2 -eq 0) -and ($String.IndexOf(&quot;:&quot;) -eq -1)) { ,@($String -split &apos;([a-f0-9]{2})&apos; | foreach-object { if ($_) {[System.Convert]::ToByte($_,16)}}) } elseif ($String.IndexOf(&quot;:&quot;) -ne -1) { ,@($String -split &apos;:+&apos; | foreach-object {[System.Convert]::ToByte($_,16)}) } else { ,@() } #The strange &quot;,@(...)&quot; syntax is needed to force the output into an #array even if there is only one element in the output (or none). } echo &apos;本程序用于去除 Evernote 非会员左下角的正方形广告。&apos; echo &apos;请稍候……&apos; $patternArray = Convert-HexStringToByteArray $pattern $replacementArray = Convert-HexStringToByteArray $replacement $path = &quot;${Env:ProgramFiles}\\Evernote\\Evernote\\Evernote.exe&quot; $path86 = &quot;${Env:ProgramFiles(x86)}\\Evernote\\Evernote\\Evernote.exe&quot; if (Test-Path $path) { $execute = Get-Item $path } elseif (Test-Path $path86) { $execute = Get-Item $path86 } else { Write-Warning &apos;没有找到 Evernote.exe。&apos; exit } $exe = gc $execute -ReadCount 0 -Encoding byte if (Replace-Pattern $exe $patternArray $replacementArray) { $newFileName = $execute.Name + &apos;.bak&apos; $newPath = Join-Path $execute.DirectoryName $newFileName Stop-Process -Name Evernote -ErrorAction SilentlyContinue Move-Item $execute $newPath Set-Content $execute -Value $exe -Encoding Byte echo &apos;广告去除成功！Evernote 未来升级后需重新运行本程序。&apos; Start-Process $execute } else { Write-Warning &apos;无法去除广告，是否已经去除过了？&apos; if (!(Get-Process -Name Evernote -ErrorAction SilentlyContinue)) { Start-Process $execute } } 您也可以从这里 下载 写好的脚本。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"技术分析：VIM，PowerShell 和签名代码","slug":"technical-analysis-vim-powershell-and-signed-code","date":"2014-01-16T16:00:00.000Z","updated":"2017-03-17T15:26:22.888Z","comments":true,"path":"2014/01/17/technical-analysis-vim-powershell-and-signed-code/","link":"","permalink":"http://blog.vichamp.com/2014/01/17/technical-analysis-vim-powershell-and-signed-code/","excerpt":"","text":"摘要：在 UNIX 和 Linux 世界中，vi 和 EMACS 长期占据了处理大量代码或其他文本的最佳编辑器的位置。后来，一个称为 VIM（Vi, IMproved 的简称）的 vi 改进克隆版出现了。VIM 具有语法高亮、一个类似 vi 的命令行界面，以及更多强大的编辑大型文本工程的功能。它很快成为 Windows 世界之外最好用的文本编辑器之一。本文关注 VIM 和 Windows PowerShell 的配合使用，并讨论如何进行代码签名。 下载 PDF 文档：《technical-analysis-vim-powershell-and-signed-code.pdf》。 本文国际来源：Technical Analysis: VIM, PowerShell and Signed Code","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://blog.vichamp.com/tags/vim/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"gvim","slug":"gvim","permalink":"http://blog.vichamp.com/tags/gvim/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 在 ISE 编辑器中打开文件","slug":"opening-files-in-ise-editor","date":"2014-01-16T16:00:00.000Z","updated":"2017-03-17T15:26:22.872Z","comments":true,"path":"2014/01/17/opening-files-in-ise-editor/","link":"","permalink":"http://blog.vichamp.com/2014/01/17/opening-files-in-ise-editor/","excerpt":"如果您想在 ISE 编辑器中打开一个脚本，一个快捷的方法是使用命令“ise”。例如要打开您的配置脚本（每次 ISE 启动时自动调用的脚本），请试试一下代码： PS&gt; ise $profile 您现在可以方便地增加或删除您希望 ISE 每次启动时自动执行的命令。 如果您的配置脚本不存在，以下单行的代码可以为您创建一个（它将覆盖已经存在的文件，所以只能在文件确实还不存在的时候运行它）： PS&gt; New-Item -Path $profile -ItemType File -Force 您也可以从一个 PowerShell.exe 控制台中使用“ise”命令来启动一个 ISE 编辑器。 （顺便提一下：有一个叫做 psEdit 的函数使用效果十分相似，但是只在 PowerShell ISE 内部有效，在 PowerShell.exe 控制台中无效。）","text":"如果您想在 ISE 编辑器中打开一个脚本，一个快捷的方法是使用命令“ise”。例如要打开您的配置脚本（每次 ISE 启动时自动调用的脚本），请试试一下代码： PS&gt; ise $profile 您现在可以方便地增加或删除您希望 ISE 每次启动时自动执行的命令。 如果您的配置脚本不存在，以下单行的代码可以为您创建一个（它将覆盖已经存在的文件，所以只能在文件确实还不存在的时候运行它）： PS&gt; New-Item -Path $profile -ItemType File -Force 您也可以从一个 PowerShell.exe 控制台中使用“ise”命令来启动一个 ISE 编辑器。 （顺便提一下：有一个叫做 psEdit 的函数使用效果十分相似，但是只在 PowerShell ISE 内部有效，在 PowerShell.exe 控制台中无效。） 本文国际来源：Opening Files in ISE Editor","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中使用块注释","slug":"block-comment-in-powershell-ise","date":"2014-01-15T16:00:00.000Z","updated":"2017-03-17T15:26:22.872Z","comments":true,"path":"2014/01/16/block-comment-in-powershell-ise/","link":"","permalink":"http://blog.vichamp.com/2014/01/16/block-comment-in-powershell-ise/","excerpt":"从 PowerShell 3.0 开始，您可以按住 ALT 键并选择一些内容，来获取一个矩形选区。 如果您尽可能地缩窄这个选区（您将只看到一条细细的蓝线），您可以方便地在选区之内增加或删除字符。只需要按下“#”键即可块注释它们，或者删除 # 号重新启用这段代码。","text":"从 PowerShell 3.0 开始，您可以按住 ALT 键并选择一些内容，来获取一个矩形选区。 如果您尽可能地缩窄这个选区（您将只看到一条细细的蓝线），您可以方便地在选区之内增加或删除字符。只需要按下“#”键即可块注释它们，或者删除 # 号重新启用这段代码。 本文国际来源：Block Comment in PowerShell ISE","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找远程计算机上已登录的用户","slug":"finding-logged-on-user-on-remote-machine","date":"2014-01-14T16:00:00.000Z","updated":"2017-03-17T15:26:22.872Z","comments":true,"path":"2014/01/15/finding-logged-on-user-on-remote-machine/","link":"","permalink":"http://blog.vichamp.com/2014/01/15/finding-logged-on-user-on-remote-machine/","excerpt":"在上一个技巧当中我们使用 quser.exe 来查询本机当前登录的用户。以下是一个支持查询远程计算机上已登录用户的函数。有个额外的好处是，返回的信息附加了一个名为“ComputerName”的属性，所以当您查询多台计算机时，您将可以知道结果是属于那一台计算机的： function Get-LoggedOnUser { param([String[]]$ComputerName = $env:COMPUTERNAME) $ComputerName | ForEach-Object { (quser /SERVER:$_) -replace &apos;\\s{2,}&apos;, &apos;,&apos; | ConvertFrom-CSV | Add-Member -MemberType NoteProperty -Name ComputerName -Value $_ -PassThru } } 以下是一个调用的例子，查询本地计算机以及一台远程计算机：","text":"在上一个技巧当中我们使用 quser.exe 来查询本机当前登录的用户。以下是一个支持查询远程计算机上已登录用户的函数。有个额外的好处是，返回的信息附加了一个名为“ComputerName”的属性，所以当您查询多台计算机时，您将可以知道结果是属于那一台计算机的： function Get-LoggedOnUser { param([String[]]$ComputerName = $env:COMPUTERNAME) $ComputerName | ForEach-Object { (quser /SERVER:$_) -replace &apos;\\s{2,}&apos;, &apos;,&apos; | ConvertFrom-CSV | Add-Member -MemberType NoteProperty -Name ComputerName -Value $_ -PassThru } } 以下是一个调用的例子，查询本地计算机以及一台远程计算机： 本文国际来源：Finding Logged-On User on Remote Machine","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查询已登录的用户","slug":"finding-logged-on-user","date":"2014-01-13T16:00:00.000Z","updated":"2017-03-17T15:26:22.866Z","comments":true,"path":"2014/01/14/finding-logged-on-user/","link":"","permalink":"http://blog.vichamp.com/2014/01/14/finding-logged-on-user/","excerpt":"有一个十分有用的控制台程序叫做 quser.exe 可以告诉您哪些用户登录到了一台机器上。该可执行程序返回的是纯文本，但通过一点点正则表达式，该文本可以转换成 CSV 并导入 PowerShell。 以下代码以对象的形式返回所有当前登录到您机器上的用户信息： (quser) -replace &apos;s{2,}&apos;, &apos;,&apos; | ConvertFrom-Csv","text":"有一个十分有用的控制台程序叫做 quser.exe 可以告诉您哪些用户登录到了一台机器上。该可执行程序返回的是纯文本，但通过一点点正则表达式，该文本可以转换成 CSV 并导入 PowerShell。 以下代码以对象的形式返回所有当前登录到您机器上的用户信息： (quser) -replace &apos;s{2,}&apos;, &apos;,&apos; | ConvertFrom-Csv 本文国际来源：Finding Logged-On User","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查询登录失败记录","slug":"finding-logon-failures","date":"2014-01-12T16:00:00.000Z","updated":"2017-03-17T15:26:22.850Z","comments":true,"path":"2014/01/13/finding-logon-failures/","link":"","permalink":"http://blog.vichamp.com/2014/01/13/finding-logon-failures/","excerpt":"只要有人使用错误的凭据登录，就会在安全日志中产生一条日志记录。以下是一个可以从安全日志中读取这些事件的函数（需要管理员特权）。它能够列出所有日志中非法的登录信息： # requires Admin privileges! function Get-LogonFailure { param($ComputerName) try { Get-EventLog -LogName security -EntryType FailureAudit -InstanceId 4625 -ErrorAction Stop @PSBoundParameters | ForEach-Object { $domain, $user = $_.ReplacementStrings[5,6] $time = $_.TimeGenerated &quot;Logon Failure: $domain\\$user at $time&quot; } } catch { if ($_.CategoryInfo.Category -eq &apos;ObjectNotFound&apos;) { Write-Host &quot;No logon failures found.&quot; -ForegroundColor Green } else { Write-Warning &quot;Error occured: $_&quot; } } } 请注意这个函数还可以在远程主机上运行。请使用 -ComputerName 参数来查询一台远程主机。远程主机需要运行 RemoteRegistry 服务，并且您需要在目标机器上的本地管理员权限。","text":"只要有人使用错误的凭据登录，就会在安全日志中产生一条日志记录。以下是一个可以从安全日志中读取这些事件的函数（需要管理员特权）。它能够列出所有日志中非法的登录信息： # requires Admin privileges! function Get-LogonFailure { param($ComputerName) try { Get-EventLog -LogName security -EntryType FailureAudit -InstanceId 4625 -ErrorAction Stop @PSBoundParameters | ForEach-Object { $domain, $user = $_.ReplacementStrings[5,6] $time = $_.TimeGenerated &quot;Logon Failure: $domain\\$user at $time&quot; } } catch { if ($_.CategoryInfo.Category -eq &apos;ObjectNotFound&apos;) { Write-Host &quot;No logon failures found.&quot; -ForegroundColor Green } else { Write-Warning &quot;Error occured: $_&quot; } } } 请注意这个函数还可以在远程主机上运行。请使用 -ComputerName 参数来查询一台远程主机。远程主机需要运行 RemoteRegistry 服务，并且您需要在目标机器上的本地管理员权限。 本文国际来源：Finding Logon Failures","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 的配置和自动加载模块","slug":"powershell-profiles-and-module-auto-loading","date":"2014-01-10T16:00:00.000Z","updated":"2017-03-17T15:26:22.850Z","comments":true,"path":"2014/01/11/powershell-profiles-and-module-auto-loading/","link":"","permalink":"http://blog.vichamp.com/2014/01/11/powershell-profiles-and-module-auto-loading/","excerpt":"","text":"以下是 PowerShell 配置（profile）的相关文章： The Windows PowerShell Profile Understanding the Six PowerShell Profiles 以下是 PowerShell 自动加载模块的相关文章： Loading Modules Automatically Improving Module Auto-loading 在所有用户登录时自动运行PowerShell脚本","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"获取最常用的 PowerShell Cmdlet 别名","slug":"get-most-used-alias-of-powershell-cmdlet","date":"2014-01-09T16:00:00.000Z","updated":"2017-03-17T15:26:22.835Z","comments":true,"path":"2014/01/10/get-most-used-alias-of-powershell-cmdlet/","link":"","permalink":"http://blog.vichamp.com/2014/01/10/get-most-used-alias-of-powershell-cmdlet/","excerpt":"","text":"我们可以对 Get-Alias 的结果进行分组和排序，看看常用的别名有哪些。 gal | group Definition | sort Count -Descending 执行结果： Count Name Group ----- ---- ----- 6 Remove-Item {del, erase, rd, ri...} 3 Move-Item {mi, move, mv} 3 Invoke-WebRequest {curl, iwr, wget} 3 Copy-Item {copy, cp, cpi} 3 Get-ChildItem {dir, gci, ls} 3 Set-Location {cd, chdir, sl} 3 Get-Content {cat, gc, type} 3 Get-History {ghy, h, history} 2 Start-Process {saps, start} 2 ForEach-Object { %, foreach} 2 Get-Location {gl, pwd} 2 Invoke-History {ihy, r} 2 Rename-Item {ren, rni} 2 Get-Process {gps, ps} 2 Write-Output {echo, write} 2 Set-Variable {set, sv} 2 Clear-Host {clear, cls} 2 Stop-Process {kill, spps} 2 New-PSDrive {mount, ndr} 2 Compare-Object {compare, diff} 2 Where-Object {?, where} 1 Receive-Job {rcjb} 1 Receive-PSSession {rcsn} 1 Measure-Object {measure} 1 Remove-PSBreakpoint {rbp} 1 Remove-PSDrive {rdr} 1 mkdir {md} ... 还可以用如下命令查看只有 1 个字母的别名（肯定最常用了）： gal | where { $_.Name.Length -eq 1 } CommandType Name ModuleName ----------- ---- ---------- Alias % -&gt; ForEach-Object Alias ? -&gt; Where-Object Alias h -&gt; Get-History Alias r -&gt; Invoke-History","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"用 PowerShell 屏蔽腾讯 QQ 的广告","slug":"block-ad-of-tencent-qq-with-powershell","date":"2014-01-09T16:00:00.000Z","updated":"2017-03-17T15:26:22.835Z","comments":true,"path":"2014/01/10/block-ad-of-tencent-qq-with-powershell/","link":"","permalink":"http://blog.vichamp.com/2014/01/10/block-ad-of-tencent-qq-with-powershell/","excerpt":"","text":"非会员 QQ，在对话窗口的右上角会显示一个广告横幅，如图所示： 我们可以将 %appdata%\\Tencent\\Users\\QQ号\\QQ\\Misc.db 文件删除并且替换成一个同名文件夹，就可以屏蔽该广告： 如果您有多个 QQ 号的话，我们可以用 PowerShell 来批量完成该任务： echo &apos;本脚本用于屏蔽 QQ 对话窗口右上方的广告条。&apos; Read-Host &apos;请关闭所有 QQ，按回车键继续&apos; | Out-Null $usersDir = &quot;$($env:AppData)\\Tencent\\Users\\&quot; dir $usersDir -Directory | foreach { $qq = $_ $qqDir = Join-Path $_.FullName &apos;QQ&apos; $miscDb = Join-Path $qqDir Misc.db if (Test-Path -PathType Leaf $miscDb) { echo &quot;正在禁用 $qq 的广告&quot; del $miscDb md $miscDb | Out-Null } } exit echo &apos;处理完毕。&apos; 您也可以从这里 下载 写好的脚本，祝您使用愉快。本方法在 QQ2013（SP6） 上验证通过。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"qq","slug":"qq","permalink":"http://blog.vichamp.com/tags/qq/"},{"name":"ad","slug":"ad","permalink":"http://blog.vichamp.com/tags/ad/"},{"name":"block","slug":"block","permalink":"http://blog.vichamp.com/tags/block/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 更改桌面背景","slug":"change-desktop-wallpaper","date":"2014-01-09T16:00:00.000Z","updated":"2017-03-17T15:26:22.835Z","comments":true,"path":"2014/01/10/change-desktop-wallpaper/","link":"","permalink":"http://blog.vichamp.com/2014/01/10/change-desktop-wallpaper/","excerpt":"PowerShell 可以通过调用 Windows API，实现更改当前桌面背景并且立即生效。以下函数实现立刻更换桌面背景： function Set-Wallpaper { param( [Parameter(Mandatory=$true)] $Path, [ValidateSet(&apos;Center&apos;, &apos;Stretch&apos;)] $Style = &apos;Stretch&apos; ) Add-Type @&quot; using System; using System.Runtime.InteropServices; using Microsoft.Win32; namespace Wallpaper { public enum Style : int { Center, Stretch } public class Setter { public const int SetDesktopWallpaper = 20; public const int UpdateIniFile = 0x01; public const int SendWinIniChange = 0x02; [DllImport(&quot;user32.dll&quot;, SetLastError = true, CharSet = CharSet.Auto)] private static extern int SystemParametersInfo (int uAction, int uParam, string lpvParam, int fuWinIni); public static void SetWallpaper ( string path, Wallpaper.Style style ) { SystemParametersInfo( SetDesktopWallpaper, 0, path, UpdateIniFile | SendWinIniChange ); RegistryKey key = Registry.CurrentUser.OpenSubKey(&quot;Control Panel\\\\Desktop&quot;, true); switch( style ) { case Style.Stretch : key.SetValue(@&quot;WallpaperStyle&quot;, &quot;2&quot;) ; key.SetValue(@&quot;TileWallpaper&quot;, &quot;0&quot;) ; break; case Style.Center : key.SetValue(@&quot;WallpaperStyle&quot;, &quot;1&quot;) ; key.SetValue(@&quot;TileWallpaper&quot;, &quot;0&quot;) ; break; } key.Close(); } } } &quot;@ [Wallpaper.Setter]::SetWallpaper( $Path, $Style ) } Set-Wallpaper -Path &apos;C:\\Windows\\Web\\Wallpaper\\Characters\\img24.jpg&apos;","text":"PowerShell 可以通过调用 Windows API，实现更改当前桌面背景并且立即生效。以下函数实现立刻更换桌面背景： function Set-Wallpaper { param( [Parameter(Mandatory=$true)] $Path, [ValidateSet(&apos;Center&apos;, &apos;Stretch&apos;)] $Style = &apos;Stretch&apos; ) Add-Type @&quot; using System; using System.Runtime.InteropServices; using Microsoft.Win32; namespace Wallpaper { public enum Style : int { Center, Stretch } public class Setter { public const int SetDesktopWallpaper = 20; public const int UpdateIniFile = 0x01; public const int SendWinIniChange = 0x02; [DllImport(&quot;user32.dll&quot;, SetLastError = true, CharSet = CharSet.Auto)] private static extern int SystemParametersInfo (int uAction, int uParam, string lpvParam, int fuWinIni); public static void SetWallpaper ( string path, Wallpaper.Style style ) { SystemParametersInfo( SetDesktopWallpaper, 0, path, UpdateIniFile | SendWinIniChange ); RegistryKey key = Registry.CurrentUser.OpenSubKey(&quot;Control Panel\\\\Desktop&quot;, true); switch( style ) { case Style.Stretch : key.SetValue(@&quot;WallpaperStyle&quot;, &quot;2&quot;) ; key.SetValue(@&quot;TileWallpaper&quot;, &quot;0&quot;) ; break; case Style.Center : key.SetValue(@&quot;WallpaperStyle&quot;, &quot;1&quot;) ; key.SetValue(@&quot;TileWallpaper&quot;, &quot;0&quot;) ; break; } key.Close(); } } } &quot;@ [Wallpaper.Setter]::SetWallpaper( $Path, $Style ) } Set-Wallpaper -Path &apos;C:\\Windows\\Web\\Wallpaper\\Characters\\img24.jpg&apos; 本文国际来源：Change Desktop Wallpaper","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 ISE 编辑器中使用块注释","slug":"using-block-comment-in-the-ise-editor","date":"2014-01-08T16:00:00.000Z","updated":"2017-03-17T15:26:22.819Z","comments":true,"path":"2014/01/09/using-block-comment-in-the-ise-editor/","link":"","permalink":"http://blog.vichamp.com/2014/01/09/using-block-comment-in-the-ise-editor/","excerpt":"在 PowerShell 3.0 中，引入了一个小技巧，可以整块注释/取消注释某一段代码。 在 ISE 编辑器中，单击插入点（比如说一段代码的开头）。然后，按住 SHIFT+ALT，然后按下 ↓键。 这时在 ISE 编辑器中将显示一条细细的绿线。当您高亮选中了这个块以后，在绿线消失前，按下 #（或任何您打算放在标记的行前的字符）。类似地，您也可以整块删除字符。","text":"在 PowerShell 3.0 中，引入了一个小技巧，可以整块注释/取消注释某一段代码。 在 ISE 编辑器中，单击插入点（比如说一段代码的开头）。然后，按住 SHIFT+ALT，然后按下 ↓键。 这时在 ISE 编辑器中将显示一条细细的绿线。当您高亮选中了这个块以后，在绿线消失前，按下 #（或任何您打算放在标记的行前的字符）。类似地，您也可以整块删除字符。 本文国际来源：Using Block Comment in the ISE Editor","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取远程主机的系统信息","slug":"getting-system-information-for-remote-systems","date":"2014-01-07T16:00:00.000Z","updated":"2017-03-17T15:26:22.819Z","comments":true,"path":"2014/01/08/getting-system-information-for-remote-systems/","link":"","permalink":"http://blog.vichamp.com/2014/01/08/getting-system-information-for-remote-systems/","excerpt":"在上一个技巧当中您已学到如何用 systeminfo.exe 获取丰富的系统资料。systeminfo.exe 内置了远程的功能，所以如果您拥有了适当的权限，您可以获取远程主机的系统信息。 以下是一个简单的函数： function Get-SystemInfo { param($ComputerName = $env:ComputerName) $header = &apos;Hostname&apos;,&apos;OSName&apos;,&apos;OSVersion&apos;,&apos;OSManufacturer&apos;,&apos;OSConfig&apos;,&apos;Buildtype&apos;,`&apos;RegisteredOwner&apos;,&apos;RegisteredOrganization&apos;,&apos;ProductID&apos;,&apos;InstallDate&apos;,&apos;StartTime&apos;,&apos;Manufacturer&apos;,`&apos;Model&apos;,&apos;Type&apos;,&apos;Processor&apos;,&apos;BIOSVersion&apos;,&apos;WindowsFolder&apos;,&apos;SystemFolder&apos;,&apos;StartDevice&apos;,&apos;Culture&apos;,`&apos;UICulture&apos;,&apos;TimeZone&apos;,&apos;PhysicalMemory&apos;,&apos;AvailablePhysicalMemory&apos;,&apos;MaxVirtualMemory&apos;,`&apos;AvailableVirtualMemory&apos;,&apos;UsedVirtualMemory&apos;,&apos;PagingFile&apos;,&apos;Domain&apos;,&apos;LogonServer&apos;,&apos;Hotfix&apos;,`&apos;NetworkAdapter&apos; systeminfo.exe /FO CSV /S $ComputerName | Select-Object -Skip 1 | ConvertFrom-CSV -Header $header } 以下是简单的调用示例：","text":"在上一个技巧当中您已学到如何用 systeminfo.exe 获取丰富的系统资料。systeminfo.exe 内置了远程的功能，所以如果您拥有了适当的权限，您可以获取远程主机的系统信息。 以下是一个简单的函数： function Get-SystemInfo { param($ComputerName = $env:ComputerName) $header = &apos;Hostname&apos;,&apos;OSName&apos;,&apos;OSVersion&apos;,&apos;OSManufacturer&apos;,&apos;OSConfig&apos;,&apos;Buildtype&apos;,`&apos;RegisteredOwner&apos;,&apos;RegisteredOrganization&apos;,&apos;ProductID&apos;,&apos;InstallDate&apos;,&apos;StartTime&apos;,&apos;Manufacturer&apos;,`&apos;Model&apos;,&apos;Type&apos;,&apos;Processor&apos;,&apos;BIOSVersion&apos;,&apos;WindowsFolder&apos;,&apos;SystemFolder&apos;,&apos;StartDevice&apos;,&apos;Culture&apos;,`&apos;UICulture&apos;,&apos;TimeZone&apos;,&apos;PhysicalMemory&apos;,&apos;AvailablePhysicalMemory&apos;,&apos;MaxVirtualMemory&apos;,`&apos;AvailableVirtualMemory&apos;,&apos;UsedVirtualMemory&apos;,&apos;PagingFile&apos;,&apos;Domain&apos;,&apos;LogonServer&apos;,&apos;Hotfix&apos;,`&apos;NetworkAdapter&apos; systeminfo.exe /FO CSV /S $ComputerName | Select-Object -Skip 1 | ConvertFrom-CSV -Header $header } 以下是简单的调用示例： 本文国际来源：Getting System Information for Remote Systems","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取系统信息","slug":"getting-system-information","date":"2014-01-05T16:00:00.000Z","updated":"2017-03-17T15:26:22.803Z","comments":true,"path":"2014/01/06/getting-system-information/","link":"","permalink":"http://blog.vichamp.com/2014/01/06/getting-system-information/","excerpt":"PowerShell 和现有的控制台程序可以很好地共存。一个最有用的是 systeminfo.exe，它可以收集各种有用的系统信息。通过导入 systeminfo.exe 提供的 CSV 信息，PowerShell 可以将文本信息转化为对象： $header = &apos;Hostname&apos;,&apos;OSName&apos;,&apos;OSVersion&apos;,&apos;OSManufacturer&apos;,&apos;OSConfig&apos;,&apos;Buildtype&apos;,`&apos;RegisteredOwner&apos;,&apos;RegisteredOrganization&apos;,&apos;ProductID&apos;,&apos;InstallDate&apos;,&apos;StartTime&apos;,&apos;Manufacturer&apos;,`&apos;Model&apos;,&apos;Type&apos;,&apos;Processor&apos;,&apos;BIOSVersion&apos;,&apos;WindowsFolder&apos;,&apos;SystemFolder&apos;,&apos;StartDevice&apos;,&apos;Culture&apos;,`&apos;UICulture&apos;,&apos;TimeZone&apos;,&apos;PhysicalMemory&apos;,&apos;AvailablePhysicalMemory&apos;,&apos;MaxVirtualMemory&apos;,`&apos;AvailableVirtualMemory&apos;,&apos;UsedVirtualMemory&apos;,&apos;PagingFile&apos;,&apos;Domain&apos;,&apos;LogonServer&apos;,&apos;Hotfix&apos;,`&apos;NetworkAdapter&apos; systeminfo.exe /FO CSV | Select-Object -Skip 1 | ConvertFrom-CSV -Header $header 当您运行这段代码时，它将停顿数秒钟，以供 systeminfo.exe 收集信息。然后，您将会获得大量的信息： 请注意 $header：这个变量定义了属性名称，并且用自定义的列表替换了缺省的表头。所以，无论操作系统是哪种语言的，这些表头永远是相同的。 您还可以将这些信息存储在一个变量中，然后分别存取其中的信息： $header = &apos;Hostname&apos;,&apos;OSName&apos;,&apos;OSVersion&apos;,&apos;OSManufacturer&apos;,&apos;OSConfig&apos;,&apos;Buildtype&apos;,`&apos;RegisteredOwner&apos;,&apos;RegisteredOrganization&apos;,&apos;ProductID&apos;,&apos;InstallDate&apos;,&apos;StartTime&apos;,&apos;Manufacturer&apos;,`&apos;Model&apos;,&apos;Type&apos;,&apos;Processor&apos;,&apos;BIOSVersion&apos;,&apos;WindowsFolder&apos;,&apos;SystemFolder&apos;,&apos;StartDevice&apos;,&apos;Culture&apos;,`&apos;UICulture&apos;,&apos;TimeZone&apos;,&apos;PhysicalMemory&apos;,&apos;AvailablePhysicalMemory&apos;,&apos;MaxVirtualMemory&apos;,`&apos;AvailableVirtualMemory&apos;,&apos;UsedVirtualMemory&apos;,&apos;PagingFile&apos;,&apos;Domain&apos;,&apos;LogonServer&apos;,&apos;Hotfix&apos;,`&apos;NetworkAdapter&apos; $result = systeminfo.exe /FO CSV | Select-Object -Skip 1 | ConvertFrom-CSV -Header $header","text":"PowerShell 和现有的控制台程序可以很好地共存。一个最有用的是 systeminfo.exe，它可以收集各种有用的系统信息。通过导入 systeminfo.exe 提供的 CSV 信息，PowerShell 可以将文本信息转化为对象： $header = &apos;Hostname&apos;,&apos;OSName&apos;,&apos;OSVersion&apos;,&apos;OSManufacturer&apos;,&apos;OSConfig&apos;,&apos;Buildtype&apos;,`&apos;RegisteredOwner&apos;,&apos;RegisteredOrganization&apos;,&apos;ProductID&apos;,&apos;InstallDate&apos;,&apos;StartTime&apos;,&apos;Manufacturer&apos;,`&apos;Model&apos;,&apos;Type&apos;,&apos;Processor&apos;,&apos;BIOSVersion&apos;,&apos;WindowsFolder&apos;,&apos;SystemFolder&apos;,&apos;StartDevice&apos;,&apos;Culture&apos;,`&apos;UICulture&apos;,&apos;TimeZone&apos;,&apos;PhysicalMemory&apos;,&apos;AvailablePhysicalMemory&apos;,&apos;MaxVirtualMemory&apos;,`&apos;AvailableVirtualMemory&apos;,&apos;UsedVirtualMemory&apos;,&apos;PagingFile&apos;,&apos;Domain&apos;,&apos;LogonServer&apos;,&apos;Hotfix&apos;,`&apos;NetworkAdapter&apos; systeminfo.exe /FO CSV | Select-Object -Skip 1 | ConvertFrom-CSV -Header $header 当您运行这段代码时，它将停顿数秒钟，以供 systeminfo.exe 收集信息。然后，您将会获得大量的信息： 请注意 $header：这个变量定义了属性名称，并且用自定义的列表替换了缺省的表头。所以，无论操作系统是哪种语言的，这些表头永远是相同的。 您还可以将这些信息存储在一个变量中，然后分别存取其中的信息： $header = &apos;Hostname&apos;,&apos;OSName&apos;,&apos;OSVersion&apos;,&apos;OSManufacturer&apos;,&apos;OSConfig&apos;,&apos;Buildtype&apos;,`&apos;RegisteredOwner&apos;,&apos;RegisteredOrganization&apos;,&apos;ProductID&apos;,&apos;InstallDate&apos;,&apos;StartTime&apos;,&apos;Manufacturer&apos;,`&apos;Model&apos;,&apos;Type&apos;,&apos;Processor&apos;,&apos;BIOSVersion&apos;,&apos;WindowsFolder&apos;,&apos;SystemFolder&apos;,&apos;StartDevice&apos;,&apos;Culture&apos;,`&apos;UICulture&apos;,&apos;TimeZone&apos;,&apos;PhysicalMemory&apos;,&apos;AvailablePhysicalMemory&apos;,&apos;MaxVirtualMemory&apos;,`&apos;AvailableVirtualMemory&apos;,&apos;UsedVirtualMemory&apos;,&apos;PagingFile&apos;,&apos;Domain&apos;,&apos;LogonServer&apos;,&apos;Hotfix&apos;,`&apos;NetworkAdapter&apos; $result = systeminfo.exe /FO CSV | Select-Object -Skip 1 | ConvertFrom-CSV -Header $header 本文国际来源：Getting System Information","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 远程启动服务","slug":"starting-services-remotely","date":"2014-01-05T16:00:00.000Z","updated":"2017-03-17T15:26:22.819Z","comments":true,"path":"2014/01/06/starting-services-remotely/","link":"","permalink":"http://blog.vichamp.com/2014/01/06/starting-services-remotely/","excerpt":"由于 Start-Service 命令没有 -ComputerName 参数，所以您无法简单地远程启动一个服务。然而您可以在一个 PowerShell 远程管理会话中运行 Start-Service 命令。在某些场景下，一个更简单的方法是使用 Set-Service 命令。以下代码可以在名为 Server12 的服务器上远程启动 Spooler 服务： Set-Service -Name Spooler -Status Running -ComputerName Server12 不幸的是，这个命令没有 -Force 开关。所以虽然您可以简单地启动服务，但您可能无法用这种方式停止它们。当一个服务依赖于另一个服务时，它必须使用“强制”的方式来停止。","text":"由于 Start-Service 命令没有 -ComputerName 参数，所以您无法简单地远程启动一个服务。然而您可以在一个 PowerShell 远程管理会话中运行 Start-Service 命令。在某些场景下，一个更简单的方法是使用 Set-Service 命令。以下代码可以在名为 Server12 的服务器上远程启动 Spooler 服务： Set-Service -Name Spooler -Status Running -ComputerName Server12 不幸的是，这个命令没有 -Force 开关。所以虽然您可以简单地启动服务，但您可能无法用这种方式停止它们。当一个服务依赖于另一个服务时，它必须使用“强制”的方式来停止。 本文国际来源：Starting Services Remotely","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 ICACLS 提高文件夹安全性","slug":"using-icacls-to-secure-folders","date":"2014-01-02T16:00:00.000Z","updated":"2017-03-17T15:26:22.803Z","comments":true,"path":"2014/01/03/using-icacls-to-secure-folders/","link":"","permalink":"http://blog.vichamp.com/2014/01/03/using-icacls-to-secure-folders/","excerpt":"在 PowerShell 系统中，控制台程序也是相同的“一等公民”。在这个例子中，New-Folder 函数使用 icacls.exe 来设置新建文件夹的权限： function New-Folder { param ( $Path, $Username ) If ( (Test-Path -Path $path) -eq $false ) { New-Item $path -Type Directory | Out-Null } icacls $path /inheritance:r /grant &apos;*S-1-5-32-544:(OI)(CI)R&apos; (&apos;{0}:(OI)(CI)F&apos; -f $username) } New-Folder 函数将创建一个新文件夹（如果它不存在），然后使用 icacls.exe 来禁止继承、允许 Administrators 组读取以及赋予指定用户完全控制权限。","text":"在 PowerShell 系统中，控制台程序也是相同的“一等公民”。在这个例子中，New-Folder 函数使用 icacls.exe 来设置新建文件夹的权限： function New-Folder { param ( $Path, $Username ) If ( (Test-Path -Path $path) -eq $false ) { New-Item $path -Type Directory | Out-Null } icacls $path /inheritance:r /grant &apos;*S-1-5-32-544:(OI)(CI)R&apos; (&apos;{0}:(OI)(CI)F&apos; -f $username) } New-Folder 函数将创建一个新文件夹（如果它不存在），然后使用 icacls.exe 来禁止继承、允许 Administrators 组读取以及赋予指定用户完全控制权限。 本文国际来源：Using ICACLS to Secure Folders","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 降低 PowerShell 进程优先级","slug":"lowering-powershell-process-priority","date":"2014-01-01T16:00:00.000Z","updated":"2017-03-17T15:26:22.803Z","comments":true,"path":"2014/01/02/lowering-powershell-process-priority/","link":"","permalink":"http://blog.vichamp.com/2014/01/02/lowering-powershell-process-priority/","excerpt":"当您运行一个 PowerShell 任务时，默认情况下它的优先级是 Normal。并且如果您脚本所做的事十分消耗 CPU 的话，您机器的性能可能会受影响。 要避免这个现象，您可以将您的 PowerShell 进程设置为更低的优先级，这样它仅在 CPU 负载允许的情况下运行。这可以确保您的 PowerShell 任务不会影响其它任务的性能。 这个例子将优先级设为“Below Normal”。您也可以将它设置为“Idle”，那样您的 PowerShell 脚本仅当机器没有别的事做时才会运行。 $process = Get-Process -Id $pid $process.PriorityClass = &apos;BelowNormal&apos; 译者注：可能的 PriorityClass 值为 Normal、Idle、High、RealTime、BelowNormal、AboveNormal。要找到明确的文档比较困难，但是有一个取巧的办法：故意打错。比如说我们可以打成 $process.PriorityClass = &#39;trudellic&#39;，运行以后提示： Exception setting &quot;PriorityClass&quot;: &quot;Cannot convert value &quot;trudellic&quot; to type &quot;System.Diagnostics.ProcessPriorityClass&quot;. Error: &quot;Unable to match the identifier name trudellic to a valid enumerator name. 这时候可用的值在错误提示中就暴露出来了 :-)","text":"当您运行一个 PowerShell 任务时，默认情况下它的优先级是 Normal。并且如果您脚本所做的事十分消耗 CPU 的话，您机器的性能可能会受影响。 要避免这个现象，您可以将您的 PowerShell 进程设置为更低的优先级，这样它仅在 CPU 负载允许的情况下运行。这可以确保您的 PowerShell 任务不会影响其它任务的性能。 这个例子将优先级设为“Below Normal”。您也可以将它设置为“Idle”，那样您的 PowerShell 脚本仅当机器没有别的事做时才会运行。 $process = Get-Process -Id $pid $process.PriorityClass = &apos;BelowNormal&apos; 译者注：可能的 PriorityClass 值为 Normal、Idle、High、RealTime、BelowNormal、AboveNormal。要找到明确的文档比较困难，但是有一个取巧的办法：故意打错。比如说我们可以打成 $process.PriorityClass = &#39;trudellic&#39;，运行以后提示： Exception setting &quot;PriorityClass&quot;: &quot;Cannot convert value &quot;trudellic&quot; to type &quot;System.Diagnostics.ProcessPriorityClass&quot;. Error: &quot;Unable to match the identifier name trudellic to a valid enumerator name. 这时候可用的值在错误提示中就暴露出来了 :-) 本文国际来源：Lowering PowerShell Process Priority","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - PowerShell 远程管理和大尺寸令牌问题","slug":"powershell-remoting-with-large-token-size","date":"2013-12-31T16:00:00.000Z","updated":"2017-03-17T15:26:22.788Z","comments":true,"path":"2014/01/01/powershell-remoting-with-large-token-size/","link":"","permalink":"http://blog.vichamp.com/2014/01/01/powershell-remoting-with-large-token-size/","excerpt":"Kerberos 令牌大小取决于用户组成员的数量。在某些重度使用组成员的企业环境中，令牌的大小可能会溢出 PowerShell 远程管理的限制。在这些情况下，PowerShell 远程管理操作会失败，提示一句模糊的信息。 要使用 PowerShell 远程管理，您可以设置两个注册表值，并且增加令牌的允许尺寸： #Source: http://www.miru.ch/how-the-kerberos-token-size-can-affect-winrm-and-other-kerberos-based-services/ New-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Services\\HTTP\\Parameters `-Name &quot;MaxFieldLength&quot; -Value 65335 -PropertyType &quot;DWORD&quot; New-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Services\\HTTP\\Parameters `-Name &quot;MaxRequestBytes&quot; -Value 40000 -PropertyType &quot;DWORD&quot;","text":"Kerberos 令牌大小取决于用户组成员的数量。在某些重度使用组成员的企业环境中，令牌的大小可能会溢出 PowerShell 远程管理的限制。在这些情况下，PowerShell 远程管理操作会失败，提示一句模糊的信息。 要使用 PowerShell 远程管理，您可以设置两个注册表值，并且增加令牌的允许尺寸： #Source: http://www.miru.ch/how-the-kerberos-token-size-can-affect-winrm-and-other-kerberos-based-services/ New-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Services\\HTTP\\Parameters `-Name &quot;MaxFieldLength&quot; -Value 65335 -PropertyType &quot;DWORD&quot; New-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Services\\HTTP\\Parameters `-Name &quot;MaxRequestBytes&quot; -Value 40000 -PropertyType &quot;DWORD&quot; 本文国际来源：PowerShell Remoting with Large Token Size","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取最新的地震信息","slug":"getting-most-recent-earthquakes","date":"2013-12-30T16:00:00.000Z","updated":"2017-03-17T15:26:22.788Z","comments":true,"path":"2013/12/31/getting-most-recent-earthquakes/","link":"","permalink":"http://blog.vichamp.com/2013/12/31/getting-most-recent-earthquakes/","excerpt":"现代社会中，所有东西都是彼此相连的。PowerShell 可以从 web service 中获取公共数据。以下仅仅一行代码就可以为您获取最新检测到的地震以及它们的震级： Invoke-RestMethod -URI &quot;http://www.seismi.org/api/eqs&quot; | Select-Object -First 30 -ExpandProperty Earthquakes | Out-GridView","text":"现代社会中，所有东西都是彼此相连的。PowerShell 可以从 web service 中获取公共数据。以下仅仅一行代码就可以为您获取最新检测到的地震以及它们的震级： Invoke-RestMethod -URI &quot;http://www.seismi.org/api/eqs&quot; | Select-Object -First 30 -ExpandProperty Earthquakes | Out-GridView 本文国际来源：Getting Most Recent Earthquakes","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从多个事件日志中获取错误事件","slug":"getting-error-events-from-multiple-event-logs","date":"2013-12-29T16:00:00.000Z","updated":"2017-03-17T15:26:22.788Z","comments":true,"path":"2013/12/30/getting-error-events-from-multiple-event-logs/","link":"","permalink":"http://blog.vichamp.com/2013/12/30/getting-error-events-from-multiple-event-logs/","excerpt":"Get-EventLog 命令每次只能读取一个事件日志。然而如果您希望从多个事件日志中读取事件，您可以传入数组信息： $events = @(Get-EventLog -LogName System -EntryType Error) $events += Get-EventLog -LogName Application -EntryType Error $events 在这些例子中，使用 WMI 来查询可能会更简单一些——它可以一次性查询任意多个系统日志。 以下代码将从应用程序和系统日志中获取前 100 条错误日志（指的是总计 100 条，所以如果前 100 条错误都是应用程序日志，则当然不会包括系统错误）： Get-WmiObject -Class Win32_NTLogEvent -Filter &apos;Type=&quot;Error&quot; and (LogFile=&quot;System&quot; or LogFile=&quot;Application&quot;)&apos; | Select-Object -First 100 -Property TimeGenerated, LogFile, EventCode, Message 当您将 Get-WmiObject 换成 Get-CimInstance（PowerShell 3.0 新增的命令），那么诡异的 WMI 日期格式将会被自动转换为普通的日期和时间： Get-CimInstance -Class Win32_NTLogEvent -Filter &apos;Type=&quot;Error&quot; and (LogFile=&quot;System&quot; or LogFile=&quot;Application&quot;)&apos; | Select-Object -First 100 -Property TimeGenerated, LogFile, EventCode, Message","text":"Get-EventLog 命令每次只能读取一个事件日志。然而如果您希望从多个事件日志中读取事件，您可以传入数组信息： $events = @(Get-EventLog -LogName System -EntryType Error) $events += Get-EventLog -LogName Application -EntryType Error $events 在这些例子中，使用 WMI 来查询可能会更简单一些——它可以一次性查询任意多个系统日志。 以下代码将从应用程序和系统日志中获取前 100 条错误日志（指的是总计 100 条，所以如果前 100 条错误都是应用程序日志，则当然不会包括系统错误）： Get-WmiObject -Class Win32_NTLogEvent -Filter &apos;Type=&quot;Error&quot; and (LogFile=&quot;System&quot; or LogFile=&quot;Application&quot;)&apos; | Select-Object -First 100 -Property TimeGenerated, LogFile, EventCode, Message 当您将 Get-WmiObject 换成 Get-CimInstance（PowerShell 3.0 新增的命令），那么诡异的 WMI 日期格式将会被自动转换为普通的日期和时间： Get-CimInstance -Class Win32_NTLogEvent -Filter &apos;Type=&quot;Error&quot; and (LogFile=&quot;System&quot; or LogFile=&quot;Application&quot;)&apos; | Select-Object -First 100 -Property TimeGenerated, LogFile, EventCode, Message 本文国际来源：Getting Error Events from Multiple Event Logs","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 有序哈希表以及更改顺序","slug":"ordered-hash-tables-and-changing-order","date":"2013-12-26T16:00:00.000Z","updated":"2017-03-17T15:26:22.772Z","comments":true,"path":"2013/12/27/ordered-hash-tables-and-changing-order/","link":"","permalink":"http://blog.vichamp.com/2013/12/27/ordered-hash-tables-and-changing-order/","excerpt":"有序哈希表是在 PowerShell 3.0 中增加的新特性，它在创建新对象的时候十分有用。和常规的哈希表不同，有序哈希表保存了您添加键时的顺序，您还可以控制这些键转化为对象属性时的顺序。以下是一个例子： $hashtable = [Ordered]@{} $hashtable.Name = &apos;Tobias&apos; $hashtable.ID = 12 $hashtable.Location = &apos;Germany&apos; New-Object -TypeName PSObject -Property $hashtable 这段代码创建了一个对象，它的属性定义严格按照它们指定时的先后顺序排列。 那么如果您希望不在尾部，例如在列表的头部增加一个属性，要怎么做呢？ $hashtable = [Ordered]@{} $hashtable.Name = &apos;Tobias&apos; $hashtable.ID = 12 $hashtable.Location = &apos;Germany&apos; $hashtable.Insert(0, &apos;Position&apos;, &apos;CSA&apos;) New-Object -TypeName PSObject -Property $hashtable","text":"有序哈希表是在 PowerShell 3.0 中增加的新特性，它在创建新对象的时候十分有用。和常规的哈希表不同，有序哈希表保存了您添加键时的顺序，您还可以控制这些键转化为对象属性时的顺序。以下是一个例子： $hashtable = [Ordered]@{} $hashtable.Name = &apos;Tobias&apos; $hashtable.ID = 12 $hashtable.Location = &apos;Germany&apos; New-Object -TypeName PSObject -Property $hashtable 这段代码创建了一个对象，它的属性定义严格按照它们指定时的先后顺序排列。 那么如果您希望不在尾部，例如在列表的头部增加一个属性，要怎么做呢？ $hashtable = [Ordered]@{} $hashtable.Name = &apos;Tobias&apos; $hashtable.ID = 12 $hashtable.Location = &apos;Germany&apos; $hashtable.Insert(0, &apos;Position&apos;, &apos;CSA&apos;) New-Object -TypeName PSObject -Property $hashtable 本文国际来源：Ordered Hash Tables and Changing Order","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取昨天午夜的日期值","slug":"getting-yesterday-s-date-at-midnight","date":"2013-12-25T16:00:00.000Z","updated":"2017-03-17T15:26:22.770Z","comments":true,"path":"2013/12/26/getting-yesterday-s-date-at-midnight/","link":"","permalink":"http://blog.vichamp.com/2013/12/26/getting-yesterday-s-date-at-midnight/","excerpt":"当您了解了每个 DateTime 对象支持 Add...() 方法之后，获取相对日期（例如昨天或下周）就十分容易了。以下代码可以获取昨天的时间值： $today = Get-Date $yesterday = $today.AddDays(-1) $yesterday $yesterday 的值是当前时间之前 24 小时整的值。那么如果您希望得到昨天特定时刻的值，比如说昨天午夜呢？ 如果您希望得到今天午夜的值，那么十分简单： $todayMidnight = Get-Date -Hour 0 -Minute 0 -Second 0 $todayMidnight 如果您希望得到另一天的该时间值，那么再次使用 Get-Date 来修改时间值。以代码获取昨天午夜的时间值： $today = Get-Date $yesterday = $today.AddDays(-1) $yesterday | Get-Date -Hour 0 -Minute 0 -Second 0 译者注：如果您只是需要获取昨天午夜的日期值，还可以有其它方法。如：(Get-Date).AddDays(-1).Date 或 [System.DateTime]::Today.Subtract([System.TimeSpan]::FromDays(1))。","text":"当您了解了每个 DateTime 对象支持 Add...() 方法之后，获取相对日期（例如昨天或下周）就十分容易了。以下代码可以获取昨天的时间值： $today = Get-Date $yesterday = $today.AddDays(-1) $yesterday $yesterday 的值是当前时间之前 24 小时整的值。那么如果您希望得到昨天特定时刻的值，比如说昨天午夜呢？ 如果您希望得到今天午夜的值，那么十分简单： $todayMidnight = Get-Date -Hour 0 -Minute 0 -Second 0 $todayMidnight 如果您希望得到另一天的该时间值，那么再次使用 Get-Date 来修改时间值。以代码获取昨天午夜的时间值： $today = Get-Date $yesterday = $today.AddDays(-1) $yesterday | Get-Date -Hour 0 -Minute 0 -Second 0 译者注：如果您只是需要获取昨天午夜的日期值，还可以有其它方法。如：(Get-Date).AddDays(-1).Date 或 [System.DateTime]::Today.Subtract([System.TimeSpan]::FromDays(1))。 本文国际来源：Getting Yesterday’s Date - at Midnight!","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 搜索并观看 PowerShell 视频","slug":"search-and-view-powershell-videos","date":"2013-12-24T16:00:00.000Z","updated":"2017-03-17T15:26:22.767Z","comments":true,"path":"2013/12/25/search-and-view-powershell-videos/","link":"","permalink":"http://blog.vichamp.com/2013/12/25/search-and-view-powershell-videos/","excerpt":"PowerShell 是令人惊叹的。它可以根据您选择的关键词搜索 YouTube 视频，然后为您呈现视频，以及根据选择播放视频。 以下这段简单的脚本（需要 Internet 连接）可以列出 YouTube 上最新的“Learn PowerShell”视频。该列表使用一个 Grid View 窗口呈现，您可以在顶部使用全文搜索或者按列排序，来查找您需要的视频。 下一步，单击视频项选中它，然后单击网格右下角的“确定”按钮。 PowerShell 将会启动您的 Web 浏览器并且播放视频。太棒了！ $keyword = &quot;Learn PowerShell&quot; Invoke-RestMethod -Uri &quot;https://gdata.youtube.com/feeds/api/videos?v=2&amp;q=$($keyword.Replace(&apos; &apos;,&apos;+&apos;))&quot; | Select-Object -Property Title, @{N=&apos;Author&apos;;E={$_.Author.Name}}, @{N=&apos;Link&apos;;E={$_.Content.src}}, @{N=&apos;Updated&apos;;E={[DateTime]$_.Updated}} | Sort-Object -Property Updated -Descending | Out-GridView -Title &quot;Select your &apos;$Keyword&apos; video, then click OK to view.&quot; -PassThru | ForEach-Object { Start-Process $_.Link } 只需要改变第一行的 $keyword 变量就可以搜索不同的视频或者主题。 请注意由于 PowerShell 3.0 的一个 bug，Invoke-RestMethod 只会返回一部分结果。PowerShell 4.0 修复了这个 bug。 译者注：由于国内暂时不可直接访问 YouTube 服务，验证本脚本需要合适的代理服务器或 VPN。","text":"PowerShell 是令人惊叹的。它可以根据您选择的关键词搜索 YouTube 视频，然后为您呈现视频，以及根据选择播放视频。 以下这段简单的脚本（需要 Internet 连接）可以列出 YouTube 上最新的“Learn PowerShell”视频。该列表使用一个 Grid View 窗口呈现，您可以在顶部使用全文搜索或者按列排序，来查找您需要的视频。 下一步，单击视频项选中它，然后单击网格右下角的“确定”按钮。 PowerShell 将会启动您的 Web 浏览器并且播放视频。太棒了！ $keyword = &quot;Learn PowerShell&quot; Invoke-RestMethod -Uri &quot;https://gdata.youtube.com/feeds/api/videos?v=2&amp;q=$($keyword.Replace(&apos; &apos;,&apos;+&apos;))&quot; | Select-Object -Property Title, @{N=&apos;Author&apos;;E={$_.Author.Name}}, @{N=&apos;Link&apos;;E={$_.Content.src}}, @{N=&apos;Updated&apos;;E={[DateTime]$_.Updated}} | Sort-Object -Property Updated -Descending | Out-GridView -Title &quot;Select your &apos;$Keyword&apos; video, then click OK to view.&quot; -PassThru | ForEach-Object { Start-Process $_.Link } 只需要改变第一行的 $keyword 变量就可以搜索不同的视频或者主题。 请注意由于 PowerShell 3.0 的一个 bug，Invoke-RestMethod 只会返回一部分结果。PowerShell 4.0 修复了这个 bug。 译者注：由于国内暂时不可直接访问 YouTube 服务，验证本脚本需要合适的代理服务器或 VPN。 本文国际来源：Search and View PowerShell Videos","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 Windows 8.1 中管理 Windows Defender","slug":"managing-windows-defender-in-windows-8-1","date":"2013-12-23T16:00:00.000Z","updated":"2017-03-17T15:26:22.750Z","comments":true,"path":"2013/12/24/managing-windows-defender-in-windows-8-1/","link":"","permalink":"http://blog.vichamp.com/2013/12/24/managing-windows-defender-in-windows-8-1/","excerpt":"Windows 8.1 发布了一个称为“Defender”的新模块。内置的 cmdlet 使您能够管理、查看和修改 Windows Defender 反病毒程序的每一个方面。 要列出所有可用的 cmdlet，请使用以下代码： Get-Command -Module Defender 如果您没有获得任何返回信息，那么您正在运行的很可能不是 Windows 8.1，所以该模块不可用。 下一步，试着浏览这些 cmdlet。例如 Get-MpPreference，将列出当前所有偏好设置。类似地，Set-MpPreference 可以改变它们的值。 Get-MpThreatDetection 将会列出当前检测到的所有威胁（如果当前没有任何威胁，则返回空）。","text":"Windows 8.1 发布了一个称为“Defender”的新模块。内置的 cmdlet 使您能够管理、查看和修改 Windows Defender 反病毒程序的每一个方面。 要列出所有可用的 cmdlet，请使用以下代码： Get-Command -Module Defender 如果您没有获得任何返回信息，那么您正在运行的很可能不是 Windows 8.1，所以该模块不可用。 下一步，试着浏览这些 cmdlet。例如 Get-MpPreference，将列出当前所有偏好设置。类似地，Set-MpPreference 可以改变它们的值。 Get-MpThreatDetection 将会列出当前检测到的所有威胁（如果当前没有任何威胁，则返回空）。 本文国际来源：Managing Windows Defender in Windows 8.1","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 搜索本地用户","slug":"searching-for-local-user-accounts","date":"2013-12-22T16:00:00.000Z","updated":"2017-03-17T15:26:22.750Z","comments":true,"path":"2013/12/23/searching-for-local-user-accounts/","link":"","permalink":"http://blog.vichamp.com/2013/12/23/searching-for-local-user-accounts/","excerpt":"您知道吗？您可以搜索计算机上的本地用户，就像搜索域账户一样。 以下的示例代码搜索所有以“A”开头并且是启用状态的本地用户： Add-Type -AssemblyName System.DirectoryServices.AccountManagement $type = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext(&apos;Machine&apos;, $env:COMPUTERNAME) $UserPrincipal = New-Object System.DirectoryServices.AccountManagement.UserPrincipal($type) # adjust your search criteria here: $UserPrincipal.Name = &apos;A*&apos; # you can add even more: $UserPrincipal.Enabled = $true $searcher = New-Object System.DirectoryServices.AccountManagement.PrincipalSearcher $searcher.QueryFilter = $UserPrincipal $results = $searcher.FindAll(); $results | Select-Object -Property Name, LastLogon, Enabled 类似地，要查找所有设置了密码、密码永不过期，并且是启用状态的本地用户，试试以下代码： Add-Type -AssemblyName System.DirectoryServices.AccountManagement $type = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext(&apos;Machine&apos;, $env:COMPUTERNAME) $UserPrincipal = New-Object System.DirectoryServices.AccountManagement.UserPrincipal($type) # adjust your search criteria here: $UserPrincipal.PasswordNeverExpires = $true $UserPrincipal.Enabled = $true $searcher = New-Object System.DirectoryServices.AccountManagement.PrincipalSearcher $searcher.QueryFilter = $UserPrincipal $results = $searcher.FindAll(); $results | Select-Object -Property Name, LastLogon, Enabled, PasswordNeverExpires","text":"您知道吗？您可以搜索计算机上的本地用户，就像搜索域账户一样。 以下的示例代码搜索所有以“A”开头并且是启用状态的本地用户： Add-Type -AssemblyName System.DirectoryServices.AccountManagement $type = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext(&apos;Machine&apos;, $env:COMPUTERNAME) $UserPrincipal = New-Object System.DirectoryServices.AccountManagement.UserPrincipal($type) # adjust your search criteria here: $UserPrincipal.Name = &apos;A*&apos; # you can add even more: $UserPrincipal.Enabled = $true $searcher = New-Object System.DirectoryServices.AccountManagement.PrincipalSearcher $searcher.QueryFilter = $UserPrincipal $results = $searcher.FindAll(); $results | Select-Object -Property Name, LastLogon, Enabled 类似地，要查找所有设置了密码、密码永不过期，并且是启用状态的本地用户，试试以下代码： Add-Type -AssemblyName System.DirectoryServices.AccountManagement $type = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext(&apos;Machine&apos;, $env:COMPUTERNAME) $UserPrincipal = New-Object System.DirectoryServices.AccountManagement.UserPrincipal($type) # adjust your search criteria here: $UserPrincipal.PasswordNeverExpires = $true $UserPrincipal.Enabled = $true $searcher = New-Object System.DirectoryServices.AccountManagement.PrincipalSearcher $searcher.QueryFilter = $UserPrincipal $results = $searcher.FindAll(); $results | Select-Object -Property Name, LastLogon, Enabled, PasswordNeverExpires 本文国际来源：Searching for Local User Accounts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取本地组成员","slug":"getting-local-group-members","date":"2013-12-19T16:00:00.000Z","updated":"2017-03-17T15:26:22.734Z","comments":true,"path":"2013/12/20/getting-local-group-members/","link":"","permalink":"http://blog.vichamp.com/2013/12/20/getting-local-group-members/","excerpt":"在 PowerShell 中，通过 .NET Framework 3.51 或更高的版本，可以使用面向对象的方式管理本地用户和组。以下代码可以列出本机上的管理员用户： Add-Type -AssemblyName System.DirectoryServices.AccountManagement $type = New-Object DirectoryServices.AccountManagement.PrincipalContext(&apos;Machine&apos;, `$env:COMPUTERNAME) $group = [DirectoryServices.AccountManagement.GroupPrincipal]::FindByIdentity($type, `&apos;SAMAccountName&apos;, &apos;Administrators&apos;) $group.Members | Select-Object -Property SAMAccountName, LastPasswordSet, LastLogon, Enabled 您还可以获取更多的信息，比如试着查询组本身的信息： 或者试着列出所有成员的所有属性：","text":"在 PowerShell 中，通过 .NET Framework 3.51 或更高的版本，可以使用面向对象的方式管理本地用户和组。以下代码可以列出本机上的管理员用户： Add-Type -AssemblyName System.DirectoryServices.AccountManagement $type = New-Object DirectoryServices.AccountManagement.PrincipalContext(&apos;Machine&apos;, `$env:COMPUTERNAME) $group = [DirectoryServices.AccountManagement.GroupPrincipal]::FindByIdentity($type, `&apos;SAMAccountName&apos;, &apos;Administrators&apos;) $group.Members | Select-Object -Property SAMAccountName, LastPasswordSet, LastLogon, Enabled 您还可以获取更多的信息，比如试着查询组本身的信息： 或者试着列出所有成员的所有属性： 本文国际来源：Getting Local Group Members","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将 Windows 8.1 中的 CMD.EXE 替换为 POWERSHELL.EXE","slug":"exchanging-cmd-exe-with-powershell-exe-in-windows-8-1","date":"2013-12-18T16:00:00.000Z","updated":"2017-03-17T15:26:22.719Z","comments":true,"path":"2013/12/19/exchanging-cmd-exe-with-powershell-exe-in-windows-8-1/","link":"","permalink":"http://blog.vichamp.com/2013/12/19/exchanging-cmd-exe-with-powershell-exe-in-windows-8-1/","excerpt":"Windows 8.1 仍然在它的一些上下文菜单中提供旧的 cmd.exe 命令行窗口。在 Windows 8.1 中，要将它由 cmd.exe 改为 powershell.exe，请右键单击任务栏，然后选择属性。 然后，单击“导航”标签页，然后选中第三个选项。 下一次，当您在 Windows 8.1 中按下 WIN+X 键时，迷你菜单上将显示“PowerShell”。","text":"Windows 8.1 仍然在它的一些上下文菜单中提供旧的 cmd.exe 命令行窗口。在 Windows 8.1 中，要将它由 cmd.exe 改为 powershell.exe，请右键单击任务栏，然后选择属性。 然后，单击“导航”标签页，然后选中第三个选项。 下一次，当您在 Windows 8.1 中按下 WIN+X 键时，迷你菜单上将显示“PowerShell”。 本文国际来源：Exchanging CMD.EXE with POWERSHELL.EXE in Windows 8.1","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 使用 PowerShell 管理 Office365","slug":"managing-office365-with-powershell","date":"2013-12-17T16:00:00.000Z","updated":"2017-03-17T15:26:22.703Z","comments":true,"path":"2013/12/18/managing-office365-with-powershell/","link":"","permalink":"http://blog.vichamp.com/2013/12/18/managing-office365-with-powershell/","excerpt":"您知道吗？您也可以用 PowerShell 管理您的 Office365 账户。如果您拥有一个 Office365 账户，请试试以下脚本： $OfficeSession = New-PSSession -ConfigurationName Microsoft.Exchange `-ConnectionUri https://ps.outlook.com/powershell/ -Credential (Get-Credential) `-Authentication Basic -AllowRedirection $import = Import-PSSession $OfficeSession -Prefix Off365 Get-Command -Noun Off365* 这段代码将使用您的凭据连接 Office 365，然后导入用于管理 Office 365 的 PowerShell cmdlet。您大约可以获得 400 个新的 cmdlet。如果您收到“Access Denied”提示，那么有可能您的账户没有足够的权限，或者您敲错了密码。 注意所有导入的 cmdlet 都是以 Off365 为前缀的，所以要查看所有的邮箱，请试试以下代码： PS&gt; Get-Off365Mailbox 您可以自己选择前缀（见前面的代码），这样您可以同时通过不同的前缀连接到多个 Office365 账户。当您执行 Import-PSSession 时，您还可以省略前缀。 要查看 Office365 导出的所有命令，请使用以下代码： $import.ExportedCommands","text":"您知道吗？您也可以用 PowerShell 管理您的 Office365 账户。如果您拥有一个 Office365 账户，请试试以下脚本： $OfficeSession = New-PSSession -ConfigurationName Microsoft.Exchange `-ConnectionUri https://ps.outlook.com/powershell/ -Credential (Get-Credential) `-Authentication Basic -AllowRedirection $import = Import-PSSession $OfficeSession -Prefix Off365 Get-Command -Noun Off365* 这段代码将使用您的凭据连接 Office 365，然后导入用于管理 Office 365 的 PowerShell cmdlet。您大约可以获得 400 个新的 cmdlet。如果您收到“Access Denied”提示，那么有可能您的账户没有足够的权限，或者您敲错了密码。 注意所有导入的 cmdlet 都是以 Off365 为前缀的，所以要查看所有的邮箱，请试试以下代码： PS&gt; Get-Off365Mailbox 您可以自己选择前缀（见前面的代码），这样您可以同时通过不同的前缀连接到多个 Office365 账户。当您执行 Import-PSSession 时，您还可以省略前缀。 要查看 Office365 导出的所有命令，请使用以下代码： $import.ExportedCommands 本文国际来源：Managing Office365 with PowerShell","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 显示 Path 环境变量","slug":"displaying-path-environment-variables","date":"2013-12-16T16:00:00.000Z","updated":"2017-03-17T15:26:22.703Z","comments":true,"path":"2013/12/17/displaying-path-environment-variables/","link":"","permalink":"http://blog.vichamp.com/2013/12/17/displaying-path-environment-variables/","excerpt":"当您启动一个程序时，$env:Path 环境变量列出了 Windows 搜索路径中的所有目录。类似地，$env:PSModulePath 列出了 PowerShell 搜索 PowerShell 模块（包括它的自动加载模块）的所有目录。 这些变量包含了以分号分隔的信息。所以使用 -split 操作符分隔并显示它们： 顺便说一下，第三行（在 Program Files 中的）是在 PowerShell 4.0 中才加入的。","text":"当您启动一个程序时，$env:Path 环境变量列出了 Windows 搜索路径中的所有目录。类似地，$env:PSModulePath 列出了 PowerShell 搜索 PowerShell 模块（包括它的自动加载模块）的所有目录。 这些变量包含了以分号分隔的信息。所以使用 -split 操作符分隔并显示它们： 顺便说一下，第三行（在 Program Files 中的）是在 PowerShell 4.0 中才加入的。 本文国际来源：Displaying Path Environment Variables","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找磁盘分区详细信息","slug":"finding-disk-partition-details","date":"2013-12-15T16:00:00.000Z","updated":"2017-03-17T15:26:22.703Z","comments":true,"path":"2013/12/16/finding-disk-partition-details/","link":"","permalink":"http://blog.vichamp.com/2013/12/16/finding-disk-partition-details/","excerpt":"要查看磁盘分区信息，请使用 WMI： Get-WmiObject -Class Win32_DiskPartition | Select-Object -Property * 然后，选择您感兴趣的属性，然后将 * 号替换成逗号分隔的属性列表。例如： Get-WmiObject -Class Win32_DiskPartition | Select-Object -Property Name, BlockSize, Description, BootPartition 如果您选择四个或四个以下的属性，结果是一个干净的表格，否则将是一个列表： 如果您想知道更多的信息，请使用 -List 参数来搜索其它 WMI 类，或者和 “disk” 有关的，或者其它完全不相关的：","text":"要查看磁盘分区信息，请使用 WMI： Get-WmiObject -Class Win32_DiskPartition | Select-Object -Property * 然后，选择您感兴趣的属性，然后将 * 号替换成逗号分隔的属性列表。例如： Get-WmiObject -Class Win32_DiskPartition | Select-Object -Property Name, BlockSize, Description, BootPartition 如果您选择四个或四个以下的属性，结果是一个干净的表格，否则将是一个列表： 如果您想知道更多的信息，请使用 -List 参数来搜索其它 WMI 类，或者和 “disk” 有关的，或者其它完全不相关的： 本文国际来源：Finding Disk Partition Details","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"手动控制 VMware 服务","slug":"manually-control-vmware-service","date":"2013-12-12T16:00:00.000Z","updated":"2017-03-17T15:26:22.672Z","comments":true,"path":"2013/12/13/manually-control-vmware-service/","link":"","permalink":"http://blog.vichamp.com/2013/12/13/manually-control-vmware-service/","excerpt":"","text":"VMware Workstation 想必是很多朋友的必装软件，强大的虚拟机功能已经不用多解释了。这里提点小小的内存优化建议，就是我们在安装完 VMware Workstation 之后，它默认是开机自启动的。那有人会说，打开msconfig，在启动项里将它关闭不就行了吗？其实不然，VMware的几个进程都是以服务方式启动的，vmware-authd.exe、vmnetdhcp.exe、vmnat.exe等等，如不经处理，它们会常驻在系统内存中。而我们并不是每天都会使用虚拟机，所以那些进程大部分时间是在浪费我们的系统资源。 但如果在服务里面将它们全部禁用，那么 VMware 也就不能使用了。最好的方法就是打开服务管理器，将它的几个服务项先全部右击停止，然后双击进去，在启动类型中改为“手动”。这样一来，开机就不会自动启动了。那么，要开 VMware 的时候怎么办呢？一个个手工开启？没必要，写个 PowerShell 脚本就可以了，我用的是最新版VMware Workstation 10，代码如下： 将所有 VMware 服务设置为手动： # Set-VMWareServiceToManual.ps1 Get-Service -DisplayName vmware* | % { Set-Service -Name $_.Name -StartupType Manual } 将所有 VMware 服务设置为自动（缺省）： # Set-VMWareServiceToAuto.ps1 Get-Service -DisplayName vmware* | % { Set-Service -Name $_.Name -StartupType Automatic } 启动所有 VMware 服务（准备运行 VMware 的时候）： # Start-VMWareService.ps1 Get-Service -DisplayName vmware* | % { Start-Service -Name $_.Name } 停止所有 VMware 服务（运行 VMware 完毕以后）： # Stop-VMWareService.ps1 Get-Service -DisplayName vmware* | % { Stop-Service -Name $_.Name -Force } 下载地址：VMWareService.zip","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"vmware","slug":"vmware","permalink":"http://blog.vichamp.com/tags/vmware/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 为 AD 用户设置缺省的 Email 地址","slug":"setting-default-email-address-for-ad-users","date":"2013-12-12T16:00:00.000Z","updated":"2017-03-17T15:26:22.687Z","comments":true,"path":"2013/12/13/setting-default-email-address-for-ad-users/","link":"","permalink":"http://blog.vichamp.com/2013/12/13/setting-default-email-address-for-ad-users/","excerpt":"编写 Active Directory 脚本不需要额外的 module。通过简单的 .NET 框架方法，您可以实现令人惊叹的功能。实际上，这个技术十分强大，您不应该在您的生产环境下运行以下的例子，除非您知道自己在做什么。 一下代码片段在您的 Active Directory 中查找存储于 CN=Users 并且没有邮箱地址的的所有用户。然后，脚本将为他们设置一个缺省的邮箱地址。该地址由姓名 + “mycompany.com” 组成。 # adjust LDAP path (i.e. remove CN=Users to search the entire domain): $SearchRoot = &apos;LDAP://CN=Users,{0}&apos; -f ([ADSI]&apos;&apos;).distinguishedName.ToString() # adjust LDAPFilter. Example: (!mail=*) = all users with no defined mail attribute $LdapFilter = &quot;(&amp;(objectClass=user)(objectCategory=person)(!mail=*))&quot; $Searcher = New-Object DirectoryServices.DirectorySearcher($SearchRoot, $LdapFilter) $Searcher.PageSize = 1000 $Searcher.FindAll() | ForEach-Object { $User = $_.GetDirectoryEntry() try { # Set mail attribute $User.Put(&quot;mail&quot;, (&apos;{0}.{1}@mycompany.com&apos; -f $user.givenName.ToString(), $user.sn.ToString())) # Commit the change $User.SetInfo() } catch { Write-Warning &quot;Problems with $user. Reason: $_&quot; } } 这个示例代码可以读取并且修改、设置任意的属性。它特别适用于不能通过 cmdlet 设置的自定义属性。","text":"编写 Active Directory 脚本不需要额外的 module。通过简单的 .NET 框架方法，您可以实现令人惊叹的功能。实际上，这个技术十分强大，您不应该在您的生产环境下运行以下的例子，除非您知道自己在做什么。 一下代码片段在您的 Active Directory 中查找存储于 CN=Users 并且没有邮箱地址的的所有用户。然后，脚本将为他们设置一个缺省的邮箱地址。该地址由姓名 + “mycompany.com” 组成。 # adjust LDAP path (i.e. remove CN=Users to search the entire domain): $SearchRoot = &apos;LDAP://CN=Users,{0}&apos; -f ([ADSI]&apos;&apos;).distinguishedName.ToString() # adjust LDAPFilter. Example: (!mail=*) = all users with no defined mail attribute $LdapFilter = &quot;(&amp;(objectClass=user)(objectCategory=person)(!mail=*))&quot; $Searcher = New-Object DirectoryServices.DirectorySearcher($SearchRoot, $LdapFilter) $Searcher.PageSize = 1000 $Searcher.FindAll() | ForEach-Object { $User = $_.GetDirectoryEntry() try { # Set mail attribute $User.Put(&quot;mail&quot;, (&apos;{0}.{1}@mycompany.com&apos; -f $user.givenName.ToString(), $user.sn.ToString())) # Commit the change $User.SetInfo() } catch { Write-Warning &quot;Problems with $user. Reason: $_&quot; } } 这个示例代码可以读取并且修改、设置任意的属性。它特别适用于不能通过 cmdlet 设置的自定义属性。 本文国际来源：Setting Default Email Address for AD Users","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 锁定屏幕","slug":"use-a-lock-screen","date":"2013-12-11T16:00:00.000Z","updated":"2017-03-17T15:26:22.672Z","comments":true,"path":"2013/12/12/use-a-lock-screen/","link":"","permalink":"http://blog.vichamp.com/2013/12/12/use-a-lock-screen/","excerpt":"借助 WPF，PowerShell 用几行代码就可以创建窗口。以下是一个有趣的关于透明屏幕覆盖层的例子。 您可以调用 Lock-Screen 并且传入一个脚本块和一个标题。PowerShell 将会用它的覆盖层锁定屏幕，再次执行代码将解锁。 function Lock-Screen([ScriptBlock] $Payload={Start-Sleep -Seconds 5}, $Title=&apos;Busy, go away.&apos;) { try { $window = New-Object Windows.Window $label = New-Object Windows.Controls.Label $label.Content = $Title $label.FontSize = 60 $label.FontFamily = &apos;Consolas&apos; $label.Background = &apos;Transparent&apos; $label.Foreground = &apos;Red&apos; $label.HorizontalAlignment = &apos;Center&apos; $label.VerticalAlignment = &apos;Center&apos; $Window.AllowsTransparency = $True $Window.Opacity = .7 $window.WindowStyle = &apos;None&apos; $window.Content = $label $window.Left = $window.Top = 0 $window.WindowState = &apos;Maximized&apos; $window.Topmost = $true $null = $window.Show() Invoke-Command -ScriptBlock $Payload } finally { $window.Close() } } $job = { Get-ChildItem c:\\windows -Recurse -ErrorAction SilentlyContinue } Lock-Screen -Payload $job -Title &apos;I am busy, go away and grab a coffee...&apos; 您很快就会发现，锁屏确实可以防止鼠标点击，但是并不会屏蔽按键。这是一个有趣的技术，不是绝对安全的锁定。","text":"借助 WPF，PowerShell 用几行代码就可以创建窗口。以下是一个有趣的关于透明屏幕覆盖层的例子。 您可以调用 Lock-Screen 并且传入一个脚本块和一个标题。PowerShell 将会用它的覆盖层锁定屏幕，再次执行代码将解锁。 function Lock-Screen([ScriptBlock] $Payload={Start-Sleep -Seconds 5}, $Title=&apos;Busy, go away.&apos;) { try { $window = New-Object Windows.Window $label = New-Object Windows.Controls.Label $label.Content = $Title $label.FontSize = 60 $label.FontFamily = &apos;Consolas&apos; $label.Background = &apos;Transparent&apos; $label.Foreground = &apos;Red&apos; $label.HorizontalAlignment = &apos;Center&apos; $label.VerticalAlignment = &apos;Center&apos; $Window.AllowsTransparency = $True $Window.Opacity = .7 $window.WindowStyle = &apos;None&apos; $window.Content = $label $window.Left = $window.Top = 0 $window.WindowState = &apos;Maximized&apos; $window.Topmost = $true $null = $window.Show() Invoke-Command -ScriptBlock $Payload } finally { $window.Close() } } $job = { Get-ChildItem c:\\windows -Recurse -ErrorAction SilentlyContinue } Lock-Screen -Payload $job -Title &apos;I am busy, go away and grab a coffee...&apos; 您很快就会发现，锁屏确实可以防止鼠标点击，但是并不会屏蔽按键。这是一个有趣的技术，不是绝对安全的锁定。 本文国际来源：Use a Lock Screen","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建临时密码","slug":"creating-temporary-password","date":"2013-12-10T16:00:00.000Z","updated":"2017-03-17T15:26:22.672Z","comments":true,"path":"2013/12/11/creating-temporary-password/","link":"","permalink":"http://blog.vichamp.com/2013/12/11/creating-temporary-password/","excerpt":"以下是一些为您创建不同长度随机密码的代码: $length = 8 $characters = [Char[]]((31..50) + (65..90) + (97..122)) $characters = $characters -ne &apos;O&apos; -ne &apos;o&apos; -ne &apos;l&apos; -ne &apos;1&apos; -ne &apos;-&apos; $password = -join ($characters | Get-Random -Count $length) &quot;Your temporary $length-character-password is $password&quot; 您的密码长度通过 $length 变量设置。用于构成密码的字符集存放在 $characters 变量中。缺省情况下使用 ASCII 编码为 31-50、65-90、97-122 的所有字符。如您所见，通过 -ne 操作符，您可以调整列表和排除字符。在我们的例子中，我们排除了容易拼写错的字母。","text":"以下是一些为您创建不同长度随机密码的代码: $length = 8 $characters = [Char[]]((31..50) + (65..90) + (97..122)) $characters = $characters -ne &apos;O&apos; -ne &apos;o&apos; -ne &apos;l&apos; -ne &apos;1&apos; -ne &apos;-&apos; $password = -join ($characters | Get-Random -Count $length) &quot;Your temporary $length-character-password is $password&quot; 您的密码长度通过 $length 变量设置。用于构成密码的字符集存放在 $characters 变量中。缺省情况下使用 ASCII 编码为 31-50、65-90、97-122 的所有字符。如您所见，通过 -ne 操作符，您可以调整列表和排除字符。在我们的例子中，我们排除了容易拼写错的字母。 本文国际来源：Creating Temporary Password","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 混淆凭据","slug":"obfuscating-credentials","date":"2013-12-09T16:00:00.000Z","updated":"2017-03-17T15:26:22.669Z","comments":true,"path":"2013/12/10/obfuscating-credentials/","link":"","permalink":"http://blog.vichamp.com/2013/12/10/obfuscating-credentials/","excerpt":"您有没有办法安全地将机密的密码包含在 PowerShell 脚本中？您肯定不敢。但您可以使得别人更难以获取到秘密的信息。 以下是一个设计成在 PowerShell ISE 编辑器中使用的代码生成器脚本： # ask for credentials $cred = Get-Credential $pwd = $cred.Password $user = $cred.UserName # create random encryption key $key = 1..32 | ForEach-Object { Get-Random -Maximum 256 } # encrypt password with key $pwdencrypted = $pwd | ConvertFrom-SecureString -Key $key # turn key and password into text representations $secret = -join ($key | ForEach-Object { &apos;{0:x2}&apos; -f $_ }) $secret += $pwdencrypted # create code $code = &apos;$i = &apos;&apos;{0}&apos;&apos;;&apos; -f $secret $code += &apos;$cred = New-Object PSCredential(&apos;&apos;&apos; $code += $user + &apos;&apos;&apos;, (ConvertTo-SecureString $i.SubString(64)&apos; $code += &apos; -k ($i.SubString(0,64) -split &quot;(?&lt;=\\G[0-9a-f]{2})(?=.)&quot; |&apos; $code += &apos; % { [Convert]::ToByte($_,16) })))&apos; # write new script $editor = $psise.CurrentPowerShellTab.files.Add().Editor $editor.InsertText($code) $editor.SetCaretPosition(1,1) 当您运行它的时候，它将询问用户输入一个用户名和密码。然后，它将会生成一段加密的 PowerShell 脚本片段。您可以在您的脚本中使用它。 以下是由以上脚本生成的一段加密的脚本片段： $i = &apos;73cc7284f9e79f68e9d245b5b2d96c4026397d96cfac6023325d1375414e5f7476492d1116743f0423413b16050a5345MgB8AGgAdABLAEkARABiAFIARgBiAGwAZwBHAHMAaQBLAFoAeQB2AGQAOQAyAGcAPQA9AHwAMgBiADIAMABmADYANwA1ADYANwBiAGYAYwA3AGMAOQA0ADIAMQA3ADcAYwAwADUANAA4ADkAZgBhADYAZgBkADkANgA4ADMAZAA5ADUANABjADgAMgAwADQANQA1ADkAZAA3AGUAMwBmADMAMQAzADQAZgBmADIAZABlADgAZQA=&apos;;$cred = New-Object PSCredential(&apos;contoso\\fabrikam&apos;, (ConvertTo-SecureString $i.SubString(64) -k ($i.SubString(0,64) -split &quot;(?&lt;=\\G[0-9a-f]{2})(?=.)&quot; | % { [Convert]::ToByte($_,16) }))) 这段自动生成的加密脚本片段将会定义一个 $cred 变量，用于保存包括密码在内的合法凭据。接下来您可以将 $cred 变量传递给您脚本中任何需要用户和密码的 -Credential 参数。","text":"您有没有办法安全地将机密的密码包含在 PowerShell 脚本中？您肯定不敢。但您可以使得别人更难以获取到秘密的信息。 以下是一个设计成在 PowerShell ISE 编辑器中使用的代码生成器脚本： # ask for credentials $cred = Get-Credential $pwd = $cred.Password $user = $cred.UserName # create random encryption key $key = 1..32 | ForEach-Object { Get-Random -Maximum 256 } # encrypt password with key $pwdencrypted = $pwd | ConvertFrom-SecureString -Key $key # turn key and password into text representations $secret = -join ($key | ForEach-Object { &apos;{0:x2}&apos; -f $_ }) $secret += $pwdencrypted # create code $code = &apos;$i = &apos;&apos;{0}&apos;&apos;;&apos; -f $secret $code += &apos;$cred = New-Object PSCredential(&apos;&apos;&apos; $code += $user + &apos;&apos;&apos;, (ConvertTo-SecureString $i.SubString(64)&apos; $code += &apos; -k ($i.SubString(0,64) -split &quot;(?&lt;=\\G[0-9a-f]{2})(?=.)&quot; |&apos; $code += &apos; % { [Convert]::ToByte($_,16) })))&apos; # write new script $editor = $psise.CurrentPowerShellTab.files.Add().Editor $editor.InsertText($code) $editor.SetCaretPosition(1,1) 当您运行它的时候，它将询问用户输入一个用户名和密码。然后，它将会生成一段加密的 PowerShell 脚本片段。您可以在您的脚本中使用它。 以下是由以上脚本生成的一段加密的脚本片段： $i = &apos;73cc7284f9e79f68e9d245b5b2d96c4026397d96cfac6023325d1375414e5f7476492d1116743f0423413b16050a5345MgB8AGgAdABLAEkARABiAFIARgBiAGwAZwBHAHMAaQBLAFoAeQB2AGQAOQAyAGcAPQA9AHwAMgBiADIAMABmADYANwA1ADYANwBiAGYAYwA3AGMAOQA0ADIAMQA3ADcAYwAwADUANAA4ADkAZgBhADYAZgBkADkANgA4ADMAZAA5ADUANABjADgAMgAwADQANQA1ADkAZAA3AGUAMwBmADMAMQAzADQAZgBmADIAZABlADgAZQA=&apos;;$cred = New-Object PSCredential(&apos;contoso\\fabrikam&apos;, (ConvertTo-SecureString $i.SubString(64) -k ($i.SubString(0,64) -split &quot;(?&lt;=\\G[0-9a-f]{2})(?=.)&quot; | % { [Convert]::ToByte($_,16) }))) 这段自动生成的加密脚本片段将会定义一个 $cred 变量，用于保存包括密码在内的合法凭据。接下来您可以将 $cred 变量传递给您脚本中任何需要用户和密码的 -Credential 参数。 本文国际来源：Obfuscating Credentials","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建一个文件夹选择器","slug":"create-a-folder-selector","date":"2013-12-08T16:00:00.000Z","updated":"2017-03-17T15:26:22.650Z","comments":true,"path":"2013/12/09/create-a-folder-selector/","link":"","permalink":"http://blog.vichamp.com/2013/12/09/create-a-folder-selector/","excerpt":"问了让您的脚本增加一些魅力，以下几行代码可以显示一个文件夹选择对话框。当用户选择了一个文件夹，您的脚本可以接收到选择的结果并且可以获得选择的路径： Add-Type -AssemblyName System.Windows.Forms [System.Windows.Forms.Application]::EnableVisualStyles() $FolderBrowser = New-Object System.Windows.Forms.FolderBrowserDialog $null = $FolderBrowser.ShowDialog() $Path = $FolderBrowser.SelectedPath &quot;You selected: $Path&quot; 请注意前两行：当您在 ISE 编辑器中运行代码时不需要它们，但当您从 powershell.exe 中运行代码时需要它们。所以我们保留着两行来确保您的代码在各个 PowerShell 宿主中都能有效运行。","text":"问了让您的脚本增加一些魅力，以下几行代码可以显示一个文件夹选择对话框。当用户选择了一个文件夹，您的脚本可以接收到选择的结果并且可以获得选择的路径： Add-Type -AssemblyName System.Windows.Forms [System.Windows.Forms.Application]::EnableVisualStyles() $FolderBrowser = New-Object System.Windows.Forms.FolderBrowserDialog $null = $FolderBrowser.ShowDialog() $Path = $FolderBrowser.SelectedPath &quot;You selected: $Path&quot; 请注意前两行：当您在 ISE 编辑器中运行代码时不需要它们，但当您从 powershell.exe 中运行代码时需要它们。所以我们保留着两行来确保您的代码在各个 PowerShell 宿主中都能有效运行。 本文国际来源：Create a Folder Selector","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通过前缀对文件夹分组","slug":"getting-folders-by-prefix","date":"2013-12-05T16:00:00.000Z","updated":"2017-03-17T15:26:22.650Z","comments":true,"path":"2013/12/06/getting-folders-by-prefix/","link":"","permalink":"http://blog.vichamp.com/2013/12/06/getting-folders-by-prefix/","excerpt":"您知道吗？Group-Object 可以方便地以自定义的规则来对元素分组。以下通过简单的一行代码实现根据前三个字母对文件夹分组： Get-ChildItem -Path C:\\Windows -Directory | Group-Object -Property { $_.Name.PadRight(3).Substring(0,3)} 稍微做一些额外的改动，您可以以这三个首字母做为键，创建一个哈希表： $lookup = Get-ChildItem -Path $env:windir -Directory | Group-Object -Property { $_.Name.PadRight(3).Substring(0,3).ToUpper()} -AsHashTable -AsString $lookup.Keys 现在我们可以很容易地取得其中的文件夹，比如说我们要取以“SYS”开头的文件夹： PS C:\\Windows\\System32&gt; $lookup.SYS 目录: C:\\Windows Mode LastWriteTime Length Name ---- ------------- ------ ---- d---- 2013/9/24 21:50 System d-r-- 2013/12/8 13:40 System32 d---- 2013/8/22 23:36 SystemResources d---- 2013/12/5 11:29 SysWOW64 这有什么实用价值呢？有些公司使用文件夹前缀作为业务单元。用上这个技术之后，我们可以很容易地把所有的业务单元文件夹“收拢”起来——您可以秒杀地计算它们的存储容量并且创建一个自动化的报表。","text":"您知道吗？Group-Object 可以方便地以自定义的规则来对元素分组。以下通过简单的一行代码实现根据前三个字母对文件夹分组： Get-ChildItem -Path C:\\Windows -Directory | Group-Object -Property { $_.Name.PadRight(3).Substring(0,3)} 稍微做一些额外的改动，您可以以这三个首字母做为键，创建一个哈希表： $lookup = Get-ChildItem -Path $env:windir -Directory | Group-Object -Property { $_.Name.PadRight(3).Substring(0,3).ToUpper()} -AsHashTable -AsString $lookup.Keys 现在我们可以很容易地取得其中的文件夹，比如说我们要取以“SYS”开头的文件夹： PS C:\\Windows\\System32&gt; $lookup.SYS 目录: C:\\Windows Mode LastWriteTime Length Name ---- ------------- ------ ---- d---- 2013/9/24 21:50 System d-r-- 2013/12/8 13:40 System32 d---- 2013/8/22 23:36 SystemResources d---- 2013/12/5 11:29 SysWOW64 这有什么实用价值呢？有些公司使用文件夹前缀作为业务单元。用上这个技术之后，我们可以很容易地把所有的业务单元文件夹“收拢”起来——您可以秒杀地计算它们的存储容量并且创建一个自动化的报表。 本文国际来源：Getting Folders by Prefix","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找已知的 USB 驱动器","slug":"finding-known-usb-drives","date":"2013-12-04T16:00:00.000Z","updated":"2017-03-17T15:26:22.634Z","comments":true,"path":"2013/12/05/finding-known-usb-drives/","link":"","permalink":"http://blog.vichamp.com/2013/12/05/finding-known-usb-drives/","excerpt":"您知道吗？Windows 维护着一个关于所有插入过您机器中的 USB 存储设备列表。要导出这个列表十分简单： $Path = &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\USBSTOR\\*\\*&apos; Get-ItemProperty -Path $Path | Select-Object -Property FriendlyName, CompatibleIDs, Mfg 结果看起来如下： FriendlyName CompatibleIDs Mfg ------------ ------------- --- SCANNER USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Android UMS Composite USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Android UMS Composite USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Generic Flash Disk USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Hitachi HTS545050B9A300 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Landi A015 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Landi A015 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Landi A015 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Linux File-CD Gadget USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Linux File-CD Gadget USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Linux File-CD Gadget USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Linux File-CD Gadget USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Multiple Card Reader USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... SAMSUNG GT-I9000 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... SAMSUNG GT-I9000 Card USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... SAMSUNG GT-I9000 Card USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Ut165 USB Flash Disk USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... WD Elements 1042 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... 列表越长，说明您的计算机插入过越多种不同的 USB 存储设备。","text":"您知道吗？Windows 维护着一个关于所有插入过您机器中的 USB 存储设备列表。要导出这个列表十分简单： $Path = &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\USBSTOR\\*\\*&apos; Get-ItemProperty -Path $Path | Select-Object -Property FriendlyName, CompatibleIDs, Mfg 结果看起来如下： FriendlyName CompatibleIDs Mfg ------------ ------------- --- SCANNER USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Android UMS Composite USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Android UMS Composite USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Generic Flash Disk USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Hitachi HTS545050B9A300 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Landi A015 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Landi A015 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Landi A015 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Linux File-CD Gadget USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Linux File-CD Gadget USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Linux File-CD Gadget USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Linux File-CD Gadget USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Multiple Card Reader USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... SAMSUNG GT-I9000 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... SAMSUNG GT-I9000 Card USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... SAMSUNG GT-I9000 Card USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Ut165 USB Flash Disk USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... WD Elements 1042 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... 列表越长，说明您的计算机插入过越多种不同的 USB 存储设备。 本文国际来源：Finding Known USB Drives","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取 DLL 文件版本信息","slug":"getting-dll-file-version-info","date":"2013-12-03T16:00:00.000Z","updated":"2017-03-17T15:26:22.634Z","comments":true,"path":"2013/12/04/getting-dll-file-version-info/","link":"","permalink":"http://blog.vichamp.com/2013/12/04/getting-dll-file-version-info/","excerpt":"是否需要获取一个 DLL 文件列表以及它们的版本信息？Get-ChildItem 可以为您获取这些信息。您只需要解开其中的一些属性，例如： Get-ChildItem c:\\windows\\system32\\*.dll | Select-Object -ExpandProperty VersionInfo | Select-Object -Property FileName, Productversion, ProductName 以上实际上将原始的 FileInfo 对象替换（-ExpandProperty）成了 VersionInfo 对象。您所做的大概是将一个对象转换成另一个对象，并且丢掉前者的一部分信息。例如，您无法再存取某些属性，如 LastWriteTime 等。 如果您希望保持原有的 FileInfo 对象，但是为它加入某些额外的信息，那么请像这样使用 Add-Member： Get-ChildItem c:\\windows\\system32\\*.dll | Add-Member -MemberType ScriptProperty -Name Version -Value { $this.VersionInfo.ProductVersion } -PassThru | Select-Object -Property LastWriteTime, Length, Name, Version | Out-GridView “$this”是您需要扩展的对象。","text":"是否需要获取一个 DLL 文件列表以及它们的版本信息？Get-ChildItem 可以为您获取这些信息。您只需要解开其中的一些属性，例如： Get-ChildItem c:\\windows\\system32\\*.dll | Select-Object -ExpandProperty VersionInfo | Select-Object -Property FileName, Productversion, ProductName 以上实际上将原始的 FileInfo 对象替换（-ExpandProperty）成了 VersionInfo 对象。您所做的大概是将一个对象转换成另一个对象，并且丢掉前者的一部分信息。例如，您无法再存取某些属性，如 LastWriteTime 等。 如果您希望保持原有的 FileInfo 对象，但是为它加入某些额外的信息，那么请像这样使用 Add-Member： Get-ChildItem c:\\windows\\system32\\*.dll | Add-Member -MemberType ScriptProperty -Name Version -Value { $this.VersionInfo.ProductVersion } -PassThru | Select-Object -Property LastWriteTime, Length, Name, Version | Out-GridView “$this”是您需要扩展的对象。 本文国际来源：Getting DLL File Version Info","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 远程执行代码","slug":"executing-code-remotely","date":"2013-12-02T16:00:00.000Z","updated":"2017-03-17T15:26:22.634Z","comments":true,"path":"2013/12/03/executing-code-remotely/","link":"","permalink":"http://blog.vichamp.com/2013/12/03/executing-code-remotely/","excerpt":"在一个域环境中，PowerShell 远程操作功能几乎是开箱即用的。您所需要做的知识在目标机器上启用远程功能（从 Server 2012 开始，PowerShell 远程操作功能对于 Administrators 组用户缺省是启用的）。 在 PowerShell 3.0 中，需要人为地启用远程功能，这就是一切要做的事了（需要管理员权限）： PS&gt; Enable-PSRemoting -SkipNetworkProfileCheck -Force 你不需要在客户端（准备发送命令的机器）上配置任何东西。 下一步，任何管理员可以将命令发送到启用了远程操作功能的机器上去执行它。以下例子将列出目标机器上所有和 PowerShell 相关的进程： $code = { Get-Process -Name powershell*, wsmprovhost -ErrorAction SilentlyContinue } $list = &apos;server1&apos;, &apos;w2k12-niki&apos;, &apos;pc11box&apos; Invoke-Command -ScriptBlock $code #-ComputerName $list 当您原样执行这段代码的时候，Invoke-Command 在您自己的机器上运行存储在 $code 中的代码块。 它列出所有运行中的 PowerShell 控制台的实例、ISE PowerShell 编辑器，以及所有由您机器上别人初始化的 PowerShell 隐藏远程会话。 而当您去掉 -ComputerName 参数的注释，代码将会在 $list 变量存储的所有计算机上执行。请确保它们存在并且已启用了远程操作功能。当您从远程计算机收到数据时，PowerShell 自动在返回的信息上附加一个 &quot;PSComputerName&quot; 属性，用来存储返回信息的计算机名。","text":"在一个域环境中，PowerShell 远程操作功能几乎是开箱即用的。您所需要做的知识在目标机器上启用远程功能（从 Server 2012 开始，PowerShell 远程操作功能对于 Administrators 组用户缺省是启用的）。 在 PowerShell 3.0 中，需要人为地启用远程功能，这就是一切要做的事了（需要管理员权限）： PS&gt; Enable-PSRemoting -SkipNetworkProfileCheck -Force 你不需要在客户端（准备发送命令的机器）上配置任何东西。 下一步，任何管理员可以将命令发送到启用了远程操作功能的机器上去执行它。以下例子将列出目标机器上所有和 PowerShell 相关的进程： $code = { Get-Process -Name powershell*, wsmprovhost -ErrorAction SilentlyContinue } $list = &apos;server1&apos;, &apos;w2k12-niki&apos;, &apos;pc11box&apos; Invoke-Command -ScriptBlock $code #-ComputerName $list 当您原样执行这段代码的时候，Invoke-Command 在您自己的机器上运行存储在 $code 中的代码块。 它列出所有运行中的 PowerShell 控制台的实例、ISE PowerShell 编辑器，以及所有由您机器上别人初始化的 PowerShell 隐藏远程会话。 而当您去掉 -ComputerName 参数的注释，代码将会在 $list 变量存储的所有计算机上执行。请确保它们存在并且已启用了远程操作功能。当您从远程计算机收到数据时，PowerShell 自动在返回的信息上附加一个 &quot;PSComputerName&quot; 属性，用来存储返回信息的计算机名。 本文国际来源：Executing Code Remotely","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 访问所有用户的桌面","slug":"accessing-all-users-desktop","date":"2013-12-01T16:00:00.000Z","updated":"2017-03-17T15:26:22.618Z","comments":true,"path":"2013/12/02/accessing-all-users-desktop/","link":"","permalink":"http://blog.vichamp.com/2013/12/02/accessing-all-users-desktop/","excerpt":"Resolve-Path 是一个相当棒的查找相同深度路径用的 Cmdlet。例如，以下是一段很短小的代码，它在您机器的每个用户桌面上创建一个文本文件： $root = Split-Path $env:USERPROFILE Resolve-Path $root\\*\\Desktop | ForEach-Object { $Path = Join-Path -Path $_ -ChildPath &apos;hello there.txt&apos; &apos;Here is some content...&apos; | Out-File -FilePath $Path Write-Warning &quot;Creating $Path&quot; } 以管理员权限运行您的脚本，它将在您机器中所有用户的桌面上创建一个文件： WARNING: Creating C:\\Users\\Administrator\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\CustomerService\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\Guest\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\PSTestGer\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\Tester\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\Tobias\\Desktop\\hello there.txt","text":"Resolve-Path 是一个相当棒的查找相同深度路径用的 Cmdlet。例如，以下是一段很短小的代码，它在您机器的每个用户桌面上创建一个文本文件： $root = Split-Path $env:USERPROFILE Resolve-Path $root\\*\\Desktop | ForEach-Object { $Path = Join-Path -Path $_ -ChildPath &apos;hello there.txt&apos; &apos;Here is some content...&apos; | Out-File -FilePath $Path Write-Warning &quot;Creating $Path&quot; } 以管理员权限运行您的脚本，它将在您机器中所有用户的桌面上创建一个文件： WARNING: Creating C:\\Users\\Administrator\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\CustomerService\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\Guest\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\PSTestGer\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\Tester\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\Tobias\\Desktop\\hello there.txt 本文国际来源：Accessing All Users Desktop","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 ISE 中快速选中结果","slug":"quickly-selecting-results-in-ise","date":"2013-11-28T16:00:00.000Z","updated":"2017-03-17T15:26:22.603Z","comments":true,"path":"2013/11/29/quickly-selecting-results-in-ise/","link":"","permalink":"http://blog.vichamp.com/2013/11/29/quickly-selecting-results-in-ise/","excerpt":"如果您想快速地选中并复制 PowerShell 3.0 ISE 编辑器中控制台窗格的结果到您的博客或您喜欢的文字处理器中，例如将结果保存为文档或者贴到文章中。以下是实现的方法： 当您运行一个命令后，光标位于 ISE 控制台窗格中并且等待输入新的命令。只需要按住 CTRL 并按下 左 键。光标将向左移动一位。然后按下 CTRL+A 选取所有的结果，然后按下 CTRL+C 将它们复制到剪贴板。完成！","text":"如果您想快速地选中并复制 PowerShell 3.0 ISE 编辑器中控制台窗格的结果到您的博客或您喜欢的文字处理器中，例如将结果保存为文档或者贴到文章中。以下是实现的方法： 当您运行一个命令后，光标位于 ISE 控制台窗格中并且等待输入新的命令。只需要按住 CTRL 并按下 左 键。光标将向左移动一位。然后按下 CTRL+A 选取所有的结果，然后按下 CTRL+C 将它们复制到剪贴板。完成！ 本文国际来源：Quickly Selecting Results in ISE","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 加速多个 WMI 查询","slug":"speeding-up-multiple-wmi-queries","date":"2013-11-27T16:00:00.000Z","updated":"2017-03-17T15:26:22.603Z","comments":true,"path":"2013/11/28/speeding-up-multiple-wmi-queries/","link":"","permalink":"http://blog.vichamp.com/2013/11/28/speeding-up-multiple-wmi-queries/","excerpt":"当您远程执行 Get-WmiObject 命令时，它将会创建一个新的连接。所以如果您查询不同的 WMI 类时，每个查询会使用一个不同的连接，这样将会影响总体性能。 从 PowerShell 3.0 开始，有一些列新的 Cmdlet。使用这些 Cmdlet 可以容易地使用现有的连接高效地运行多个查询： $session = New-CimSession –ComputerName localhost $os = Get-CimInstance –ClassName Win32_OperatingSystem –CimSession $session $bios = Get-CimInstance -ClassName Win32_BIOS -CimSession $session 会话缺省使用 WSMAN 协议： PS&gt; $session Id : 1 Name : CimSession1 InstanceId : 0bb38128-3633-4eb8-8b55-6d2910b89bcd ComputerName : localhost Protocol : WSMAN 当您创建会话是，您可以显式地指定一个不同的远程传输协议，例如 DCOM。","text":"当您远程执行 Get-WmiObject 命令时，它将会创建一个新的连接。所以如果您查询不同的 WMI 类时，每个查询会使用一个不同的连接，这样将会影响总体性能。 从 PowerShell 3.0 开始，有一些列新的 Cmdlet。使用这些 Cmdlet 可以容易地使用现有的连接高效地运行多个查询： $session = New-CimSession –ComputerName localhost $os = Get-CimInstance –ClassName Win32_OperatingSystem –CimSession $session $bios = Get-CimInstance -ClassName Win32_BIOS -CimSession $session 会话缺省使用 WSMAN 协议： PS&gt; $session Id : 1 Name : CimSession1 InstanceId : 0bb38128-3633-4eb8-8b55-6d2910b89bcd ComputerName : localhost Protocol : WSMAN 当您创建会话是，您可以显式地指定一个不同的远程传输协议，例如 DCOM。 本文国际来源：Speeding Up Multiple WMI Queries","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 访问终极 PowerShell 生存指南","slug":"visit-the-ultimate-powershell-survival-guide","date":"2013-11-26T16:00:00.000Z","updated":"2017-03-17T15:26:22.587Z","comments":true,"path":"2013/11/27/visit-the-ultimate-powershell-survival-guide/","link":"","permalink":"http://blog.vichamp.com/2013/11/27/visit-the-ultimate-powershell-survival-guide/","excerpt":"您熟悉 PowerShell 生存指南吗？它是终极的 PowerShell 维基页面，包括视频、Module，和您很可能需要的关于 PowerShell 的一切资源。最棒的部分：它是一个开放式维基，所以如果您自己创建了一个 PowerShell 资源，希望让其他人知道它，那么您完全可以编辑 PowerShell 生存指南来让别人知道它。 http://social.technet.microsoft.com/wiki/contents/articles/183.windows-powershell-survival-guide.aspx","text":"您熟悉 PowerShell 生存指南吗？它是终极的 PowerShell 维基页面，包括视频、Module，和您很可能需要的关于 PowerShell 的一切资源。最棒的部分：它是一个开放式维基，所以如果您自己创建了一个 PowerShell 资源，希望让其他人知道它，那么您完全可以编辑 PowerShell 生存指南来让别人知道它。 http://social.technet.microsoft.com/wiki/contents/articles/183.windows-powershell-survival-guide.aspx 本文国际来源：Visit the Ultimate PowerShell Survival Guide","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"修正 SubManager 的一个 bug","slug":"fix-a-bug-of-submanager","date":"2013-11-25T16:00:00.000Z","updated":"2017-03-17T15:26:22.572Z","comments":true,"path":"2013/11/26/fix-a-bug-of-submanager/","link":"","permalink":"http://blog.vichamp.com/2013/11/26/fix-a-bug-of-submanager/","excerpt":"","text":"目前最好的字幕下载工具是爱页工作室的 SubManager 字幕管理器。程序通过射手网开放的API自批量动下载电影对应的字幕，省去逐个找字幕的麻烦。其工作原理与射手播放器一致，但有十余项增强。 目前它的最新版是 v2013.7.2，我在使用过程中发现一个问题： 当搜索目录中含有扩展名为空的文件时，程序出现异常： 有关调用实时(JIT)调试而不是此对话框的详细信息， 请参见此消息的结尾。 ************** 异常文本 ************** System.ArgumentException: 字符串的长度不能为零。 参数名: oldValue 在 System.String.Replace(String oldValue, String newValue) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir, String[] fileList) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir, String[] fileList) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir, String[] fileList) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir, String[] fileList) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir, String[] fileList) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir, String[] fileList) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir) 在 ShooterDownloader.DownloadForm.txtDir_KeyUp(Object sender, KeyEventArgs e) 在 System.Windows.Forms.Control.OnKeyUp(KeyEventArgs e) 在 System.Windows.Forms.Control.ProcessKeyEventArgs(Message&amp; m) 在 System.Windows.Forms.Control.ProcessKeyMessage(Message&amp; m) 在 System.Windows.Forms.Control.WmKeyChar(Message&amp; m) 在 System.Windows.Forms.Control.WndProc(Message&amp; m) 在 System.Windows.Forms.TextBoxBase.WndProc(Message&amp; m) 在 System.Windows.Forms.TextBox.WndProc(Message&amp; m) 在 System.Windows.Forms.Control.ControlNativeWindow.OnMessage(Message&amp; m) 在 System.Windows.Forms.Control.ControlNativeWindow.WndProc(Message&amp; m) 在 System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam) 用 Reflector 将 SubManager.exe 反编译，得到它的源代码，定位到 DownloadForm 的 PopulateFileList(String, String[]) : Void 方法。其中只有一行用到 String.Replace() 方法： if ((File.Exists(info.FullName.Replace(info.Extension, &quot;.srt&quot;)) || File.Exists(info.FullName.Replace(info.Extension, &quot;.ass&quot;))) || (File.Exists(info.FullName.Replace(info.Extension, &quot;.ssa&quot;)) || File.Exists(info.FullName.Replace(info.Extension, &quot;.smi&quot;)))) 把它改为： if (string.IsNullOrEmpty(info.Extension) || (File.Exists(info.FullName.Replace(info.Extension, &quot;.srt&quot;)) || File.Exists(info.FullName.Replace(info.Extension, &quot;.ass&quot;))) || (File.Exists(info.FullName.Replace(info.Extension, &quot;.ssa&quot;)) || File.Exists(info.FullName.Replace(info.Extension, &quot;.smi&quot;)))) 并重新编译，该错误提示消失了。 我联系了作者 ayeah，他表示将在下一个版本修复。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":".net","slug":"net","permalink":"http://blog.vichamp.com/tags/net/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 获取 WMI 智能感知信息","slug":"getting-wmi-intellisense","date":"2013-11-25T16:00:00.000Z","updated":"2017-03-17T15:26:22.587Z","comments":true,"path":"2013/11/26/getting-wmi-intellisense/","link":"","permalink":"http://blog.vichamp.com/2013/11/26/getting-wmi-intellisense/","excerpt":"Get-WmiObject 并未对 WMI 类提供智能感知信息，所以您要么事先知道 WMI 类的名字，要么使用 -List 参数来搜索它。 不过有一个聪明的技巧：Get-CimInstance 命令几乎完成相同的事情，并且它的参数 -ClassName 也接受一个 WMI 类名。而这个参数提供了智能感知支持。 在 PowerShell 3.0 ISE 中进行以下操作： PS&gt; Get-CimInstance -ClassName Win32_ 然后按下 CTRL+SPACE 键来调用智能感知。请观察状态栏提示。由于有几百个 WMI 类名，所以首次尝试的时候，智能感知在获取所有类信息的时候可能会超时。过一段时间，或者您稍微限定以下类名，它就可以正常工作了。 所以只要用 Get-CimInstance 来代替 Get-WmiObject，然后在智能感知的支持下选择类名，然后将 Cmdlet 和参数改回 Get-WmiObject -Class 即可。 或者，从头到尾都使用 Get-CimInstance。它返回基本相同价值的信息。但在缺省情况下，它使用 WSMan 协议来进行远程操作，而不是 DCOM。","text":"Get-WmiObject 并未对 WMI 类提供智能感知信息，所以您要么事先知道 WMI 类的名字，要么使用 -List 参数来搜索它。 不过有一个聪明的技巧：Get-CimInstance 命令几乎完成相同的事情，并且它的参数 -ClassName 也接受一个 WMI 类名。而这个参数提供了智能感知支持。 在 PowerShell 3.0 ISE 中进行以下操作： PS&gt; Get-CimInstance -ClassName Win32_ 然后按下 CTRL+SPACE 键来调用智能感知。请观察状态栏提示。由于有几百个 WMI 类名，所以首次尝试的时候，智能感知在获取所有类信息的时候可能会超时。过一段时间，或者您稍微限定以下类名，它就可以正常工作了。 所以只要用 Get-CimInstance 来代替 Get-WmiObject，然后在智能感知的支持下选择类名，然后将 Cmdlet 和参数改回 Get-WmiObject -Class 即可。 或者，从头到尾都使用 Get-CimInstance。它返回基本相同价值的信息。但在缺省情况下，它使用 WSMan 协议来进行远程操作，而不是 DCOM。 本文国际来源：Getting WMI IntelliSense","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 列出“真实”的硬盘","slug":"listing-quot-real-quot-hard-drives","date":"2013-11-24T16:00:00.000Z","updated":"2017-03-17T15:26:22.572Z","comments":true,"path":"2013/11/25/listing-quot-real-quot-hard-drives/","link":"","permalink":"http://blog.vichamp.com/2013/11/25/listing-quot-real-quot-hard-drives/","excerpt":"WMI 可以提供一个系统的很多信息，但是有些时候这些信息太多了。当您查询逻辑磁盘时，您得到的往往不止是物理磁盘。 设置额外的过滤器可以解决此问题。以下这行代码通过设置 DriveType=3 来获取物理驱动器： PS&gt; Get-WmiObject -Class Win32_LogicalDisk -Filter &apos;DriveType=3&apos; DeviceID : C: DriveType : 3 ProviderName : FreeSpace : 4468535296 (...) 由于 Get-WmiObject 有一个 -ComputerName 参数，所以您也可以远程获取该信息。如果您想知道有哪些其他的驱动器类型，只需要去掉过滤条件，或者用搜索引擎搜索 &quot;Win32_LogicalDisk DriveType&quot;。","text":"WMI 可以提供一个系统的很多信息，但是有些时候这些信息太多了。当您查询逻辑磁盘时，您得到的往往不止是物理磁盘。 设置额外的过滤器可以解决此问题。以下这行代码通过设置 DriveType=3 来获取物理驱动器： PS&gt; Get-WmiObject -Class Win32_LogicalDisk -Filter &apos;DriveType=3&apos; DeviceID : C: DriveType : 3 ProviderName : FreeSpace : 4468535296 (...) 由于 Get-WmiObject 有一个 -ComputerName 参数，所以您也可以远程获取该信息。如果您想知道有哪些其他的驱动器类型，只需要去掉过滤条件，或者用搜索引擎搜索 &quot;Win32_LogicalDisk DriveType&quot;。 本文国际来源：Listing “Real” Hard Drives","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 改进版的自动加载 Module","slug":"improving-module-auto-loading","date":"2013-11-21T16:00:00.000Z","updated":"2017-03-17T15:26:22.566Z","comments":true,"path":"2013/11/22/improving-module-auto-loading/","link":"","permalink":"http://blog.vichamp.com/2013/11/22/improving-module-auto-loading/","excerpt":"当您按照上一个技巧进行设置以后，PowerShell 3.0 便可以自动加载 Module。然而，对于某些 Module，该技术没有效果。那些 Cmdlet 仍然只能通过 Import-Module 的方式来导入 Module。 导致它们的原因是由于它们构建的方式。PowerShell 无法检测到这些 Module 导出了哪些 Cmdlet。 然而，有一行简单的命令可以让更多的 Module 自动变得可用： PS&gt; Get-Module -ListAvailable -Refresh 该 -Refresh switch 参数告知 PowerShell 完整地遍历所有的 Module 并且生成或刷新内部的命令缓存。","text":"当您按照上一个技巧进行设置以后，PowerShell 3.0 便可以自动加载 Module。然而，对于某些 Module，该技术没有效果。那些 Cmdlet 仍然只能通过 Import-Module 的方式来导入 Module。 导致它们的原因是由于它们构建的方式。PowerShell 无法检测到这些 Module 导出了哪些 Cmdlet。 然而，有一行简单的命令可以让更多的 Module 自动变得可用： PS&gt; Get-Module -ListAvailable -Refresh 该 -Refresh switch 参数告知 PowerShell 完整地遍历所有的 Module 并且生成或刷新内部的命令缓存。 本文国际来源：Improving Module Auto-loading","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 自动加载 Module","slug":"loading-modules-automatically","date":"2013-11-20T16:00:00.000Z","updated":"2017-03-17T15:26:22.549Z","comments":true,"path":"2013/11/21/loading-modules-automatically/","link":"","permalink":"http://blog.vichamp.com/2013/11/21/loading-modules-automatically/","excerpt":"从 PowerShell 3.0 开始，PowerShell 具备了能够智能识别哪些 Cmdlet 是由哪个扩展 Module 导出的特性。所以您再也不需要知道 Module 的名称并且（用 Import-Module 手动导入它）。与之相反，自动完成和智能感知特性将为所有安装在标准 Module 文件夹中的每一个命令提供建议。以下是列出这些标准文件夹的方法： PS&gt; $env:PSModulePath -split &apos;;&apos; C:\\Users\\Victor\\Documents\\WindowsPowerShell\\Modules C:\\Program Files\\WindowsPowerShell\\Modules C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules\\ 这些标准文件夹也许不一定相同，您可以根据需要增加更多的文件夹到环境变量中，甚至将 Module 存放在 USB 闪存盘或外置驱动器中。以下命令将把 USB 驱动器的路径增加到您的模块列表中，这样在该文件夹中的所有 Module 也将会被自动加载： PS&gt; $env:PSModulePath += &apos;;g:\\mypersonalmodules&apos;","text":"从 PowerShell 3.0 开始，PowerShell 具备了能够智能识别哪些 Cmdlet 是由哪个扩展 Module 导出的特性。所以您再也不需要知道 Module 的名称并且（用 Import-Module 手动导入它）。与之相反，自动完成和智能感知特性将为所有安装在标准 Module 文件夹中的每一个命令提供建议。以下是列出这些标准文件夹的方法： PS&gt; $env:PSModulePath -split &apos;;&apos; C:\\Users\\Victor\\Documents\\WindowsPowerShell\\Modules C:\\Program Files\\WindowsPowerShell\\Modules C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules\\ 这些标准文件夹也许不一定相同，您可以根据需要增加更多的文件夹到环境变量中，甚至将 Module 存放在 USB 闪存盘或外置驱动器中。以下命令将把 USB 驱动器的路径增加到您的模块列表中，这样在该文件夹中的所有 Module 也将会被自动加载： PS&gt; $env:PSModulePath += &apos;;g:\\mypersonalmodules&apos; 本文国际来源：Loading Modules Automatically","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 安装 Windows Server 2012 桌面体验","slug":"installing-server-2012-desktop-experience","date":"2013-11-19T16:00:00.000Z","updated":"2017-03-17T15:26:22.533Z","comments":true,"path":"2013/11/20/installing-server-2012-desktop-experience/","link":"","permalink":"http://blog.vichamp.com/2013/11/20/installing-server-2012-desktop-experience/","excerpt":"如果您希望将 Windows Server 2012 （或 Windows Server 2008 R2）作为工作站机器使用并且使它看起来像 Windows 8（包括在文件浏览器中刻录 ISO 文件，以及个性化您的桌面和其它设置），您所需要做的只是添加桌面体验功能。以下是用 PowerShell 实现的方法： Add-WindowsFeature -Name Desktop-Experience 在 PowerShell 2.0 中，您首先需要手动导入合适的 module： Import-Module ServerManager","text":"如果您希望将 Windows Server 2012 （或 Windows Server 2008 R2）作为工作站机器使用并且使它看起来像 Windows 8（包括在文件浏览器中刻录 ISO 文件，以及个性化您的桌面和其它设置），您所需要做的只是添加桌面体验功能。以下是用 PowerShell 实现的方法： Add-WindowsFeature -Name Desktop-Experience 在 PowerShell 2.0 中，您首先需要手动导入合适的 module： Import-Module ServerManager 本文国际来源：Installing Server 2012 Desktop Experience","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 以不同用户运行 PowerShell","slug":"launching-powershell-as-different-user","date":"2013-11-17T16:00:00.000Z","updated":"2017-03-17T15:26:22.533Z","comments":true,"path":"2013/11/18/launching-powershell-as-different-user/","link":"","permalink":"http://blog.vichamp.com/2013/11/18/launching-powershell-as-different-user/","excerpt":"当您将 PowerShell 固定到任务栏后，您可以右键单击固定的 PowerShell 图标来打开一个跳转列表并且使用完整的 Administrator 特权来打开 PowerShell 或 ISE 编辑器。 您还可以按住 SHIFT 键并且右键单击跳转列表中的 PowerShell 图标。这将打开另一个快捷菜单，您可以在这里选择一个完全不同的凭据来运行 PowerShell。 并没有针对 ISE 编辑器的这个选项，但是当您以不同的凭据运行了 PowerShell 之后，您可以简单地键入命令“ise”来以相同的账户运行 ISE 编辑器。","text":"当您将 PowerShell 固定到任务栏后，您可以右键单击固定的 PowerShell 图标来打开一个跳转列表并且使用完整的 Administrator 特权来打开 PowerShell 或 ISE 编辑器。 您还可以按住 SHIFT 键并且右键单击跳转列表中的 PowerShell 图标。这将打开另一个快捷菜单，您可以在这里选择一个完全不同的凭据来运行 PowerShell。 并没有针对 ISE 编辑器的这个选项，但是当您以不同的凭据运行了 PowerShell 之后，您可以简单地键入命令“ise”来以相同的账户运行 ISE 编辑器。 本文国际来源：Launching PowerShell as Different User","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 监测日志文件","slug":"monitoring-log-files","date":"2013-11-14T16:00:00.000Z","updated":"2017-03-17T15:26:22.533Z","comments":true,"path":"2013/11/15/monitoring-log-files/","link":"","permalink":"http://blog.vichamp.com/2013/11/15/monitoring-log-files/","excerpt":"从 PowerShell 3.0 开始，实时监测基于文本的日志文件变得很容易。试试以下代码： $Path = &quot;$home\\Desktop\\testfile.txt&quot; &apos;Test&apos; | Out-File &quot;$home\\Desktop\\testfile.txt&quot; notepad $Path Get-Content -Path $Path -Tail 0 -Wait | Out-GridView -Title $Path 这段代码将在桌面上创建一个文本文件，然后在记事本中打开它。然后 PowerShell 将开始监视文件的变化。一旦您向记事本窗口键入新的文本并保存，则变化的部分会呈现在 PowerShell 的网格视图中。 要监视另一个基于文本的日志文件，只需要改变路径参数即可。由于 PowerShell 在监视文件的状态下处于阻塞状态，您可能需要在另一个 PowerShell 实例中执行新的代码。 译者注：Get-Content -Tail 的效果和 Linux 下的 tail -f 命令的执行效果一致。但 PowerShell 是面向 .NET 对象的，可以利用管道和其它命令，例如 Out-GridView 配合，更为强大。","text":"从 PowerShell 3.0 开始，实时监测基于文本的日志文件变得很容易。试试以下代码： $Path = &quot;$home\\Desktop\\testfile.txt&quot; &apos;Test&apos; | Out-File &quot;$home\\Desktop\\testfile.txt&quot; notepad $Path Get-Content -Path $Path -Tail 0 -Wait | Out-GridView -Title $Path 这段代码将在桌面上创建一个文本文件，然后在记事本中打开它。然后 PowerShell 将开始监视文件的变化。一旦您向记事本窗口键入新的文本并保存，则变化的部分会呈现在 PowerShell 的网格视图中。 要监视另一个基于文本的日志文件，只需要改变路径参数即可。由于 PowerShell 在监视文件的状态下处于阻塞状态，您可能需要在另一个 PowerShell 实例中执行新的代码。 译者注：Get-Content -Tail 的效果和 Linux 下的 tail -f 命令的执行效果一致。但 PowerShell 是面向 .NET 对象的，可以利用管道和其它命令，例如 Out-GridView 配合，更为强大。 本文国际来源：Monitoring Log Files","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 按 F1 跳转到 PowerShell 帮助主题","slug":"press-f1-to-navigate-powershell-help-topics","date":"2013-11-13T16:00:00.000Z","updated":"2017-03-17T15:26:22.518Z","comments":true,"path":"2013/11/14/press-f1-to-navigate-powershell-help-topics/","link":"","permalink":"http://blog.vichamp.com/2013/11/14/press-f1-to-navigate-powershell-help-topics/","excerpt":"要在 PowerShell 3.0 ISE 编辑器中获得 PowerShell 所有类型的操作符帮助信息，首先列出关于操作符的所有帮助主题： help operators 您将会见到一个类似这样的列表： PS&gt; help operators Name Category Module Synopsis ---- -------- ------ -------- about_Arithmetic_Operators HelpFile SHORT DESCRIPTION about_Assignment_Operators HelpFile SHORT DESCRIPTION about_Comparison_Operators HelpFile SHORT DESCRIPTION about_Logical_Operators HelpFile SHORT DESCRIPTION about_Operators HelpFile SHORT DESCRIPTION about_Type_Operators HelpFile SHORT DESCRIPTION 如果您没有看见这个列表，您也许需要先下载 PowerShell 帮助文档。请通过 Update-Help 来查看方法！ 然后，单击其中的任意一个主题，然后按下 F1 键。帮助窗口将会打开，并显示详细的帮助。","text":"要在 PowerShell 3.0 ISE 编辑器中获得 PowerShell 所有类型的操作符帮助信息，首先列出关于操作符的所有帮助主题： help operators 您将会见到一个类似这样的列表： PS&gt; help operators Name Category Module Synopsis ---- -------- ------ -------- about_Arithmetic_Operators HelpFile SHORT DESCRIPTION about_Assignment_Operators HelpFile SHORT DESCRIPTION about_Comparison_Operators HelpFile SHORT DESCRIPTION about_Logical_Operators HelpFile SHORT DESCRIPTION about_Operators HelpFile SHORT DESCRIPTION about_Type_Operators HelpFile SHORT DESCRIPTION 如果您没有看见这个列表，您也许需要先下载 PowerShell 帮助文档。请通过 Update-Help 来查看方法！ 然后，单击其中的任意一个主题，然后按下 F1 键。帮助窗口将会打开，并显示详细的帮助。本文国际来源：Press F1 to Navigate PowerShell Help Topics","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"快速生成树形结构的纯文本","slug":"generate-plain-text-tree-structure","date":"2013-11-13T16:00:00.000Z","updated":"2017-03-17T15:26:22.502Z","comments":true,"path":"2013/11/14/generate-plain-text-tree-structure/","link":"","permalink":"http://blog.vichamp.com/2013/11/14/generate-plain-text-tree-structure/","excerpt":"","text":"今天帮朋友整理一些材料，需要为这些材料整理一个目录。之前有研究过一些方案，例如： Print plain text tree from tree data structure (java) How to print binary tree diagram? How do I print out a tree structure? Expanding a tree-like data structure 这些方案有一个共性：麻烦。也就是无法像手头的工具一样拿来就用。于是发掘了一番，发现 tree 这个 dos 时代的命令刚好能满足需要。该命令的帮助如下： 以图形显示驱动器或路径的文件夹结构。 TREE [drive:][path] [/F] [/A] /F 显示每个文件夹中文件的名称。 /A 使用 ASCII 字符，而不使用扩展字符。 我们可以用以下命令将 D:\\work 下的结构输出到 output.txt 文本文件： TREE &quot;D:\\work&quot; /F /A &gt; output.txt 然后用记事本之类的文本编辑器对它进行简单的编辑，就可以达到目的。 还可以拓展一下思路：在撰写文章的时候，常常需要描述一个有层次的结构（可以是心得体会之类的，不仅限于描述一系列文件）。此时可以在硬盘里创建一个临时目录，在里面创建一些文件夹和文件，用资源管理器拖拽调整目录结构，然后用上述命令导出一个目录文件，就可以快速地用于文档的撰写了。请不要徒手编辑这样的文本，因为那样很愚蠢，调整起来也相当费功夫。 命令执行效果参考： 卷 os 的文件夹 PATH 列表 卷序列号为 0000002C 000E:BD6F C:. | HaxLogs.log | setmockup.log | WEVTUTIL.exe | +---adt-bundle-windows-x86 | | SDK Manager.exe | | | +---android-ndk-r9 | | | documentation.html | | | GNUmakefile ... | | | README.TXT | | | RELEASE.TXT | | | | | +---build | | | +---awk | | | | check-awk.awk | | | | extract-debuggable.awk","categories":[{"name":"text","slug":"text","permalink":"http://blog.vichamp.com/categories/text/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"text","slug":"text","permalink":"http://blog.vichamp.com/tags/text/"},{"name":"command","slug":"command","permalink":"http://blog.vichamp.com/tags/command/"},{"name":"dos","slug":"dos","permalink":"http://blog.vichamp.com/tags/dos/"}],"keywords":[{"name":"text","slug":"text","permalink":"http://blog.vichamp.com/categories/text/"}]},{"title":"PowerShell 技能连载 - 键盘技巧","slug":"keyboard-trick","date":"2013-11-12T16:00:00.000Z","updated":"2017-03-17T15:26:22.486Z","comments":true,"path":"2013/11/13/keyboard-trick/","link":"","permalink":"http://blog.vichamp.com/2013/11/13/keyboard-trick/","excerpt":"在 PowerShell ISE 4.0 控制台窗格中，按住 CTRL 键，然后按 向上 键，可以将光标从命令行中移到结果区域中。","text":"在 PowerShell ISE 4.0 控制台窗格中，按住 CTRL 键，然后按 向上 键，可以将光标从命令行中移到结果区域中。本文国际来源：Keyboard Trick","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找缺少邮箱地址的 Active Directory 用户","slug":"finding-active-directory-users-with-missing-mail-address","date":"2013-11-11T16:00:00.000Z","updated":"2017-03-17T15:26:22.469Z","comments":true,"path":"2013/11/12/finding-active-directory-users-with-missing-mail-address/","link":"","permalink":"http://blog.vichamp.com/2013/11/12/finding-active-directory-users-with-missing-mail-address/","excerpt":"LDAP 查询的功能非常强大，可以帮助查找缺少信息的账户。 这段代码将返回所有带邮箱地址的 Active Directory 用户： $searcher = [ADSISearcher]&quot;(&amp;(sAMAccountType=$(0x30000000))(mail=*))&quot; $searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property sAMAccountName, name, mail 如果您想查询相反的内容，请通过“!”号进行相反的查询。以下代码可以返回所有缺少邮箱地址的 Active Directory 用户： $searcher = [ADSISearcher]&quot;(&amp;(sAMAccountType=$(0x30000000))(!(mail=*)))&quot; $searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property sAMAccountName, name, mail","text":"LDAP 查询的功能非常强大，可以帮助查找缺少信息的账户。 这段代码将返回所有带邮箱地址的 Active Directory 用户： $searcher = [ADSISearcher]&quot;(&amp;(sAMAccountType=$(0x30000000))(mail=*))&quot; $searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property sAMAccountName, name, mail 如果您想查询相反的内容，请通过“!”号进行相反的查询。以下代码可以返回所有缺少邮箱地址的 Active Directory 用户： $searcher = [ADSISearcher]&quot;(&amp;(sAMAccountType=$(0x30000000))(!(mail=*)))&quot; $searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property sAMAccountName, name, mail 本文国际来源：Finding Active Directory Users with Missing Mail Address","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能月刊","slug":"powertips-monthly","date":"2013-11-11T16:00:00.000Z","updated":"2017-03-17T15:26:22.471Z","comments":true,"path":"2013/11/12/powertips-monthly/","link":"","permalink":"http://blog.vichamp.com/2013/11/12/powertips-monthly/","excerpt":"编号 发布时间 标题 PDF Vol.01 2013年06月 文件系统任务 下载 Vol.02 2013年07月 数组和哈希表 下载 Vol.03 2013年08月 日期、时间和文化 下载 Vol.04 2013年09月 对象和类型 下载 Vol.05 2013年10月 WMI 下载 Vol.06 2013年11月 正则表达式 下载 Vol.07 2013年12月 函数 下载 Vol.08 2013年12月 静态 .NET 方法 下载 Vol.09 2014年01月 注册表 下载 Vol.10 2014年02月 Internet 相关任务 下载 Vol.11 2014年03月 XML 相关任务 下载 Vol.12 2014年08月 安全相关任务 下载 如果您（和我一样）足够懒，也可以用这样一行 PowerShell 代码来下载： 1..12 | ForEach-Object { Invoke-WebRequest &quot;http://powershell.com/cs/PowerTips_Monthly_Volume_$_.pdf&quot; -OutFile &quot;PowerTips_Monthly_Volume_$_.pdf&quot; }","text":"编号 发布时间 标题 PDF Vol.01 2013年06月 文件系统任务 下载 Vol.02 2013年07月 数组和哈希表 下载 Vol.03 2013年08月 日期、时间和文化 下载 Vol.04 2013年09月 对象和类型 下载 Vol.05 2013年10月 WMI 下载 Vol.06 2013年11月 正则表达式 下载 Vol.07 2013年12月 函数 下载 Vol.08 2013年12月 静态 .NET 方法 下载 Vol.09 2014年01月 注册表 下载 Vol.10 2014年02月 Internet 相关任务 下载 Vol.11 2014年03月 XML 相关任务 下载 Vol.12 2014年08月 安全相关任务 下载 如果您（和我一样）足够懒，也可以用这样一行 PowerShell 代码来下载： 1..12 | ForEach-Object { Invoke-WebRequest &quot;http://powershell.com/cs/PowerTips_Monthly_Volume_$_.pdf&quot; -OutFile &quot;PowerTips_Monthly_Volume_$_.pdf&quot; } 本文国际来源：PowerTips Reference Library","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"download","slug":"download","permalink":"http://blog.vichamp.com/tags/download/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"monthly","slug":"monthly","permalink":"http://blog.vichamp.com/tags/monthly/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 脚本获取天气实况","slug":"get-real-time-weather-report-by-powershell","date":"2013-11-11T16:00:00.000Z","updated":"2017-03-17T15:26:22.471Z","comments":true,"path":"2013/11/12/get-real-time-weather-report-by-powershell/","link":"","permalink":"http://blog.vichamp.com/2013/11/12/get-real-time-weather-report-by-powershell/","excerpt":"","text":"只要两行命令，就可以“轻松”地获取实时天气预报： (curl http://61.4.185.48:81/g/ -UseBasicParsing).Content -cmatch &apos;var id=(\\d+);&apos; | Out-Null irm &quot;http://www.weather.com.cn/data/sk/$($matches[1]).html&quot; | select -exp weatherinfo 使用效果： PS &gt;(curl http://61.4.185.48:81/g/ -UseBasicParsing).Content -cmatch &apos;var id=(\\d+);&apos; | Out-Null PS &gt;irm &quot;http://www.weather.com.cn/data/sk/$($matches[1]).html&quot; | select -exp weatherinfo city : 福州 cityid : 101230101 temp : 15 WD : 北风 WS : 2级 SD : 79% WSE : 2 time : 10:20 isRadar : 1 Radar : JC_RADAR_AZ9591_JB 您还可以把第二行改为以下形式，获取更猛的数据： irm &quot;http://m.weather.com.cn/data/$($matches[1]).html&quot; | select -exp weatherinfo 或： irm &quot;http://www.weather.com.cn/data/cityinfo/$($matches[1]).html&quot; | select -exp weatherinfo 源代码下载 顺便透露一下，高富帅一般不这么看天气预报哦！","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 自动找借口的脚本","slug":"getting-excuses-automatically","date":"2013-11-10T16:00:00.000Z","updated":"2017-03-17T15:26:22.466Z","comments":true,"path":"2013/11/11/getting-excuses-automatically/","link":"","permalink":"http://blog.vichamp.com/2013/11/11/getting-excuses-automatically/","excerpt":"译者注：您没有看错！这是近期最邪恶的一个技巧，文末有译者机器上的实验效果。 厌倦了每次自己想蹩脚的借口？以下脚本能让您每调用一次 Get-Excuse 就得到一个新的接口！您所需的一切只是 Internet 连接： function Get-Excuse { $url = &apos;http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl&apos; $ProgressPreference = &apos;SilentlyContinue&apos; $page = Invoke-WebRequest -Uri $url -UseBasicParsing $pattern = &apos;&lt;br&gt;&lt;font size = &quot;\\+2&quot;&gt;(.+)&apos; if ($page.Content -match $pattern) { $matches[1] } } 如果您需要通过代理服务器或者身份认证来访问 Internet，那么请查看函数中 Invoke-WebRequest 的参数。您可以通过它提交代理服务器信息，例如身份验证信息。 译者注：以下是 Get-Excuse 为笔者找的“借口”，很有创意吧 ;-) PS &gt;Get-Excuse your process is not ISO 9000 compliant PS &gt;Get-Excuse evil hackers from Serbia. PS &gt;Get-Excuse piezo-electric interference PS &gt;Get-Excuse Bogon emissions PS &gt;Get-Excuse because Bill Gates is a Jehovah&apos;s witness and so nothing can work on St. Swithin&apos;s day. PS &gt;Get-Excuse Your cat tried to eat the mouse. PS &gt;Get-Excuse It works the way the Wang did, what&apos;s the problem PS &gt;Get-Excuse Telecommunications is upgrading. PS &gt;Get-Excuse Your computer&apos;s union contract is set to expire at midnight. PS &gt;Get-Excuse Daemon escaped from pentagram PS &gt;Get-Excuse nesting roaches shorted out the ether cable PS &gt;Get-Excuse We ran out of dial tone and we&apos;re and waiting for the phone company to deliver another bottle. PS &gt;Get-Excuse Root nameservers are out of sync","text":"译者注：您没有看错！这是近期最邪恶的一个技巧，文末有译者机器上的实验效果。 厌倦了每次自己想蹩脚的借口？以下脚本能让您每调用一次 Get-Excuse 就得到一个新的接口！您所需的一切只是 Internet 连接： function Get-Excuse { $url = &apos;http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl&apos; $ProgressPreference = &apos;SilentlyContinue&apos; $page = Invoke-WebRequest -Uri $url -UseBasicParsing $pattern = &apos;&lt;br&gt;&lt;font size = &quot;\\+2&quot;&gt;(.+)&apos; if ($page.Content -match $pattern) { $matches[1] } } 如果您需要通过代理服务器或者身份认证来访问 Internet，那么请查看函数中 Invoke-WebRequest 的参数。您可以通过它提交代理服务器信息，例如身份验证信息。 译者注：以下是 Get-Excuse 为笔者找的“借口”，很有创意吧 ;-) PS &gt;Get-Excuse your process is not ISO 9000 compliant PS &gt;Get-Excuse evil hackers from Serbia. PS &gt;Get-Excuse piezo-electric interference PS &gt;Get-Excuse Bogon emissions PS &gt;Get-Excuse because Bill Gates is a Jehovah&apos;s witness and so nothing can work on St. Swithin&apos;s day. PS &gt;Get-Excuse Your cat tried to eat the mouse. PS &gt;Get-Excuse It works the way the Wang did, what&apos;s the problem PS &gt;Get-Excuse Telecommunications is upgrading. PS &gt;Get-Excuse Your computer&apos;s union contract is set to expire at midnight. PS &gt;Get-Excuse Daemon escaped from pentagram PS &gt;Get-Excuse nesting roaches shorted out the ether cable PS &gt;Get-Excuse We ran out of dial tone and we&apos;re and waiting for the phone company to deliver another bottle. PS &gt;Get-Excuse Root nameservers are out of sync 本文国际来源：Getting Excuses Automatically","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 导出和导入 PowerShell 历史","slug":"exporting-and-importing-powershell-history","date":"2013-11-07T16:00:00.000Z","updated":"2017-03-17T15:26:22.417Z","comments":true,"path":"2013/11/08/exporting-and-importing-powershell-history/","link":"","permalink":"http://blog.vichamp.com/2013/11/08/exporting-and-importing-powershell-history/","excerpt":"PowerShell 保存了您键入的所有命令列表，但是当您关闭 PowerShell 时，这个列表就丢失了。 以下是一个保存当前命令历史到文件的单行代码： Get-History | Export-Clixml $env:temp\\myHistory.xml 当您启动一个新的 PowerShell 控制台或 ISE 编辑器实例时，您可以将保存的历史读入 PowerShell： Import-Clixml $env:\\temp\\myHistory.xml | Add-History 不过，加载历史并不会影响键盘缓冲区，所以按下上下键并不会显示新导入的历史条目。然而，您可以用 TAB 自动完成功能来查找您之前输入的命令： #(KEYWORD) &lt;-现在按下（TAB）键！","text":"PowerShell 保存了您键入的所有命令列表，但是当您关闭 PowerShell 时，这个列表就丢失了。 以下是一个保存当前命令历史到文件的单行代码： Get-History | Export-Clixml $env:temp\\myHistory.xml 当您启动一个新的 PowerShell 控制台或 ISE 编辑器实例时，您可以将保存的历史读入 PowerShell： Import-Clixml $env:\\temp\\myHistory.xml | Add-History 不过，加载历史并不会影响键盘缓冲区，所以按下上下键并不会显示新导入的历史条目。然而，您可以用 TAB 自动完成功能来查找您之前输入的命令： #(KEYWORD) &lt;-现在按下（TAB）键！ 本文国际来源：Exporting and Importing PowerShell History","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"在 PowerShell 脚本中使用 C# 代码","slug":"using-csharp-c-code-in-powershell-scripts","date":"2013-11-07T16:00:00.000Z","updated":"2017-03-17T15:26:22.433Z","comments":true,"path":"2013/11/08/using-csharp-c-code-in-powershell-scripts/","link":"","permalink":"http://blog.vichamp.com/2013/11/08/using-csharp-c-code-in-powershell-scripts/","excerpt":"PowerShell 使我们拥有了一门非常强大的脚本语言。许多产品，例如 SharePoint 以 Cmdlet 的形式提供了它们自己的管理扩展。 客户们喜欢脚本语言，是因为它使他们能够编写自己的代码而不需要运行某个编译器，也不需要将可执行程序拷贝到它们的目标计算机中。相对于部署一个脚本，在那些目标计算机中运行一个可执行程序或者在命令行 Shell 中执行一些命令通常需要更复杂的审批过程。 但是从另一方面来说，编写 PowerShell 脚本需要学习一门新的脚本语言并且需要使用他们所熟悉范围之外的工具。作为一个开发者，我喜欢 C# 和 Visual Studio 的智能提示等强大功能。并且，在过去几年内，我用 C# 开发了许多工具——并且我不希望在移植到 PowerShell 的过程中丢弃这些设计好的轮子。 所以如果能在 PowerShell 中复用现有的 C# 代码，而不需要将它以 Cmdlet的形式实现的话，那就十分理想了。 实际上 PowerShell 2.0 提供了一种方式来实现它：使用 Add-Type Cmdlet，它能够通过您提供的 C# 源代码在内存中生成一个新的 .NET 程序集，并且可以将该程序集直接用于同一个会话中的 PowerShell 脚本中。 出于演示的目的，我们假设已有以下简单的 C# 代码，作用是获取和设置 SharePoint 中的 Content Deployment 的 RemoteTimeout 值： using Microsoft.SharePoint.Publishing.Administration; using System; namespace StefanG.Tools { public static class CDRemoteTimeout { public static void Get() { ContentDeploymentConfiguration cdconfig = ContentDeploymentConfiguration.GetInstance(); Console.WriteLine(&quot;Remote Timeout: &quot;+cdconfig.RemoteTimeout); } public static void Set(int seconds) { ContentDeploymentConfiguration cdconfig = ContentDeploymentConfiguration.GetInstance(); cdconfig.RemoteTimeout = seconds; cdconfig.Update(); } } } 除了引用 .NET 框架之外，这个工具还引用了两个 SharePoint DLL（Microsoft.SharePoint.dll 和 Microsoft.SharePoint.Publishing.dll），它们用来存取 SharePoint 的对象模型。为了确保 PowerShell 能正确地生成程序集，我们需要为 Add-Type Cmdlet 用 -ReferencedAssemblies 参数提供引用信息。 为了指定源代码的语言（可以使用 CSharp、CSharpVersion3、Visual Basic 和 JScript），您需要使用 -Language 参数。缺省值是 CSharp。 在我的系统中我有一个 csharptemplate.ps1csharptemplate.ps1 文件，我可以快速地复制和修改成我需要的样子来运行我的 C# 代码： $Assem = ( ...add referenced assemblies here... ) $Source = @&quot; ...add C# source code here... &quot;@ Add-Type -ReferencedAssemblies $Assem -TypeDefinition $Source -Language CSharp 对于上述的 C# 例子，对应的最终 PowerShell 脚本如下： $Assem = ( &quot;Microsoft.SharePoint, Version=14.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c&quot; , &quot;Microsoft.SharePoint.Publishing, Version=14.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c&quot; ) $Source = @&quot; using Microsoft.SharePoint.Publishing.Administration; using System; namespace StefanG.Tools { public static class CDRemoteTimeout { public static void Get() { ContentDeploymentConfiguration cdconfig = ContentDeploymentConfiguration.GetInstance(); Console.WriteLine(&quot;Remote Timeout: &quot;+cdconfig.RemoteTimeout); } public static void Set(int seconds) { ContentDeploymentConfiguration cdconfig = ContentDeploymentConfiguration.GetInstance(); cdconfig.RemoteTimeout = seconds; cdconfig.Update(); } } } &quot;@ Add-Type -ReferencedAssemblies $Assem -TypeDefinition $Source -Language CSharp [StefanG.Tools.CDRemoteTimeout]::Get() [StefanG.Tools.CDRemoteTimeout]::Set(600) 上述例子的最后几行演示了如何在 PowerShell 中调用 C# 方法。 注：文中涉及到的 csharptemplate.ps1 可以在这里下载。","text":"PowerShell 使我们拥有了一门非常强大的脚本语言。许多产品，例如 SharePoint 以 Cmdlet 的形式提供了它们自己的管理扩展。 客户们喜欢脚本语言，是因为它使他们能够编写自己的代码而不需要运行某个编译器，也不需要将可执行程序拷贝到它们的目标计算机中。相对于部署一个脚本，在那些目标计算机中运行一个可执行程序或者在命令行 Shell 中执行一些命令通常需要更复杂的审批过程。 但是从另一方面来说，编写 PowerShell 脚本需要学习一门新的脚本语言并且需要使用他们所熟悉范围之外的工具。作为一个开发者，我喜欢 C# 和 Visual Studio 的智能提示等强大功能。并且，在过去几年内，我用 C# 开发了许多工具——并且我不希望在移植到 PowerShell 的过程中丢弃这些设计好的轮子。 所以如果能在 PowerShell 中复用现有的 C# 代码，而不需要将它以 Cmdlet的形式实现的话，那就十分理想了。 实际上 PowerShell 2.0 提供了一种方式来实现它：使用 Add-Type Cmdlet，它能够通过您提供的 C# 源代码在内存中生成一个新的 .NET 程序集，并且可以将该程序集直接用于同一个会话中的 PowerShell 脚本中。 出于演示的目的，我们假设已有以下简单的 C# 代码，作用是获取和设置 SharePoint 中的 Content Deployment 的 RemoteTimeout 值： using Microsoft.SharePoint.Publishing.Administration; using System; namespace StefanG.Tools { public static class CDRemoteTimeout { public static void Get() { ContentDeploymentConfiguration cdconfig = ContentDeploymentConfiguration.GetInstance(); Console.WriteLine(&quot;Remote Timeout: &quot;+cdconfig.RemoteTimeout); } public static void Set(int seconds) { ContentDeploymentConfiguration cdconfig = ContentDeploymentConfiguration.GetInstance(); cdconfig.RemoteTimeout = seconds; cdconfig.Update(); } } } 除了引用 .NET 框架之外，这个工具还引用了两个 SharePoint DLL（Microsoft.SharePoint.dll 和 Microsoft.SharePoint.Publishing.dll），它们用来存取 SharePoint 的对象模型。为了确保 PowerShell 能正确地生成程序集，我们需要为 Add-Type Cmdlet 用 -ReferencedAssemblies 参数提供引用信息。 为了指定源代码的语言（可以使用 CSharp、CSharpVersion3、Visual Basic 和 JScript），您需要使用 -Language 参数。缺省值是 CSharp。 在我的系统中我有一个 csharptemplate.ps1csharptemplate.ps1 文件，我可以快速地复制和修改成我需要的样子来运行我的 C# 代码： $Assem = ( ...add referenced assemblies here... ) $Source = @&quot; ...add C# source code here... &quot;@ Add-Type -ReferencedAssemblies $Assem -TypeDefinition $Source -Language CSharp 对于上述的 C# 例子，对应的最终 PowerShell 脚本如下： $Assem = ( &quot;Microsoft.SharePoint, Version=14.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c&quot; , &quot;Microsoft.SharePoint.Publishing, Version=14.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c&quot; ) $Source = @&quot; using Microsoft.SharePoint.Publishing.Administration; using System; namespace StefanG.Tools { public static class CDRemoteTimeout { public static void Get() { ContentDeploymentConfiguration cdconfig = ContentDeploymentConfiguration.GetInstance(); Console.WriteLine(&quot;Remote Timeout: &quot;+cdconfig.RemoteTimeout); } public static void Set(int seconds) { ContentDeploymentConfiguration cdconfig = ContentDeploymentConfiguration.GetInstance(); cdconfig.RemoteTimeout = seconds; cdconfig.Update(); } } } &quot;@ Add-Type -ReferencedAssemblies $Assem -TypeDefinition $Source -Language CSharp [StefanG.Tools.CDRemoteTimeout]::Get() [StefanG.Tools.CDRemoteTimeout]::Set(600) 上述例子的最后几行演示了如何在 PowerShell 中调用 C# 方法。 注：文中涉及到的 csharptemplate.ps1 可以在这里下载。 本文国际来源：Using CSharp (C#) code in Powershell scripts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"csharp","slug":"csharp","permalink":"http://blog.vichamp.com/tags/csharp/"},{"name":"c#","slug":"c","permalink":"http://blog.vichamp.com/tags/c/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 将单词首字母转换为大写","slug":"capitalizing-words","date":"2013-11-06T16:00:00.000Z","updated":"2017-03-17T15:26:22.417Z","comments":true,"path":"2013/11/07/capitalizing-words/","link":"","permalink":"http://blog.vichamp.com/2013/11/07/capitalizing-words/","excerpt":"要正确地将单词首字母转换为大写，您可以用正则表达式或者一点系统函数： 用正则表达式的话，您可以这样做： $sentence = &apos;here is some text where i would like the first letter to be capitalized.&apos; $pattern = &apos;\\b(\\w)&apos; [RegEx]::Replace($sentence, $pattern, { param($x) $x.Value.ToUpper() }) 用系统函数的话，这样做可以达到相同的效果： $sentence = &apos;here is some text where i would like the first letter to be capitalized.&apos; (Get-Culture).TextInfo.ToTitleCase($sentence) 正则表达式稍微复杂一点，但是功能更多。例如如果出于某种古怪的原因，您需要将每个单词的首字母替换为它的 ASCII 码，那么正则表达式可以轻松地实现： $sentence = &apos;here is some text where i would like the first letter to be capitalized.&apos; $pattern = &apos;\\b(\\w)&apos; [RegEx]::Replace($sentence, $pattern, { param($x) [Byte][Char]$x.Value })","text":"要正确地将单词首字母转换为大写，您可以用正则表达式或者一点系统函数： 用正则表达式的话，您可以这样做： $sentence = &apos;here is some text where i would like the first letter to be capitalized.&apos; $pattern = &apos;\\b(\\w)&apos; [RegEx]::Replace($sentence, $pattern, { param($x) $x.Value.ToUpper() }) 用系统函数的话，这样做可以达到相同的效果： $sentence = &apos;here is some text where i would like the first letter to be capitalized.&apos; (Get-Culture).TextInfo.ToTitleCase($sentence) 正则表达式稍微复杂一点，但是功能更多。例如如果出于某种古怪的原因，您需要将每个单词的首字母替换为它的 ASCII 码，那么正则表达式可以轻松地实现： $sentence = &apos;here is some text where i would like the first letter to be capitalized.&apos; $pattern = &apos;\\b(\\w)&apos; [RegEx]::Replace($sentence, $pattern, { param($x) [Byte][Char]$x.Value }) 本文国际来源：Capitalizing Words","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找缺省的 Outlook 配置文件","slug":"finding-default-outlook-profile","date":"2013-11-05T16:00:00.000Z","updated":"2017-03-17T15:26:22.386Z","comments":true,"path":"2013/11/06/finding-default-outlook-profile/","link":"","permalink":"http://blog.vichamp.com/2013/11/06/finding-default-outlook-profile/","excerpt":"PowerShell 可以操作 COM 对象，例如 Outlook 应用程序。以下简单的两行代码能返回当前的 Outlook 配置文件名： $outlookApplication = New-Object -ComObject Outlook.Application $outlookApplication.Application.DefaultProfileName","text":"PowerShell 可以操作 COM 对象，例如 Outlook 应用程序。以下简单的两行代码能返回当前的 Outlook 配置文件名： $outlookApplication = New-Object -ComObject Outlook.Application $outlookApplication.Application.DefaultProfileName 本文国际来源：Finding Default Outlook Profile","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 处理纯文本 - 4","slug":"processing-plain-text-with-powershell-4","date":"2013-11-04T16:00:00.000Z","updated":"2017-03-17T15:26:22.386Z","comments":true,"path":"2013/11/05/processing-plain-text-with-powershell-4/","link":"","permalink":"http://blog.vichamp.com/2013/11/05/processing-plain-text-with-powershell-4/","excerpt":"","text":"命题QQ 群里的史瑞克朋友提出的一个命题： $txt=&quot;192.168.1 192.168.2 192.168.3 172.19.3 192.16.1 192.16.2 192.16.11 192.16.3 10.0.4 192.16.29 192.16.9 192.16.99 192.16.100&quot; 要求输出： 10.0.4 172.19.3 192.16.1-192.16.3 192.16.9 192.16.11 192.16.29 192.16.99-192.16.100 192.168.1-192.168.3 问题解析* 将各个 IP 段补充为三位的格式 * 按字符串排序 * 遍历每一行，按照以下规则处理： * 如果和上一行连续，则上一段可能没有结束，更新 `$endIP` * 如果和上一行不连续 * 若 `$startIP` 和 `$endIP` 相同，说明是单个 IP，将单个 IP 加入 $result * 若 `$startIP` 和 `$endIP` 不同，说明是一段 IP，将一段 IP 加入 $result * 更新 `$startIP` 和 `$endIP` * 最后一行需要特殊处理 PowerShell 实现$DebugPreference = &quot;Continue&quot; $txt=&quot;192.168.1 192.168.2 192.168.3 172.19.3 192.16.1 192.16.2 192.16.11 192.16.3 10.0.4 192.16.29 192.16.9 192.16.99 192.16.100&quot; $txt += &quot;`n999.999.999&quot; $startIP = @(0, 0, 0) $endIP = @(0, 0, 0) $result = @() -split $txt | % { $fullSegments = ($_ -split &quot;\\.&quot; | % { &quot;{0:D3}&quot; -f [int]$_ }) $fullSegments -join &quot;.&quot; } | sort | % { Write-Debug &quot;Processing $_&quot; $segments = @($_ -split &quot;\\.&quot; | % { [int]$_ }) if ($endIP[0] -eq $segments[0] -and $endIP[1] -eq $segments[1] -and $endIP[2] + 1 -eq $segments[2]) { Write-Debug &apos;和上一个IP连续&apos; $endIP = $segments } else { Write-Debug &apos;和上一个IP不连续&apos; if (($startIP -join &quot;.&quot;) -eq ($endIP -join &quot;.&quot;)) { Write-Debug &apos;单个IP&apos; $result += $startIP -join &quot;.&quot; } else { Write-Debug &apos;一段IP&apos; $result += ($startIP -join &quot;.&quot;) + &quot;-&quot; + ($endIP -join &quot;.&quot;) } $startIP = $segments $endIP = $segments } } $result | select -Skip 1 源代码请在这里下载。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"learning","slug":"learning","permalink":"http://blog.vichamp.com/tags/learning/"},{"name":"skill","slug":"skill","permalink":"http://blog.vichamp.com/tags/skill/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}]},{"title":"PowerShell 技能连载 - PowerShell 4.0 中的动态方法","slug":"dynamic-methods-in-powershell-4","date":"2013-11-04T16:00:00.000Z","updated":"2017-03-17T15:26:22.370Z","comments":true,"path":"2013/11/05/dynamic-methods-in-powershell-4/","link":"","permalink":"http://blog.vichamp.com/2013/11/05/dynamic-methods-in-powershell-4/","excerpt":"从 PowerShell 4.0 开始，方法名可以是一个变量。以下是一个简单的例子： $method = &apos;ToUpper&apos; &apos;Hello&apos;.$method() 当您需要调用的方法须通过一段脚本计算得到的时候，这个特性十分有用。 function Convert-Text { param ( [Parameter(Mandatory)] $Text, [Switch]$ToUpper ) if ($ToUpper) { $method = &apos;ToUpper&apos; } else { $method = &apos;ToLower&apos; } $text.$method() } 以下是用户调用该函数的方法： PS&gt; Convert-Text &apos;Hello&apos; hello PS&gt; Convert-Text &apos;Hello&apos; -ToUpper HELLO 缺省情况下，该函数将文本转换为小写。当指定了开关参数 -ToUpper 时，函数将文本转换为大写。由于动态方法特性的支持，该函数不需要为此写两遍代码。 译者注：在旧版本的 PowerShell 中，您可以通过 .NET 方法（而不是脚本方法）中的反射来实现相同的目的。虽然它不那么整洁，但它能运行在 PowerShell 4.0 以下的环境： function Convert-Text { param ( [Parameter(Mandatory)] $Text, [Switch]$ToUpper ) if ($ToUpper) { $method = &apos;ToUpper&apos; } else { $method = &apos;ToLower&apos; } $methodInfo = $Text.GetType().GetMethod($method, [type[]]@()) $methodInfo.Invoke($Text, $null) }","text":"从 PowerShell 4.0 开始，方法名可以是一个变量。以下是一个简单的例子： $method = &apos;ToUpper&apos; &apos;Hello&apos;.$method() 当您需要调用的方法须通过一段脚本计算得到的时候，这个特性十分有用。 function Convert-Text { param ( [Parameter(Mandatory)] $Text, [Switch]$ToUpper ) if ($ToUpper) { $method = &apos;ToUpper&apos; } else { $method = &apos;ToLower&apos; } $text.$method() } 以下是用户调用该函数的方法： PS&gt; Convert-Text &apos;Hello&apos; hello PS&gt; Convert-Text &apos;Hello&apos; -ToUpper HELLO 缺省情况下，该函数将文本转换为小写。当指定了开关参数 -ToUpper 时，函数将文本转换为大写。由于动态方法特性的支持，该函数不需要为此写两遍代码。 译者注：在旧版本的 PowerShell 中，您可以通过 .NET 方法（而不是脚本方法）中的反射来实现相同的目的。虽然它不那么整洁，但它能运行在 PowerShell 4.0 以下的环境： function Convert-Text { param ( [Parameter(Mandatory)] $Text, [Switch]$ToUpper ) if ($ToUpper) { $method = &apos;ToUpper&apos; } else { $method = &apos;ToLower&apos; } $methodInfo = $Text.GetType().GetMethod($method, [type[]]@()) $methodInfo.Invoke($Text, $null) } 本文国际来源：Dynamic Methods in PowerShell 4","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - PowerShell 4.0 中的动态参数","slug":"dynamic-parameters-in-powershell-4-0","date":"2013-11-03T16:00:00.000Z","updated":"2017-03-17T15:26:22.370Z","comments":true,"path":"2013/11/04/dynamic-parameters-in-powershell-4-0/","link":"","permalink":"http://blog.vichamp.com/2013/11/04/dynamic-parameters-in-powershell-4-0/","excerpt":"在 PowerShell 中，您可以使用变量来指代属性名。这段示例脚本定义了四个 profile 的属性名，然后在一个循环中分别查询这些属性值： $list = &apos;AllUsersAllHosts&apos;,&apos;AllUsersCurrentHost&apos;,&apos;CurrentUserAllHosts&apos;,&apos;CurrentUserCurrentHost&apos; foreach ($property in $list) { $profile.$property } 您也可以在一个管道中使用它： &apos;AllUsersAllHosts&apos;,&apos;AllUsersCurrentHost&apos;,&apos;CurrentUserAllHosts&apos;,&apos;CurrentUserCurrentHost&apos; | ForEach-Object { $profile.$_ } 通过这种方式，您可以检查和返回 PowerShell 当前使用的所有 profile： &apos;AllUsersAllHosts&apos;,&apos;AllUsersCurrentHost&apos;,&apos;CurrentUserAllHosts&apos;,&apos;CurrentUserCurrentHost&apos; | ForEach-Object { $profile.$_ } | Where-Object { Test-Path $_ } 类似地，您可以首先使用 Get-Member 来获取一个指定对象包含的所有属性。以下代码可以返回 PowerShell 的“PrivateData”对象中所有名字包含“color”的属性： $host.PrivateData | Get-Member -Name *color* | Select-Object -ExpandProperty Name 接下来，您可以用一行代码获取所有的颜色设置： $object = $host.PrivateData $object | Get-Member -Name *color* -MemberType *property | ForEach-Object { $PropertyName = $_.Name $PropertyValue = $object.$PropertyName &quot;$PropertyName = $PropertyValue&quot; } | Out-GridView","text":"在 PowerShell 中，您可以使用变量来指代属性名。这段示例脚本定义了四个 profile 的属性名，然后在一个循环中分别查询这些属性值： $list = &apos;AllUsersAllHosts&apos;,&apos;AllUsersCurrentHost&apos;,&apos;CurrentUserAllHosts&apos;,&apos;CurrentUserCurrentHost&apos; foreach ($property in $list) { $profile.$property } 您也可以在一个管道中使用它： &apos;AllUsersAllHosts&apos;,&apos;AllUsersCurrentHost&apos;,&apos;CurrentUserAllHosts&apos;,&apos;CurrentUserCurrentHost&apos; | ForEach-Object { $profile.$_ } 通过这种方式，您可以检查和返回 PowerShell 当前使用的所有 profile： &apos;AllUsersAllHosts&apos;,&apos;AllUsersCurrentHost&apos;,&apos;CurrentUserAllHosts&apos;,&apos;CurrentUserCurrentHost&apos; | ForEach-Object { $profile.$_ } | Where-Object { Test-Path $_ } 类似地，您可以首先使用 Get-Member 来获取一个指定对象包含的所有属性。以下代码可以返回 PowerShell 的“PrivateData”对象中所有名字包含“color”的属性： $host.PrivateData | Get-Member -Name *color* | Select-Object -ExpandProperty Name 接下来，您可以用一行代码获取所有的颜色设置： $object = $host.PrivateData $object | Get-Member -Name *color* -MemberType *property | ForEach-Object { $PropertyName = $_.Name $PropertyValue = $object.$PropertyName &quot;$PropertyName = $PropertyValue&quot; } | Out-GridView 本文国际来源：Dynamic Parameters in PowerShell 4.0","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 脚本将书签批量导入 Delicious","slug":"use-powershell-to-batch-import-bookmarks-into-delicious","date":"2013-10-31T16:00:00.000Z","updated":"2017-03-17T15:26:22.348Z","comments":true,"path":"2013/11/01/use-powershell-to-batch-import-bookmarks-into-delicious/","link":"","permalink":"http://blog.vichamp.com/2013/11/01/use-powershell-to-batch-import-bookmarks-into-delicious/","excerpt":"前言美味书签是 Delicious 在线书签服务的中国本地化版本。由于各方面原因，美味书签实现的功能有限，远远达不到 Delicious 的功能。所以我希望将美味书签中的使用记录迁移回 Delicious。 经过一年使用，我在美味书签中已经积累了 5000+ 条书签记录。由于美味书签不支持书签导出功能，所以将美味书签中的书签导出至 Delicious 是一件需要动手动脑的事。幸好我们有 PowerShell 脚本，可以助我们完成这项单调枯燥的事。 这是一个系列文章，一共分为 3 部分： 用 PowerShell 脚本来导出美味书签 [用 PowerShell 脚本来清除 Delicious 账户下的所有书签][用 PowerShell 脚本来批量删除 Delicious 账户下的所有书签] 用 PowerShell 脚本将书签批量导入 Delicious 原理分析Delicious API通过阅读 Delicious API，可以知道我们只需要这样一条 API /v1/posts/add?，它的参数为： &amp;url={URL} (required) — The url of the item. &amp;description={...} (required) — The description of the item. &amp;extended={...} (optional) — Botes for the item. &amp;tags={...} (optional) — Tags for the item (comma delimited). &amp;dt={CCYY-MM-DDThh:mm:ssZ} (optional) — Datestamp of the item (format “CCYY-MM-DDThh:mm:ssZ”). Requires a LITERAL “T” and “Z” like in ISO8601 at http://www.cl.cam.ac.uk/~mgk25/iso-time.html for Example: 1984-09-01T14:21:31Z &amp;replace=no (optional) — Don’t replace post if given url has already been posted. &amp;shared=no (optional) — Make the item private 关于身份验证，请参考本系列的另一篇文章 用 PowerShell 脚本来清除 Delicious 账户下的所有书签 。 URL 编码我们需要提交的书签中，description 字段和 tags 字段是有可能出现 URL 中不允许的字符的，例如 ?、&amp;，以及中文字符等。我们需要将它们进行 URL 编码以后，才可以拼接到 URL 字符串中。在 PowerShell 中进行 URL 编码的方法如下： Add-Type -AssemblyName &apos;System.Web&apos; [System.Web.HttpUtility]::UrlEncode(&apos;中文&apos;) 其中第一行是为了加载 System.Web 程序集。还可以用以下两种方法来实现： [void][system.Reflection.Assembly]::LoadWithPartialName(&quot;System.Web&quot;) 以及： [Reflection.Assembly]::LoadFile(&apos;C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.50727\\System.Web.dll&apos;) | Out-Null 生成查询字符串我们要在查询字符串中包含 API 文档中提到的那 7 个参数。用 string -f 的方式显得有点笨拙。于是我们编写这样一个函数： function Get-QueryString ($params) { $keyValuePairs = ($params.Keys | % { write (&apos;{0}={1}&apos; -f $_, $params[$_]) }) return $keyValuePairs -join &apos;&amp;&apos; } 这个函数接收一个哈希表作为参数，也可以是 [ordered] （即OrderedDictionary）。函数中循环地取出所有键，将它们的值用 &amp; 符号拼接在一起。 容错设计若是 Invoke-WebRequest 命令抛出异常，或是 HTTP 响应码不为 200，或是 XML 中不是 &lt;result code=&quot;done&quot; /&gt; 这样的返回，那么表示添加书签失败。我们可以把这些书签收集起来，输出到 failed_import.csv 文件中。然后下次可以再对这个文件进行导入。直到这个文件中没有记录为止。当然，您也可以将脚本改进一下，全自动地做完上述的事情。那么您一定是懒（勤劳）到家了 ;-) 源代码","text":"前言美味书签是 Delicious 在线书签服务的中国本地化版本。由于各方面原因，美味书签实现的功能有限，远远达不到 Delicious 的功能。所以我希望将美味书签中的使用记录迁移回 Delicious。 经过一年使用，我在美味书签中已经积累了 5000+ 条书签记录。由于美味书签不支持书签导出功能，所以将美味书签中的书签导出至 Delicious 是一件需要动手动脑的事。幸好我们有 PowerShell 脚本，可以助我们完成这项单调枯燥的事。 这是一个系列文章，一共分为 3 部分： 用 PowerShell 脚本来导出美味书签 [用 PowerShell 脚本来清除 Delicious 账户下的所有书签][用 PowerShell 脚本来批量删除 Delicious 账户下的所有书签] 用 PowerShell 脚本将书签批量导入 Delicious 原理分析Delicious API通过阅读 Delicious API，可以知道我们只需要这样一条 API /v1/posts/add?，它的参数为： &amp;url={URL} (required) — The url of the item. &amp;description={...} (required) — The description of the item. &amp;extended={...} (optional) — Botes for the item. &amp;tags={...} (optional) — Tags for the item (comma delimited). &amp;dt={CCYY-MM-DDThh:mm:ssZ} (optional) — Datestamp of the item (format “CCYY-MM-DDThh:mm:ssZ”). Requires a LITERAL “T” and “Z” like in ISO8601 at http://www.cl.cam.ac.uk/~mgk25/iso-time.html for Example: 1984-09-01T14:21:31Z &amp;replace=no (optional) — Don’t replace post if given url has already been posted. &amp;shared=no (optional) — Make the item private 关于身份验证，请参考本系列的另一篇文章 用 PowerShell 脚本来清除 Delicious 账户下的所有书签 。 URL 编码我们需要提交的书签中，description 字段和 tags 字段是有可能出现 URL 中不允许的字符的，例如 ?、&amp;，以及中文字符等。我们需要将它们进行 URL 编码以后，才可以拼接到 URL 字符串中。在 PowerShell 中进行 URL 编码的方法如下： Add-Type -AssemblyName &apos;System.Web&apos; [System.Web.HttpUtility]::UrlEncode(&apos;中文&apos;) 其中第一行是为了加载 System.Web 程序集。还可以用以下两种方法来实现： [void][system.Reflection.Assembly]::LoadWithPartialName(&quot;System.Web&quot;) 以及： [Reflection.Assembly]::LoadFile(&apos;C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.50727\\System.Web.dll&apos;) | Out-Null 生成查询字符串我们要在查询字符串中包含 API 文档中提到的那 7 个参数。用 string -f 的方式显得有点笨拙。于是我们编写这样一个函数： function Get-QueryString ($params) { $keyValuePairs = ($params.Keys | % { write (&apos;{0}={1}&apos; -f $_, $params[$_]) }) return $keyValuePairs -join &apos;&amp;&apos; } 这个函数接收一个哈希表作为参数，也可以是 [ordered] （即OrderedDictionary）。函数中循环地取出所有键，将它们的值用 &amp; 符号拼接在一起。 容错设计若是 Invoke-WebRequest 命令抛出异常，或是 HTTP 响应码不为 200，或是 XML 中不是 &lt;result code=&quot;done&quot; /&gt; 这样的返回，那么表示添加书签失败。我们可以把这些书签收集起来，输出到 failed_import.csv 文件中。然后下次可以再对这个文件进行导入。直到这个文件中没有记录为止。当然，您也可以将脚本改进一下，全自动地做完上述的事情。那么您一定是懒（勤劳）到家了 ;-) 源代码 $userName = &apos;vichamp&apos; $importFileName = &apos;meiweisq-export-20131030.csv&apos; #$importFileName = &apos;failed_import.csv&apos; Add-Type -AssemblyName &apos;System.Web&apos; #$password = ConvertTo-SecureString –String &quot;xxx&quot; –AsPlainText -Force $credential = Get-Credential -UserName $userName -Message &apos;请输入密码&apos; function Get-QueryString ($params) { $keyValuePairs = ($params.Keys | % { write (&apos;{0}={1}&apos; -f $_, $params[$_]) }) return $keyValuePairs -join &apos;&amp;&apos; } $startTime = [datetime]::Now $template = &apos;https://api.del.icio.us/v1/posts/add?{0}&apos; $bookmarks = Import-Csv $importFileName $failedBookmarks = @() $index = 0 $bookmarks | foreach { $params = @{} $params.Add(&apos;description&apos;, [System.Web.HttpUtility]::UrlEncode($_.Title)) if ($false) { $params.Add(&apos;extended&apos;, [System.Web.HttpUtility]::UrlEncode(&apos;&apos;)) } $params.Add(&apos;tags&apos;, [System.Web.HttpUtility]::UrlEncode([string]::Join(&apos;,&apos;, $_.Tags -split &apos;, &apos;))) $params.Add(&apos;dt&apos;, (&quot;{0}T00:00:00Z&quot; -f ($_.LinkTime -creplace &apos;/&apos;, &apos;-&apos;))) $params.Add(&apos;replace&apos;, &apos;no&apos;) $params.Add(&apos;shared&apos;, &apos;yes&apos;) $params.Add(&apos;url&apos;, $_.Url) $queryString = Get-QueryString $params $url = $template -f $queryString $message = &quot;Bookmark: {0} / {1}, Elapsed: {2}&quot; -f @( $($index + 1), $bookmarks.Length, ([datetime]::Now - $startTime).ToString() ) Write-Progress -Activity &apos;Adding bookmarks&apos; -PercentComplete (100 * $index / $bookmarks.Length) -CurrentOperation $message #echo &quot;Requesting $_.Url&quot; $isSuccess = $false try { [xml]$response = Invoke-WebRequest -Uri $url -Credential $credential $isSuccess = $response.StatusCode -eq 200 -and $response.result.code -eq &apos;done&apos; } catch { } if ($isSuccess) { Write-Output &quot;[SUCC] $($_.Url)&quot; } else { Write-Warning &quot;[FAIL] $($_.Url)&quot; $failedBookmarks += $_ } $index++ } $failedBookmarks | Export-Csv &apos;failed_import.csv&apos; -Encoding UTF8 -NoTypeInformation 您也可以点击这里下载源代码。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"delicious","slug":"delicious","permalink":"http://blog.vichamp.com/tags/delicious/"},{"name":"web","slug":"web","permalink":"http://blog.vichamp.com/tags/web/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"用 PowerShell 脚本来导出美味书签","slug":"use-powershell-to-export-bookmarks-in-meiweisq","date":"2013-10-31T16:00:00.000Z","updated":"2017-03-17T15:26:22.370Z","comments":true,"path":"2013/11/01/use-powershell-to-export-bookmarks-in-meiweisq/","link":"","permalink":"http://blog.vichamp.com/2013/11/01/use-powershell-to-export-bookmarks-in-meiweisq/","excerpt":"前言美味书签是 Delicious 在线书签服务的中国本地化版本。由于各方面原因，美味书签实现的功能有限，远远达不到 Delicious 的功能。所以我希望将美味书签中的使用记录迁移回 Delicious。 经过一年使用，我在美味书签中已经积累了 5000+ 条书签记录。由于美味书签不支持书签导出功能，所以将美味书签中的书签导出至 Delicious 是一件需要动手动脑的事。幸好我们有 PowerShell 脚本，可以助我们完成这项单调枯燥的事。 这是一个系列文章，一共分为 3 部分： 用 PowerShell 脚本来导出美味书签 用 PowerShell 脚本来清除 Delicious 账户下的所有书签 用 PowerShell 脚本将书签批量导入 Delicious 原理分析模拟美味书签的登录过程美味书签的登录页面地址为 http://meiweisq.com/login 。我们可以使用 Invoke-WebRequest 获取登录页面，同时把会话信息记录到 $rb 变量中。 相应的 PowerShell 代码如下： $response = Invoke-WebRequest -Uri $homeUrl -Method Default -SessionVariable rb -ContentType application/html 得到的响应中其中包含多个表单。通过查看网页源代码，我们可以确定 Action 为“/login”的那个表单是我们所要的： 相应的 PowerShell 代码为： $loginForm = ($response.Forms | where { $_.Action -eq &apos;/login&apos; })[0] 我们在 Chrome 浏览器中登录一下，通过“开发者工具”的“Network”选项卡查看提交的数据： 根据提交的数据，我们可以编写 PowerShell 代码来提交表单，模拟登录按钮的动作。注意传入会话变量 $rb，以在后续的过程中保持会话身份，否则下次提交又会提示需要登录： $loginForm.Fields[&apos;email&apos;] = $email $loginForm.Fields[&apos;password&apos;] = $password $loginForm.Fields[&apos;type&apos;] = &apos;登录&apos; $loginForm.Fields[&apos;return-url&apos;] = &apos;/home&apos; $loginForm.Fields[&apos;remember&apos;] = &apos;off&apos; $response = Invoke-WebRequest -Uri $loginAction -WebSession $rb -Method POST -Body $loginForm 取得书签总数在登录后的页面底部有“1 - 30 共 5126 个书签”的字样，其中 30 和 5126 两个数字是我们关心的。我们用正则表达式 1 - (\\d+) 共 (\\d+) 个书签 从整个网页中提取书签的总数量。在 PowerShell 使用正则表达式： $response.Content -cmatch &apos;1 - (\\d+) 共 (\\d+) 个书签&apos; $page1Count = $Matches[1] $totalCount = $Matches[2] echo &quot;1 - $page1Count 共 $totalCount 个书签&quot; 根据 $page1Count 和 $totalCount，就可以计算总页数了： $pageCount = [math]::Ceiling($totalCount / $bookmarksPerPage) 遍历每一页知道了总页数，自然想到用 for 循环来遍历它们。我们观察每一页的规律，发现页码是通过 URL 的 page 参数指定的。我们用 PowerShell 来拼接 URL 字符串： $uri = &apos;http://meiweisq.com/home?page=&apos; + $page 对于每一页，继续用 Invoke-WebRequest 来获取它的内容： $response = Invoke-WebRequest -Uri $uri -Method Default -WebSession $rb 分析书签在每一页中，含有不超过 30 个书签，其中包含了书签的标题、URL、标签、时间等信息。 接下来是一些 DOM 的分析，需要一点耐心。我们先把它输出为 .html 文件，以便分析： $response.Content &gt; current_page.html 从 Chrome 的开发者工具中，可以观察到 DOM 的结构。和我们有关系的是 class 为 links、link、tags、tag这些元素。我们用 jQuery 的语法来表达它们，整理成一个表格如下： 选择器 含义 div.links 本页所有书签的集合 div.links &gt; div.link 一个书签 div.links &gt; div.link a.link-title 书签标题、URL div.links &gt; div.link a.link-time 时间 div.links &gt; div.link ul.tags &gt; tag 标签 请注意一下，在 Invoke-WebRequest 的结果（COM 对象）中做 DOM 查询，是有点慢的，不像 WEB 中的 jQuery 那么高效。在我们需要做一定的优化，以缩短大量的查询的总时间。我的优化原则如下： 能用 id 过滤的，不用 tag。 如果需要查询一个节点的子节点，则把前者保存到临时变量中，不要每次都从根对象（document）开始查询。 以下是 DOM 查询的相关代码： $html = $response.ParsedHtml $linksDiv = ($html.getElementsByTagName(&apos;div&apos;) | where { $_.classname -eq &apos;links&apos; })[0] $linksDiv.getElementsByTagName(&apos;div&apos;) | where { $_.classname -cmatch &apos;\\blink[\\s,$]&apos; } $linkTitle = $div.getElementsByTagName(&apos;a&apos;) | where { $_.className -eq &apos;link-title&apos; } $title = $linkTitle | select -exp innerText $url = $linkTitle | select -exp href $linkTime = $div.getElementsByTagName(&apos;p&apos;) | where { $_.className -eq &apos;link-time&apos; } | select -exp innerText $ul = $div.getElementsByTagName(&apos;ul&apos;) | where { $_.className -cmatch &apos;\\btags[\\s,$]&apos; } $tags = $ul.getElementsByTagName(&apos;a&apos;) | where { $_.className -cmatch &apos;tag&apos; } $tagNames = $tags | foreach { $_.getAttribute(&apos;tag&apos;) } Javascript 的时间转换美味书签的时间以 yyyy/MM/dd 的形式表达，而 Delicious 导入/导出文件的时间以 Javascript 格式表达。它们之间的转换方法是，前者减去1970年1月1日0时整的时间差，得到的总秒数，即得到其 Javascript 的格式表达。PowerShell 实现代码如下： $jsTime = ([datetime]::ParseExact($_.LinkTime, &apos;yyyy/MM/dd&apos;, $null) - [datetime]&apos;1970-01-01&apos;).TotalSeconds 输出经过上面的步骤，我们已将所有的书签以 PSObject 的形式存放在 $bookmarks 数组中。现在可以随心所欲地将 $bookmarks 输出为我们所希望的格式了： 这是输出为 CSV 格式的代码： $bookmarks | Export-Csv (&quot;meiweisq-export-{0:yyyyMMdd}.csv&quot; -f [datetime]::Now) -Encoding UTF8 -NoTypeInformation 这是输出到 GUI 界面的代码： $bookmarks | Out-GridView 另外，我们可以导出为 Delicious 的专用格式。由于格式比较简单，我们就不用 ConvertTo-HTML 之类的函数了。 源代码","text":"前言美味书签是 Delicious 在线书签服务的中国本地化版本。由于各方面原因，美味书签实现的功能有限，远远达不到 Delicious 的功能。所以我希望将美味书签中的使用记录迁移回 Delicious。 经过一年使用，我在美味书签中已经积累了 5000+ 条书签记录。由于美味书签不支持书签导出功能，所以将美味书签中的书签导出至 Delicious 是一件需要动手动脑的事。幸好我们有 PowerShell 脚本，可以助我们完成这项单调枯燥的事。 这是一个系列文章，一共分为 3 部分： 用 PowerShell 脚本来导出美味书签 用 PowerShell 脚本来清除 Delicious 账户下的所有书签 用 PowerShell 脚本将书签批量导入 Delicious 原理分析模拟美味书签的登录过程美味书签的登录页面地址为 http://meiweisq.com/login 。我们可以使用 Invoke-WebRequest 获取登录页面，同时把会话信息记录到 $rb 变量中。 相应的 PowerShell 代码如下： $response = Invoke-WebRequest -Uri $homeUrl -Method Default -SessionVariable rb -ContentType application/html 得到的响应中其中包含多个表单。通过查看网页源代码，我们可以确定 Action 为“/login”的那个表单是我们所要的： 相应的 PowerShell 代码为： $loginForm = ($response.Forms | where { $_.Action -eq &apos;/login&apos; })[0] 我们在 Chrome 浏览器中登录一下，通过“开发者工具”的“Network”选项卡查看提交的数据： 根据提交的数据，我们可以编写 PowerShell 代码来提交表单，模拟登录按钮的动作。注意传入会话变量 $rb，以在后续的过程中保持会话身份，否则下次提交又会提示需要登录： $loginForm.Fields[&apos;email&apos;] = $email $loginForm.Fields[&apos;password&apos;] = $password $loginForm.Fields[&apos;type&apos;] = &apos;登录&apos; $loginForm.Fields[&apos;return-url&apos;] = &apos;/home&apos; $loginForm.Fields[&apos;remember&apos;] = &apos;off&apos; $response = Invoke-WebRequest -Uri $loginAction -WebSession $rb -Method POST -Body $loginForm 取得书签总数在登录后的页面底部有“1 - 30 共 5126 个书签”的字样，其中 30 和 5126 两个数字是我们关心的。我们用正则表达式 1 - (\\d+) 共 (\\d+) 个书签 从整个网页中提取书签的总数量。在 PowerShell 使用正则表达式： $response.Content -cmatch &apos;1 - (\\d+) 共 (\\d+) 个书签&apos; $page1Count = $Matches[1] $totalCount = $Matches[2] echo &quot;1 - $page1Count 共 $totalCount 个书签&quot; 根据 $page1Count 和 $totalCount，就可以计算总页数了： $pageCount = [math]::Ceiling($totalCount / $bookmarksPerPage) 遍历每一页知道了总页数，自然想到用 for 循环来遍历它们。我们观察每一页的规律，发现页码是通过 URL 的 page 参数指定的。我们用 PowerShell 来拼接 URL 字符串： $uri = &apos;http://meiweisq.com/home?page=&apos; + $page 对于每一页，继续用 Invoke-WebRequest 来获取它的内容： $response = Invoke-WebRequest -Uri $uri -Method Default -WebSession $rb 分析书签在每一页中，含有不超过 30 个书签，其中包含了书签的标题、URL、标签、时间等信息。 接下来是一些 DOM 的分析，需要一点耐心。我们先把它输出为 .html 文件，以便分析： $response.Content &gt; current_page.html 从 Chrome 的开发者工具中，可以观察到 DOM 的结构。和我们有关系的是 class 为 links、link、tags、tag这些元素。我们用 jQuery 的语法来表达它们，整理成一个表格如下： 选择器 含义 div.links 本页所有书签的集合 div.links &gt; div.link 一个书签 div.links &gt; div.link a.link-title 书签标题、URL div.links &gt; div.link a.link-time 时间 div.links &gt; div.link ul.tags &gt; tag 标签 请注意一下，在 Invoke-WebRequest 的结果（COM 对象）中做 DOM 查询，是有点慢的，不像 WEB 中的 jQuery 那么高效。在我们需要做一定的优化，以缩短大量的查询的总时间。我的优化原则如下： 能用 id 过滤的，不用 tag。 如果需要查询一个节点的子节点，则把前者保存到临时变量中，不要每次都从根对象（document）开始查询。 以下是 DOM 查询的相关代码： $html = $response.ParsedHtml $linksDiv = ($html.getElementsByTagName(&apos;div&apos;) | where { $_.classname -eq &apos;links&apos; })[0] $linksDiv.getElementsByTagName(&apos;div&apos;) | where { $_.classname -cmatch &apos;\\blink[\\s,$]&apos; } $linkTitle = $div.getElementsByTagName(&apos;a&apos;) | where { $_.className -eq &apos;link-title&apos; } $title = $linkTitle | select -exp innerText $url = $linkTitle | select -exp href $linkTime = $div.getElementsByTagName(&apos;p&apos;) | where { $_.className -eq &apos;link-time&apos; } | select -exp innerText $ul = $div.getElementsByTagName(&apos;ul&apos;) | where { $_.className -cmatch &apos;\\btags[\\s,$]&apos; } $tags = $ul.getElementsByTagName(&apos;a&apos;) | where { $_.className -cmatch &apos;tag&apos; } $tagNames = $tags | foreach { $_.getAttribute(&apos;tag&apos;) } Javascript 的时间转换美味书签的时间以 yyyy/MM/dd 的形式表达，而 Delicious 导入/导出文件的时间以 Javascript 格式表达。它们之间的转换方法是，前者减去1970年1月1日0时整的时间差，得到的总秒数，即得到其 Javascript 的格式表达。PowerShell 实现代码如下： $jsTime = ([datetime]::ParseExact($_.LinkTime, &apos;yyyy/MM/dd&apos;, $null) - [datetime]&apos;1970-01-01&apos;).TotalSeconds 输出经过上面的步骤，我们已将所有的书签以 PSObject 的形式存放在 $bookmarks 数组中。现在可以随心所欲地将 $bookmarks 输出为我们所希望的格式了： 这是输出为 CSV 格式的代码： $bookmarks | Export-Csv (&quot;meiweisq-export-{0:yyyyMMdd}.csv&quot; -f [datetime]::Now) -Encoding UTF8 -NoTypeInformation 这是输出到 GUI 界面的代码： $bookmarks | Out-GridView 另外，我们可以导出为 Delicious 的专用格式。由于格式比较简单，我们就不用 ConvertTo-HTML 之类的函数了。 源代码 $email = &apos;victorwoo@gmail.com&apos; $password = &apos;xxx&apos; $homeUrl = &apos;http://meiweisq.com/home&apos; $loginAction = &apos;http://meiweisq.com/login&apos; $bookmarksPerPage = 30 $countPerExport = 10 function Get-DeliciousHtml($bookmarks) { $pre = @&quot; &lt;!DOCTYPE NETSCAPE-Bookmark-file-1&gt; &lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=UTF-8&quot;&gt; &lt;!-- This is an automatically generated file. It will be read and overwritten. Do Not Edit! --&gt; &lt;TITLE&gt;Bookmarks&lt;/TITLE&gt; &lt;H1&gt;Bookmarks&lt;/H1&gt; &lt;DL&gt;&lt;p&gt; &quot;@ $post = @&quot; &lt;/DL&gt;&lt;p&gt; &quot;@ $bookmarkTemplate = @&quot; &lt;DT&gt;&lt;A HREF=&quot;{0}&quot; ADD_DATE=&quot;{1}&quot; PRIVATE=&quot;{2}&quot; TAGS=&quot;{3}&quot;&gt;{4}&lt;/A&gt; &lt;DD&gt;{5} &quot;@ $result = $pre $bookmarks | foreach { $jsTime = ([datetime]::ParseExact($_.LinkTime, &apos;yyyy/MM/dd&apos;, $null) - [datetime]&apos;1970-01-01&apos;).TotalSeconds $tags = [string]::Join(&apos;,&apos;, $_.Tags -split &apos;, &apos;) $bookmarkString = $bookmarkTemplate -f $_.Url, $jsTime, 0, $tags, $_.Title, &apos;&apos; $result += $bookmarkString } $result += $post return $result } $startTime = [datetime]::Now echo &apos;Requesting home&apos; $response = Invoke-WebRequest -Uri $homeUrl -Method Default -SessionVariable rb -ContentType application/html if ($response.StatusCode -ne 200) { Write-Warning &quot;[$response.StatusCode] $homeUrl&quot; return } $response.Content &gt; mwsq_login.html echo &apos;Logining&apos; $loginForm = ($response.Forms | where { $_.Action -eq &apos;/login&apos; })[0] $loginForm.Fields[&apos;email&apos;] = $email $loginForm.Fields[&apos;password&apos;] = $password $loginForm.Fields[&apos;type&apos;] = &apos;登录&apos; $loginForm.Fields[&apos;return-url&apos;] = &apos;/home&apos; $loginForm.Fields[&apos;remember&apos;] = &apos;off&apos; $response = Invoke-WebRequest -Uri $loginAction -WebSession $rb -Method POST -Body $loginForm if ($response.StatusCode -ne 200) { Write-Warning &quot;[$response.StatusCode] $loginAction&quot; return } $response.Content &gt; mwsq_home.html if ($response.Content -cnotmatch &apos;1 - (\\d+) 共 (\\d+) 个书签&apos;) { Write-Warning &apos;找不到书签个数&apos; return } $page1Count = $Matches[1] $totalCount = $Matches[2] echo &quot;1 - $page1Count 共 $totalCount 个书签&quot; $pageCount = [math]::Ceiling($totalCount / $bookmarksPerPage) echo &quot;共 $pageCount 页&quot; echo &apos;&apos; $bookmarks = @() for ($page = 1; $page -le $pageCount; $page++) { $uri = &apos;http://meiweisq.com/home?page=&apos; + $page echo &quot;Requesting $uri&quot; $isSuccess = $false while (!$isSuccess) { try { $response = Invoke-WebRequest -Uri $uri -Method Default -WebSession $rb if ($response.StatusCode -ne 200) { Write-Warning &quot;[$response.StatusCode] $loginAction&quot; continue } $isSuccess = $true } catch { } } $response.Content &gt; current_page.html $html = $response.ParsedHtml $linksDiv = ($html.getElementsByTagName(&apos;div&apos;) | where { $_.classname -eq &apos;links&apos; })[0] $linksDiv.getElementsByTagName(&apos;div&apos;) | where { $_.classname -cmatch &apos;\\blink[\\s,$]&apos; } | foreach { $message = &quot;Bookmark: {0} / {1}, Page: {2} / {3}, Elapsed: {4}&quot; -f @( $($bookmarks.Length + 1), $totalCount, $page $pageCount, ([datetime]::Now - $startTime).ToString() ) Write-Progress -Activity &apos;Getting bookmarks&apos; -PercentComplete (100 * ($bookmarks.Length + 1) / $totalCount) -CurrentOperation $message echo &quot;$($bookmarks.Length + 1) of $totalCount&quot; $div = $_ $linkTitle = $div.getElementsByTagName(&apos;a&apos;) | where { $_.className -eq &apos;link-title&apos; } $title = $linkTitle | select -exp innerText $title = $title.Trim() echo $title $url = $linkTitle | select -exp href echo $url $linkTime = $div.getElementsByTagName(&apos;p&apos;) | where { $_.className -eq &apos;link-time&apos; } | select -exp innerText $linkTime = $linkTime.Trim() echo $linkTime $ul = $div.getElementsByTagName(&apos;ul&apos;) | where { $_.className -cmatch &apos;\\btags[\\s,$]&apos; } $tags = $ul.getElementsByTagName(&apos;a&apos;) | where { $_.className -cmatch &apos;tag&apos; } $tagNames = $tags | foreach { $_.getAttribute(&apos;tag&apos;) } if ($tagNames -eq $null) { $tagNames = @() } echo &quot;[$([string]::Join(&apos; | &apos;, $tagNames))]&quot; echo &apos;&apos; $bookmark = [PSObject]@{ Title = $title Url = $url LinkTime = $linkTime Tags = [string]::Join(&apos;, &apos;, $tagNames) } $bookmarks += New-Object -TypeName PSObject -Property $bookmark } } echo &apos;Exporting html thant you can import into del.icio.us&apos; $index = 0 while ($index -lt $totalCount) { $currentCountInExport = [math]::Min($countPerExport, $totalCount - $index) $endIndex = $index + $currentCountInExport $deliciousHtml = Get-DeliciousHtml ($bookmarks | select -Skip $index -First $currentCountInExport) $deliciousHtml | sc -Encoding UTF8 (&quot;meiweisq-export-{0:yyyyMMdd}-{1}-{2}.html&quot; -f [datetime]::Now, $index, $endIndex) $index += $currentCountInExport } $deliciousHtml = Get-DeliciousHtml $bookmarks $deliciousHtml | sc -Encoding UTF8 (&quot;meiweisq-export-{0:yyyyMMdd}-all.html&quot; -f [datetime]::Now) echo &apos;Exporting CSV.&apos; $bookmarks | Export-Csv (&quot;meiweisq-export-{0:yyyyMMdd}.csv&quot; -f [datetime]::Now) -Encoding UTF8 -NoTypeInformation echo &apos;Exporting GUI.&apos; $bookmarks | Out-GridView echo &apos;All done.&apos; 您也可以点击这里下载源代码。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"delicious","slug":"delicious","permalink":"http://blog.vichamp.com/tags/delicious/"},{"name":"web","slug":"web","permalink":"http://blog.vichamp.com/tags/web/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"用 PowerShell 处理纯文本 - 3","slug":"processing-plain-text-with-powershell-3","date":"2013-10-31T16:00:00.000Z","updated":"2017-03-17T15:26:22.333Z","comments":true,"path":"2013/11/01/processing-plain-text-with-powershell-3/","link":"","permalink":"http://blog.vichamp.com/2013/11/01/processing-plain-text-with-powershell-3/","excerpt":"","text":"命题： 怎样把字符 “ABC-EFGH-XYZ” 替换为 “012-3456-789” 为了解决这个 case，先归纳它的规律： 注意字符集和数字之间的对应关系，我们可以自定义一个字符集来表示。 保留 - 号。 不区分大小写，提高适应性。 根据以上规律编写 PowerShell 代码： $charSet = &apos;ABCEFGHXYZ&apos;.ToCharArray() $text = &apos;ABC-EFGH-XYZ&apos; $array = ($text.ToUpper().ToCharArray() | % { if ($_ -eq &apos;-&apos;) { &apos;-&apos; } else { [string]([System.Array]::IndexOf($charSet, $_)) } }) $array -join &apos;&apos; 结果是： 012-3456-789","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"learning","slug":"learning","permalink":"http://blog.vichamp.com/tags/learning/"},{"name":"skill","slug":"skill","permalink":"http://blog.vichamp.com/tags/skill/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}]},{"title":"用 PowerShell 脚本来清除您 Delicious 账户下的所有书签","slug":"use-powershell-to-clear-all-bookmarks-in-your-delicious-account","date":"2013-10-31T16:00:00.000Z","updated":"2017-03-17T15:26:22.348Z","comments":true,"path":"2013/11/01/use-powershell-to-clear-all-bookmarks-in-your-delicious-account/","link":"","permalink":"http://blog.vichamp.com/2013/11/01/use-powershell-to-clear-all-bookmarks-in-your-delicious-account/","excerpt":"前言美味书签是 Delicious 在线书签服务的中国本地化版本。由于各方面原因，美味书签实现的功能有限，远远达不到 Delicious 的功能。所以我希望将美味书签中的使用记录迁移回 Delicious。 经过一年使用，我在美味书签中已经积累了 5000+ 条书签记录。由于美味书签不支持书签导出功能，所以将美味书签中的书签导出至 Delicious 是一件需要动手动脑的事。幸好我们有 PowerShell 脚本，可以助我们完成这项单调枯燥的事。 这是一个系列文章，一共分为 3 部分： 用 PowerShell 脚本来导出美味书签 [用 PowerShell 脚本来清除 Delicious 账户下的所有书签][用 PowerShell 脚本来批量删除 Delicious 账户下的所有书签] 用 PowerShell 脚本将书签批量导入 Delicious 原理分析Delicious API通过阅读 Delicious API，我们找出需要的 API 来： API 功能 /v1/posts/all? 列出所有书签 /v1/posts/all?hashes 以哈希的形式列出所有书签 /v1/posts/delete? 删除一条书签 其中 /v1/posts/all?hashes 这条 API 暂时用不到。 身份验证在 Delicious API 文档中提到了在 URL 中包含用户和密码的方式来验证身份： $ curl https://user:passwd@api.delicious.com/v1/posts/get?tag=webdev&amp;meta=yes 但在实际中这个方法行不通。我们还是通过 PowerShell 的 Get-Credential 命令来实现： $credential = Get-Credential -UserName $userName -Message &apos;请输入密码&apos; 这段代码的执行效果是弹出一个身份验证框 当然，您也可以把身份信息硬编码的方式写在脚本中，在调试期可以提高效率。但在脚本发布时，可以采用 Get-Credential 这种优雅的方式来提示用户输入。 调用 API调用 Delicious API 的方法十分简单，由于返回的是一个 XML 文档，我们可以显式地将 $listResponse 返回值的数据类型声明为 [xml]。 [xml]$listResponse = Invoke-WebRequest -Uri &apos;https://api.del.icio.us/v1/posts/all?red=api&apos; -Credential $credential 解析执行结果我们可以在浏览器中试着敲入 https://api.delicious.com/v1/posts/all?red=api 来观察执行结果，浏览器将会要求您输入 Delicious 的用户名与密码： 通过观察 XML 的结构，我们可以从 API 响应中取得所有书签的链接，用 XPATH 表达为 posts/post/@href。用 PowerShell 来表达，代码如下： $links = $listResponse.posts.post | select -exp href -Unique 考虑到有些链接可能重复，我们加了个 -Unique 参数，取得不重复的唯一结果。 删除链接通过上述方法得到所有的书签链接之后，我们可以循环调用 /v1/posts/delete? API 来删除它们。根据文档，若删除成功，将返回： &lt;result code=&quot;done&quot; /&gt; 所以我们可以这样设计脚本： if ($response.result.code -eq &apos;done&apos;) { # } 吝啬地休眠API 文档中有一句严厉的警告，原文如下： Please wait at least one second between HTTP queries, or you are likely to get automatically throttled. If you are releasing a library to access the API, you must do this. 意思是说 HTTP 请求不能太频繁，至少要间隔 1 秒。但我觉得时间是珍贵的，如果每次 Start-Sleep -Seconds 1 的话，每一次加上网络传输时间，就不止 1 秒了。时间浪费在 sleep 上十分可惜，特别是在大量的循环中更是如此。我希望 sleep 的时间恰好是 1 秒。所以我设计了一个函数，计算当前时间与上一次 sleep 时的时间差。然后精确地 sleep 这个时间差值，一点也不多睡 ;-) function Invoke-StingySleep ($seconds) { if (!$lastSleepTime) { $lastSleepTime = Get-Date } $span = $lastSleepTime + (New-TimeSpan -Seconds 1) - (Get-Date) Start-Sleep -Milliseconds $span.TotalMilliseconds } 不过实际使用中，似乎 Delicious 的开发者比较仁慈。如果我把 Start-Sleep 这行去掉，服务器并没有因为我们连续不断地请求而把我们的程序给屏蔽掉。当然也有可能是我所在的地方网络延迟太大了。 容错技巧其实这个程序还有很多地方可以改进，例如每次调用删除 API 后判断服务器的 HTTP 响应是否正确，但可以不去改进它。理由是：既然我们的目的是删除所有的书签，那么如果有某一些漏网之鱼没有删掉，那么在下一轮循环中会被查询出来，重新删除。只要脚本工作得不离谱的话，一定能删到完为止。 源代码","text":"前言美味书签是 Delicious 在线书签服务的中国本地化版本。由于各方面原因，美味书签实现的功能有限，远远达不到 Delicious 的功能。所以我希望将美味书签中的使用记录迁移回 Delicious。 经过一年使用，我在美味书签中已经积累了 5000+ 条书签记录。由于美味书签不支持书签导出功能，所以将美味书签中的书签导出至 Delicious 是一件需要动手动脑的事。幸好我们有 PowerShell 脚本，可以助我们完成这项单调枯燥的事。 这是一个系列文章，一共分为 3 部分： 用 PowerShell 脚本来导出美味书签 [用 PowerShell 脚本来清除 Delicious 账户下的所有书签][用 PowerShell 脚本来批量删除 Delicious 账户下的所有书签] 用 PowerShell 脚本将书签批量导入 Delicious 原理分析Delicious API通过阅读 Delicious API，我们找出需要的 API 来： API 功能 /v1/posts/all? 列出所有书签 /v1/posts/all?hashes 以哈希的形式列出所有书签 /v1/posts/delete? 删除一条书签 其中 /v1/posts/all?hashes 这条 API 暂时用不到。 身份验证在 Delicious API 文档中提到了在 URL 中包含用户和密码的方式来验证身份： $ curl https://user:passwd@api.delicious.com/v1/posts/get?tag=webdev&amp;meta=yes 但在实际中这个方法行不通。我们还是通过 PowerShell 的 Get-Credential 命令来实现： $credential = Get-Credential -UserName $userName -Message &apos;请输入密码&apos; 这段代码的执行效果是弹出一个身份验证框 当然，您也可以把身份信息硬编码的方式写在脚本中，在调试期可以提高效率。但在脚本发布时，可以采用 Get-Credential 这种优雅的方式来提示用户输入。 调用 API调用 Delicious API 的方法十分简单，由于返回的是一个 XML 文档，我们可以显式地将 $listResponse 返回值的数据类型声明为 [xml]。 [xml]$listResponse = Invoke-WebRequest -Uri &apos;https://api.del.icio.us/v1/posts/all?red=api&apos; -Credential $credential 解析执行结果我们可以在浏览器中试着敲入 https://api.delicious.com/v1/posts/all?red=api 来观察执行结果，浏览器将会要求您输入 Delicious 的用户名与密码： 通过观察 XML 的结构，我们可以从 API 响应中取得所有书签的链接，用 XPATH 表达为 posts/post/@href。用 PowerShell 来表达，代码如下： $links = $listResponse.posts.post | select -exp href -Unique 考虑到有些链接可能重复，我们加了个 -Unique 参数，取得不重复的唯一结果。 删除链接通过上述方法得到所有的书签链接之后，我们可以循环调用 /v1/posts/delete? API 来删除它们。根据文档，若删除成功，将返回： &lt;result code=&quot;done&quot; /&gt; 所以我们可以这样设计脚本： if ($response.result.code -eq &apos;done&apos;) { # } 吝啬地休眠API 文档中有一句严厉的警告，原文如下： Please wait at least one second between HTTP queries, or you are likely to get automatically throttled. If you are releasing a library to access the API, you must do this. 意思是说 HTTP 请求不能太频繁，至少要间隔 1 秒。但我觉得时间是珍贵的，如果每次 Start-Sleep -Seconds 1 的话，每一次加上网络传输时间，就不止 1 秒了。时间浪费在 sleep 上十分可惜，特别是在大量的循环中更是如此。我希望 sleep 的时间恰好是 1 秒。所以我设计了一个函数，计算当前时间与上一次 sleep 时的时间差。然后精确地 sleep 这个时间差值，一点也不多睡 ;-) function Invoke-StingySleep ($seconds) { if (!$lastSleepTime) { $lastSleepTime = Get-Date } $span = $lastSleepTime + (New-TimeSpan -Seconds 1) - (Get-Date) Start-Sleep -Milliseconds $span.TotalMilliseconds } 不过实际使用中，似乎 Delicious 的开发者比较仁慈。如果我把 Start-Sleep 这行去掉，服务器并没有因为我们连续不断地请求而把我们的程序给屏蔽掉。当然也有可能是我所在的地方网络延迟太大了。 容错技巧其实这个程序还有很多地方可以改进，例如每次调用删除 API 后判断服务器的 HTTP 响应是否正确，但可以不去改进它。理由是：既然我们的目的是删除所有的书签，那么如果有某一些漏网之鱼没有删掉，那么在下一轮循环中会被查询出来，重新删除。只要脚本工作得不离谱的话，一定能删到完为止。 源代码 $userName = &apos;vichamp&apos; Add-Type -AssemblyName &apos;System.Web&apos; #$password = ConvertTo-SecureString –String &quot;xxx&quot; –AsPlainText -Force $credential = Get-Credential -UserName $userName -Message &apos;请输入密码&apos; function Invoke-StingySleep ($seconds) { if (!$lastSleepTime) { $lastSleepTime = Get-Date } $span = $lastSleepTime + (New-TimeSpan -Seconds 1) - (Get-Date) #Start-Sleep -Milliseconds $span.TotalMilliseconds } while ($true) { Invoke-StingySleep 1 [xml]$listResponse = Invoke-WebRequest -Uri &apos;https://api.delicious.com/v1/posts/all?red=api&apos; -Credential $credential #[xml]$response = Invoke-WebRequest -Uri &apos;https://api.del.icio.us/v1/posts/all?hashes&apos; -Credential $credential if (!$listResponse.posts.post) { break } $links = $listResponse.posts.post | select -exp href -Unique $links | foreach { $encodedLink = [System.Web.HttpUtility]::UrlEncode($_) Invoke-StingySleep 1 [xml]$response = Invoke-WebRequest -Uri &quot;https://api.delicious.com/v1/posts/delete?url=$encodedLink&quot; -Credential $credential if ($response.result.code -eq &apos;done&apos;) { Write-Output &quot;[$($response.result.code)] $_&quot; } else { Write-Warning &quot;[$($response.result.code)] $_&quot; } } } echo &apos;Done&apos; 您也可以点击这里下载源代码。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"delicious","slug":"delicious","permalink":"http://blog.vichamp.com/tags/delicious/"},{"name":"web","slug":"web","permalink":"http://blog.vichamp.com/tags/web/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 替换文本中的指定字符","slug":"replacing-specific-characters-in-a-text","date":"2013-10-31T16:00:00.000Z","updated":"2017-03-17T15:26:22.348Z","comments":true,"path":"2013/11/01/replacing-specific-characters-in-a-text/","link":"","permalink":"http://blog.vichamp.com/2013/11/01/replacing-specific-characters-in-a-text/","excerpt":"如果您只是需要替换文本中字符出现的所有位置，这是很简单的。以下可以将文本中所有的“l”变为大写： &quot;Hello World&quot;.Replace(&apos;l&apos;, &apos;L&apos;) 然而有些时候，您需要替换特定位置的某几个字符。我们假设您的文本是一个比特掩码，并且您需要对某些比特置位或清除。以上代码是不能用的，因为它一口气改变了所有的位： PS&gt; &quot;110100011110110&quot;.Replace(&apos;1&apos;, &apos;0&apos;) 000000000000000 而且您也不能通过索引来改变字符。您可以读取一个字符（例如检查某一个位是否为“1”），但您无法改变它的值： PS&gt; &quot;110100011110110&quot;[-1] -eq &apos;1&apos; False PS&gt; &quot;110100011110110&quot;[-2] -eq &apos;1&apos; True PS&gt; &quot;110100011110110&quot;[-2] = &apos;0&apos; 无法对 System.String 类型的对象进行索引。 要改变一个字符串中的某些字符，请将它转换为一个 StringBuilder： PS&gt; $sb = New-Object System.Text.StringBuilder(&quot;1101100011110110&quot;) PS&gt; $sb[-1] 0 PS&gt; $sb[-1] -eq &apos;1&apos; False PS&gt; $sb[-2] -eq &apos;1&apos; True PS&gt; $sb[-2] = &apos;0&apos; PS&gt; $sb[-2] -eq &apos;1&apos; False PS&gt; $sb.ToString() 110100011110100 以下是将二进制转换为十进制格式的方法： PS&gt; $sb.ToString() 110100011110100 PS&gt; [System.Convert]::ToInt64($sb.ToString(), 2) 26868","text":"如果您只是需要替换文本中字符出现的所有位置，这是很简单的。以下可以将文本中所有的“l”变为大写： &quot;Hello World&quot;.Replace(&apos;l&apos;, &apos;L&apos;) 然而有些时候，您需要替换特定位置的某几个字符。我们假设您的文本是一个比特掩码，并且您需要对某些比特置位或清除。以上代码是不能用的，因为它一口气改变了所有的位： PS&gt; &quot;110100011110110&quot;.Replace(&apos;1&apos;, &apos;0&apos;) 000000000000000 而且您也不能通过索引来改变字符。您可以读取一个字符（例如检查某一个位是否为“1”），但您无法改变它的值： PS&gt; &quot;110100011110110&quot;[-1] -eq &apos;1&apos; False PS&gt; &quot;110100011110110&quot;[-2] -eq &apos;1&apos; True PS&gt; &quot;110100011110110&quot;[-2] = &apos;0&apos; 无法对 System.String 类型的对象进行索引。 要改变一个字符串中的某些字符，请将它转换为一个 StringBuilder： PS&gt; $sb = New-Object System.Text.StringBuilder(&quot;1101100011110110&quot;) PS&gt; $sb[-1] 0 PS&gt; $sb[-1] -eq &apos;1&apos; False PS&gt; $sb[-2] -eq &apos;1&apos; True PS&gt; $sb[-2] = &apos;0&apos; PS&gt; $sb[-2] -eq &apos;1&apos; False PS&gt; $sb.ToString() 110100011110100 以下是将二进制转换为十进制格式的方法： PS&gt; $sb.ToString() 110100011110100 PS&gt; [System.Convert]::ToInt64($sb.ToString(), 2) 26868 本文国际来源：Replacing Specific Characters in a Text","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 怪异的文本格式化（以及解决方法）","slug":"weird-text-formatting-and-what-to-do-about-it","date":"2013-10-30T16:00:00.000Z","updated":"2017-03-17T15:26:22.317Z","comments":true,"path":"2013/10/31/weird-text-formatting-and-what-to-do-about-it/","link":"","permalink":"http://blog.vichamp.com/2013/10/31/weird-text-formatting-and-what-to-do-about-it/","excerpt":"试试以下的代码并且找到问题所在： $desc = Get-Process -Id $pid | Select-Object -Property Description &quot;PowerShell process description: $desc&quot; 这段代码的目的是获取 PowerShell 宿主进程并且读取进程的描述信息，然后输出到字符串。它的结果看起来是怪异的： PowerShell process description: @{Description=Windows PowerShell} 这是因为代码中选择了整个 Description 属性，而且结果不仅是描述字符串，而且包括了整个属性： PS&gt; $desc Description ----------- Windows PowerShell ISE 当您只选择一个属性时，请确保使用 -ExpandProperty 而不是 -Property。前者避免产生一个属性列，并且字符串看起来正常了： PS&gt; $desc = Get-Process -Id $pid | Select-Object -ExpandProperty Description PS&gt; &quot;PowerShell process description: $desc&quot; PowerShell process description: Windows PowerShell ISE","text":"试试以下的代码并且找到问题所在： $desc = Get-Process -Id $pid | Select-Object -Property Description &quot;PowerShell process description: $desc&quot; 这段代码的目的是获取 PowerShell 宿主进程并且读取进程的描述信息，然后输出到字符串。它的结果看起来是怪异的： PowerShell process description: @{Description=Windows PowerShell} 这是因为代码中选择了整个 Description 属性，而且结果不仅是描述字符串，而且包括了整个属性： PS&gt; $desc Description ----------- Windows PowerShell ISE 当您只选择一个属性时，请确保使用 -ExpandProperty 而不是 -Property。前者避免产生一个属性列，并且字符串看起来正常了： PS&gt; $desc = Get-Process -Id $pid | Select-Object -ExpandProperty Description PS&gt; &quot;PowerShell process description: $desc&quot; PowerShell process description: Windows PowerShell ISE 本文国际来源：Weird Text Formatting (and what to do about it)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在 PowerShell 中查找服务","slug":"finding-services-in-powershell","date":"2013-10-29T16:00:00.000Z","updated":"2017-03-17T15:26:22.317Z","comments":true,"path":"2013/10/30/finding-services-in-powershell/","link":"","permalink":"http://blog.vichamp.com/2013/10/30/finding-services-in-powershell/","excerpt":"Get-Service 可以列出计算机上的所有服务，但是返回的信息十分少。您无法很容易地看出一个服务做什么、它是一个 Microsoft 服务还是一个第三方服务，以及服务所对应的可执行程序。 通过合并一些信息，您可以获取许多更丰富的信息。以下是一个 Find-Service 函数，可以返回一系列丰富的信息： function Find-Service { param ( $Name = &apos;*&apos;, $DisplayName = &apos;*&apos;, $Started ) $pattern = &apos;^.*\\.exe\\b&apos; $Name = $Name.Replace(&apos;*&apos;,&apos;%&apos;) $DisplayName = $DisplayName.Replace(&apos;*&apos;,&apos;%&apos;) Get-WmiObject -Class Win32_Service -Filter &quot;Name like &apos;$Name&apos; and DisplayName like &apos;$DisplayName&apos;&quot;| ForEach-Object { if ($_.PathName -match $pattern) { $Path = $matches[0].Trim(&apos;&quot;&apos;) $file = Get-Item -Path $Path $rv = $_ | Select-Object -Property Name, DisplayName, isMicrosoft, Started, StartMode, Description, CompanyName, ProductName, FileDescription, ServiceType, ExitCode, InstallDate, DesktopInteract, ErrorControl, ExecutablePath, PathName $rv.CompanyName = $file.VersionInfo.CompanyName $rv.ProductName = $file.VersionInfo.ProductName $rv.FileDescription = $file.VersionInfo.FileDescription $rv.ExecutablePath = $path $rv.isMicrosoft = $file.VersionInfo.CompanyName -like &apos;*Microsoft*&apos; $rv } else { Write-Warning (&quot;Service {0} has no EXE attached. PathName=&apos;{1}&apos;&quot; -f $_.PathName) } } } Find-Service | Out-GridView","text":"Get-Service 可以列出计算机上的所有服务，但是返回的信息十分少。您无法很容易地看出一个服务做什么、它是一个 Microsoft 服务还是一个第三方服务，以及服务所对应的可执行程序。 通过合并一些信息，您可以获取许多更丰富的信息。以下是一个 Find-Service 函数，可以返回一系列丰富的信息： function Find-Service { param ( $Name = &apos;*&apos;, $DisplayName = &apos;*&apos;, $Started ) $pattern = &apos;^.*\\.exe\\b&apos; $Name = $Name.Replace(&apos;*&apos;,&apos;%&apos;) $DisplayName = $DisplayName.Replace(&apos;*&apos;,&apos;%&apos;) Get-WmiObject -Class Win32_Service -Filter &quot;Name like &apos;$Name&apos; and DisplayName like &apos;$DisplayName&apos;&quot;| ForEach-Object { if ($_.PathName -match $pattern) { $Path = $matches[0].Trim(&apos;&quot;&apos;) $file = Get-Item -Path $Path $rv = $_ | Select-Object -Property Name, DisplayName, isMicrosoft, Started, StartMode, Description, CompanyName, ProductName, FileDescription, ServiceType, ExitCode, InstallDate, DesktopInteract, ErrorControl, ExecutablePath, PathName $rv.CompanyName = $file.VersionInfo.CompanyName $rv.ProductName = $file.VersionInfo.ProductName $rv.FileDescription = $file.VersionInfo.FileDescription $rv.ExecutablePath = $path $rv.isMicrosoft = $file.VersionInfo.CompanyName -like &apos;*Microsoft*&apos; $rv } else { Write-Warning (&quot;Service {0} has no EXE attached. PathName=&apos;{1}&apos;&quot; -f $_.PathName) } } } Find-Service | Out-GridView 本文国际来源：Finding Services in PowerShell","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取 1000 个以上 Active Directory 结果","slug":"getting-more-than-1000-active-directory-results","date":"2013-10-28T16:00:00.000Z","updated":"2017-03-17T15:26:22.301Z","comments":true,"path":"2013/10/29/getting-more-than-1000-active-directory-results/","link":"","permalink":"http://blog.vichamp.com/2013/10/29/getting-more-than-1000-active-directory-results/","excerpt":"当您使用 ADSISearcher 时，默认情况下，Active Directory 只返回前 1000 个搜索结果。这是一个防止意外的 LDAP 查询导致域控制器负荷过重的安全保护机制。 如果您需要完整的搜索结果，并且明确地知道它将超过 1000 条记录，请设置 PageSize 为 1000。通过这种方式，ADSISearcher 每一批返回 1000 个搜索结果元素。 以下查询将会返回您域中的所有用户账户（在运行这个查询之前，您也许需要联系一下您的域管理员）： $searcher = [ADSISearcher]&quot;sAMAccountType=$(0x30000000)&quot; # get all results, do not stop at 1000 results $searcher.PageSize = 1000 $searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property * | Out-GridView","text":"当您使用 ADSISearcher 时，默认情况下，Active Directory 只返回前 1000 个搜索结果。这是一个防止意外的 LDAP 查询导致域控制器负荷过重的安全保护机制。 如果您需要完整的搜索结果，并且明确地知道它将超过 1000 条记录，请设置 PageSize 为 1000。通过这种方式，ADSISearcher 每一批返回 1000 个搜索结果元素。 以下查询将会返回您域中的所有用户账户（在运行这个查询之前，您也许需要联系一下您的域管理员）： $searcher = [ADSISearcher]&quot;sAMAccountType=$(0x30000000)&quot; # get all results, do not stop at 1000 results $searcher.PageSize = 1000 $searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property * | Out-GridView 本文国际来源：Getting More Than 1000 Active Directory Results","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 在智能感知中隐藏参数","slug":"hiding-parameters-from-intellisense","date":"2013-10-27T16:00:00.000Z","updated":"2017-03-17T15:26:22.301Z","comments":true,"path":"2013/10/28/hiding-parameters-from-intellisense/","link":"","permalink":"http://blog.vichamp.com/2013/10/28/hiding-parameters-from-intellisense/","excerpt":"从 PowerShell 4.0 开始，脚本作者可以决定隐藏某些参数，使之不在智能感知中出现。通过这种方式，可以在 ISE 的智能感知上下文菜单中隐藏不常用的参数。 function Test-Function { param( $Name, [Parameter(DontShow)] [Switch] $IAmSecret ) if ($IAmSecret) { &quot;Doing secret things with $Name&quot; } else { &quot;Regular behavior with $Name&quot; } } 当您在 PowerShell 4.0 ISE 中运行这个函数时，只有 “Name” 参数会出现在智能感知上下文菜单中。然而，如果您事先知道这个隐藏参数，并且键入了第一个字母，然后按下 (TAB) 键，这个参数仍会显示： 在帮助窗口，隐藏参数总是可以显示，您可以通过类似这种方式打开：","text":"从 PowerShell 4.0 开始，脚本作者可以决定隐藏某些参数，使之不在智能感知中出现。通过这种方式，可以在 ISE 的智能感知上下文菜单中隐藏不常用的参数。 function Test-Function { param( $Name, [Parameter(DontShow)] [Switch] $IAmSecret ) if ($IAmSecret) { &quot;Doing secret things with $Name&quot; } else { &quot;Regular behavior with $Name&quot; } } 当您在 PowerShell 4.0 ISE 中运行这个函数时，只有 “Name” 参数会出现在智能感知上下文菜单中。然而，如果您事先知道这个隐藏参数，并且键入了第一个字母，然后按下 (TAB) 键，这个参数仍会显示： 在帮助窗口，隐藏参数总是可以显示，您可以通过类似这种方式打开： 本文国际来源：Hiding Parameters from IntelliSense","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 快速查找 Active Directory 用户账户","slug":"finding-active-directory-user-accounts-fast","date":"2013-10-24T16:00:00.000Z","updated":"2017-03-17T15:26:22.301Z","comments":true,"path":"2013/10/25/finding-active-directory-user-accounts-fast/","link":"","permalink":"http://blog.vichamp.com/2013/10/25/finding-active-directory-user-accounts-fast/","excerpt":"LDAP 查询条件越明确，查询速度就越快，占用的资源就越少，并且查询结果越清晰。 例如，许多人使用 objectClass 来限制查询结果为某个指定的对象类型。若只需要查询用户账户，他们常常使用 &quot;objectClass=user&quot; 的写法。许多人不知道计算机账户也共享这个对象类型。让我们来验证这一点： 这个例子将会查找所有 SamAccountName 以 “a” 开头，并且 objectClass=”user” 的账户。 # get all users with a SamAccountName that starts with &quot;a&quot; $searcher = [ADSISearcher]&quot;(&amp;(objectClass=User)(sAMAccountName=a*))&quot; # see how long this takes $result = Measure-Command { $all = $searcher.FindAll() $found = $all.Count } $seconds = $result.TotalSeconds &quot;The search returned $found objects and took $sec seconds.&quot; 然后使用这行来代替上面的代码： $searcher = [ADSISearcher]&quot;(&amp;(sAMAccountType=$(0x30000000))(sAMAccountName=a*))&quot; 当您换成这行代码以后，查询速度显著提升了。并且结果更清晰。这是因为普通用户账户和计算机账户的 SamAccountType 不同： SAM_NORMAL_USER_ACCOUNT 0x30000000 SAM_MACHINE_ACCOUNT 0x30000001 两者的 objectClass 都属于 “User”。","text":"LDAP 查询条件越明确，查询速度就越快，占用的资源就越少，并且查询结果越清晰。 例如，许多人使用 objectClass 来限制查询结果为某个指定的对象类型。若只需要查询用户账户，他们常常使用 &quot;objectClass=user&quot; 的写法。许多人不知道计算机账户也共享这个对象类型。让我们来验证这一点： 这个例子将会查找所有 SamAccountName 以 “a” 开头，并且 objectClass=”user” 的账户。 # get all users with a SamAccountName that starts with &quot;a&quot; $searcher = [ADSISearcher]&quot;(&amp;(objectClass=User)(sAMAccountName=a*))&quot; # see how long this takes $result = Measure-Command { $all = $searcher.FindAll() $found = $all.Count } $seconds = $result.TotalSeconds &quot;The search returned $found objects and took $sec seconds.&quot; 然后使用这行来代替上面的代码： $searcher = [ADSISearcher]&quot;(&amp;(sAMAccountType=$(0x30000000))(sAMAccountName=a*))&quot; 当您换成这行代码以后，查询速度显著提升了。并且结果更清晰。这是因为普通用户账户和计算机账户的 SamAccountType 不同： SAM_NORMAL_USER_ACCOUNT 0x30000000 SAM_MACHINE_ACCOUNT 0x30000001 两者的 objectClass 都属于 “User”。本文国际来源：Finding Active Directory User Accounts Fast","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通过 SID 查找 Active Directory 账户","slug":"finding-active-directory-accounts-by-sid","date":"2013-10-23T16:00:00.000Z","updated":"2017-03-17T15:26:22.301Z","comments":true,"path":"2013/10/24/finding-active-directory-accounts-by-sid/","link":"","permalink":"http://blog.vichamp.com/2013/10/24/finding-active-directory-accounts-by-sid/","excerpt":"如果您已知账户的 SID 并且希望找到相应的 Active Directory 账户，那么 LDAP 查询并不适合这项工作。为了使它能工作，您需要将 SID 的格式改成符合 LDAP 规则的格式，这不是一个简单的过程。 以下是一个更简单的使用 LDAP 路径的办法。假设您使用 $SID 变量保存了一个 SID 字符串，并且您希望查找出和它关联的 Active Directory 账户。试试以下的代码： $SID = &apos;&lt;enter SID here&gt;&apos; # like S-1-5-21-1234567-... $account = [ADSI]&quot;LDAP://&lt;SID=$SID&gt;&quot; $account $account.distinguishedName","text":"如果您已知账户的 SID 并且希望找到相应的 Active Directory 账户，那么 LDAP 查询并不适合这项工作。为了使它能工作，您需要将 SID 的格式改成符合 LDAP 规则的格式，这不是一个简单的过程。 以下是一个更简单的使用 LDAP 路径的办法。假设您使用 $SID 变量保存了一个 SID 字符串，并且您希望查找出和它关联的 Active Directory 账户。试试以下的代码： $SID = &apos;&lt;enter SID here&gt;&apos; # like S-1-5-21-1234567-... $account = [ADSI]&quot;LDAP://&lt;SID=$SID&gt;&quot; $account $account.distinguishedName 本文国际来源：Finding Active Directory Accounts by SID","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 处理纯文本 - 2","slug":"processing-plain-text-with-powershell-2","date":"2013-10-22T16:00:00.000Z","updated":"2017-03-17T15:26:22.286Z","comments":true,"path":"2013/10/23/processing-plain-text-with-powershell-2/","link":"","permalink":"http://blog.vichamp.com/2013/10/23/processing-plain-text-with-powershell-2/","excerpt":"","text":"应朋友要求，帮忙解决一例 PowerShell 问题： 有一个 CSV 文件，其中有一个 Photo 字段存的是 BASE64 编码的字符串，这个字符串包含换行符。在 Import-Csv 的时候，Photo 字段不会作为一个整体值，而是会变成每行一个。文件的内容是这样的： StaffNum,LogonName,ObjName,Title,Office,Department,Photo 03138,wangjunhao,王俊豪,流程优化主管,宜山路,运营平台中心/项目部,/9j/4AAQSkZJRgABAgAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy ... PyoooGSr0qRCdtFFMBy9qkFFFJCYo60w85oopgNzjoBTto9KKKQj/9k= 为了解决这个 case，先归纳它的规律： BASE64 字符串的字符集为 0..9、a..z、A..Z，以及/和=。 BASE64 字符串每一行不超过 76 个字符。 如果某一行从第一个字符到最后一个字符，都符合上述 2 条规律，说明前一行并没有结束。应当把当前行拼接到前一行中。 根据以上规律编写 PowerShell 代码： $fileName = &apos;AllUsers.csv&apos; $currentLine = &apos;&apos; gc $fileName | % -process { if ($_ -cmatch &apos;^[a-zA-Z0-9/+=]{1,76}$&apos;) { # 如果符合 BASE64 特征，说明上一行未结束。 $currentLine += $_ } else { # 如果不符合 BASE64 特征，说明上一行是完整的。 Write-Output $currentLine $currentLine = $_ } } -end { $currentLine } | ConvertFrom-Csv 完整的 .CSV 及 .PS1 文件请在这里下载。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"learning","slug":"learning","permalink":"http://blog.vichamp.com/tags/learning/"},{"name":"skill","slug":"skill","permalink":"http://blog.vichamp.com/tags/skill/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}]},{"title":"PowerShell 技能连载 - 在不同的 Domain 中查找","slug":"searching-in-different-domains","date":"2013-10-22T16:00:00.000Z","updated":"2017-03-17T15:26:22.301Z","comments":true,"path":"2013/10/23/searching-in-different-domains/","link":"","permalink":"http://blog.vichamp.com/2013/10/23/searching-in-different-domains/","excerpt":"当你那使用 ADSISearcher 类型加速器来查找 Active Directory 账户时，它缺省情况下在您当前登录的域中查找。如果您需要在一个不同的域中查找，请确保相应地定义了搜索的根路径。 This example will find all accounts with a SamAccountName that starts with “tobias”, and it searches the domain “powershell.local” (adjust to a real domain name, of course):这个例子将查找所有 SamAccountName 以 “tobias” 开头的账户，并且它在 “powershell.local” 域中搜索（当然，请根据实际情况调整名字）： # get all users with a SamAccountName that starts with &quot;tobias&quot; $searcher = [ADSISearcher]&quot;(&amp;(objectClass=User)(objectCategory=person)(sAMAccountName=tobias*))&quot; # use powershell.local for searching $domain = New-Object System.DirectoryServices.DirectoryEntry(&apos;DC=powershell,DC=local&apos;) $searcher.SearchRoot = $domain # execute the query $searcher.FindAll()","text":"当你那使用 ADSISearcher 类型加速器来查找 Active Directory 账户时，它缺省情况下在您当前登录的域中查找。如果您需要在一个不同的域中查找，请确保相应地定义了搜索的根路径。 This example will find all accounts with a SamAccountName that starts with “tobias”, and it searches the domain “powershell.local” (adjust to a real domain name, of course):这个例子将查找所有 SamAccountName 以 “tobias” 开头的账户，并且它在 “powershell.local” 域中搜索（当然，请根据实际情况调整名字）： # get all users with a SamAccountName that starts with &quot;tobias&quot; $searcher = [ADSISearcher]&quot;(&amp;(objectClass=User)(objectCategory=person)(sAMAccountName=tobias*))&quot; # use powershell.local for searching $domain = New-Object System.DirectoryServices.DirectoryEntry(&apos;DC=powershell,DC=local&apos;) $searcher.SearchRoot = $domain # execute the query $searcher.FindAll() 本文国际来源：Searching in Different Domains","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"快速运行 .ps1 脚本的 N 种方法","slug":"n-ways-to-run-ps1-rapidly","date":"2013-10-22T16:00:00.000Z","updated":"2017-03-17T15:26:22.286Z","comments":true,"path":"2013/10/23/n-ways-to-run-ps1-rapidly/","link":"","permalink":"http://blog.vichamp.com/2013/10/23/n-ways-to-run-ps1-rapidly/","excerpt":"由于安全的原因，微软禁止以双击的方式执行 PowerShell 的 .ps1 脚本。但如果我们一味地追求效率，而暂时“无视”其安全性的话，要怎样快速地执行 .ps1 脚本呢？以下是 QQ 群里讨论的一些方案： 为每个 .ps1 配一个 .cmd 批处理文件这种方法适用于可能需要将 PowerShell 脚本发送给朋友执行，而朋友可能只是初学者或普通用户的场景，并且该脚本不会修改注册表。具体做法是：将以下代码保存为一个 .cmd 文件，放在 .ps1 的同一个目录下。注意主文件名必须和 .ps1 的主文件名一致。 @set Path=%Path%;%SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\ &amp; powershell -ExecutionPolicy Unrestricted -NoExit -NoProfile %~dpn0.ps1 例如，您希望朋友执行 My-Script.ps1，那么您只需要将以上代码保存为 My-Script.cmd，放在同一个目录之下发给您的朋友即可。 这种方法还有个小小的好处是，不需要为不同的 .ps1 而修改 .cmd 的内容。 用批处理文件做一个简单的菜单，列出 .ps1 文件","text":"由于安全的原因，微软禁止以双击的方式执行 PowerShell 的 .ps1 脚本。但如果我们一味地追求效率，而暂时“无视”其安全性的话，要怎样快速地执行 .ps1 脚本呢？以下是 QQ 群里讨论的一些方案： 为每个 .ps1 配一个 .cmd 批处理文件这种方法适用于可能需要将 PowerShell 脚本发送给朋友执行，而朋友可能只是初学者或普通用户的场景，并且该脚本不会修改注册表。具体做法是：将以下代码保存为一个 .cmd 文件，放在 .ps1 的同一个目录下。注意主文件名必须和 .ps1 的主文件名一致。 @set Path=%Path%;%SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\ &amp; powershell -ExecutionPolicy Unrestricted -NoExit -NoProfile %~dpn0.ps1 例如，您希望朋友执行 My-Script.ps1，那么您只需要将以上代码保存为 My-Script.cmd，放在同一个目录之下发给您的朋友即可。 这种方法还有个小小的好处是，不需要为不同的 .ps1 而修改 .cmd 的内容。 用批处理文件做一个简单的菜单，列出 .ps1 文件 该方法由 @PS 网友提供。优点在于可以为多个 .ps1 脚本配一个 .cmd 批处理。执行 .cmd 以后，将显示一个简易的字符界面选择菜单。可以根据用户的选择执行相应的 .ps1 脚本。以下是代码： @echo off setlocal enabledelayedexpansion for %%i in (*.ps1) do ( set /a num+=1 set .!num!=%%i echo !num!. %%i ) set/p n=这里输入序列： echo !.%n%! set Path=%Path%;%SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\ &amp; powershell -ExecutionPolicy Unrestricted -NoProfile .\\!.%n%! pause 用命令行修改 PowerShell 文件的打开方式该方法由 @史瑞克 网友提供，只需要在命令行中执行一次以下代码，以后即可双击运行 .ps1 脚本： ftype Microsoft.PowerShellScript.1=&quot;%SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; &quot;.\\%1&quot; 用这种方法可以设置打开方式和默认打开方式，需要管理员权限。恢复方法： ftype Microsoft.PowerShellScript.1=&quot;%SystemRoot%\\system32\\notepad.exe&quot; &quot;%1&quot; 用 PowerShell 脚本修改 PowerShell 文件的打开方式该方法由 StackOverflow 上的 @JPBlanc 网友提供。只需要在 PowerShell 中执行一次以下代码，以后即可双击运行 .ps1 脚本。优点是可以开可以关。原文是法文，已由 @Andy Arismendi 网友翻译为英文。 &lt;# .SYNOPSIS Change the registry key in order that double-clicking on a file with .PS1 extension start its execution with PowerShell. .DESCRIPTION This operation bring (partly) .PS1 files to the level of .VBS as far as execution through Explorer.exe is concern. This operation is not advised by Microsoft. .NOTES File Name : ModifyExplorer.ps1 Author : J.P. Blanc - jean-paul_blanc@silogix-fr.com Prerequisite: PowerShell V2 on Vista and later versions. Copyright 2010 - Jean Paul Blanc/Silogix .LINK Script posted on: http://www.silogix.fr .EXAMPLE PS C:\\silogix&gt; Set-PowAsDefault -On Call Powershell for .PS1 files. Done ! .EXAMPLE PS C:\\silogix&gt; Set-PowAsDefault Tries to go back Done ! #&gt; function Set-PowAsDefault { [CmdletBinding()] Param ( [Parameter(mandatory=$false,ValueFromPipeline=$false)] [Alias(&quot;Active&quot;)] [switch] [bool]$On ) begin { if ($On.IsPresent) { Write-Host &quot;Call Powershell for .PS1 files.&quot; } else { Write-Host &quot;Try to go back.&quot; } } Process { # Text Menu [string]$TexteMenu = &quot;Go inside PowerShell&quot; # Text of the program to create [string] $TexteCommande = &quot;%systemroot%\\system32\\WindowsPowerShell\\v1.0\\powershell.exe -Command &quot;&quot;&amp;&apos;%1&apos;&quot;&quot;&quot; # Key to create [String] $clefAModifier = &quot;HKLM:\\SOFTWARE\\Classes\\Microsoft.PowerShellScript.1\\Shell\\Open\\Command&quot; try { $oldCmdKey = $null $oldCmdKey = Get-Item $clefAModifier -ErrorAction SilentlyContinue $oldCmdValue = $oldCmdKey.getvalue(&quot;&quot;) if ($oldCmdValue -ne $null) { if ($On.IsPresent) { $slxOldValue = $null $slxOldValue = Get-ItemProperty $clefAModifier -Name &quot;slxOldValue&quot; -ErrorAction SilentlyContinue if ($slxOldValue -eq $null) { New-ItemProperty $clefAModifier -Name &quot;slxOldValue&quot; -Value $oldCmdValue -PropertyType &quot;String&quot; | Out-Null New-ItemProperty $clefAModifier -Name &quot;(default)&quot; -Value $TexteCommande -PropertyType &quot;ExpandString&quot; | Out-Null Write-Host &quot;Done !&quot; } else { Write-Host &quot;Already done !&quot; } } else { $slxOldValue = $null $slxOldValue = Get-ItemProperty $clefAModifier -Name &quot;slxOldValue&quot; -ErrorAction SilentlyContinue if ($slxOldValue -ne $null) { New-ItemProperty $clefAModifier -Name &quot;(default)&quot; -Value $slxOldValue.&quot;slxOldValue&quot; -PropertyType &quot;String&quot; | Out-Null Remove-ItemProperty $clefAModifier -Name &quot;slxOldValue&quot; Write-Host &quot;Done !&quot; } else { Write-Host &quot;No former value !&quot; } } } } catch { $_.exception.message } } end {} } 使用方法很简单，Set-PowAsDefault -On为打开，Set-PowAsDefault为关闭。需要管理员权限。 以上是目前搜集的几种方法，希望对您有用。您可以在这里下载以上所有脚本的例子。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"command","slug":"command","permalink":"http://blog.vichamp.com/tags/command/"},{"name":"cmd","slug":"cmd","permalink":"http://blog.vichamp.com/tags/cmd/"},{"name":"registry","slug":"registry","permalink":"http://blog.vichamp.com/tags/registry/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 从 DN 中获得 Domain","slug":"getting-domain-from-dn","date":"2013-10-21T16:00:00.000Z","updated":"2017-03-17T15:26:22.286Z","comments":true,"path":"2013/10/22/getting-domain-from-dn/","link":"","permalink":"http://blog.vichamp.com/2013/10/22/getting-domain-from-dn/","excerpt":"“DN” 指的是是 Active Directory 对象的路径，看起来大概如下： &apos;CN=Tobias,OU=Authors,DC=powershell,DC=local&apos; 要获取 DN 中的域部分，请使用如下代码： $DN = &apos;CN=Tobias,OU=Authors,DC=powershell,DC=local&apos; $pattern = &apos;(?i)DC=\\w{1,}?\\b&apos; ([RegEx]::Matches($DN, $pattern) | ForEach-Object { $_.Value }) -join &apos;,&apos; 这段代码用一个正则表达式来查找 DN 的所有 DC= 部分；然后将它们用逗号分隔符连接起来。 执行结果如下： DC=powershell,DC=local","text":"“DN” 指的是是 Active Directory 对象的路径，看起来大概如下： &apos;CN=Tobias,OU=Authors,DC=powershell,DC=local&apos; 要获取 DN 中的域部分，请使用如下代码： $DN = &apos;CN=Tobias,OU=Authors,DC=powershell,DC=local&apos; $pattern = &apos;(?i)DC=\\w{1,}?\\b&apos; ([RegEx]::Matches($DN, $pattern) | ForEach-Object { $_.Value }) -join &apos;,&apos; 这段代码用一个正则表达式来查找 DN 的所有 DC= 部分；然后将它们用逗号分隔符连接起来。 执行结果如下： DC=powershell,DC=local 本文国际来源：Getting Domain from DN","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将二进制 SID 转换为 SID 字符串","slug":"converting-binary-sid-to-string-sid","date":"2013-10-20T16:00:00.000Z","updated":"2017-03-17T15:26:22.270Z","comments":true,"path":"2013/10/21/converting-binary-sid-to-string-sid/","link":"","permalink":"http://blog.vichamp.com/2013/10/21/converting-binary-sid-to-string-sid/","excerpt":"Active Directory 账户有一个二进制形式存储的 SID。要将字节数组转换为字符串的表达形式，可以用如下的 .NET 函数： # get current user $searcher = [ADSISearcher]&quot;(&amp;(objectClass=User)(objectCategory=person)(sAMAccountName=$env:username))&quot; $user = $searcher.FindOne().GetDirectoryEntry() # get binary SID from AD account $binarySID = $user.ObjectSid.Value # convert to string SID $stringSID = (New-Object System.Security.Principal.SecurityIdentifier($binarySID,0)).Value $binarySID $stringSID 在这个例子中，一个 ADSI 搜索器获取当前的用户账户（返回当前登录到一个域中的用户）。然后，将二进制的 SID 转换为 SID 字符串。","text":"Active Directory 账户有一个二进制形式存储的 SID。要将字节数组转换为字符串的表达形式，可以用如下的 .NET 函数： # get current user $searcher = [ADSISearcher]&quot;(&amp;(objectClass=User)(objectCategory=person)(sAMAccountName=$env:username))&quot; $user = $searcher.FindOne().GetDirectoryEntry() # get binary SID from AD account $binarySID = $user.ObjectSid.Value # convert to string SID $stringSID = (New-Object System.Security.Principal.SecurityIdentifier($binarySID,0)).Value $binarySID $stringSID 在这个例子中，一个 ADSI 搜索器获取当前的用户账户（返回当前登录到一个域中的用户）。然后，将二进制的 SID 转换为 SID 字符串。 本文国际来源：Converting Binary SID to String SID","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"下载 Visual Studio 2013","slug":"download-visual-studio-2013","date":"2013-10-18T16:00:00.000Z","updated":"2017-03-17T15:26:22.270Z","comments":true,"path":"2013/10/19/download-visual-studio-2013/","link":"","permalink":"http://blog.vichamp.com/2013/10/19/download-visual-studio-2013/","excerpt":"","text":"下载信息英文版Visual Studio Ultimate 2013 (x86) - DVD (English) 语言：英语(美国) 文件名：en_visual_studio_ultimate_2013_x86_dvd_3009107.iso 发布日期(UTC)：2013-10-17 18:43:01文件大小：2.82 GB SHA1：79DBBA7B6EF12B1A4E715A7F20951EE66FBCDAB4 英文版下载地址（HTTP） 英文版下载地址（ED2K） 英文WEB在线安装版 中文版Visual Studio Ultimate 2013 (x86) - DVD (Chinese-Simplified) 语言：中文(简体) 文件名：cn_visual_studio_ultimate_2013_x86_dvd_3009109.iso 发布日期(UTC)：2013-10-17 18:43:01文件大小：2.87 GB SHA1：07313542D36ED8BEEF18520AA4F15E33E32C7F77 中文版下载地址（HTTP） 中文版下载地址（ED2K） 中文WEB在线安装版 相关链接 官方下载页面（中文） 官方下载页面（英文） Announcing the Release of Visual Studio 2013 and Great Improvements to ASP.NET and Entity Framework","categories":[{"name":"visualstudio","slug":"visualstudio","permalink":"http://blog.vichamp.com/categories/visualstudio/"}],"tags":[{"name":"download","slug":"download","permalink":"http://blog.vichamp.com/tags/download/"},{"name":"visualstudio","slug":"visualstudio","permalink":"http://blog.vichamp.com/tags/visualstudio/"},{"name":"microsoft","slug":"microsoft","permalink":"http://blog.vichamp.com/tags/microsoft/"},{"name":"iso","slug":"iso","permalink":"http://blog.vichamp.com/tags/iso/"},{"name":"release","slug":"release","permalink":"http://blog.vichamp.com/tags/release/"}],"keywords":[{"name":"visualstudio","slug":"visualstudio","permalink":"http://blog.vichamp.com/categories/visualstudio/"}]},{"title":"PowerShell 技能连载 - 查找当前的脚本文件夹","slug":"finding-current-script-folder","date":"2013-10-17T16:00:00.000Z","updated":"2017-03-17T15:26:22.270Z","comments":true,"path":"2013/10/18/finding-current-script-folder/","link":"","permalink":"http://blog.vichamp.com/2013/10/18/finding-current-script-folder/","excerpt":"从 PowerShell 3.0 开始，有一个很简单的办法来确定一个脚本所在的文件夹：$PSScriptRoot。这个变量总是保存了指定脚本所存放的文件夹路径。 通过这种方法，可以很方便地加载额外的资源，比如说其它脚本。以下代码将读取位于同一个文件夹中，一个名为 myFunctions.ps1 的脚本文件： &quot;$PSScriptRoot\\myFunctions.ps1&quot; 别忘了用“dot-source”语法（在路径之前加点号）。否则只会输出该路径名（而不是执行该路径表示的脚本）。","text":"从 PowerShell 3.0 开始，有一个很简单的办法来确定一个脚本所在的文件夹：$PSScriptRoot。这个变量总是保存了指定脚本所存放的文件夹路径。 通过这种方法，可以很方便地加载额外的资源，比如说其它脚本。以下代码将读取位于同一个文件夹中，一个名为 myFunctions.ps1 的脚本文件： &quot;$PSScriptRoot\\myFunctions.ps1&quot; 别忘了用“dot-source”语法（在路径之前加点号）。否则只会输出该路径名（而不是执行该路径表示的脚本）。 本文国际来源：Finding Current Script Folder","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 获取 Active Directory 账户信息","slug":"getting-active-directory-account-information","date":"2013-10-16T16:00:00.000Z","updated":"2017-03-17T15:26:22.249Z","comments":true,"path":"2013/10/17/getting-active-directory-account-information/","link":"","permalink":"http://blog.vichamp.com/2013/10/17/getting-active-directory-account-information/","excerpt":"在上一段脚本中，您应该已经发现了可以多么轻易地用几行 PowerShell 代码来获取 Active Directory 账户。它的结果是一个搜索结果对象，而不是实际的账户对象。 要获取一个账户的更详细信息，请使用 GetDirectoryEntry() 将搜索结果转换为一个实际的账户对象： # get 10 results max $searcher.SizeLimit = 10 # find account location $searcher.FindAll() | # get account object ForEach-Object { $_.GetDirectoryEntry() } | # display all properties Select-Object -Property * | # display in a grid view window (ISE needs to be installed for this step) Out-GridView","text":"在上一段脚本中，您应该已经发现了可以多么轻易地用几行 PowerShell 代码来获取 Active Directory 账户。它的结果是一个搜索结果对象，而不是实际的账户对象。 要获取一个账户的更详细信息，请使用 GetDirectoryEntry() 将搜索结果转换为一个实际的账户对象： # get 10 results max $searcher.SizeLimit = 10 # find account location $searcher.FindAll() | # get account object ForEach-Object { $_.GetDirectoryEntry() } | # display all properties Select-Object -Property * | # display in a grid view window (ISE needs to be installed for this step) Out-GridView 本文国际来源：Getting Active Directory Account Information","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找 Active Directory 用户账号","slug":"finding-ad-user-accounts","date":"2013-10-15T16:00:00.000Z","updated":"2017-03-17T15:26:22.249Z","comments":true,"path":"2013/10/16/finding-ad-user-accounts/","link":"","permalink":"http://blog.vichamp.com/2013/10/16/finding-ad-user-accounts/","excerpt":"有很多用于 Active Directory 的 Module 和 Cmdlet，但是有些时候用 .NET 代码来做反而更方便快捷。 比如说，如果您只是想知道，某个用户是否存在于您的 Active Directory中，那么实现查找一个用户是很容易的： # sending LDAP query to Active Directory $searcher = [ADSISearcher]&apos;(&amp;(objectClass=User)(objectCategory=person)(SamAccountName=tobias*))&apos; # finding first match $searcher.FindOne() # finding ALL matches $searcher.FindAll() 这段代码将查找所有 SamAccountName 以 “tobias” 开头的用户账号。您可以接着用这个方法来便捷地找出这个用户所在的位置： # find account location $searcher.FindAll() | Select-Object -ExpandProperty Path","text":"有很多用于 Active Directory 的 Module 和 Cmdlet，但是有些时候用 .NET 代码来做反而更方便快捷。 比如说，如果您只是想知道，某个用户是否存在于您的 Active Directory中，那么实现查找一个用户是很容易的： # sending LDAP query to Active Directory $searcher = [ADSISearcher]&apos;(&amp;(objectClass=User)(objectCategory=person)(SamAccountName=tobias*))&apos; # finding first match $searcher.FindOne() # finding ALL matches $searcher.FindAll() 这段代码将查找所有 SamAccountName 以 “tobias” 开头的用户账号。您可以接着用这个方法来便捷地找出这个用户所在的位置： # find account location $searcher.FindAll() | Select-Object -ExpandProperty Path 本文国际来源：Finding AD User Accounts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"将 Windows 8.1 的命令提示符替换为 PowerShell","slug":"replace-command-prompt-by-powershell-in-windows-81","date":"2013-10-14T16:00:00.000Z","updated":"2017-03-17T15:26:22.233Z","comments":true,"path":"2013/10/15/replace-command-prompt-by-powershell-in-windows-81/","link":"","permalink":"http://blog.vichamp.com/2013/10/15/replace-command-prompt-by-powershell-in-windows-81/","excerpt":"","text":"在 Windows 8.1 中，增加了一个“将 WIN+X 菜单中将命令提示符替换为 Windows PowerShell”功能，您注意到了吗？ 打开这个选项的方法是：右键单击 Windows 任务栏，选择“属性”。在“导航”选项卡中，您可以找到这个功能。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"windows","slug":"windows","permalink":"http://blog.vichamp.com/tags/windows/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 多行输入对话框、打开文件对话框、文件夹浏览对话框、输入框及消息框","slug":"powershell-multi-line-input-box-dialog-open-file-dialog-folder-browser-dialog-input-box-and-message-box","date":"2013-10-14T16:00:00.000Z","updated":"2017-03-17T15:26:22.233Z","comments":true,"path":"2013/10/15/powershell-multi-line-input-box-dialog-open-file-dialog-folder-browser-dialog-input-box-and-message-box/","link":"","permalink":"http://blog.vichamp.com/2013/10/15/powershell-multi-line-input-box-dialog-open-file-dialog-folder-browser-dialog-input-box-and-message-box/","excerpt":"我热爱 PowerShell，当我需要提示用户输入时，我常常更喜欢使用 GUI 控件，而不是让他们什么都往控制台里输入；有些东西比如说浏览文件或文件夹，或输入多行文本，不是很方便直接往 PowerShell 的命令行窗口中输入。所以我想我可以分享一些我常常用于这些场景的 PowerShell 脚本。 您可以从这儿下载包含以下所有函数的脚本。 显示消息框： # Show message box popup and return the button clicked by the user. Add-Type -AssemblyName System.Windows.Forms function Read-MessageBoxDialog([string]$Message, [string]$WindowTitle, [System.Windows.Forms.MessageBoxButtons]$Buttons = [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]$Icon = [System.Windows.Forms.MessageBoxIcon]::None) { return [System.Windows.Forms.MessageBox]::Show($Message, $WindowTitle, $Buttons, $Icon) } 提示简易的用户输入（单行）： # Show input box popup and return the value entered by the user. function Read-InputBoxDialog([string]$Message, [string]$WindowTitle, [string]$DefaultText) { Add-Type -AssemblyName Microsoft.VisualBasic return [Microsoft.VisualBasic.Interaction]::InputBox($Message, $WindowTitle, $DefaultText) } 提示输入一个文件路径（基于脚本小子的一篇文章）： # Show an Open File Dialog and return the file selected by the user. function Read-OpenFileDialog([string]$WindowTitle, [string]$InitialDirectory, [string]$Filter = &quot;All files (*.*)|*.*&quot;, [switch]$AllowMultiSelect) { Add-Type -AssemblyName System.Windows.Forms $openFileDialog = New-Object System.Windows.Forms.OpenFileDialog $openFileDialog.Title = $WindowTitle if (![string]::IsNullOrWhiteSpace($InitialDirectory)) { $openFileDialog.InitialDirectory = $InitialDirectory } $openFileDialog.Filter = $Filter if ($AllowMultiSelect) { $openFileDialog.MultiSelect = $true } $openFileDialog.ShowHelp = $true # Without this line the ShowDialog() function may hang depending on system configuration and running from console vs. ISE. $openFileDialog.ShowDialog() &gt; $null if ($AllowMultiSelect) { return $openFileDialog.Filenames } else { return $openFileDialog.Filename } } 提示输入一个文件夹（使用 System.Windows.Forms.FolderBrowserDialog 有可能会导致执行时挂起，要看系统配置以及从控制台运行还是从 PowerShell ISE中运行）： # Show an Open Folder Dialog and return the directory selected by the user. function Read-FolderBrowserDialog([string]$Message, [string]$InitialDirectory) { $app = New-Object -ComObject Shell.Application $folder = $app.BrowseForFolder(0, $Message, 0, $InitialDirectory) if ($folder) { return $folder.Self.Path } else { return &apos;&apos; } } 提示用户输入多行文本（基于TechNet 这篇文章中的代码）： function Read-MultiLineInputBoxDialog([string]$Message, [string]$WindowTitle, [string]$DefaultText) { &lt;# .SYNOPSIS Prompts the user with a multi-line input box and returns the text they enter, or null if they cancelled the prompt. .DESCRIPTION Prompts the user with a multi-line input box and returns the text they enter, or null if they cancelled the prompt. .PARAMETER Message The message to display to the user explaining what text we are asking them to enter. .PARAMETER WindowTitle The text to display on the prompt window&apos;s title. .PARAMETER DefaultText The default text to show in the input box. .EXAMPLE $userText = Read-MultiLineInputDialog &quot;Input some text please:&quot; &quot;Get User&apos;s Input&quot; Shows how to create a simple prompt to get mutli-line input from a user. .EXAMPLE # Setup the default multi-line address to fill the input box with. $defaultAddress = @&apos; John Doe 123 St. Some Town, SK, Canada A1B 2C3 &apos;@ $address = Read-MultiLineInputDialog &quot;Please enter your full address, including name, street, city, and postal code:&quot; &quot;Get User&apos;s Address&quot; $defaultAddress if ($address -eq $null) { Write-Error &quot;You pressed the Cancel button on the multi-line input box.&quot; } Prompts the user for their address and stores it in a variable, pre-filling the input box with a default multi-line address. If the user pressed the Cancel button an error is written to the console. .EXAMPLE $inputText = Read-MultiLineInputDialog -Message &quot;If you have a really long message you can break it apart`nover two lines with the powershell newline character:&quot; -WindowTitle &quot;Window Title&quot; -DefaultText &quot;Default text for the input box.&quot; Shows how to break the second parameter (Message) up onto two lines using the powershell newline character (`n). If you break the message up into more than two lines the extra lines will be hidden behind or show ontop of the TextBox. .NOTES Name: Show-MultiLineInputDialog Author: Daniel Schroeder (originally based on the code shown at http://technet.microsoft.com/en-us/library/ff730941.aspx) Version: 1.0 #&gt; Add-Type -AssemblyName System.Drawing Add-Type -AssemblyName System.Windows.Forms # Create the Label. $label = New-Object System.Windows.Forms.Label $label.Location = New-Object System.Drawing.Size(10,10) $label.Size = New-Object System.Drawing.Size(280,20) $label.AutoSize = $true $label.Text = $Message # Create the TextBox used to capture the user&apos;s text. $textBox = New-Object System.Windows.Forms.TextBox $textBox.Location = New-Object System.Drawing.Size(10,40) $textBox.Size = New-Object System.Drawing.Size(575,200) $textBox.AcceptsReturn = $true $textBox.AcceptsTab = $false $textBox.Multiline = $true $textBox.ScrollBars = &apos;Both&apos; $textBox.Text = $DefaultText # Create the OK button. $okButton = New-Object System.Windows.Forms.Button $okButton.Location = New-Object System.Drawing.Size(510,250) $okButton.Size = New-Object System.Drawing.Size(75,25) $okButton.Text = &quot;OK&quot; $okButton.Add_Click({ $form.Tag = $textBox.Text; $form.Close() }) # Create the Cancel button. $cancelButton = New-Object System.Windows.Forms.Button $cancelButton.Location = New-Object System.Drawing.Size(415,250) $cancelButton.Size = New-Object System.Drawing.Size(75,25) $cancelButton.Text = &quot;Cancel&quot; $cancelButton.Add_Click({ $form.Tag = $null; $form.Close() }) # Create the form. $form = New-Object System.Windows.Forms.Form $form.Text = $WindowTitle $form.Size = New-Object System.Drawing.Size(610,320) $form.FormBorderStyle = &apos;FixedSingle&apos; $form.StartPosition = &quot;CenterScreen&quot; $form.AutoSizeMode = &apos;GrowAndShrink&apos; $form.Topmost = $True $form.AcceptButton = $okButton $form.CancelButton = $cancelButton $form.ShowInTaskbar = $true # Add all of the controls to the form. $form.Controls.Add($label) $form.Controls.Add($textBox) $form.Controls.Add($okButton) $form.Controls.Add($cancelButton) # Initialize and show the form. $form.Add_Shown({$form.Activate()}) $form.ShowDialog() &gt; $null # Trash the text of the button that was clicked. # Return the text that the user entered. return $form.Tag } 所有的这些，除了多行输入框以外，都是直接使用了现有的 Windows Form 或 Visual Basic 控件。以下是我的多行输入框显示的模样： 我曾经使用动词 Get 作为函数的前缀，然后改成了动词 Show，但是读完整篇文章以后，我觉得使用动词 Read 也许是最合适的（而且它和 Read-Host Cmdlet的形式相匹配）。 希望您觉得这篇文章有用。 Happy coding!","text":"我热爱 PowerShell，当我需要提示用户输入时，我常常更喜欢使用 GUI 控件，而不是让他们什么都往控制台里输入；有些东西比如说浏览文件或文件夹，或输入多行文本，不是很方便直接往 PowerShell 的命令行窗口中输入。所以我想我可以分享一些我常常用于这些场景的 PowerShell 脚本。 您可以从这儿下载包含以下所有函数的脚本。 显示消息框： # Show message box popup and return the button clicked by the user. Add-Type -AssemblyName System.Windows.Forms function Read-MessageBoxDialog([string]$Message, [string]$WindowTitle, [System.Windows.Forms.MessageBoxButtons]$Buttons = [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]$Icon = [System.Windows.Forms.MessageBoxIcon]::None) { return [System.Windows.Forms.MessageBox]::Show($Message, $WindowTitle, $Buttons, $Icon) } 提示简易的用户输入（单行）： # Show input box popup and return the value entered by the user. function Read-InputBoxDialog([string]$Message, [string]$WindowTitle, [string]$DefaultText) { Add-Type -AssemblyName Microsoft.VisualBasic return [Microsoft.VisualBasic.Interaction]::InputBox($Message, $WindowTitle, $DefaultText) } 提示输入一个文件路径（基于脚本小子的一篇文章）： # Show an Open File Dialog and return the file selected by the user. function Read-OpenFileDialog([string]$WindowTitle, [string]$InitialDirectory, [string]$Filter = &quot;All files (*.*)|*.*&quot;, [switch]$AllowMultiSelect) { Add-Type -AssemblyName System.Windows.Forms $openFileDialog = New-Object System.Windows.Forms.OpenFileDialog $openFileDialog.Title = $WindowTitle if (![string]::IsNullOrWhiteSpace($InitialDirectory)) { $openFileDialog.InitialDirectory = $InitialDirectory } $openFileDialog.Filter = $Filter if ($AllowMultiSelect) { $openFileDialog.MultiSelect = $true } $openFileDialog.ShowHelp = $true # Without this line the ShowDialog() function may hang depending on system configuration and running from console vs. ISE. $openFileDialog.ShowDialog() &gt; $null if ($AllowMultiSelect) { return $openFileDialog.Filenames } else { return $openFileDialog.Filename } } 提示输入一个文件夹（使用 System.Windows.Forms.FolderBrowserDialog 有可能会导致执行时挂起，要看系统配置以及从控制台运行还是从 PowerShell ISE中运行）： # Show an Open Folder Dialog and return the directory selected by the user. function Read-FolderBrowserDialog([string]$Message, [string]$InitialDirectory) { $app = New-Object -ComObject Shell.Application $folder = $app.BrowseForFolder(0, $Message, 0, $InitialDirectory) if ($folder) { return $folder.Self.Path } else { return &apos;&apos; } } 提示用户输入多行文本（基于TechNet 这篇文章中的代码）： function Read-MultiLineInputBoxDialog([string]$Message, [string]$WindowTitle, [string]$DefaultText) { &lt;# .SYNOPSIS Prompts the user with a multi-line input box and returns the text they enter, or null if they cancelled the prompt. .DESCRIPTION Prompts the user with a multi-line input box and returns the text they enter, or null if they cancelled the prompt. .PARAMETER Message The message to display to the user explaining what text we are asking them to enter. .PARAMETER WindowTitle The text to display on the prompt window&apos;s title. .PARAMETER DefaultText The default text to show in the input box. .EXAMPLE $userText = Read-MultiLineInputDialog &quot;Input some text please:&quot; &quot;Get User&apos;s Input&quot; Shows how to create a simple prompt to get mutli-line input from a user. .EXAMPLE # Setup the default multi-line address to fill the input box with. $defaultAddress = @&apos; John Doe 123 St. Some Town, SK, Canada A1B 2C3 &apos;@ $address = Read-MultiLineInputDialog &quot;Please enter your full address, including name, street, city, and postal code:&quot; &quot;Get User&apos;s Address&quot; $defaultAddress if ($address -eq $null) { Write-Error &quot;You pressed the Cancel button on the multi-line input box.&quot; } Prompts the user for their address and stores it in a variable, pre-filling the input box with a default multi-line address. If the user pressed the Cancel button an error is written to the console. .EXAMPLE $inputText = Read-MultiLineInputDialog -Message &quot;If you have a really long message you can break it apart`nover two lines with the powershell newline character:&quot; -WindowTitle &quot;Window Title&quot; -DefaultText &quot;Default text for the input box.&quot; Shows how to break the second parameter (Message) up onto two lines using the powershell newline character (`n). If you break the message up into more than two lines the extra lines will be hidden behind or show ontop of the TextBox. .NOTES Name: Show-MultiLineInputDialog Author: Daniel Schroeder (originally based on the code shown at http://technet.microsoft.com/en-us/library/ff730941.aspx) Version: 1.0 #&gt; Add-Type -AssemblyName System.Drawing Add-Type -AssemblyName System.Windows.Forms # Create the Label. $label = New-Object System.Windows.Forms.Label $label.Location = New-Object System.Drawing.Size(10,10) $label.Size = New-Object System.Drawing.Size(280,20) $label.AutoSize = $true $label.Text = $Message # Create the TextBox used to capture the user&apos;s text. $textBox = New-Object System.Windows.Forms.TextBox $textBox.Location = New-Object System.Drawing.Size(10,40) $textBox.Size = New-Object System.Drawing.Size(575,200) $textBox.AcceptsReturn = $true $textBox.AcceptsTab = $false $textBox.Multiline = $true $textBox.ScrollBars = &apos;Both&apos; $textBox.Text = $DefaultText # Create the OK button. $okButton = New-Object System.Windows.Forms.Button $okButton.Location = New-Object System.Drawing.Size(510,250) $okButton.Size = New-Object System.Drawing.Size(75,25) $okButton.Text = &quot;OK&quot; $okButton.Add_Click({ $form.Tag = $textBox.Text; $form.Close() }) # Create the Cancel button. $cancelButton = New-Object System.Windows.Forms.Button $cancelButton.Location = New-Object System.Drawing.Size(415,250) $cancelButton.Size = New-Object System.Drawing.Size(75,25) $cancelButton.Text = &quot;Cancel&quot; $cancelButton.Add_Click({ $form.Tag = $null; $form.Close() }) # Create the form. $form = New-Object System.Windows.Forms.Form $form.Text = $WindowTitle $form.Size = New-Object System.Drawing.Size(610,320) $form.FormBorderStyle = &apos;FixedSingle&apos; $form.StartPosition = &quot;CenterScreen&quot; $form.AutoSizeMode = &apos;GrowAndShrink&apos; $form.Topmost = $True $form.AcceptButton = $okButton $form.CancelButton = $cancelButton $form.ShowInTaskbar = $true # Add all of the controls to the form. $form.Controls.Add($label) $form.Controls.Add($textBox) $form.Controls.Add($okButton) $form.Controls.Add($cancelButton) # Initialize and show the form. $form.Add_Shown({$form.Activate()}) $form.ShowDialog() &gt; $null # Trash the text of the button that was clicked. # Return the text that the user entered. return $form.Tag } 所有的这些，除了多行输入框以外，都是直接使用了现有的 Windows Form 或 Visual Basic 控件。以下是我的多行输入框显示的模样： 我曾经使用动词 Get 作为函数的前缀，然后改成了动词 Show，但是读完整篇文章以后，我觉得使用动词 Read 也许是最合适的（而且它和 Read-Host Cmdlet的形式相匹配）。 希望您觉得这篇文章有用。 Happy coding! 本文国际来源：Powershell Multi Line Input Box Dialog, Open File Dialog, Folder Browser Dialog, Input Box, and Message Box","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 在 ISE 中重设 PowerShell 宿主","slug":"resetting-powershell-host-in-ise","date":"2013-10-14T16:00:00.000Z","updated":"2017-03-17T15:26:22.249Z","comments":true,"path":"2013/10/15/resetting-powershell-host-in-ise/","link":"","permalink":"http://blog.vichamp.com/2013/10/15/resetting-powershell-host-in-ise/","excerpt":"想象一下您在 ISE 编辑器中长时间地编写一个脚本。当您开发的时候，您也许定义了变量、创建了函数、加载了对象，等等。 要确保您的脚本能像所希望的那样运行，您最终需要一个干净的测试环境。 获得一个干净的 PowerShell 并且移除所有变量和函数的最简单办法如下： 在 ISE 编辑器中，选择 文件 &gt; 新建 PowerShell 选项卡。这实际上将创建一个新的 PowerShell 选项卡，以及一个全新的 PowerShell 宿主。这将确保没有任何不希望存在的旧变量和函数存在。","text":"想象一下您在 ISE 编辑器中长时间地编写一个脚本。当您开发的时候，您也许定义了变量、创建了函数、加载了对象，等等。 要确保您的脚本能像所希望的那样运行，您最终需要一个干净的测试环境。 获得一个干净的 PowerShell 并且移除所有变量和函数的最简单办法如下： 在 ISE 编辑器中，选择 文件 &gt; 新建 PowerShell 选项卡。这实际上将创建一个新的 PowerShell 选项卡，以及一个全新的 PowerShell 宿主。这将确保没有任何不希望存在的旧变量和函数存在。 本文国际来源：Resetting PowerShell Host in ISE","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找 Cmdlet","slug":"finding-cmdlets","date":"2013-10-13T16:00:00.000Z","updated":"2017-03-17T15:26:22.233Z","comments":true,"path":"2013/10/14/finding-cmdlets/","link":"","permalink":"http://blog.vichamp.com/2013/10/14/finding-cmdlets/","excerpt":"Get-Command 可以用来查找 Cmdlet，但是在 PowerShell 3.0 中，它往往会返回比想象中还要多的 Cmdlet。由于自动加载模块的原因，Get-Command 不仅返回当前已加载 Module 中的 Cmdlet，还会返回所有可用 Module 中的 Cmdlet。 如果您仅希望在当前已加载的 Module 中查找一个 Cmdlet，请使用新的 -ListImported 参数： PS&gt; Get-Command -Verb Get | Measure-Object Count : 422 PS&gt; Get-Command -Verb Get -ListImported | Measure-Object Count : 174","text":"Get-Command 可以用来查找 Cmdlet，但是在 PowerShell 3.0 中，它往往会返回比想象中还要多的 Cmdlet。由于自动加载模块的原因，Get-Command 不仅返回当前已加载 Module 中的 Cmdlet，还会返回所有可用 Module 中的 Cmdlet。 如果您仅希望在当前已加载的 Module 中查找一个 Cmdlet，请使用新的 -ListImported 参数： PS&gt; Get-Command -Verb Get | Measure-Object Count : 422 PS&gt; Get-Command -Verb Get -ListImported | Measure-Object Count : 174 本文国际来源：Finding Cmdlets","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 从ISE编辑器中粘贴 PowerShell 代码","slug":"pasting-powershell-code-from-ise-editor","date":"2013-10-10T16:00:00.000Z","updated":"2017-03-17T15:26:22.217Z","comments":true,"path":"2013/10/11/pasting-powershell-code-from-ise-editor/","link":"","permalink":"http://blog.vichamp.com/2013/10/11/pasting-powershell-code-from-ise-editor/","excerpt":"PowerShell ISE 编辑器的代码复制粘贴功能十分强大，例如将代码复制粘贴到 Microsoft Word 和其它文字处理器。由于 ISE 将剪贴板文字格式化为 RTF 格式，颜色代码将不会丢失。 然而，粘贴的时候字体往往太大或太小。 您可以在 ISE 编辑器中更改它。打开工具 &gt; 选项，然后选择一个不同的字号。您在这儿选择的字号将用于粘贴的代码中。 当您更改完字号并关闭对话框之后，试着用 ISE 编辑器窗口右下角的滑块调整字体显示大小。这里的缩放级别只会影响 ISE 编辑器中的代码，并且不会影响粘贴的代码。 您也可以用鼠标滚轮来调整 ISE 编辑器中的显示字体大小。","text":"PowerShell ISE 编辑器的代码复制粘贴功能十分强大，例如将代码复制粘贴到 Microsoft Word 和其它文字处理器。由于 ISE 将剪贴板文字格式化为 RTF 格式，颜色代码将不会丢失。 然而，粘贴的时候字体往往太大或太小。 您可以在 ISE 编辑器中更改它。打开工具 &gt; 选项，然后选择一个不同的字号。您在这儿选择的字号将用于粘贴的代码中。 当您更改完字号并关闭对话框之后，试着用 ISE 编辑器窗口右下角的滑块调整字体显示大小。这里的缩放级别只会影响 ISE 编辑器中的代码，并且不会影响粘贴的代码。 您也可以用鼠标滚轮来调整 ISE 编辑器中的显示字体大小。 本文国际来源：Pasting PowerShell Code from ISE Editor","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建日历（和日期列表）","slug":"creating-calendars-and-lists-of-dates","date":"2013-10-09T16:00:00.000Z","updated":"2017-03-17T15:26:22.217Z","comments":true,"path":"2013/10/10/creating-calendars-and-lists-of-dates/","link":"","permalink":"http://blog.vichamp.com/2013/10/10/creating-calendars-and-lists-of-dates/","excerpt":"以下是一段创建 DateTime 集合的脚本片段。只需要指定年和月，脚本将会针对该月的每一天创建一个 DateTime 对象： $month = 8 $year = 2013 1..[DateTime]::DaysInMonth($year,$month) | ForEach-Object { Get-Date -Day $_ -Month $month -Year $year } 这段代码十分有用：只要加一个日期过滤器，您就可以过滤出工作日来。它将列出指定月份的所有周一至周五（因为它排除了 weekday 0（星期日）和 weekday 6（星期六））： $month = 8 $year = 2013 1..[DateTime]::DaysInMonth($year,$month) | ForEach-Object { Get-Date -Day $_ -Month $month -Year $year } | Where-Object { 0,6 -notcontains $_.DayOfWeek } 类似地，以下代码将统计指定月份所有星期三和星期五的天数： $month = 8 $year = 2013 $days = 1..[DateTime]::DaysInMonth($year,$month) | ForEach-Object { Get-Date -Day $_ -Month $month -Year $year } | Where-Object { 3,5 -contains $_.DayOfWeek } $days &quot;There are {0} Wednesdays and Fridays&quot; -f $days.Count","text":"以下是一段创建 DateTime 集合的脚本片段。只需要指定年和月，脚本将会针对该月的每一天创建一个 DateTime 对象： $month = 8 $year = 2013 1..[DateTime]::DaysInMonth($year,$month) | ForEach-Object { Get-Date -Day $_ -Month $month -Year $year } 这段代码十分有用：只要加一个日期过滤器，您就可以过滤出工作日来。它将列出指定月份的所有周一至周五（因为它排除了 weekday 0（星期日）和 weekday 6（星期六））： $month = 8 $year = 2013 1..[DateTime]::DaysInMonth($year,$month) | ForEach-Object { Get-Date -Day $_ -Month $month -Year $year } | Where-Object { 0,6 -notcontains $_.DayOfWeek } 类似地，以下代码将统计指定月份所有星期三和星期五的天数： $month = 8 $year = 2013 $days = 1..[DateTime]::DaysInMonth($year,$month) | ForEach-Object { Get-Date -Day $_ -Month $month -Year $year } | Where-Object { 3,5 -contains $_.DayOfWeek } $days &quot;There are {0} Wednesdays and Fridays&quot; -f $days.Count 本文国际来源：Creating Calendars (and Lists of Dates)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 发生了什么？","slug":"what-is-going-on-here","date":"2013-10-08T16:00:00.000Z","updated":"2017-03-17T15:26:22.217Z","comments":true,"path":"2013/10/09/what-is-going-on-here/","link":"","permalink":"http://blog.vichamp.com/2013/10/09/what-is-going-on-here/","excerpt":"经常地，您需要用 PowerShell 来获取数据，并且您需要提取信息的一部分并且把它们用于报表。类似如下： $serial = Get-WmiObject -Class Win32_OperatingSystem | Select-Object -Property SerialNumber &quot;Serial Number is $serial&quot; 但是上述代码产生的结果如下： Serial Number is @{SerialNumber=00261-30000-00000-AA825} 当您查看 $serial 的值，它看起来似乎很正常： PS&gt; $serial SerialNumber ------------ 00261-30000-00000-AA825 但问题出在列头（译者注：我们只需要 SerialNumber 的值，而不是需要一个包含 SerialNumber 属性的临时对象）。您可以用 Select-Object 只选出一列，用 -ExpandProperty 而不是 -Property 就可以消除列头： $serial = Get-WmiObject -Class Win32_OperatingSystem | Select-Object -ExpandProperty SerialNumber &quot;Serial Number is $serial&quot; 现在，一切正常了： Serial Number is 00261-30000-00000-AA825","text":"经常地，您需要用 PowerShell 来获取数据，并且您需要提取信息的一部分并且把它们用于报表。类似如下： $serial = Get-WmiObject -Class Win32_OperatingSystem | Select-Object -Property SerialNumber &quot;Serial Number is $serial&quot; 但是上述代码产生的结果如下： Serial Number is @{SerialNumber=00261-30000-00000-AA825} 当您查看 $serial 的值，它看起来似乎很正常： PS&gt; $serial SerialNumber ------------ 00261-30000-00000-AA825 但问题出在列头（译者注：我们只需要 SerialNumber 的值，而不是需要一个包含 SerialNumber 属性的临时对象）。您可以用 Select-Object 只选出一列，用 -ExpandProperty 而不是 -Property 就可以消除列头： $serial = Get-WmiObject -Class Win32_OperatingSystem | Select-Object -ExpandProperty SerialNumber &quot;Serial Number is $serial&quot; 现在，一切正常了： Serial Number is 00261-30000-00000-AA825 本文国际来源：What Is Going On Here?","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 密码混淆器脚本","slug":"password-obfuscator-script","date":"2013-10-07T16:00:00.000Z","updated":"2017-03-17T15:26:22.202Z","comments":true,"path":"2013/10/08/password-obfuscator-script/","link":"","permalink":"http://blog.vichamp.com/2013/10/08/password-obfuscator-script/","excerpt":"曾经需要将密码保存在脚本中？曾经需要自动弹出一个身份验证对话框？对于前者，将密码和其它身份信息存储在脚本中是很糟糕的；对于后者，如果您这么做了的话，至少能使黑客更难于窃取信息。 以下是一个脚本生成器。运行它，并且输入一个域/用户名和密码，脚本生成器会为您生成一段新脚本。 $pwd = Read-Host &apos;Enter Password&apos; $user = Read-Host &apos;Enter Username&apos; $key = 1..32 | ForEach-Object { Get-Random -Maximum 256 } $pwdencrypted = $pwd | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString -Key $key $text = @() $text += &apos;$password = &quot;{0}&quot;&apos; -f ($pwdencrypted -join &apos; &apos;) $text += &apos;$key = &quot;{0}&quot;&apos; -f ($key -join &apos; &apos;) $text += &apos;$passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(&quot; &quot;))&apos; $text += &apos;$cred = New-Object system.Management.Automation.PSCredential(&quot;{0}&quot;, $passwordSecure)&apos; -f $user $text += &apos;$cred&apos; $newFile = $psise.CurrentPowerShellTab.Files.Add() $newFile.Editor.Text = $text | Out-String 这段脚本包含混淆过的密码脚本，看起来大概类似这样： $password = &quot;76492d1116743f0423413b16050a5345MgB8AFcAMABGAEIANAB1AGEAdQA3ADUASABhAE0AMgBNADUAUwBnAFYAYQA1AEEAPQA9AHwAMgAyAGIAZgA1ADUAZgA0ADIANAA0ADUANwA2ADAAMgA5ADkAZAAxAGUANwA4ADUAZQA4ADkAZAA1AGMAMAA2AA==&quot; $key = &quot;246 185 95 207 87 105 146 74 99 163 58 194 93 229 80 241 160 35 68 220 130 193 84 113 122 155 208 49 152 86 85 178&quot; $passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(&quot; &quot;)) $cred = New-Object system.Management.Automation.PSCredential(&quot;test\\tobias&quot;, $passwordSecure) $cred 当您运行它，它将生成一个 Credential 对象，您可以立即将它用于身份验证。只要将它传给一个需要 Credential 对象的形参即可。 再强调一下，这并不是安全的。但是要想获取密码的明文还需要更多点知识才行。","text":"曾经需要将密码保存在脚本中？曾经需要自动弹出一个身份验证对话框？对于前者，将密码和其它身份信息存储在脚本中是很糟糕的；对于后者，如果您这么做了的话，至少能使黑客更难于窃取信息。 以下是一个脚本生成器。运行它，并且输入一个域/用户名和密码，脚本生成器会为您生成一段新脚本。 $pwd = Read-Host &apos;Enter Password&apos; $user = Read-Host &apos;Enter Username&apos; $key = 1..32 | ForEach-Object { Get-Random -Maximum 256 } $pwdencrypted = $pwd | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString -Key $key $text = @() $text += &apos;$password = &quot;{0}&quot;&apos; -f ($pwdencrypted -join &apos; &apos;) $text += &apos;$key = &quot;{0}&quot;&apos; -f ($key -join &apos; &apos;) $text += &apos;$passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(&quot; &quot;))&apos; $text += &apos;$cred = New-Object system.Management.Automation.PSCredential(&quot;{0}&quot;, $passwordSecure)&apos; -f $user $text += &apos;$cred&apos; $newFile = $psise.CurrentPowerShellTab.Files.Add() $newFile.Editor.Text = $text | Out-String 这段脚本包含混淆过的密码脚本，看起来大概类似这样： $password = &quot;76492d1116743f0423413b16050a5345MgB8AFcAMABGAEIANAB1AGEAdQA3ADUASABhAE0AMgBNADUAUwBnAFYAYQA1AEEAPQA9AHwAMgAyAGIAZgA1ADUAZgA0ADIANAA0ADUANwA2ADAAMgA5ADkAZAAxAGUANwA4ADUAZQA4ADkAZAA1AGMAMAA2AA==&quot; $key = &quot;246 185 95 207 87 105 146 74 99 163 58 194 93 229 80 241 160 35 68 220 130 193 84 113 122 155 208 49 152 86 85 178&quot; $passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(&quot; &quot;)) $cred = New-Object system.Management.Automation.PSCredential(&quot;test\\tobias&quot;, $passwordSecure) $cred 当您运行它，它将生成一个 Credential 对象，您可以立即将它用于身份验证。只要将它传给一个需要 Credential 对象的形参即可。 再强调一下，这并不是安全的。但是要想获取密码的明文还需要更多点知识才行。 本文国际来源：Password Obfuscator Script","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"快速替换文本文件中的字符串","slug":"quickly-replace-strings-in-text-files","date":"2013-10-07T16:00:00.000Z","updated":"2017-03-17T15:26:22.217Z","comments":true,"path":"2013/10/08/quickly-replace-strings-in-text-files/","link":"","permalink":"http://blog.vichamp.com/2013/10/08/quickly-replace-strings-in-text-files/","excerpt":"","text":"不用开什么vim、emac、UltraEdit、Eclipse之类的编辑器了，PowerShell可以帮助手无寸铁的您快速地替换文本文件中的字符串： dir *.txt -Recurse | % { (gc $_ -Raw) | % { $_ ` -creplace &apos;111&apos;, &apos;AAA&apos; ` -creplace &apos;222&apos;, &apos;BBB&apos; ` -creplace &apos;333&apos;, &apos;CCC&apos; } | sc $_ } 注意 -creplace 区分大小写，-replace 不区分大小写。并且它们支持正则表达式！","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"在PowerShell中以管理员身份运行程序","slug":"invoke-admin-in-powershell","date":"2013-10-04T16:00:00.000Z","updated":"2017-03-17T15:26:22.202Z","comments":true,"path":"2013/10/05/invoke-admin-in-powershell/","link":"","permalink":"http://blog.vichamp.com/2013/10/05/invoke-admin-in-powershell/","excerpt":"","text":"对于已知的需要以管理员身份运行的命令，我们可以通过这个 Invoke-Admin 函数运行。这个函数确保以管理员身份运行一个程序。如果不是以管理员身份运行，则将弹出 UAC 对话框。 function Invoke-Admin() { param ( [string]$program = $(throw &quot;Please specify a program&quot; ), [string]$argumentString = &quot;&quot;, [switch]$waitForExit ) $psi = new-object &quot;Diagnostics.ProcessStartInfo&quot; $psi.FileName = $program $psi.Arguments = $argumentString $psi.Verb = &quot;runas&quot; $proc = [Diagnostics.Process]::Start($psi) if ( $waitForExit ) { $proc.WaitForExit(); } } 来源：Showing the UAC prompt in PowerShell if the action requires elevation","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"uac","slug":"uac","permalink":"http://blog.vichamp.com/tags/uac/"},{"name":"cmdlet","slug":"cmdlet","permalink":"http://blog.vichamp.com/tags/cmdlet/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 检查磁盘分区和数据块大小","slug":"checking-disk-partitions-and-block-size","date":"2013-10-03T16:00:00.000Z","updated":"2017-03-17T15:26:22.202Z","comments":true,"path":"2013/10/04/checking-disk-partitions-and-block-size/","link":"","permalink":"http://blog.vichamp.com/2013/10/04/checking-disk-partitions-and-block-size/","excerpt":"WMI 是一个装满信息的宝库。以下这行代码将读取本地分区以及它们的数据块大小信息： Get-WmiObject -Class Win32_Diskpartition | Select-Object -Property __Server, Caption, BlockSize 使用 Get-WmiObject 的 -ComputerName 参数可以对一台或多台机器远程执行同样的操作。 要查看其它所有的 WMI 类，您可以替换掉 Win32_DiskPartition，试试以下的代码： Get-WmiObject -Class Win32_* -List | Where-Object { ($_.Qualifiers | Select-Object -ExpandProperty Name) -notcontains &apos;Association&apos; } | Where-Object { $_.Name -notlike &apos;*_Perf*&apos; }","text":"WMI 是一个装满信息的宝库。以下这行代码将读取本地分区以及它们的数据块大小信息： Get-WmiObject -Class Win32_Diskpartition | Select-Object -Property __Server, Caption, BlockSize 使用 Get-WmiObject 的 -ComputerName 参数可以对一台或多台机器远程执行同样的操作。 要查看其它所有的 WMI 类，您可以替换掉 Win32_DiskPartition，试试以下的代码： Get-WmiObject -Class Win32_* -List | Where-Object { ($_.Qualifiers | Select-Object -ExpandProperty Name) -notcontains &apos;Association&apos; } | Where-Object { $_.Name -notlike &apos;*_Perf*&apos; } 本文国际来源：Checking Disk Partitions and Block Size","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 将Excel导出的CSV转换为UTF-8编码","slug":"converting-excel-csv-to-utf8","date":"2013-10-02T16:00:00.000Z","updated":"2017-03-17T15:26:22.186Z","comments":true,"path":"2013/10/03/converting-excel-csv-to-utf8/","link":"","permalink":"http://blog.vichamp.com/2013/10/03/converting-excel-csv-to-utf8/","excerpt":"当您导出 Microsoft Excel 数据表到 CSV 文件时，Excel缺省将保存为 ANSI 编码的 CSV 文件。这是很糟糕的，因为当您用 Import-Csv 导入数据到 PowerShell 中时，特殊字符将会截断（译者注：例如中文出现乱码）。 要确保特殊字符不会丢失，您必须确保导入数据之前 CSV 文件采用的是 UTF-8 编码： $Path = &apos;c:\\temp\\somedata.csv&apos; (Get-Content -Path $Path) | Set-Content -Path $Path -Encoding UTF8","text":"当您导出 Microsoft Excel 数据表到 CSV 文件时，Excel缺省将保存为 ANSI 编码的 CSV 文件。这是很糟糕的，因为当您用 Import-Csv 导入数据到 PowerShell 中时，特殊字符将会截断（译者注：例如中文出现乱码）。 要确保特殊字符不会丢失，您必须确保导入数据之前 CSV 文件采用的是 UTF-8 编码： $Path = &apos;c:\\temp\\somedata.csv&apos; (Get-Content -Path $Path) | Set-Content -Path $Path -Encoding UTF8 本文国际来源：Converting Excel CSV to UTF8","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找所有用户脚本","slug":"finding-all-powershell-profile-scripts","date":"2013-10-01T16:00:00.000Z","updated":"2017-03-17T15:26:22.186Z","comments":true,"path":"2013/10/02/finding-all-powershell-profile-scripts/","link":"","permalink":"http://blog.vichamp.com/2013/10/02/finding-all-powershell-profile-scripts/","excerpt":"有些时候我们会疑惑当 PowerShell 启动的时候，将执行哪些启动脚本。它们数量很多，而且各不相同，要看您运行的是 PowerShell 控制台，ISE，还是其他宿主。 然而，了解您的用户脚本是十分重要的。它们决定了应用到 PowerShell 环境的配置。 这个 Get-PSProfileStatus 函数列出了所有宿主（PowerShell 环境）可能用到的的启动脚本。它也显示了哪些脚本是物理存在的。 function Get-PSProfileStatus { $profile | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name | ForEach-Object { $_, (Split-Path $profile.$_ -Leaf), (Split-Path $profile.$_), (Test-Path -Path $profile.$_) -join &apos;,&apos; | ConvertFrom-Csv -Header Profile, FileName, FolderName, Present } } Get-PSProfileStatus 结果看起来类似这样： 将结果用管道输出到 Out-GridView 来查看，避免截断字符被截断： Get-PSProfileStatus | Out-GridView","text":"有些时候我们会疑惑当 PowerShell 启动的时候，将执行哪些启动脚本。它们数量很多，而且各不相同，要看您运行的是 PowerShell 控制台，ISE，还是其他宿主。 然而，了解您的用户脚本是十分重要的。它们决定了应用到 PowerShell 环境的配置。 这个 Get-PSProfileStatus 函数列出了所有宿主（PowerShell 环境）可能用到的的启动脚本。它也显示了哪些脚本是物理存在的。 function Get-PSProfileStatus { $profile | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name | ForEach-Object { $_, (Split-Path $profile.$_ -Leaf), (Split-Path $profile.$_), (Test-Path -Path $profile.$_) -join &apos;,&apos; | ConvertFrom-Csv -Header Profile, FileName, FolderName, Present } } Get-PSProfileStatus 结果看起来类似这样： 将结果用管道输出到 Out-GridView 来查看，避免截断字符被截断： Get-PSProfileStatus | Out-GridView 本文国际来源：Finding All PowerShell Profile Scripts","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通过CSV创建对象","slug":"creating-objects-with-csv","date":"2013-09-30T16:00:00.000Z","updated":"2017-03-17T15:26:22.186Z","comments":true,"path":"2013/10/01/creating-objects-with-csv/","link":"","permalink":"http://blog.vichamp.com/2013/10/01/creating-objects-with-csv/","excerpt":"有多种方法可以创建自定义对象。以下是一种创新的办法，在很多种场景中都很有效：创建一个逗号分隔，每行表示一个值的列表文本，然后用 ConvertFrom-Csv 来创建对象： for($x=0; $x -lt 20; $x++) { ($x,(Get-Random),(Get-Date) -join &apos;,&apos;) | ConvertFrom-Csv -Header ID, RandomNumber, Date } 不过，这种做法效率并不是很高。还有三种其它方法可以用来创建对象。分别用 Measure-Command 测量创建 2000 个对象所消耗的时间： Measure-Command { for($x=0; $x -lt 2000; $x++) { ($x,(Get-Random),(Get-Date) -join &apos;,&apos;) | ConvertFrom-Csv -Header ID, RandomNumber, Date } } Measure-Command { for($x=0; $x -lt 2000; $x++) { $obj = 1 | Select-Object -Property ID, RandomNumber, Date $obj.ID = $x $obj.RandomNumber = Get-Random $obj.Date = Get-Date $obj } } Measure-Command { for($x=0; $x -lt 2000; $x++) { [PSObject]@{ ID = $x RandomNumber = Get-Random Date = Get-Date } } } Measure-Command { for($x=0; $x -lt 2000; $x++) { [Ordered]@{ ID = $x RandomNumber = Get-Random Date = Get-Date } } } 如结果所示，最后两种方法的效率是 CSV 方法的大约三倍。在我们的测试系统上，所有的测试都在一秒之内完成，所以现实环境中影响并不大。 请挑选一个您自己最喜欢的方式——不过请注意最后一个例子需要 PowerShell 3.0 或更高的版本。","text":"有多种方法可以创建自定义对象。以下是一种创新的办法，在很多种场景中都很有效：创建一个逗号分隔，每行表示一个值的列表文本，然后用 ConvertFrom-Csv 来创建对象： for($x=0; $x -lt 20; $x++) { ($x,(Get-Random),(Get-Date) -join &apos;,&apos;) | ConvertFrom-Csv -Header ID, RandomNumber, Date } 不过，这种做法效率并不是很高。还有三种其它方法可以用来创建对象。分别用 Measure-Command 测量创建 2000 个对象所消耗的时间： Measure-Command { for($x=0; $x -lt 2000; $x++) { ($x,(Get-Random),(Get-Date) -join &apos;,&apos;) | ConvertFrom-Csv -Header ID, RandomNumber, Date } } Measure-Command { for($x=0; $x -lt 2000; $x++) { $obj = 1 | Select-Object -Property ID, RandomNumber, Date $obj.ID = $x $obj.RandomNumber = Get-Random $obj.Date = Get-Date $obj } } Measure-Command { for($x=0; $x -lt 2000; $x++) { [PSObject]@{ ID = $x RandomNumber = Get-Random Date = Get-Date } } } Measure-Command { for($x=0; $x -lt 2000; $x++) { [Ordered]@{ ID = $x RandomNumber = Get-Random Date = Get-Date } } } 如结果所示，最后两种方法的效率是 CSV 方法的大约三倍。在我们的测试系统上，所有的测试都在一秒之内完成，所以现实环境中影响并不大。 请挑选一个您自己最喜欢的方式——不过请注意最后一个例子需要 PowerShell 3.0 或更高的版本。 本文国际来源：Creating Objects with CSV","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通过关键词查找脚本","slug":"finding-scripts-by-keyword","date":"2013-09-29T16:00:00.000Z","updated":"2017-03-17T15:26:22.170Z","comments":true,"path":"2013/09/30/finding-scripts-by-keyword/","link":"","permalink":"http://blog.vichamp.com/2013/09/30/finding-scripts-by-keyword/","excerpt":"随着您硬盘上的 PowerShell 脚本数量的增多，要想找到您想要的脚本会变得越来越困难。以下是一个叫做 Find-Script 的工具函数。只要传入一个关键词，PowerShell 将会在您的个人文件夹下找出所有包含该关键词的脚本。 查找的结果将在一个 GridView 窗口中显示，您可以选中其中的文件，按下确认按钮以后将用 ISE 编辑器打开这些文件。 function Find-Script { param ( [Parameter(Mandatory=$true)] $Keyword, $Maximum = 20, $StartPath = $env:USERPROFILE ) Get-ChildItem -Path $StartPath -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue | Select-String -SimpleMatch -Pattern $Keyword -List | Select-Object -Property FileName, Path, Line -First $Maximum | Out-GridView -Title &apos;Select Script File&apos; -PassThru | ForEach-Object { ise $_.Path } } 默认情况下，Find-Script 只返回满足搜索条件的前 20 个脚本。您可以通过 -Maximum 和 -StartPath 参数来改变最大搜索条数和搜索位置。","text":"随着您硬盘上的 PowerShell 脚本数量的增多，要想找到您想要的脚本会变得越来越困难。以下是一个叫做 Find-Script 的工具函数。只要传入一个关键词，PowerShell 将会在您的个人文件夹下找出所有包含该关键词的脚本。 查找的结果将在一个 GridView 窗口中显示，您可以选中其中的文件，按下确认按钮以后将用 ISE 编辑器打开这些文件。 function Find-Script { param ( [Parameter(Mandatory=$true)] $Keyword, $Maximum = 20, $StartPath = $env:USERPROFILE ) Get-ChildItem -Path $StartPath -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue | Select-String -SimpleMatch -Pattern $Keyword -List | Select-Object -Property FileName, Path, Line -First $Maximum | Out-GridView -Title &apos;Select Script File&apos; -PassThru | ForEach-Object { ise $_.Path } } 默认情况下，Find-Script 只返回满足搜索条件的前 20 个脚本。您可以通过 -Maximum 和 -StartPath 参数来改变最大搜索条数和搜索位置。 本文国际来源：Finding Scripts by Keyword","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"在PowerShell中操作Word - 使用格式化样式","slug":"integrating-microsoft-word-with-powershell-format-style-documents","date":"2013-09-28T16:00:00.000Z","updated":"2017-03-17T15:26:22.117Z","comments":true,"path":"2013/09/29/integrating-microsoft-word-with-powershell-format-style-documents/","link":"","permalink":"http://blog.vichamp.com/2013/09/29/integrating-microsoft-word-with-powershell-format-style-documents/","excerpt":"在这个系列的上一步中，我们演示了用Windows PowerShell创建Microsoft Word文档的基本步骤。如果您试用了我的示例脚本，您会注意到文档格式化方面略有不足。幸运的是，我们有一些简洁的办法来改进您文档的质量，我将会在这篇文章中向您演示这个过程。我们将用第一部分的脚本作为起点。","text":"在这个系列的上一步中，我们演示了用Windows PowerShell创建Microsoft Word文档的基本步骤。如果您试用了我的示例脚本，您会注意到文档格式化方面略有不足。幸运的是，我们有一些简洁的办法来改进您文档的质量，我将会在这篇文章中向您演示这个过程。我们将用第一部分的脚本作为起点。 关键之处在于 Selection 对象。 PS C:\\&gt;$word=new-object -ComObject &quot;Word.Application&quot; PS C:\\&gt;$doc=$word.documents.Add() PS C:\\&gt; $selection=$word.Selection 您可以更改 Selection 对象的一个重要元素是 Font。您可以轻松地修改字体大小和颜色，以及使用哪种字体。我将把日期和时间的字体改为绿色。 PS C:\\&gt; $selection.Font.Color=&quot;wdColorGreen&quot; PS C:\\&gt; $selection.TypeText((Get-Date)) 在VBScript的年代中，我们需要定义 wdColorGreen 的值并将它赋给一个常量。但是在PowerShell中我们可以轻松地以字符串的形式插入这个常量。您一定很好奇有哪些颜色可以使用？问问PowerShell吧： PS C:\\&gt; [enum]::GetNames([microsoft.office.interop.word.wdcolor]) 您需要把字体颜色改回来，除非您需要把整个文档设为这个颜色。 PS C:\\ &gt;$selection.font.Color=&quot;wdColorAutomatic&quot; PS C:\\&gt; $selection.TypeParagraph() 在我原先的脚本中我插入了一个标题。现在我们把它变成大一点的字体。我将用我上次使用的WMI代码。 $selection.Font.Size=12 $selection.TypeText(&quot;Operating System Information for $($os.CSName)&quot;) 回顾一下前面一篇文章，有一个问题是PowerShell输出到Word早期是用等宽字体而后来用的是非等宽字体。解决方法是从PowerShell中插入结果之前指定一个合适的字体。 PS C:\\&gt; $selection.Font.Size=10 PS C:\\&gt; $selection.Font.Name=&quot;Consolas&quot; PS C:\\&gt; $selection.TypeText(($os | Select -Property $props | Out-String)) 还要做的最后一件事是添加一段格式化的文本，说明报告的创建者。我希望采用Word的斜体格式来呈现。 PS C:\\&gt; $selection.Font.size=8 PS C:\\&gt; $selection.Font.Name=&quot;Calibri&quot; PS C:\\&gt; $selection.Font.Italic=$True PS C:\\&gt; $by=&quot;Report created by $env:userdomain\\$env:username&quot; PS C:\\&gt; $selection.TypeText($by) 我相信您一定也掌握了如何使文本变成粗体。 除了指定字体之外，您还可以采用Word内置的样式。 $selection.Style=&quot;Title&quot; $selection.TypeText(&quot;Operating System Report&quot;) $selection.TypeParagraph() 您可以用PowerShell查询 Document 对象，看看有哪些样式可以用。 $doc.Styles | select NameLocal 大多数这些样式只能应用在文本的第一行，不过您也可以自己做实验调整一下。 通过这些步骤您可以简洁地通过您的PowerShell脚本创建一个漂亮的Word文档。请下载版本修订过的脚本，New-WordDoc2，并且自己做一下实验。 用PowerShell操作Office系列文章 在PowerShell中操作Word - 生成文档 在PowerShell中操作Word - 使用格式化样式 在PowerShell中操作Excel - 创建一个简单的报表 在PowerShell中操作Excel - 创建一个富Excel文档 在PowerShell中操作Excel - 读取数据","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"office","slug":"powershell/office","permalink":"http://blog.vichamp.com/categories/powershell/office/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"office","slug":"powershell/office","permalink":"http://blog.vichamp.com/categories/powershell/office/"}]},{"title":"Visual Studio的PowerShell扩展工具","slug":"powershell-tools-for-visual-studio","date":"2013-09-27T16:00:00.000Z","updated":"2017-03-17T15:26:22.117Z","comments":true,"path":"2013/09/28/powershell-tools-for-visual-studio/","link":"","permalink":"http://blog.vichamp.com/2013/09/28/powershell-tools-for-visual-studio/","excerpt":"","text":"Visual Studio的PowerShell扩展工具为Visual Studio 2012和2013 RC增加了PowerShell语言支持。 本工具目前为BETA版。 下载地址：Visual Studio工具库开源项目：GitHub 必须条件： Visual Studio 2012或2013 RC PowerShell 3.0 Windows 8和Server 2012已自带 Windows 8或Server 2012以下的系统需要Windows Management Framework 3.0 编辑器扩展语法高亮、智能感知和代码折叠 方法导航 调试器扩展脚本输出 断点支持 本地变量支持 调用堆栈支持 工程系统支持","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"visualstudio","slug":"visualstudio","permalink":"http://blog.vichamp.com/tags/visualstudio/"},{"name":"develop","slug":"develop","permalink":"http://blog.vichamp.com/tags/develop/"},{"name":"tool","slug":"tool","permalink":"http://blog.vichamp.com/tags/tool/"},{"name":"ide","slug":"ide","permalink":"http://blog.vichamp.com/tags/ide/"},{"name":"extension","slug":"extension","permalink":"http://blog.vichamp.com/tags/extension/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"在PowerShell中操作Word - 生成文档","slug":"integrating-microsoft-word-with-powershell-generate-a-document","date":"2013-09-27T16:00:00.000Z","updated":"2017-03-17T15:26:22.101Z","comments":true,"path":"2013/09/28/integrating-microsoft-word-with-powershell-generate-a-document/","link":"","permalink":"http://blog.vichamp.com/2013/09/28/integrating-microsoft-word-with-powershell-generate-a-document/","excerpt":"我假设许多读者用PowerShell生成服务器、事件以及Windows网络上各种数据的报表。您也许创建过纯文本文件，甚至漂亮的HTML报表。但是您也可以用上Microsoft Word，当然，前提是您已经安装了Word。在这个系列的第二部分，我将会向您演示如何用PowerShell为Word文档套用样式。 创建Word应用程序对象PowerShell可以通过COM接口控制Word应用程序。有趣的地方是，虽然您可以交互式地做所有的操作，但我希望您最终能够用脚本操作一切。我们从创建一个Word程序对象开始。 PS C:\\&gt; $word=new-object -ComObject &quot;Word.Application&quot;","text":"我假设许多读者用PowerShell生成服务器、事件以及Windows网络上各种数据的报表。您也许创建过纯文本文件，甚至漂亮的HTML报表。但是您也可以用上Microsoft Word，当然，前提是您已经安装了Word。在这个系列的第二部分，我将会向您演示如何用PowerShell为Word文档套用样式。 创建Word应用程序对象PowerShell可以通过COM接口控制Word应用程序。有趣的地方是，虽然您可以交互式地做所有的操作，但我希望您最终能够用脚本操作一切。我们从创建一个Word程序对象开始。 PS C:\\&gt; $word=new-object -ComObject &quot;Word.Application&quot; 如果您好奇的话，可以将这个对象输出到 Get-Member 命令。我们将创建一系列对象，您可以将每一个对象通过管道输出到 Get-Member 来探索它们。 下一步，我们创建一个文档对象。 PS C:\\&gt; $doc=$word.documents.Add() 现在，Word程序已经启动，并且创建了一个新文档，但是您在屏幕上看不到任何东西。通常这是正常的，因为我们需要它在后台运行。但是如果您想查看所创建的文档，您需要将应用程序的 Visible 属性设置为 True。 PS C:\\&gt; $word.Visible=$True 在我们插入文本之前，我们需要获取焦点。创建一个 Selection 对象可以帮我们做一些诸如设置字体大小和颜色等操作，我们将在第二部分介绍这些操作。 PS C:\\&gt; $selection=$word.Selection 用PowerShell在文档中插入文本现在光标在文档的顶部，现在可以开始插入文本了。我们将用 Selection 对象的 TypeText() 方法插入当前的日期和时间。 PS C:\\&gt; $selection.TypeText((Get-Date)) 如果我们继续插入文本，那么文本将会紧挨在日期的后面。现在我们用 TypeParagraph() 方法插入一个回车符。 PS C:\\&gt; $selection.TypeParagraph() 让我们继续插入一些文本。我将用WMI获取本地计算机的操作系统信息。 PS C:\\&gt; $os=Get-WmiObject -class win32_OperatingSystem PS C:\\&gt; $selection.TypeText(&quot;Operating System Information for $($os.CSName)&quot;) 由于我希望写入所有的非系统属性，所以我将快速递创建一个数组用来保存所有的属性名。 PS C:\\&gt; $os.properties | select Name | foreach -begin {$props=@()} -proc {$props+=&quot;$($_.name)&quot;} 现在我可以从 $os 获取所有的属性并插入Word文档。很重要的一点是 TypeText() 的值是字符串型的，所以我需要将内联的PowerShell表达式通过管道输出到 Out-String。 PS C:\\&gt; $selection.TypeText(($os | Select -Property $props | Out-String)) 如果需要的话，还可以继续插入文字和图片。当完成操作以后，我将保存并关闭文档。 PS C:\\&gt; $doc.SaveAs([ref]&quot;c:\\work\\osreport.docx&quot;) PS C:\\&gt; $doc.Close() 请确认使用 [ref] 为文件路径转换数据类型。假设我不再创建新的文档，那么剩下的就是关闭Word应用程序。 PS C:\\&gt; $word.quit() 这些就是要做的所有事情。最终生成的Word文档是可用的，虽然可能不太漂亮。在我的例子中发现一个问题：Word用的事非等宽字体，而PowerShell的输出格式假设用的是等宽字体。（译者注：可能会造成输出的结果对不整齐）。在第二部分，我将向您演示如何解决这些问题。同时，欢迎下载示例脚本 New-WordDoc.ps1。 用PowerShell操作Office系列文章 在PowerShell中操作Word - 生成文档 在PowerShell中操作Word - 使用格式化样式 在PowerShell中操作Excel - 创建一个简单的报表 在PowerShell中操作Excel - 创建一个富Excel文档 在PowerShell中操作Excel - 读取数据","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"office","slug":"powershell/office","permalink":"http://blog.vichamp.com/categories/powershell/office/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"office","slug":"powershell/office","permalink":"http://blog.vichamp.com/categories/powershell/office/"}]},{"title":"PowerShell 技能连载 - 设置显示器亮度","slug":"setting-monitor-brightness","date":"2013-09-26T16:00:00.000Z","updated":"2017-03-17T15:26:22.101Z","comments":true,"path":"2013/09/27/setting-monitor-brightness/","link":"","permalink":"http://blog.vichamp.com/2013/09/27/setting-monitor-brightness/","excerpt":"如果您的显示驱动程序支持WMI，那么您可以用PowerShell改变显示器的亮度——甚至是远程的计算机！ 以下是实现改变显示器亮度的函数： function Set-MonitorBrightness { param ( [Parameter(Mandatory=$true)] [Int][ValidateRange(0,100)] $Value, $ComputerName, $Credential ) $null = $PSBoundParameters.Remove(&apos;Value&apos;) $helper = Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightnessMethods @PSBoundParameters $helper.WmiSetBrightness(1, $Value) } 只需要指定一个0-100之间的值，您就可以看到显示器亮度发生改变。为 -ComputerName 参数指定远程计算机名或IP地址（均支持多个），然后您远程的同事们会惊讶地发现去吃午餐的时候显示器都变暗了！当然，远程操作WMI需要本地管理员权限，并且为防火墙设置了允许远程管理的规则。 如果提示“不支持”的错误提示信息，那么说明您的显示驱动程序不支持WMI。 这是“有趣”的部分：模拟一个古怪的显示效果： for($x=0; $x -lt 20; $x++) { Set-MonitorBrightness -Value (Get-Random -Minimum 20 -Maximum 101) Start-Sleep -Seconds 1 }","text":"如果您的显示驱动程序支持WMI，那么您可以用PowerShell改变显示器的亮度——甚至是远程的计算机！ 以下是实现改变显示器亮度的函数： function Set-MonitorBrightness { param ( [Parameter(Mandatory=$true)] [Int][ValidateRange(0,100)] $Value, $ComputerName, $Credential ) $null = $PSBoundParameters.Remove(&apos;Value&apos;) $helper = Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightnessMethods @PSBoundParameters $helper.WmiSetBrightness(1, $Value) } 只需要指定一个0-100之间的值，您就可以看到显示器亮度发生改变。为 -ComputerName 参数指定远程计算机名或IP地址（均支持多个），然后您远程的同事们会惊讶地发现去吃午餐的时候显示器都变暗了！当然，远程操作WMI需要本地管理员权限，并且为防火墙设置了允许远程管理的规则。 如果提示“不支持”的错误提示信息，那么说明您的显示驱动程序不支持WMI。 这是“有趣”的部分：模拟一个古怪的显示效果： for($x=0; $x -lt 20; $x++) { Set-MonitorBrightness -Value (Get-Random -Minimum 20 -Maximum 101) Start-Sleep -Seconds 1 } 本文国际来源：Setting Monitor Brightness","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 检测显示器亮度","slug":"check-monitor-brightness","date":"2013-09-25T16:00:00.000Z","updated":"2017-03-17T15:26:22.086Z","comments":true,"path":"2013/09/26/check-monitor-brightness/","link":"","permalink":"http://blog.vichamp.com/2013/09/26/check-monitor-brightness/","excerpt":"如果您想检查您当前的显示器亮度（当然，尤其是针对笔记本电脑），以下是一个快捷的函数： function Get-MonitorBrightness { param($ComputerName, $Credential) Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightness @PSBoundParameters | Select-Object -Property PSComputerName, CurrentBrightness, Levels } 它甚至支持 -ComputerName 和 -Credential，所以您也可以查询远程的主机。 如果您为 -ComputerName 参数传入一个用逗号分隔的主机名或IP地址列表，您将获得所有具有local Admin权限的主机的执行结果。","text":"如果您想检查您当前的显示器亮度（当然，尤其是针对笔记本电脑），以下是一个快捷的函数： function Get-MonitorBrightness { param($ComputerName, $Credential) Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightness @PSBoundParameters | Select-Object -Property PSComputerName, CurrentBrightness, Levels } 它甚至支持 -ComputerName 和 -Credential，所以您也可以查询远程的主机。 如果您为 -ComputerName 参数传入一个用逗号分隔的主机名或IP地址列表，您将获得所有具有local Admin权限的主机的执行结果。 本文国际来源：Check Monitor Brightness","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 创建符号链接","slug":"creating-symbolic-links","date":"2013-09-24T16:00:00.000Z","updated":"2017-03-17T15:26:22.086Z","comments":true,"path":"2013/09/25/creating-symbolic-links/","link":"","permalink":"http://blog.vichamp.com/2013/09/25/creating-symbolic-links/","excerpt":"符号链接使用起来很像“普通”的链接文件（*.lnk）：它们可以虚拟地指向任何文件或者文件夹，甚至UNC路径。和lnk文件不同的是，创建符号链接需要完整管理员权限，并且用户不可以存取符号链接属性。 以下是一个创建符号链接的函数：","text":"符号链接使用起来很像“普通”的链接文件（*.lnk）：它们可以虚拟地指向任何文件或者文件夹，甚至UNC路径。和lnk文件不同的是，创建符号链接需要完整管理员权限，并且用户不可以存取符号链接属性。 以下是一个创建符号链接的函数： function New-SymbolicLink { param ( [Parameter(Mandatory=$true)] $OriginalPath, [Parameter(Mandatory=$true)] $MirroredPath, [ValidateSet(&apos;File&apos;, &apos;Directory&apos;)] $Type=&apos;File&apos; ) if(!([bool]((whoami /groups) -match &quot;S-1-16-12288&quot;) )) { Write-Warning &apos;Must be an admin&apos; break } $signature = &apos; [DllImport(&quot;kernel32.dll&quot;)] public static extern bool CreateSymbolicLink(string lpSymlinkFileName, string lpTargetFileName, int dwFlags); &apos; Add-Type -MemberDefinition $signature -Name Creator -Namespace SymbolicLink $Flags = [Int]($Type -eq &apos;Directory&apos;) [SymbolicLink.Creator]::CreateSymbolicLink($MirroredPath, $OriginalPath,$Flags) } $downloads = &quot;$env:userprofile\\Downloads&quot; $desktop = &quot;$env:userprofile\\Desktop\\MyDownloads&quot; New-SymbolicLink -OriginalPath $downloads -MirroredPath $desktop -Type Directory 当您（以管理员身份）运行这段代码时，它将使您能在桌面上访问下载文件夹。请右击符号链接并选择属性，并和“普通”的*.link文件做对比。 本文国际来源：Creating Symbolic Links","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"Clover 3 为您的 Windows Explorer 插上翅膀！","slug":"clover","date":"2013-09-23T16:00:00.000Z","updated":"2017-03-17T15:26:22.070Z","comments":true,"path":"2013/09/24/clover/","link":"","permalink":"http://blog.vichamp.com/2013/09/24/clover/","excerpt":"Clover 3为您的Windows Explorer插上翅膀！Clover 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。 官方网站：易捷科技","text":"Clover 3为您的Windows Explorer插上翅膀！Clover 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。 官方网站：易捷科技 Version:3.0.386 Requirements:Windows XP / Windows 7 / Windows 8 Language:English / 简体中文 / 繁體中文 / 日本語 / Français / Español / Deutsch / Nederlands / Português","categories":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/categories/geek/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"software","slug":"software","permalink":"http://blog.vichamp.com/tags/software/"}],"keywords":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/categories/geek/"}]},{"title":"PowerShell 技能连载 - 检查管理员权限","slug":"testing-administrator-privileges","date":"2013-09-23T16:00:00.000Z","updated":"2017-03-17T15:26:22.086Z","comments":true,"path":"2013/09/24/testing-administrator-privileges/","link":"","permalink":"http://blog.vichamp.com/2013/09/24/testing-administrator-privileges/","excerpt":"以下通过一个非常规的办法实现检查一段脚本是否以管理员权限运行（通过提升UAC），这体现了PowerShell强大的灵活性： function Test-Admin { [bool]((whoami /groups) -match &quot;S-1-16-12288&quot;) } 它的基本原理是检查当前用户是否是高完整性级别用户组的成员。该用户组是专门针对提升权限的管理员设置的。 如果您不想使用本地命令（whoami.exe）的话，还可以使用更贴近PowerShell（或.NET）的方法，如以下代码所示： function Test-Admin { $id = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent()) $id.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator) }","text":"以下通过一个非常规的办法实现检查一段脚本是否以管理员权限运行（通过提升UAC），这体现了PowerShell强大的灵活性： function Test-Admin { [bool]((whoami /groups) -match &quot;S-1-16-12288&quot;) } 它的基本原理是检查当前用户是否是高完整性级别用户组的成员。该用户组是专门针对提升权限的管理员设置的。 如果您不想使用本地命令（whoami.exe）的话，还可以使用更贴近PowerShell（或.NET）的方法，如以下代码所示： function Test-Admin { $id = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent()) $id.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator) } 本文国际来源：Testing Administrator Privileges","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"用 PowerShell 处理纯文本 - 1","slug":"processing-plain-text-with-powershell-1","date":"2013-09-22T16:00:00.000Z","updated":"2017-03-17T15:26:22.070Z","comments":true,"path":"2013/09/23/processing-plain-text-with-powershell-1/","link":"","permalink":"http://blog.vichamp.com/2013/09/23/processing-plain-text-with-powershell-1/","excerpt":"","text":"原始文本：”data1”:111,”data2”:22,”data3”:3,”data4”:4444444,”data5”:589要求：转换成对象 方法一，采用字符串运算及 ConvertFrom-StringData 命令： $rawTxt=&apos;&quot;data1&quot;:111,&quot;data2&quot;:22,&quot;data3&quot;:3,&quot;data4&quot;:4444444&apos; $rawTxt -split &apos;,&apos; | ForEach-Object { $temp= $_ -split &apos;:&apos; &quot;{0}={1}&quot; -f $temp[0].Substring(1,$temp[0].Length-2),$temp[1] } | ConvertFrom-StringData 方法二，采用正则表达式，使用.NET的方法： $rawTxt = &apos;&quot;data1&quot;:111,&quot;data2&quot;:22,&quot;data3&quot;:3,&quot;data4&quot;:4444444,&quot;data5&quot;:589&apos; $regex = [regex] &apos;&quot;(?&lt;name&gt;\\w*)&quot;:(?&lt;value&gt;\\d*),?&apos; $match = $regex.Match($rawTxt) while ($match.Success) { [PSCustomObject]@{ Name = $match.Groups[&apos;name&apos;].Value Value = $match.Groups[&apos;value&apos;].Value } $match = $match.NextMatch() } 方法三，采用正则表达式，使用 Select-String Cmdlet： Select-String -InputObject $rawTxt -Pattern $regex -AllMatches | % { $_.Matches } | % { [PSCustomObject]@{ Name = $_.Groups[&apos;name&apos;].Value Value = $_.Groups[&apos;value&apos;].Value } } 三者的执行结果都是这样： Name Value ---- ----- data1 111 data2 22 data3 3 data4 4444444 data5 589 原命题参见：PowerShell 文本处理实例(三)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"regex","slug":"regex","permalink":"http://blog.vichamp.com/tags/regex/"},{"name":"learning","slug":"learning","permalink":"http://blog.vichamp.com/tags/learning/"},{"name":"skill","slug":"skill","permalink":"http://blog.vichamp.com/tags/skill/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"text","slug":"powershell/text","permalink":"http://blog.vichamp.com/categories/powershell/text/"}]},{"title":"PowerShell 技能连载 - 创建硬连接","slug":"creating-hard-links","date":"2013-09-22T16:00:00.000Z","updated":"2017-03-17T15:26:22.070Z","comments":true,"path":"2013/09/23/creating-hard-links/","link":"","permalink":"http://blog.vichamp.com/2013/09/23/creating-hard-links/","excerpt":"硬连接是NTFS文件系统中文件的“镜像”。它们使得一个文件能在多个文件系统位置（必须在一个卷中）中出现。 所以文件仅仅占用它的原始位置空间，但是在其它地方也可用。当您需要让大文件在多个地方可用的时候，这是一个十分有用的功能。 以下是 New-HardLink 函数的介绍。它演示了PowerShell如何调用底层的API函数：","text":"硬连接是NTFS文件系统中文件的“镜像”。它们使得一个文件能在多个文件系统位置（必须在一个卷中）中出现。 所以文件仅仅占用它的原始位置空间，但是在其它地方也可用。当您需要让大文件在多个地方可用的时候，这是一个十分有用的功能。 以下是 New-HardLink 函数的介绍。它演示了PowerShell如何调用底层的API函数： function New-HardLink { param ( [Parameter(Mandatory=$true)] $OriginalFilePath, [Parameter(Mandatory=$true)] $MirroredFilePath ) $signature = &apos; [DllImport(&quot;Kernel32.dll&quot;)] public static extern bool CreateHardLink(string lpFileName,string lpExistingFileName,IntPtr lpSecurityAttributes); &apos; Add-Type -MemberDefinition $signature -Name Creator -Namespace Link [Link.Creator]::CreateHardLink($MirroredFilePath,$OriginalFilePath,[IntPtr]::Zero) } 以下是它的使用方法： $Original = &quot;$env:temp\\testfile.txt&quot; $Copy1 = &quot;$env:userprofile\\Desktop\\mirrorfile1.txt&quot; $Copy2 = &quot;$env:userprofile\\Desktop\\mirrorfile2.txt&quot; # create original file: Set-Content -Path $Original -Value &apos;Hello&apos; # create hard link #1: New-HardLink -OriginalFilePath $Original -MirroredFilePath $Copy1 # create hard link #2: New-HardLink -OriginalFilePath $Original -MirroredFilePath $Copy2 这段代码首先在临时文件夹中创建一个物理文件。然后在您的桌面上创建两个硬连接。它们看上去分别是mirrorfile1.txt和mirrorfile2.txt。虽然它们看上去像是独立的文件，而实际上他们都指向刚创建的临时文件。 您可以打开桌面上两个文件中的某一个，做一些修改，然后保存并关闭。当打开另一个文件时，您可以看到一模一样的修改后的内容。您还可以简单地删掉一个镜像文件来移除硬连接。 本文国际来源：Returning Multiple Values","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"获取2013年剩余天数","slug":"get-rest-days-of-2013","date":"2013-09-21T16:00:00.000Z","updated":"2017-03-17T15:26:22.067Z","comments":true,"path":"2013/09/22/get-rest-days-of-2013/","link":"","permalink":"http://blog.vichamp.com/2013/09/22/get-rest-days-of-2013/","excerpt":"","text":"用PowerShell获取2013年剩余天数的两种写法。 ((Get-Date 2014-1-1) - (Get-Date)).Days 100 ([datetime]&quot;2014-1-1&quot; - [datetime]::now).Days 100 顺便励志一下，2013年只剩下100天了。Come on，小伙伴们！","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"在PowerShell中操作Excel - 读取数据","slug":"integrating-microsoft-excel-with-powershell-reading-data","date":"2013-09-20T16:00:00.000Z","updated":"2017-03-17T15:26:22.048Z","comments":true,"path":"2013/09/21/integrating-microsoft-excel-with-powershell-reading-data/","link":"","permalink":"http://blog.vichamp.com/2013/09/21/integrating-microsoft-excel-with-powershell-reading-data/","excerpt":"欢迎回到“在PowerShell中操作Excel”三部曲系列文章。在这一系列的前两部分，我们学习了如何将数据写入Excel并且创建“富”报表，以及额外的格式化选项等Microsoft Excel高级用法。 对于IT专家来说，这个故事的另一半是如何从一个Excel文档中读取数据。它的挑战性在于您必须事先知道工作表的结构。我们可以搜索数据，但那是更复杂的情况。我假设您已有一个用过且了其解结构的Excel文档。这样，用PowerShell读取数据就不那么复杂。","text":"欢迎回到“在PowerShell中操作Excel”三部曲系列文章。在这一系列的前两部分，我们学习了如何将数据写入Excel并且创建“富”报表，以及额外的格式化选项等Microsoft Excel高级用法。 对于IT专家来说，这个故事的另一半是如何从一个Excel文档中读取数据。它的挑战性在于您必须事先知道工作表的结构。我们可以搜索数据，但那是更复杂的情况。我假设您已有一个用过且了其解结构的Excel文档。这样，用PowerShell读取数据就不那么复杂。 读取数据像我们在本系列文章的前两部分那样，第一步是创建一个Excel应用程序对象。 $xl=New-Object -ComObject &quot;Excel.Application&quot; 我将在我的脚本中使用这个Excel文件。 用工作簿对象的 Open() 方法打开文件。 $wb=$xl.Workbooks.Open($file) $ws=$wb.ActiveSheet $ws对象是我们对数据最重要的的引用点。我需要用的数据从A2单元格开始。在我的测试环境中，我也许知道我需要处理多少行，但是既然我知道从哪儿开始，我可以用一个Do循环来读取每一行，获取数据，进行进一步操作。 $Row=2 do { $data=$ws.Range(&quot;A$Row&quot;).Text ... 通过使用Range属性，我可以获取A2单元格。Text属性是该单元格的值。我的示例脚本将要从第一列获取计算机名，获取一些WMI信息，然后向管道写入一个和电子表格的其它部分数据有关的自定义数据。 当您处理Excel数据的时候，我建议您进行一系列校验。假设单元格里有一个数据，我假设它是一个机器名，那么我会试着ping一下它。 if ($data) { Write-Verbose &quot;Querying $data&quot; $ping=Test-Connection -ComputerName $data -Quiet 如果ping通了，我将会使用WMI来获取操作系统名称，否则我会设置$OS变量为$Null。 if ($Ping) { $OS=(Get-WmiObject -Class Win32_OperatingSystem -Property Caption -computer $data).Caption } else { $OS=$Null 最后，对于每台计算机，我将用 New-Object cmdlet创建一个自定义对象。 New-Object -TypeName PSObject -Property @{ Computername=$Data.ToUpper() OS=$OS Ping=$Ping Location=$ws.Range(&quot;B$Row&quot;).Text AssetAge=((Get-Date)-($ws.Range(&quot;D$Row&quot;).Text -as [datetime])).TotalDays -as [int] } 请注意我设置的其它属性值，比如说Location，是位于B2单元格，至少对于这台计算机而言。请注意您从它的Text属性获取到的只是文本。但您还可以将它们转换为各种数据类型，就像我对AssetAge属性的处理那样。我从D2单元格读取文本，并把它转换为一个 DateTime 对象，于是我可以将它和当前时间做减法，得到一个 TimeSpan 对象。该对象有一个 TotalDays 属性。 loop循环的最后一步是使行计数器自增1。 $Row++ } While ($data) 下一次进入lopp循环的时候，脚本将会处理第3行的数据。直到PowerShell遇到一个空行。在最后，我将关闭文件并且退出。 $xl.displayAlerts=$False $wb.Close() $xl.Application.Quit() 我的脚本运行以后生成一下输出结果： PS C:\\scripts&gt; .\\Demo-ReadExcel.ps1 AssetAge : 687 Ping : True Computername : SERENITY Location : R1-1 OS : Microsoft Windows 7 Ultimate AssetAge : 293 Ping : True Computername : QUARK Location : R1-4 OS : Microsoft Windows 7 Professional AssetAge : 293 Ping : False Computername : SERVER01 Location : R3-2 OS : AssetAge : 2005 Ping : True Computername : JDHIT-DC01 Location : R2-1 OS : Microsoft(R) Windows(R) Server 2003, Enterprise Edition 我在PowerShell中用数的代码就可以实现从Excel电子表格中读取数据并且在我的程序中使用它。如果需要的话，我可以结合前面文章中的技术，在读取的同时更新电子表格的内容！ 结论您可以下载我的示例脚本并且自己做一下实验。记住，当使用PowerShell读取Excel文件的时候，您需要事先了解文档的结构，并且做好错误处理和数据有效性验证。我并不推荐初学者用PowerShell操作Excel，但具有一些经验并投入一些耐心以后，您可以得到很丰厚的回报。 用PowerShell操作Office系列文章 在PowerShell中操作Word - 生成文档 在PowerShell中操作Word - 使用格式化样式 在PowerShell中操作Excel - 创建一个简单的报表 在PowerShell中操作Excel - 创建一个富Excel文档 在PowerShell中操作Excel - 读取数据","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"office","slug":"powershell/office","permalink":"http://blog.vichamp.com/categories/powershell/office/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"office","slug":"powershell/office","permalink":"http://blog.vichamp.com/categories/powershell/office/"}]},{"title":"PowerShell 技能连载 - 在文件管理器中显示隐藏文件","slug":"showing-hidden-files-in-file-explorer","date":"2013-09-19T16:00:00.000Z","updated":"2017-03-17T15:26:22.048Z","comments":true,"path":"2013/09/20/showing-hidden-files-in-file-explorer/","link":"","permalink":"http://blog.vichamp.com/2013/09/20/showing-hidden-files-in-file-explorer/","excerpt":"PowerShell可以方便地读写注册表。注册表是Windows设置的中心仓库。 这是一个可以设置文件管理器显示/不显示隐藏文件的函数。它聪明的地方在于不需要向注册表写入新值。它相当于文件管理器窗口如何显示和改变它们的内容。 function Show-HiddenFile { param([Switch]$Off) $value = -not $Off.IsPresent Set-ItemProperty -Path HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced ` -Name Hidden -Value $value -type DWORD $shell = New-Object -ComObject Shell.Application $shell.Windows() | Where-Object { $_.document.url -eq $null } | ForEach-Object { $_.Refresh() } } Show-HiddenFile 使得隐藏文件变得可见；而 Show-HiddenFile -Off 使得隐藏文件不可见。操作结果几乎在所有文件管理窗口中立即生效。如果您在没有打开文件管理窗口的情况下做出改变，则改变不会立即生效，因为没有可以调用 Refresh() 方法的窗口。","text":"PowerShell可以方便地读写注册表。注册表是Windows设置的中心仓库。 这是一个可以设置文件管理器显示/不显示隐藏文件的函数。它聪明的地方在于不需要向注册表写入新值。它相当于文件管理器窗口如何显示和改变它们的内容。 function Show-HiddenFile { param([Switch]$Off) $value = -not $Off.IsPresent Set-ItemProperty -Path HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced ` -Name Hidden -Value $value -type DWORD $shell = New-Object -ComObject Shell.Application $shell.Windows() | Where-Object { $_.document.url -eq $null } | ForEach-Object { $_.Refresh() } } Show-HiddenFile 使得隐藏文件变得可见；而 Show-HiddenFile -Off 使得隐藏文件不可见。操作结果几乎在所有文件管理窗口中立即生效。如果您在没有打开文件管理窗口的情况下做出改变，则改变不会立即生效，因为没有可以调用 Refresh() 方法的窗口。 本文国际来源：Showing Hidden Files in File Explorer","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - PowerShell函数的详细输出","slug":"verbose-output-for-powershell-functions","date":"2013-09-18T16:00:00.000Z","updated":"2017-03-17T15:26:22.048Z","comments":true,"path":"2013/09/19/verbose-output-for-powershell-functions/","link":"","permalink":"http://blog.vichamp.com/2013/09/19/verbose-output-for-powershell-functions/","excerpt":"若要为您的PowerShell函数增加指定的详细输出信息（verbose output），请增加 CmdletBinding 属性到您的函数，使它支持公共参数。（译者注：公共参数例如 -Verbose、-Debug 等） function test { [CmdletBinding()] param() } 下一步，添加 Write-Verbose 来输出文本信息。它们仅当用户指定了 -Verbose 参数时才有效： function test { [CmdletBinding()] param() Write-Verbose &quot;Starting&quot; &quot;Doing Something&quot; Write-Verbose &quot;Shutting Down&quot; } 所以当您按以下方式运行它时，您会见到正常的输出信息： PS &gt; test Doing Something 然而，如果您增加了 -Verbose 参数，您将会看到您输出的详细信息： PS &gt; test -Verbose Starting Doing Something Shutting Down","text":"若要为您的PowerShell函数增加指定的详细输出信息（verbose output），请增加 CmdletBinding 属性到您的函数，使它支持公共参数。（译者注：公共参数例如 -Verbose、-Debug 等） function test { [CmdletBinding()] param() } 下一步，添加 Write-Verbose 来输出文本信息。它们仅当用户指定了 -Verbose 参数时才有效： function test { [CmdletBinding()] param() Write-Verbose &quot;Starting&quot; &quot;Doing Something&quot; Write-Verbose &quot;Shutting Down&quot; } 所以当您按以下方式运行它时，您会见到正常的输出信息： PS &gt; test Doing Something 然而，如果您增加了 -Verbose 参数，您将会看到您输出的详细信息： PS &gt; test -Verbose Starting Doing Something Shutting Down 本文国际来源：Verbose Output for PowerShell Functions","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"在PowerShell中操作Excel - 创建一个简单的报表","slug":"integrating-microsoft-excel-with-powershell-build-a-basic-report","date":"2013-09-18T16:00:00.000Z","updated":"2017-03-17T15:26:22.033Z","comments":true,"path":"2013/09/19/integrating-microsoft-excel-with-powershell-build-a-basic-report/","link":"","permalink":"http://blog.vichamp.com/2013/09/19/integrating-microsoft-excel-with-powershell-build-a-basic-report/","excerpt":"除了文本文件之外，Windows系统管理员最常用的工具是Microsoft Excel。我观察论坛中人们的讨论发现，有一大堆关于Excel电子表格讨论。许多人想要读写Excel的方法。通常，我告诉人们如果他们使用PowerShell，那么可以简单地将结果导出到CSV文件，然后用Excel打开，但是您很有可能需要一个真正的Excel文件。 我着手准备写几个关于如何在PowerShell中操作Excel的专题。今天我们将要通过Microsoft Excel和Windows PowerShell创建一个简单的报表。在第二部分中，我将演示如何创建一个更复杂的Excel文档。然后在第三部分中，我将向您演示如何从Excel文件中读取数据。","text":"除了文本文件之外，Windows系统管理员最常用的工具是Microsoft Excel。我观察论坛中人们的讨论发现，有一大堆关于Excel电子表格讨论。许多人想要读写Excel的方法。通常，我告诉人们如果他们使用PowerShell，那么可以简单地将结果导出到CSV文件，然后用Excel打开，但是您很有可能需要一个真正的Excel文件。 我着手准备写几个关于如何在PowerShell中操作Excel的专题。今天我们将要通过Microsoft Excel和Windows PowerShell创建一个简单的报表。在第二部分中，我将演示如何创建一个更复杂的Excel文档。然后在第三部分中，我将向您演示如何从Excel文件中读取数据。 创建一个简单的报表Microsoft Excel包含一个非常复杂的COM对象模型，我们可以在Windows Powershell中和它交互。让我们从头开始创建一个Excel应用程序的对象。 PS C:\\&gt; $xl=New-Object -ComObject &quot;Excel.Application&quot; 执行完这一步以后，Excel已经开始在后台运行，虽然看不见可交互窗口。 PS C:\\&gt; get-process excel Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 203 23 16392 24340 267 0.28 1280 EXCEL 下一步，我们将要创建一个工作簿对象。 PS C:\\&gt; $wb=$xl.Workbooks.Add() 下一步，我们将要创建一个工作表对象。 PS C:\\&gt; $ws=$wb.ActiveSheet 您可以将任何一个对象通过管道输出到 Get-Member 来学习它们。下一步，我们将使这个应用程序可见。 PS C:\\&gt; $xl.Visible=$True 当您开始写脚本的时候，您可以不必做这步。但是这步能帮您检验我们写的PowerShell命令的执行结果。有很多种办法能将信息输入到电子表格中。做为一个简单的任务，我将演示如何使用单元格（cell）对象。 PS C:\\&gt; $cells=$ws.Cells 我们可以用行和列坐标来获取每一个单元格对象。 PS C:\\&gt; $cells.item(1,1) 如果您试这行代码，您将获取到很多信息。我们将继续往下并且输入一些信息到这个单元格。 PS C:\\&gt; $cells.item(1,1)=$env:computername 您的计算机名将会被填入 A1 单元格。让我们来填入更多的数据。 PS C:\\&gt; $cells.item(1,2)=$env:username PS C:\\&gt; $cells.item(2,1)=(get-Date) 这个过程真的很简单。您只需要不断地记下当前的位置即可。如果您需要基本的格式，您可以使用每个单元格的 Font 属性。 PS C:\\&gt; $cells.item(1,1).font.bold=$True PS C:\\&gt; $cells.item(1,2).font.bold=$True PS C:\\&gt; $cells.item(1,1).font.size=16 PS C:\\&gt; $cells.item(1,2).font.size=16 好了，现在我们可以用 WorkBook 对象的 SaveAs() 方法保存这个文件。 PS C:\\&gt; $wb.SaveAs(&quot;c:\\work\\test.xlsx&quot;) To fully exit, we’ll close the workbook and quit Excel.若要完全退出，我们需要关闭工作簿并且退出Excel。 PS C:\\&gt; $wb.Close() PS C:\\&gt; $xl.Quit() 如果您检查进程的话，您也许会发现Excel任然在运行，但它将会在5-10分钟之内退出，自少按我的经验是这样。以上是基本的要点，但在圆满完成之前，让我整理一个脚本，将这些材料整合在一起。 Param([string]$computer=$env:computername) #get disk data $disks=Get-WmiObject -Class Win32_LogicalDisk -ComputerName $computer -Filter &quot;DriveType=3&quot; $xl=New-Object -ComObject &quot;Excel.Application&quot; $wb=$xl.Workbooks.Add() $ws=$wb.ActiveSheet $cells=$ws.Cells $cells.item(1,1)=&quot;{0} Disk Drive Report&quot; -f $disks[0].SystemName $cells.item(1,1).font.bold=$True $cells.item(1,1).font.size=18 #define some variables to control navigation $row=3 $col=1 #insert column headings &quot;Drive&quot;,&quot;SizeGB&quot;,&quot;FreespaceGB&quot;,&quot;UsedGB&quot;,&quot;%Free&quot;,&quot;%Used&quot; | foreach { $cells.item($row,$col)=$_ $cells.item($row,$col).font.bold=$True $col++ } foreach ($drive in $disks) { $row++ $col=1 $cells.item($Row,$col)=$drive.DeviceID $col++ $cells.item($Row,$col)=$drive.Size/1GB $cells.item($Row,$col).NumberFormat=&quot;0&quot; $col++ $cells.item($Row,$col)=$drive.Freespace/1GB $cells.item($Row,$col).NumberFormat=&quot;0.00&quot; $col++ $cells.item($Row,$col)=($drive.Size - $drive.Freespace)/1GB $cells.item($Row,$col).NumberFormat=&quot;0.00&quot; $col++ $cells.item($Row,$col)=($drive.Freespace/$drive.size) $cells.item($Row,$col).NumberFormat=&quot;0.00%&quot; $col++ $cells.item($Row,$col)=($drive.Size - $drive.Freespace) / $drive.size $cells.item($Row,$col).NumberFormat=&quot;0.00%&quot; } $xl.Visible=$True $filepath=Read-Host &quot;Enter a path and filename to save the file&quot; if ($filepath) { $wb.SaveAs($filepath) } 这也许是您想在PowerShell里做的事情：用WMI获取磁盘使用信息并将其记录在Excel电子表格中。这段脚本以计算机名做为参数，缺省值为localhost。然后使用Get-WMIObject来获取磁盘信息。 脚本的第一部分看起来应该很熟悉，它创建一个Excel应用程序和对象。该脚本向A1单元格插入一个标题。 $cells.item(1,1)=&quot;{0} Disk Drive Report&quot; -f $disks[0].SystemName $cells.item(1,1).font.bold=$True $cells.item(1,1).font.size=18 脚本的主体部分从每个逻辑磁盘中提取数据，并且将一些属性写入Excel。由于我需要通过行和列来操作这些单元格对象，所以我将定义一些用来定位用的辅助变量。 $row=3 $col=1 通过它们，我可以插入我的表头。 &quot;Drive&quot;,&quot;SizeGB&quot;,&quot;FreespaceGB&quot;,&quot;UsedGB&quot;,&quot;%Free&quot;,&quot;%Used&quot; | foreach { $cells.item($row,$col)=$_ $cells.item($row,$col).font.bold=$True $col++ } 每循环一次，$col就增加1，所以达到向右“移动”的效果。现在我需要遍历disks集合。每次需要“向下”移动一行，并且从第一列开始。 foreach ($drive in $disks) { $row++ $col=1 $cells.item($Row,$col)=$drive.DeviceID $col++ $cells.item($Row,$col)=$drive.Size/1GB $cells.item($Row,$col).NumberFormat=&quot;0&quot; $col++ ... 接下来我将合适的WMI属性插入对应的单元格。每增加一行，我可以从左开始这个过程。请注意我使用了 NumberFormat 属性来格式化每个单元格的值。有一种探索的方法是创建一个Excel宏来记下所有您希望的步骤，然后查看生成的VBA代码。通过稍许的练习，您可以将这些命令翻译为PowerShell代码。 当脚本向电子表格写完数据以后，我把它显示出来并且提示用户输入文件名。如果用户输入的文件名，那么文件以该文件名保存。否则，您可以继续编辑电子表格，然后手动保存它。这个演示脚本并不会自动关闭Excel。这个脚本执行的结果如图1所示： 结论我知道还有很多问题，所以我将会把它们总结出来。在第二部分，我们将看到一些高级的格式化选项，以及其它使用Microsoft Excel的深入用法。如果您将要用PowerShell来创建Excel文档，您会尽可能做到极致。 用PowerShell操作Office系列文章 在PowerShell中操作Word - 生成文档 在PowerShell中操作Word - 使用格式化样式 在PowerShell中操作Excel - 创建一个简单的报表 在PowerShell中操作Excel - 创建一个富Excel文档 在PowerShell中操作Excel - 读取数据","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"office","slug":"powershell/office","permalink":"http://blog.vichamp.com/categories/powershell/office/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"office","slug":"powershell/office","permalink":"http://blog.vichamp.com/categories/powershell/office/"}]},{"title":"在PowerShell中操作Excel - 创建一个富Excel文档","slug":"integrating-microsoft-excel-with-powershell-create-a-rich-excel-doc","date":"2013-09-18T16:00:00.000Z","updated":"2017-03-17T15:26:22.033Z","comments":true,"path":"2013/09/19/integrating-microsoft-excel-with-powershell-create-a-rich-excel-doc/","link":"","permalink":"http://blog.vichamp.com/2013/09/19/integrating-microsoft-excel-with-powershell-create-a-rich-excel-doc/","excerpt":"让我们继续《在PowerShell中操作Excel》系列文章。上一次我们掩饰了如何用Microsoft Excel和Windows PowerShell来创建一个基本的报表。从某些方面来讲，我们上次创建的东西和创建CSV并在Excel中打开差不了多少。所以，如果您希望用Excel，让我们彻彻底底地使用它！在今天的文章中，我将沿用上次的演示脚本，但是创建一个更“富（richer）”的Excel文档。下一步，在第三部分中，我将为您演示如何从Excel文件中读取数据。","text":"让我们继续《在PowerShell中操作Excel》系列文章。上一次我们掩饰了如何用Microsoft Excel和Windows PowerShell来创建一个基本的报表。从某些方面来讲，我们上次创建的东西和创建CSV并在Excel中打开差不了多少。所以，如果您希望用Excel，让我们彻彻底底地使用它！在今天的文章中，我将沿用上次的演示脚本，但是创建一个更“富（richer）”的Excel文档。下一步，在第三部分中，我将为您演示如何从Excel文件中读取数据。 创建一个富Excel文档和之前一样，我们将通过WMI获取磁盘信息，并创建一个Excel应用程序对象。 $disks=Get-WmiObject -Class Win32_LogicalDisk -ComputerName $computer -Filter &quot;DriveType=3&quot; $xl=New-Object -ComObject &quot;Excel.Application&quot; 和Microsoft Word类似，Excel自动化很大程度依赖于使用类似 xlDown 等内置常量。我可以记下一个常量值并创建一个变量，或者可以读取包含所需常量的合适的类。在我印象中，我将需要提取以下信息： $xlConditionValues=[Microsoft.Office.Interop.Excel.XLConditionValueTypes] $xlTheme=[Microsoft.Office.Interop.Excel.XLThemeColor] $xlChart=[Microsoft.Office.Interop.Excel.XLChartType] $xlIconSet=[Microsoft.Office.Interop.Excel.XLIconSet] $xlDirection=[Microsoft.Office.Interop.Excel.XLDirection] 将来当我希望使用 xlDown 时，我可以通过 $xlDirection::xlDown 来指定它。您等等会看到一些这样的代码。现在，我将像第一部分那样写入磁盘数据，但先让我们加入一些样式。另一种引用电子表格的一部分是使用工作簿对象的 Range 属性。您既可以通过类似的方式 A1 引用一个单元格，或者通过类似 A1:A10 的方式引用一个范围。范围（Range）对象有一个样式（Style）属性。我将把 A1 单元格的样式设置成“Title”，并且把我的表头样式设置成“Heading 2”。 $range=$ws.range(&quot;A1&quot;) $range.Style=&quot;Title&quot; #或者用这种方法 $ws.Range(&quot;A3:F3&quot;).Style = &quot;Heading 2&quot; 另一个常见的格式化选项是调整列宽。我们可以设置列宽为固定值或者为自动调整列宽。 $ws.columns.item(&quot;C:C&quot;).columnwidth=15 $ws.columns.item(&quot;D:F&quot;).columnwidth=10.5 $ws.columns.item(&quot;B:B&quot;).EntireColumn.AutoFit() | out-null 顺便提一句，我将某些方法，比如 AutoFit() 输出到管道 Out-Null 来禁止不需要的输出。以下是很有意思的地方：我想如果能用上Excel的条件格式功能将会很酷。具体来说，我想用交通灯图标集来反映每个驱动器的使用量。如我之前所说，既然我们要创建一个Excel文件，那么尽量做到极致。我将为您演示这些代码，不用紧张:) $start=$ws.range(&quot;F4&quot;) #获取最后一个单元格 $Selection=$ws.Range($start,$start.End($xlDirection::xlDown)) #增加图标集 $Selection.FormatConditions.AddIconSetCondition() | Out-Null $Selection.FormatConditions.item($($Selection.FormatConditions.Count)).SetFirstPriority() $Selection.FormatConditions.item(1).ReverseOrder = $True $Selection.FormatConditions.item(1).ShowIconOnly = $False $Selection.FormatConditions.item(1).IconSet = xlIconSet::xl3TrafficLights1 $Selection.FormatConditions.item(1).IconCriteria.Item(2).Type = xlConditionValues::xlConditionValueNumber $Selection.FormatConditions.item(1).IconCriteria.Item(2).Value = 0.8 $Selection.FormatConditions.item(1).IconCriteria.Item(2).Operator = 7 $Selection.FormatConditions.item(1).IconCriteria.Item(3).Type = xlConditionValues::xlConditionValueNumber $Selection.FormatConditions.item(1).IconCriteria.Item(3).Value = 0.9 $Selection.FormatConditions.item(1).IconCriteria.Item(3).Operator = 7 我并不是一夜之间突然知道怎么用PowerShell来做这些事情。相反地，我创建了一个Excel宏，然后应用样式，然后将代码翻译成PowerShell脚本。我希望我可以为您提供一系列翻译的规则，但是碰到一系列障碍和错误。请注意常量的使用？（译者注：原文为I wish I could give you a set of translation rules, but it just takes trial and error and experience. Notice the use of the constant values?） 下一步，我将为插入一个柱形图到工作表： $chart=$ws.Shapes.AddChart().Chart $chart.chartType=$xlChart::xlBarClustered 我又一次采用了创建一个宏来观察其中的方法并修正其中的值的方法。接下来，我需要为图表选择数据源。 $start=$ws.range(&quot;A3&quot;) #获取最后一个单元格 $Y=$ws.Range($start,$start.End($xlDirection::xlDown)) $start=$ws.range(&quot;F3&quot;) #获取最后一个单元格 $X=$ws.Range($start,$start.End($xlDirection::xlDown)) 驱动器名称将作为Y轴，%Used将作为X轴。我将用这个区域的集合来定义图表的数据。 $chartdata=$ws.Range(&quot;A$($Y.item(1).Row):A$($Y.item($Y.count).Row),F$($X.item(1).Row):F$($X.item($X.count).Row)&quot;) $chart.SetSourceData($chartdata) 我希望对这个图表做的最后一件事是增加数据标题和图表标题。 $chart.seriesCollection(1).Select() | Out-Null $chart.SeriesCollection(1).ApplyDataLabels() | out-Null $chart.ChartTitle.Text = &quot;Utilization&quot; Excel很可能并不会按您所希望的位置摆放这个图表，所以您可以使用以下代码来定位它： $ws.shapes.item(&quot;Chart 1&quot;).top=40 $ws.shapes.item(&quot;Chart 1&quot;).left=400 Top 和 Left 是从Excel窗口开始计算的顶边距和左边距。可能会在获取右边距的时候遇到一些障碍和错误，但请注意在多台计算机上进行测试。最后一步是将工作表以计算机名来命名。 $xl.worksheets.Item(&quot;Sheet1&quot;).name=$name 当您明白所有这些Excel的魔法师如何工作的，那么要为您希望查看的每台计算机增加一个工作表也不是那么难了。以下截图显示最终的结果： 结论您可以下载我的演示脚本并且自己进行测试。如果您的确需要写数据到Excel，我建议您完整地操作一遍。也许需要掌握一些基础知识，但这方面的努力是值得的。下一步我们将演示如何从Excel文件中读取数据。 用PowerShell操作Office系列文章 在PowerShell中操作Word - 生成文档 在PowerShell中操作Word - 使用格式化样式 在PowerShell中操作Excel - 创建一个简单的报表 在PowerShell中操作Excel - 创建一个富Excel文档 在PowerShell中操作Excel - 读取数据","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"office","slug":"powershell/office","permalink":"http://blog.vichamp.com/categories/powershell/office/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"office","slug":"powershell/office","permalink":"http://blog.vichamp.com/categories/powershell/office/"}]},{"title":"PowerShell 技能连载 - 将结果复制到剪贴板","slug":"copying-results-to-clipboard","date":"2013-09-17T16:00:00.000Z","updated":"2017-03-17T15:26:22.017Z","comments":true,"path":"2013/09/18/copying-results-to-clipboard/","link":"","permalink":"http://blog.vichamp.com/2013/09/18/copying-results-to-clipboard/","excerpt":"要将 CmdLet 的输出结果复制到别的应用程序，只需要简单地将它们通过管道传输到 clip.exe。然后，将结果粘贴到您所要的应用程序即可： Get-Service | clip","text":"要将 CmdLet 的输出结果复制到别的应用程序，只需要简单地将它们通过管道传输到 clip.exe。然后，将结果粘贴到您所要的应用程序即可： Get-Service | clip 译者注 - CLIP 命令的帮助信息： C:\\&gt;clip /? CLIP 描述: 将命令行工具的输出重定向到 Windows 剪贴板。这个文本输出可以被粘贴 到其他程序中。 参数列表: /? 显示此帮助消息。 示例: DIR | CLIP 将一份当前目录列表的副本放入 Windows 剪贴板。 CLIP &lt; README.TXT 将 readme.txt 的一份文本放入 Windows 剪贴板。 本文国际来源：Copying Results to Clipboard","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"理解PowerShell的类型转换魔法","slug":"understanding-powershells-type-conversion-magic","date":"2013-09-16T16:00:00.000Z","updated":"2017-03-17T15:26:22.017Z","comments":true,"path":"2013/09/17/understanding-powershells-type-conversion-magic/","link":"","permalink":"http://blog.vichamp.com/2013/09/17/understanding-powershells-type-conversion-magic/","excerpt":"毫无疑问地，PowerShell中的类型转换是它最有用的“魔法”功能之一。如果您执行一个需要特定参数类型（例如：DateTime 或 TimeSpan）的命令，情况似乎“一切正常”。 例如，Twitter上的这条问题： PowerShell 的 TimeSpan 参数将10理解为10个计时周期，10:00理解为10小时，”10”理解为10天。 译者注：计时周期的概念请参见 TimeSpan.Ticks 属性。 但是，这是怎么做到的呢？ 以下是PowerShell根据您的需要将输入值转换为所需要的类型的步骤——例如 TimeSpan。和许多事情一样，并不是什么魔法——只是一堆繁琐的工作。","text":"毫无疑问地，PowerShell中的类型转换是它最有用的“魔法”功能之一。如果您执行一个需要特定参数类型（例如：DateTime 或 TimeSpan）的命令，情况似乎“一切正常”。 例如，Twitter上的这条问题： PowerShell 的 TimeSpan 参数将10理解为10个计时周期，10:00理解为10小时，”10”理解为10天。 译者注：计时周期的概念请参见 TimeSpan.Ticks 属性。 但是，这是怎么做到的呢？ 以下是PowerShell根据您的需要将输入值转换为所需要的类型的步骤——例如 TimeSpan。和许多事情一样，并不是什么魔法——只是一堆繁琐的工作。 1. 直接赋值如果您的输入值是可直接赋值的，那么直接将您的输入值转型为该类型。 2. 基于语言的转换这些基于语言的转换适用于目标类型是 void、Boolean、String、Array、Hashtable、PSReference（例如：[ref]）、XmlDocument（例如：[xml]）、Delegate（用于支持代码块转换到Delegate） 和 Enum 类型。 3. 解析转换如果目标类型定义了一个 Parse() 方法接受该输入值，那么将使用它来做转换。 4. 静态创建转换如果目标类型定义了一个静态的 ::Create() 方法并接受该输入值，那么将使用它来转做换。 5. 构造函数转换如果目标类型定义了一个构造函数接受该输入值，那么将用它来做转换。 6. 强制类型转换如果目标类型针对源类型 隐式或显示地 定义了一个强制类型转换操作符，那么将用它来做转换。如果源类型定义了一个隐式或显式转换到目标类型的前置类型转换操作符，那么使用它来做转换。 7. IConvertible转换如果源类型定义了一个知道如何转换为目标类型的 IConvertible 的实现，那么将使用它来做转换。 8. IDictionary转换如果源类型是一个 IDictionary（例如：Hashtable） 类型，则尝试用目标类型的缺省构造函数创建一个实例，并且使用 IDictionary 中的同名键值对为源对象的属性赋值。 9. PSObject属性转换如果源类型是 PSObject，那么用目标类型的缺省构造函数创建一个实例，然后用 PSObject 中的属性名和属性值为源对象赋值。如果某个名字对应的是一个方法而不是一个属性，则以该值作为实参执行该方法。 10. TypeConverter 转换如果注册了一个可以处理该转换的 TypeConverter 或 PSTypeConverter，则用它来做转换。您可以在 types.ps1xml 文件中注册一个 TypeConverter（参见：$pshome\\Types.ps1xml），或通过 Update-TypeData 来注册。 好了，现在考考您能不能指出这些分别是什么类型的转换，以及为什么？ [TimeSpan] 10 [TimeSpan] &quot;10&quot; [TimeSpan] &quot;0:10&quot; 希望本文对您有所帮助！ Lee Holmes [MSFT]Windows PowerShell开发团队 本文国际来源：Understanding PowerShell’s Type Conversion Magic","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"PowerShell 技能连载 - 将Out-GridView改造为选择对话框","slug":"turn-out-gridview-into-selection-dialog","date":"2013-09-16T16:00:00.000Z","updated":"2017-03-17T15:26:22.002Z","comments":true,"path":"2013/09/17/turn-out-gridview-into-selection-dialog/","link":"","permalink":"http://blog.vichamp.com/2013/09/17/turn-out-gridview-into-selection-dialog/","excerpt":"在PowerShell 3.0中，Out-GridView 终于可以被改为一个多功能选择对话框——只要增加一个新的参数 -PassThru 就可以看到效果： $Title = &apos;Select one or more files to open&apos; Get-ChildItem -Path $env:windir -Filter *.log | Out-GridView -PassThru -Title $title | ForEach-Object { notepad $_.FullName } 您可以通过管道将任何对象传给 Out-GridView。用户可以从界面中选择输出结果的一部分，或者用关键词过滤结果，然后选择结果的一个或多个元素。点击 OK 之后，选中的元素将传输到下一个命令。","text":"在PowerShell 3.0中，Out-GridView 终于可以被改为一个多功能选择对话框——只要增加一个新的参数 -PassThru 就可以看到效果： $Title = &apos;Select one or more files to open&apos; Get-ChildItem -Path $env:windir -Filter *.log | Out-GridView -PassThru -Title $title | ForEach-Object { notepad $_.FullName } 您可以通过管道将任何对象传给 Out-GridView。用户可以从界面中选择输出结果的一部分，或者用关键词过滤结果，然后选择结果的一个或多个元素。点击 OK 之后，选中的元素将传输到下一个命令。 本文国际来源：Turn Out-GridView into Selection Dialog","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 3个最有用的ISE技巧","slug":"three-most-useful-ise-tricks","date":"2013-09-15T16:00:00.000Z","updated":"2017-03-17T15:26:22.002Z","comments":true,"path":"2013/09/16/three-most-useful-ise-tricks/","link":"","permalink":"http://blog.vichamp.com/2013/09/16/three-most-useful-ise-tricks/","excerpt":"如果您在使用PowerShell 3.0和ISE编辑器，那么您必须知道以下3个最有用的技巧： 按 CTRL+J 打开一系列包含 loops、conditions、functions 以及 workflows 等内置代码片段的清单。这个技巧可以帮助您快速起步。 当您选取一段代码后，按下 F8 将执行选中部分的代码。这个技巧在被注释的区域里也可以使用。所以您可以用 &lt;# 和 #&gt; 将一些代码注释掉，当需要执行的时候，选中它们并按下 F8 键。 若要获得cmdlet的上下文帮助，点击脚本中的cmdlet并按 F1 键。","text":"如果您在使用PowerShell 3.0和ISE编辑器，那么您必须知道以下3个最有用的技巧： 按 CTRL+J 打开一系列包含 loops、conditions、functions 以及 workflows 等内置代码片段的清单。这个技巧可以帮助您快速起步。 当您选取一段代码后，按下 F8 将执行选中部分的代码。这个技巧在被注释的区域里也可以使用。所以您可以用 &lt;# 和 #&gt; 将一些代码注释掉，当需要执行的时候，选中它们并按下 F8 键。 若要获得cmdlet的上下文帮助，点击脚本中的cmdlet并按 F1 键。 本文国际来源：Vertical Grid View","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 竖排的网格视图","slug":"vertical-grid-view","date":"2013-09-12T16:00:00.000Z","updated":"2017-03-17T15:26:22.002Z","comments":true,"path":"2013/09/13/vertical-grid-view/","link":"","permalink":"http://blog.vichamp.com/2013/09/13/vertical-grid-view/","excerpt":"效果图： 您总是可以将多个对象通过管道输出到 Out-GridView 并且得到一个美观的窗口，窗口中含有一个表格，表格中的每一行对应对象所有属性。当您需要显示很多对象的时候这种做法十分有效。 如果您只是希望显示单个对象的所有属性，那么显示为一个竖排的表格则更为美观。实际上您可以通过名为 PropertyGrid 的控件来实现。以下是相应的方法：","text":"效果图： 您总是可以将多个对象通过管道输出到 Out-GridView 并且得到一个美观的窗口，窗口中含有一个表格，表格中的每一行对应对象所有属性。当您需要显示很多对象的时候这种做法十分有效。 如果您只是希望显示单个对象的所有属性，那么显示为一个竖排的表格则更为美观。实际上您可以通过名为 PropertyGrid 的控件来实现。以下是相应的方法： Function Show-Object { param ( [Parameter(Mandatory=$true,ValueFromPipeline=$true)] [Object] $InputObject, $Title ) Add-Type -AssemblyName system.Windows.Forms Add-Type -AssemblyName system.Drawing if (!$Title) { $Title = &quot;$InputObject&quot; } $Form = New-Object &quot;System.Windows.Forms.Form&quot; $Form.Size = New-Object System.Drawing.Size @(600,600) $PropertyGrid = New-Object System.Windows.Forms.PropertyGrid $PropertyGrid.Dock = [System.Windows.Forms.DockStyle]::Fill $Form.Text = $Title $PropertyGrid.SelectedObject = $InputObject $PropertyGrid.PropertySort = &apos;Alphabetical&apos; $Form.Controls.Add($PropertyGrid) $Form.TopMost = $true $null = $Form.ShowDialog() } 现在，您可以将任何对象通过管道输出至 Show-Object，它将显示一个竖排的属性网格（PropertyGrid）。更有趣的是，所有可写的对象都被加粗，并且您的的确确可以在网格中修改这些值（注意，改变值有可能很危险）。并且许多对象，当您选择一个属性，将在状态条上显示详细的描述信息： Get-Process -id $pid | Show-Object $host | Show-Object Get-Item -Path $pshome\\powershell.exe | Show-Object 本文国际来源：Vertical Grid View","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 通过F12键跳转到函数定义","slug":"go-to-function-definition-on-f12","date":"2013-09-11T16:00:00.000Z","updated":"2017-03-17T15:26:21.986Z","comments":true,"path":"2013/09/12/go-to-function-definition-on-f12/","link":"","permalink":"http://blog.vichamp.com/2013/09/12/go-to-function-definition-on-f12/","excerpt":"如果您将要编写又长又复杂，有很多函数的PowerShell代码，那么这篇文章对您有所帮助。在其它开发环境中，当您将光标停在一个函数上，并按下F12键，编辑器将跳转到函数的定义处。而PowerShell ISE并不会那么做。 然而，您可以为ISE增加这个功能。以下代码将在 AddOns 菜单处增加一个新的 Find Definition 命令，并且为其绑定键盘的 F12 热键。 下一次您在一大段脚本中点击某个函数，ISE将直接导航到该函数的定义处（当函数在脚本内定义时）。 function Find-Definition { $e = $psISE.CurrentFile.Editor $Column = $e.CaretColumn $Line = $e.CaretLine $AST = [Management.Automation.Language.Parser]::ParseInput($e.Text,[ref]$null,[ref]$null) $AST.Find({param($ast) ($ast -is [System.Management.Automation.Language.CommandAst]) -and (($ast.Extent.StartLineNumber -lt $Line -and $ast.Extent.EndLineNumber -gt $line) -or ($ast.Extent.StartLineNumber -eq $Line -and $ast.Extent.StartColumnNumber -le $Column) -or ($ast.Extent.EndLineNumber -eq $Line -and $ast.Extent.EndColumnNumber -ge $Column))}, $true) | Select-Object -ExpandProperty CommandElements | ForEach-Object { $name = $_.Value $AST.Find({param($ast) ($ast -is [System.Management.Automation.Language.FunctionDefinitionAst]) -and ($ast.Name -eq $name)}, $true) | Select-Object -Last 1 | ForEach-Object { $e.SetCaretPosition($_.Extent.StartLineNumber,$_.Extent.StartColumnNumber) } } } $psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add(&quot;Goto Definition&quot;,{Find-Definition},&apos;F12&apos;)","text":"如果您将要编写又长又复杂，有很多函数的PowerShell代码，那么这篇文章对您有所帮助。在其它开发环境中，当您将光标停在一个函数上，并按下F12键，编辑器将跳转到函数的定义处。而PowerShell ISE并不会那么做。 然而，您可以为ISE增加这个功能。以下代码将在 AddOns 菜单处增加一个新的 Find Definition 命令，并且为其绑定键盘的 F12 热键。 下一次您在一大段脚本中点击某个函数，ISE将直接导航到该函数的定义处（当函数在脚本内定义时）。 function Find-Definition { $e = $psISE.CurrentFile.Editor $Column = $e.CaretColumn $Line = $e.CaretLine $AST = [Management.Automation.Language.Parser]::ParseInput($e.Text,[ref]$null,[ref]$null) $AST.Find({param($ast) ($ast -is [System.Management.Automation.Language.CommandAst]) -and (($ast.Extent.StartLineNumber -lt $Line -and $ast.Extent.EndLineNumber -gt $line) -or ($ast.Extent.StartLineNumber -eq $Line -and $ast.Extent.StartColumnNumber -le $Column) -or ($ast.Extent.EndLineNumber -eq $Line -and $ast.Extent.EndColumnNumber -ge $Column))}, $true) | Select-Object -ExpandProperty CommandElements | ForEach-Object { $name = $_.Value $AST.Find({param($ast) ($ast -is [System.Management.Automation.Language.FunctionDefinitionAst]) -and ($ast.Name -eq $name)}, $true) | Select-Object -Last 1 | ForEach-Object { $e.SetCaretPosition($_.Extent.StartLineNumber,$_.Extent.StartColumnNumber) } } } $psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add(&quot;Goto Definition&quot;,{Find-Definition},&apos;F12&apos;) 本文国际来源：Go to Function Definition on F12","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 增加新的类型加速器","slug":"adding-new-type-accelerators-in-powershell","date":"2013-09-10T16:00:00.000Z","updated":"2017-03-17T15:26:21.986Z","comments":true,"path":"2013/09/11/adding-new-type-accelerators-in-powershell/","link":"","permalink":"http://blog.vichamp.com/2013/09/11/adding-new-type-accelerators-in-powershell/","excerpt":"如果您发现您常常使用某些.NET类型，您可能会希望创建一些快捷方式，使您的生活变得更简单。 例如，System.IO.Path .NET类型有许多常用的路径功能： [System.IO.Path]::GetExtension(&apos;c:\\test.txt&apos;) [System.IO.Path]::ChangeExtension(&apos;c:\\test.txt&apos;, &apos;bak&apos;) 如果您觉得每次为了这个.NET类型敲入长长的代码太辛苦，只需要用这种方式增加一个快捷方式： [PSObject].Assembly.GetType(&quot;System.Management.Automation.TypeAccelerators&quot;)::Add(&apos;Path&apos;, [System.IO.Path]) 现在，您可以通过 Path 快捷方式获得完全一样的功能： [Path]::GetExtension(&apos;c:\\test.txt&apos;) [Path]::ChangeExtension(&apos;c:\\test.txt&apos;, &apos;bak&apos;) 要查看一个类型所支持的所有方法和属性，用以下的代码： [Path] | Get-Member -Static","text":"如果您发现您常常使用某些.NET类型，您可能会希望创建一些快捷方式，使您的生活变得更简单。 例如，System.IO.Path .NET类型有许多常用的路径功能： [System.IO.Path]::GetExtension(&apos;c:\\test.txt&apos;) [System.IO.Path]::ChangeExtension(&apos;c:\\test.txt&apos;, &apos;bak&apos;) 如果您觉得每次为了这个.NET类型敲入长长的代码太辛苦，只需要用这种方式增加一个快捷方式： [PSObject].Assembly.GetType(&quot;System.Management.Automation.TypeAccelerators&quot;)::Add(&apos;Path&apos;, [System.IO.Path]) 现在，您可以通过 Path 快捷方式获得完全一样的功能： [Path]::GetExtension(&apos;c:\\test.txt&apos;) [Path]::ChangeExtension(&apos;c:\\test.txt&apos;, &apos;bak&apos;) 要查看一个类型所支持的所有方法和属性，用以下的代码： [Path] | Get-Member -Static 本文国际来源：Adding New Type Accelerators in Powershell","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 查找类型加速器","slug":"finding-type-accelerators","date":"2013-09-09T16:00:00.000Z","updated":"2017-03-17T15:26:21.986Z","comments":true,"path":"2013/09/10/finding-type-accelerators/","link":"","permalink":"http://blog.vichamp.com/2013/09/10/finding-type-accelerators/","excerpt":"PowerShell维护着一系列.NET类型的缩写，使您编写代码更加自如。例如要将一个字符串转换成DateTime类型，您可以这样写： [DateTime] &apos;2013-07-02&apos; 它的幕后机制只是一个名为 System.DateTime 类型的缩写。您可以通过 FullName 属性查看这些缩写实际上代表的类型： [DateTime].FullName 若要获取所有支持的“类型加速器”（缩写），您可以使用以下代码。这段代码返回PowerShell实现的所有加速器。这段代码十分有用，因为它列出了PowerShell开发者认为十分重要的所有.NET内部类型。 [PSObject].Assembly.GetType(&quot;System.Management.Automation.TypeAccelerators&quot;)::Get | Sort-Object -Property Value 当您将结果通过管道输出到一个grid view窗口时，您可以方便地搜索类型加速器。只需要在grid view窗口顶部的搜索框内键入类型名的一部分即可： [PSObject].Assembly.GetType(&quot;System.Management.Automation.TypeAccelerators&quot;)::Get | Sort-Object -Property Value | Out-GridView","text":"PowerShell维护着一系列.NET类型的缩写，使您编写代码更加自如。例如要将一个字符串转换成DateTime类型，您可以这样写： [DateTime] &apos;2013-07-02&apos; 它的幕后机制只是一个名为 System.DateTime 类型的缩写。您可以通过 FullName 属性查看这些缩写实际上代表的类型： [DateTime].FullName 若要获取所有支持的“类型加速器”（缩写），您可以使用以下代码。这段代码返回PowerShell实现的所有加速器。这段代码十分有用，因为它列出了PowerShell开发者认为十分重要的所有.NET内部类型。 [PSObject].Assembly.GetType(&quot;System.Management.Automation.TypeAccelerators&quot;)::Get | Sort-Object -Property Value 当您将结果通过管道输出到一个grid view窗口时，您可以方便地搜索类型加速器。只需要在grid view窗口顶部的搜索框内键入类型名的一部分即可： [PSObject].Assembly.GetType(&quot;System.Management.Automation.TypeAccelerators&quot;)::Get | Sort-Object -Property Value | Out-GridView 本文国际来源：Finding Type Accelerators","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 汇总索引","slug":"index","date":"2013-09-08T16:00:00.000Z","updated":"2017-03-17T15:26:21.970Z","comments":true,"path":"2013/09/09/index/","link":"","permalink":"http://blog.vichamp.com/2013/09/09/index/","excerpt":"","text":"2013 年2013 年 09 月 2013-09-04 处理文件系统路径(第1部分) 2013-09-05 处理文件系统路径(第2部分) 2013-09-06 处理文件系统路径(第3部分) 2013-09-09 多个返回值 2013-09-10 查找类型加速器 2013-09-11 增加新的类型加速器 2013-09-12 通过F12键跳转到函数定义 2013-09-13 竖排的网格视图 2013-09-16 3个最有用的ISE技巧 2013-09-17 将Out-GridView改造为选择对话框 2013-09-18 将结果复制到剪贴板 2013-09-19 PowerShell函数的详细输出 2013-09-20 在文件管理器中显示隐藏文件 2013-09-23 创建硬连接 2013-09-24 检查管理员权限 2013-09-25 创建符号链接 2013-09-26 检测显示器亮度 2013-09-27 设置显示器亮度 2013-09-30 通过关键词查找脚本 2013 年 10 月 2013-10-01 通过CSV创建对象 2013-10-02 查找所有用户脚本 2013-10-03 将Excel导出的CSV转换为UTF-8编码 2013-10-04 检查磁盘分区和数据块大小 2013-10-08 密码混淆器脚本 2013-10-09 发生了什么？ 2013-10-10 创建日历（和日期列表） 2013-10-11 从ISE编辑器中粘贴 PowerShell 代码 2013-10-14 查找 Cmdlet 2013-10-15 在 ISE 中重设 PowerShell 宿主 2013-10-16 查找 Active Directory 用户账号 2013-10-17 获取 Active Directory 账户信息 2013-10-18 查找当前的脚本文件夹 2013-10-21 将二进制 SID 转换为 SID 字符串 2013-10-22 从 DN 中获得 Domain 2013-10-23 在不同的 Domain 中查找 2013-10-24 通过 SID 查找 Active Directory 账户 2013-10-25 快速查找 Active Directory 用户账户 2013-10-28 在智能感知中隐藏参数 2013-10-29 获取 1000 个以上 Active Directory 结果 2013-10-30 在 PowerShell 中查找服务 2013-10-31 怪异的文本格式化（以及解决方法） 2013 年 11 月 2013-11-01 替换文本中的指定字符 2013-11-04 PowerShell 4.0 中的动态参数 2013-11-05 PowerShell 4.0 中的动态方法 2013-11-06 查找缺省的 Outlook 配置文件 2013-11-07 将单词首字母转换为大写 2013-11-08 导出和导入 PowerShell 历史 2013-11-11 自动找借口的脚本 2013-11-12 查找缺少邮箱地址的 Active Directory 用户 2013-11-13 键盘技巧 2013-11-14 按 F1 跳转到 PowerShell 帮助主题 2013-11-15 监测日志文件 2013-11-18 以不同用户运行 PowerShell 2013-11-20 安装 Windows Server 2012 桌面体验 2013-11-21 自动加载 Module 2013-11-22 改进版的自动加载 Module 2013-11-25 列出“真实”的硬盘 2013-11-26 获取 WMI 智能感知信息 2013-11-27 访问终极 PowerShell 生存指南 2013-11-28 加速多个 WMI 查询 2013-11-29 在 ISE 中快速选中结果 2013 年 12 月 2013-12-02 访问所有用户的桌面 2013-12-03 远程执行代码 2013-12-04 获取 DLL 文件版本信息 2013-12-05 查找已知的 USB 驱动器 2013-12-06 通过前缀对文件夹分组 2013-12-09 创建一个文件夹选择器 2013-12-10 混淆凭据 2013-12-11 创建临时密码 2013-12-12 锁定屏幕 2013-12-13 为 AD 用户设置缺省的 Email 地址 2013-12-16 查找磁盘分区详细信息 2013-12-17 显示 Path 环境变量 2013-12-18 使用 PowerShell 管理 Office365 2013-12-19 将 Windows 8.1 中的 CMD.EXE 替换为 POWERSHELL.EXE 2013-12-20 获取本地组成员 2013-12-23 搜索本地用户 2013-12-24 在 Windows 8.1 中管理 Windows Defender 2013-12-25 搜索并观看 PowerShell 视频 2013-12-26 获取昨天午夜的日期值 2013-12-27 有序哈希表以及更改顺序 2013-12-30 从多个事件日志中获取错误事件 2013-12-31 获取最新的地震信息 2014 年2014 年 01 月 2014-01-01 PowerShell 远程管理和大尺寸令牌问题 2014-01-02 降低 PowerShell 进程优先级 2014-01-03 使用 ICACLS 提高文件夹安全性 2014-01-06 获取系统信息 2014-01-06 远程启动服务 2014-01-08 获取远程主机的系统信息 2014-01-09 在 ISE 编辑器中使用块注释 2014-01-10 更改桌面背景 2014-01-13 查询登录失败记录 2014-01-14 查询已登录的用户 2014-01-15 查找远程计算机上已登录的用户 2014-01-16 在 PowerShell ISE 中使用块注释 2014-01-17 在 ISE 编辑器中打开文件 2014-01-20 PowerShell 4.0 中隐藏的数组扩展方法 2014-01-21 删除空结果 2014-01-22 解锁下载的文件 2014-01-23 启动任何版本的 Excel 2014-01-24 快速创建新的本地管理员账户 2014-01-27 读写 NTFS 流 2014-01-28 根据主机名获取 DNS IP 地址 2014-01-29 当发生错误时播放一段声音 2014-01-30 Ping 主机 2014-01-31 单行内为多个变量赋值 2014 年 02 月 2014-02-03 朗读英文和德文（以及西班牙文，或您指定的语言） 2014-02-04 检测合法的时间 2014-02-05 用逗号作为十进制数分隔符 2014-02-06 带对话框的必选参数 2014-02-07 设置（及删除）环境变量 2014-02-10 读取注册表的可扩充字符串值 2014-02-11 从 PFX 文件中导入证书 2014-02-12 确保向后兼容 2014-02-13 在 Remoting 中使用完整限定名 2014-02-14 从 PFX 文件中导入多个证书 2014-02-17 在 PowerShell ISE 中创建干净的测试环境 2014-02-18 正确地按日期时间筛选 2014-02-19 用 PowerShell 为 VBScript 文件签名 2014-02-20 使用 $PSScriptRoot 加载资源 2014-02-21 持有一个进程的句柄 2014-02-24 过滤命令输出的文本 2014-02-25 使用别名来启动 Windows 组件 2014-02-26 展开字符串中的变量 2014-02-27 用 Select-Object -First 节省时间！ 2014-02-28 为对象增加信息 2014 年 03 月 2014-03-03 担心隐藏的输入密码请求 2014-03-04 消除重复 2014-03-05 轻松地格式化数字 2014-03-06 字符串左右对齐 2014-03-07 自动连接到公共热点 2014-03-09 查找一个时间点附近的日志 2014-03-11 导出数据到 Excel 2014-03-12 查找昨天以来的错误 2014-03-13 查找空闲容量低的硬盘驱动器 2014-03-14 以 GB 和百分比的形式显示驱动器容量 2014-03-17 查找无线网卡 2014-03-18 获取无线网卡 2014-03-19 在 PowerShell 中提升命令权限 2014-03-20 获取系统信息 2014-03-21 应用 NTFS 存取权限 2014-03-24 传递参数给 EXE 文件 2014-03-25 查找过期的证书 2014-03-26 获取时间服务器（以及读取所有注册表键值） 2014-03-27 查找 U 盘信息 2014-03-28 用 PowerShell 导入导出凭据 2014-03-31 启用传统远程控制 2014 年 04 月 2014-04-01 启用 PowerShell 远程管理 2014-04-02 验证 UNC 路径 2014-04-03 使用加密文件系统（EFS）来保护密码 2014-04-04 存储秘密数据 2014-04-07 读取整个文本文件 2014-04-08 修正 Excel CSV 的编码 2014-04-09 记录脚本的运行时间 2014-04-10 将 Tick 转换为真实的日期 2014-04-11 PowerShell 中的并行处理 2014-04-14 高效运行后台任务 2014-04-15 从所有事件日志中获取全部事件 2014-04-16 屏蔽终止性错误 2014-04-17 捕获非终止性错误 2014-04-18 记录所有错误 2014-04-21 将日志写入自定义的事件日志 2014-04-22 智能感知显示变量的技巧 2014-04-23 查找注册的事件源 2014-04-24 从 Google 图片搜索中获取图片 URL 2014-04-25 通过 Google 图片搜索自动下载图片 2014-04-28 弹出对话框时播放随机的音效 2014-04-29 从命令行中提取可执行程序名 2014-04-30 从命令行获取参数 2014 年 05 月 2014-05-01 查找缺省的 MAPI 客户端 2014-05-02 通过 Outlook 发送电子邮件 2014-05-05 显示 WPF 消息提示 2014-05-06 键盘鼠标自动化 2014-05-07 更新 Windows Defender 病毒定义 2014-05-08 获取父作用域中的变量值 2014-05-09 用 JSON 来创建对象 2014-05-12 PowerShell 不支持 JSON 数据类型 2014-05-13 创建 Excel 报表 2014-05-14 修正 Excel 报表中的显示 2014-05-15 批量重命名对象的属性 2014-05-16 ISE 的缺陷导致调试器阻塞 2014-05-19 将文本数组转换为字符串 2014-05-20 添加或重置 NTFS 权限 2014-05-21 编译二进制 Cmdlet 2014-05-22 开始学习 DSC 2014-05-23 获取免费的速查表 2014-05-26 检查 Windows 更新 2014-05-27 PowerShell 上帝模式 2014-05-28 移除选定的 NTFS 权限 2014-05-29 阻止非管理员权限运行脚本 2014-05-30 设置注册表权限 2014 年 06 月 2014-06-02 快速获取成员身份 2014-06-03 用 Splatting 技术提交参数 2014-06-04 用 Splatting 技术封装 WMI 调用 2014-06-05 获取数据库连接字符串 2014-06-06 远程执行 gpupdate 2014-06-09 远程读取已安装的软件 2014-06-10 从照片中读取拍摄日期 2014-06-11 批量重命名文件 2014-06-12 留意副作用 2014-06-13 使用配置脚本 2014-06-16 通过按键跳过配置脚本 2014-06-17 有趣的路径名 2014-06-18 不中断处理 Cmdlet 中的错误 2014-06-19 轻松读取注册表键值 2014-06-20 用事件日志代替日志文件 2014-06-23 加速数组操作 2014-06-24 使用嵌套的哈希表 2014-06-25 处理环境变量 2014-06-26 使用 break、continue 和 return 语句 2014-06-27 理解 exit 语句 2014-06-30 加速后台任务 2014 年 07 月 2014-07-01 为什么目录的大小为 1 2014-07-02 列出工作日 2014-07-03 通过 StringBuilder 加速脚本 2014-07-04 使用缺省参数 2014-07-07 查找两个日期之间的所有日子 2014-07-08 复制命令行历史记录 2014-07-09 复制命令行历史的工具函数 2014-07-10 简单地读取注册表值 2014-07-11 接受多重输入 2014-07-14 创建优越的报告 2014-07-15 从独立的文件中加载函数 2014-07-16 快速查找 AD 账户 2014-07-17 删除别名 2014-07-18 测试不带别名的脚本 2014-07-21 转换特殊字符（第一部分） 2014-07-22 转换特殊字符（第二部分） 2014-07-23 别名有可能带来风险 2014-07-24 以底层的方式管理打印机 2014-07-25 指定递归深度 2014-07-28 使系统休眠 2014-07-29 修正名单中的大小写 2014-07-30 修正 PowerShell 中的路径 2014-07-31 查找并提取注册表键的路径 2014 年 08 月 2014-08-01 查找 AD 用户 2014-08-04 请注意 UNC 路径！ 2014-08-05 编辑“hosts”文件 2014-08-06 产生多个返回值 2014-08-07 有趣的声音提示 2014-08-08 记录脚本做了什么事 2014-08-11 用 PowerShell 来励志 2014-08-12 用 Group-Object 来创建哈希表 2014-08-13 使用“打开文件”对话框 2014-08-14 修正 ISE 的编码 2014-08-15 获取指定扩展名的文件 2014-08-18 用正则表达式搜索文件 2014-08-19 复制命令行历史 2014-08-20 获取关机信息 2014-08-21 过滤 Hotfix 信息 2014-08-22 理解顺序过滤 2014-08-25 获取睡眠或休眠的时间 2014-08-26 获取 WMI 设备清单 2014-08-27 测试服务的响应性 2014-08-28 查找插入的 U 盘 2014-08-29 获取系统开机时长 2014 年 09 月 2014-09-01 播放 WAV 声音 2014-09-02 使用 -f 操作符合并字符串和数据 2014-09-03 计算倒计时小时数 2014-09-04 合并执行结果 2014-09-05 查找最大值和最小值 2014-09-08 快速处理路径 2014-09-09 重要的数学函数 2014-09-10 同时支持可选参数和必选参数 2014-09-11 忽略输出结果 2014-09-12 移除非法的路径字符 2014-09-15 获取字符串的行数 2014-09-16 检测文本中是否含有大写字母 2014-09-17 查找脚本中的错误 2014-09-18 等待按键 2014-09-19 下载 PowerShell 语言规范 2014-09-22 比较服务配置 2014-09-23 导出服务状态信息 2014-09-24 查找 PowerShell 函数 2014-09-25 创建短网址 2014-09-26 替换重复的空格 2014-09-29 分隔文本 2014-09-30 高级文本分隔 2014 年 10 月 2014-10-01 获取 MAC 地址 2014-10-02 通过 MAC 地址识别网卡厂家 2014-10-03 格式化行尾符 2014-10-06 重命名变量 2014-10-07 获取变量详细清单 2014-10-08 查找可改变的属性 2014-10-09 查找文件以及错误信息 2014-10-10 获取包含数据类型信息在内的注册表键值 2014-10-13 获取美国邮政编码 2014-10-14 列出所有信息 2014-10-15 WMI 搜索工具 2014-10-16 从文件中读取系统日志 2014-10-17 启用、禁用 PowerShell 远程操作 2014-10-20 在非域环境中使用 PowerShell 远程操作 2014-10-21 创建新对象 2014-10-22 伪造对象类型 2014-10-23 控制可执行文件的执行 2014-10-24 关闭“完整语言”模式 2014-10-27 创建彩色的 HTML 报告 2014-10-28 存取 SQLServer 数据库 2014-10-29 读取 PFX 证书 2014-10-30 改变 PowerShell 的优先级 2014-10-31 创建新的共享文件夹 2014 年 11 月 2014-11-03 调用记事本打印文本 2014-11-04 导入及安装证书 2014-11-05 显示 PowerShell 的命令行历史 2014-11-06 Invoke-Expression 是邪恶的 2014-11-07 用 Out-Host 代替 More 2014-11-10 用 EFS 加解密文件 2014-11-11 函数的优先级永远比 cmdlet 高 2014-11-12 在 PowerShell ISE 中使用 F1 键 2014-11-13 使用 IPv4 来 Ping 2014-11-24 用 Cmdlet 管理虚拟硬盘驱动器 2014-11-25 Join-Path 遇上不存在的驱动器会失败 2014-11-26 查看 Windows 版本 2014-11-27 读取磁盘和分区信息 2014-11-28 随机排列数字列表 2014 年 12 月 2014-12-01 数组中的空值 2014-12-02 配置 PowerShell 的步骤（第 1 部分） 2014-12-03 配置 PowerShell 的步骤（第 2 部分） 2014-12-04 PowerShell 技能连载 - 配置 PowerShell 的步骤（第 3 部分） 2014-12-05 PowerShell 技能连载 - 移除 AD 组成员 2014-12-08 根据 Excel 表批量创建 AD 用户 2014-12-09 设置 Active Directory 属性 2014-12-10 解析 DISM 日志文件 2014-12-11 查找进程所有者 2014-12-12 获取系统启动时间 2014-12-15 使用 WMI 继承 2014-12-16 捕获本地 EXE 的错误（第 1 部分） 2014-12-17 克隆 NTFS 权限 2014-12-18 用 SDDL 替换 NTFS 权限 2014-12-19 捕获本地 EXE 的错误（第 2 部分） 2014-12-22 设置 AD 或 Windows 的权限 2014-12-23 限制 String 的最大长度 2014-12-24 创建一大堆测试文件 2014-12-25 从 LDAP 路径获取 OU 2014-12-26 压缩路径 2014-12-29 处理 %ERRORLEVEL% 2014-12-30 检查 PowerShell 安全性 2014-12-31 改变 GPO 描述/备注 2015 年2015 年 01 月 2015-01-01 处理隐藏文件 2015-01-02 不通过 ProgID 操作 COM 对象 2015-01-05 查找非继承的权限 2015-01-06 创建 NTFS 安全报告 2015-01-07 检测 64 位操作系统 2015-01-08 条件断点 2015-01-09 解析 IP 地址（和参数类型） 2015-01-12 在输出中使用系统的错误颜色 2015-01-13 映射驱动器 2015-01-14 将代码转为大写 2015-01-15 简化 .NET 类型 2015-01-16 管理打印机 2015-01-19 远程更新组策略 2015-01-20 列出所有打印任务 2015-01-21 分析并移除打印任务 2015-01-22 要求管理员权限 2015-01-23 读取多行文本 2015-01-26 用 Cmdlet 来管理 MSI 安装包 2015-01-27 在线检测 DELL 保修 2015-01-28 获取计算机序列号 2015-01-29 复制命令行历史 2015-01-30 自动展开和内存消耗 2015 年 02 月 2015-02-02 凭据混淆器 2015-02-03 管理终端服务设置 2015-02-04 记录拒绝存取的文件夹 2015-02-05 使用打开文件夹对话框 2015-02-06 为必须的参数弹出一个对话框 2015-02-09 有用的静态 .NET 方法 2015-02-10 查找 AD 复制失败信息 2015-02-11 将 PowerShell 工具增加到 Windows 8 启动屏幕 2015-02-12 获得一个干净的 PowerShell 环境 2015-02-13 导出 Out-GridView 的内容 2015-02-16 查找所有可停止的服务 2015-02-17 Out-GridView：通用对话框 2015-02-18 将结果复制到剪贴板 2015-02-19 进程终结器（和一些陷阱） 2015-02-20 在 ISE 中使用代码区域 2015-02-23 使用 PowerShell ISE 调试器 2015-02-24 将文件的扩展名正常化 2015-02-25 获取 DELL 保修信息（第二部分） 2015-02-26 简化命令提示符 2015-02-27 使用数组作为参数的缺省值 2015 年 03 月 2015-03-02 使用基于 JSON 的 Web Service 2015-03-03 查找进程所有者 2015-03-04 PowerShell ISE 自动化 2015-03-05 播放 WAV 文件 2015-03-06 用 Finally 来处理关键的清理任务 2015-03-09 检测 Wi-Fi 适配器和电源 2015-03-10 随时获取 cmdlet 的帮助 2015-03-11 禁止确认信息 2015-03-12 展开对象数据结构 2015-03-13 检查网站的响应（和执行时间） 2015-03-16 用 PowerShell 打开网页 2015-03-17 根据类型对数据排序 2015-03-18 从注册表中读取文件扩展名关联（第一部分） 2015-03-19 从注册表中读取文件扩展名关联（第二部分） 2015-03-20 从注册表中读取用户配置文件 2015-03-23 在 PowerShell ISE 中使用“more” 2015-03-24 在脚本中包含资源 2015-03-25 使用常量 2015-03-26 只读及强类型变量 2015-03-27 查找只读型和常量型变量 2015-03-30 访问非 Microsoft LDAP 服务 2015-03-31 ISE 自动完成技巧 2015 年 04 月 2015-04-01 发现高影响级别 cmdlet 2015-04-02 智能参数验证 2015-04-03 查找 Exchange 邮箱 2015-04-06 用 Windows 加密信息 2015-04-07 用口令对文本信息加密 2015-04-08 查找所有活动的驱动器号 2015-04-09 对密码加密 2015-04-10 批量重命名文件 2015-04-13 比较文件夹内容 2015-04-14 查找电视剧信息 2015-04-15 读取注册表键值和值类型 2015-04-16 读取 RSS 频道 2015-04-17 使用 Splatting 技术 2015-04-20 安全使用 UNC 路径 2015-04-21 验证域凭据 2015-04-22 获取当前 IP 地址 2015-04-23 获取 IP 地址的地理信息 2015-04-24 检测危险的 NTFS 权限 2015-04-27 理解 break、continue、return 和 exit 语句 2015-04-28 为什么“exit”将会关掉 PowerShell 2015-04-29 从 PowerShell 脚本中接收错误返回值 2015-04-30 移除空白（和换行） 2015 年 05 月 2015-05-01 禁止更新后自动重启 2015-05-04 谁在使用网络资源？ 2015-05-05 将 CSV 转换为 Excel 文件 2015-05-06 面向管理员的免费 PowerShell 模块 2015-05-07 向管道传递一个数组 2015-05-08 跳出管道 2015-05-11 解析 PowerShell 脚本 2015-05-12 互斥参数 (1) 2015-05-13 互斥参数 (2) 2015-05-14 使用闭包将变量保持在脚本块内 2015-05-15 获取内存消耗值 2015-05-18 “Continue” 和标签 2015-05-19 跳出管道 2015-05-20 测试嵌套深度 2015-05-21 在控制台输出中使用符号 2015-05-22 在控制台输出中使用绿色的复选标记 2015-05-25 查找大写字符 2015-05-26 根据大写字符分割文本 2015-05-27 查找可执行程序 2015-05-28 在后台播放声音 2015-05-29 使用 PowerShell 的帮助窗口作为通用输出 2015 年 06 月 2015-06-01 显示函数参数 2015-06-02 分割超长代码行 2015-06-03 创建一个包含 NTFS 权限的文件夹 2015-06-04 管理 NTFS 权限 2015-06-05 获取非继承的 NTFS 权限 2015-06-08 移除非继承的 NTFS 权限 2015-06-09 管理 NTFS 权限继承 2015-06-10 创建动态脚本块 2015-06-11 安装 Windows 功能 2015-06-12 获取 CPU 核心和处理器信息 2015-06-15 如何查找包含指定参数的命令 2015-06-16 加载 PowerShell 模块 2015-06-17 从 PSSnapin 中加载 cmdlet 2015-06-18 刷新新挂载的磁盘 2015-06-19 查找最重要的错误系统日志 2015-06-22 分析（所有）事件日志源 2015-06-23 快捷循环 2015-06-24 列出所有脚本中的所有变量 2015-06-25 将“列出所有变量”功能加入 PowerShell 2015-06-26 获取 Active Directory 用户名 2015-06-29 打开网页 2015-06-30 创建“结束进程”应用 2015 年 07 月 2015-07-01 创建友好的“结束进程”应用程序 2015-07-02 将过期的日志存档 2015-07-03 加密文本 2015-07-06 设置本地 Administrator 账号的密码 2015-07-07 AD 操作自动化入门 2015-07-08 批量删除 AD 的防意外删除保护 2015-07-09 设置 AD 账号的过期时间 2015-07-10 使用 PowerShell 的帮助 2015-07-13 简单的 AD 组管理 2015-07-14 将命令历史保存到文件 2015-07-15 复制 Active Directory 安全设置 2015-07-16 向 AD 对象增加自定义属性 2015-07-17 更新 Active Directory 中的办公电话号码 2015-07-20 获取 SQL Server 连接字符串 2015-07-21 通过连接字符串访问 SQL 数据库 2015-07-22 查找物理登录的用户 2015-07-23 查找登录的用户 2015-07-24 测试一个网络端口 2015-07-27 查找打开了 PowerShell 远程操作功能的计算机 2015-07-28 解压 ZIP 文件 2015-07-29 在 PowerShell 3.0 和 4.0 中解压 ZIP 文件 2015-07-30 在任意 Powershell 版本中解压 ZIP 文件 2015-07-31 改变 ISE 缩放比例 2015 年 08 月 2015-08-03 查找带动态参数的 cmdlet 2015-08-04 发现动态参数 2015-08-05 当前脚本的路径 2015-08-06 定义多行文本 2015-08-07 解码 PowerShell 命令 2015-08-10 避免使用重定向符 2015-08-11 截短文本 2015-08-12 快速获取 IP 地址 2015-08-13 删除数组元素 2015-08-14 简单的 INI 文件替代 2015-08-17 向原始数据类型增加额外信息 2015-08-18 向对象增加额外信息 2015-08-19 隐藏变量内容 2015-08-20 快速查找脚本 2015-08-21 快速设置多个环境变量 2015-08-24 查找驱动器号 2015-08-25 以管理员身份执行指定的代码 2015-08-26 指定执行超时 2015-08-27 映射网络驱动器（第 1 部分） 2015-08-28 映射网络驱动器（第 2 部分） 2015-08-31 映射网络驱动器（第 3 部分） 2015 年 09 月 2015-09-02 只用一行代码创建新对象 2015-09-02 列出（并检查）PowerShell 用户配置 2015-09-03 逐行显示对象的属性 2015-09-04 通用属性和可选的通用属性 2015-09-07 输出的同时赋值 2015-09-08 定义缺省参数 2015-09-09 在 PowerShell ISE 中使用 PowerShell Tabs 2015-09-10 向 PowerShell ISE 添加测试宿主 2015-09-11 创建真实的类 2015-09-14 用 ProcessID 定位服务 2015-09-15 分析 svchost 进程 2015-09-16 访问网页内容 2015-09-17 为什么 Invoke-Expression 是邪恶的 2015-09-18 将哈希表用作条件化的代码库 2015-09-21 下载文件 2015-09-22 设置新的 Windows 注册所有者 2015-09-23 修正远程发送者信息 2015-09-24 移除 Windows 10 应用 2015-09-25 使用后台任务 2015-09-28 用 try..finally 在 PowerShell 关闭时执行代码 2015-09-29 使用编码的脚本 2015-09-30 复制数组（第 1 部分） 2015 年 10 月 2015-10-01 复制数组（第 2 部分） 2015-10-02 复制对象 2015-10-05 获取最后启动时间 2015-10-06 增加历史缓存 2015-10-07 复制命令历史 2015-10-08 为什么 $MaximumHistoryCount 容量有限 2015-10-09 为变量增加 ValidateRange 2015-10-12 快速创建编码的 PowerShell 命令 2015-10-13 删除别名 2015-10-14 为什么 GetTempFileName() 是有害的 2015-10-15 创建临时文件名 2015-10-16 简化参数属性 2015-10-19 查找 cmdlet 参数别名 2015-10-20 查找已加载的程序集 2015-10-21 自动修正 PowerShell 代码的大小写 2015-10-22 增加“命令未找到”处理器 2015-10-23 试试 CTRL+SPACE！ 2015-10-26 帮助 PowerShell 做得更好！ 2015-10-27 在命令提示符中显示路径 2015-10-28 为什么捕获不到某些错误 2015-10-29 查看操作系统版本 2015-10-30 和 Powershell 对话 2015 年 11 月 2015-11-05 将数字列表转换为有用的列表 2015-11-06 尽可能使用服务端过滤 2015-11-09 显示消息对话框 2015-11-10 从注册表中读取已安装的软件 2015-11-11 远程获取已安装的软件列表 2015-11-12 查找脚本块变量 2015-11-13 根据参数值执行不同的代码 2015-11-16 等待进程启动 2015-11-17 转换日期、时间格式 2015-11-18 以不同的格式输出文件大小 2015-11-19 使用网格窗口作为一个通用的对话框 2015-11-20 从 WMI 中搜索有用的信息 2015-11-23 将结果通过管道直接传给 Office Word 2015-11-24 为大量文件建立拷贝备份 2015-11-25 理解 -f 操作符 2015 年 12 月 2015-12-22 根据 OU 分析操作系统 2015-12-23 获取操作系统清单 2015-12-24 查询当前登录的用户名 2015-12-25 自动获取重要的支持响应信息 2015-12-28 强制用户修改密码 2015-12-29 清除回收站 2015-12-30 查找递归的 AD 成员 2015-12-31 管理 Windows 防火墙 2016 年2016 年 01 月 2016-01-01 用 Base64 编解码文本 2016-01-04 对图片编码 2016-01-05 用 WPF 窗口加载 Base64 编码的图片 2016-01-06 理解 PowerShell 的流 2016-01-07 使用 DCOM 协议运行 Get-CimInstance 2016-01-08 通过哈希表转换创建新的对象 2016-01-11 查找当前文件系统路径 2016 年 02 月 2016-02-02 处理数据（第 1 部分） 2016-02-03 处理数据（第 2 部分） 2016-02-04 处理数据（第 3 部分） 2016-02-05 将窗口置于前台 2016-02-08 统计一个 Word 文档中的页数 2016-02-09 换算货币 2016-02-10 神奇的下划线变量 2016-02-11 发送文本到记事本 2016-02-12 将对象发送到记事本 2016-02-15 谁在监听？（第一部分） 2016-02-16 谁在监听？（第二部分） 2016-02-17 得到一个借口 2016-02-18 不要混合不同的对象 2016-02-19 用 #requires 语句装饰脚本 2016-02-22 使用工作流来并发执行代码 2016-02-23 直接使用 .NET 类型 2016 年 08 月 2016-08-30 友好地使用 Robocopy 2016-08-31 替换类似 “Umlauts” 的特殊字符 2016 年 09 月 2016-09-01 通过管道输入数据 2016-09-02 替换 CSV 文件列名 2016-09-05 查找自启动项 2016-09-06 启用远程管理 2016-09-07 检查（本地和远程的）硬盘容量 2016-09-08 查看 ASCII 码 2016-09-09 Saving PowerShell User Defaults 2016-09-12 颜色之周: 设置 PowerShell ISE 控制台的颜色 2016-09-13 色彩之周: 为 PowerShell ISE 指定命名的颜色 2016-09-14 色彩之周: 设置 PowerShell ISE 的背景色 2016-09-15 色彩之周: 在 PowerShell ISE 控制台中使用透明度 2016-09-16 色彩之周: 改变错误信息颜色 2016-09-19 色彩之周: 改变 PowerShell ISE 中的错误信息颜色 2016-09-20 色彩之周: 为 PowerShell 控制台中的符号着色 2016-09-21 用秒表测定脚本执行时间 2016-09-22 显示对话框 2016-09-23 使用 UTC 时间 2016-09-26 Enum 之周: 枚举的自动转换 2016-09-27 Enum 之周: 列出枚举值 2016-09-28 Enum 之周: 理解枚举值 2016-09-29 Enum 之周: 快速关闭 Cmdlet 错误提示 2016-09-30 Enum 之周: PowerShell 5 中的枚举 2016 年 10 月 2016-10-03 查找由 DHCP 分配的 IP 地址 2016-10-04 查找 IP 地址的地理位置 2016-10-05 查找公开 IP 地址 2016-10-06 在地图上定位您的地理位置 2016-10-07 查找一个月中的第一天和最后一天 2016-10-10 在 Active Directory 中查找操作系统版本 2016-10-11 查找操作系统架构信息 2016-10-12 获取计算机的地理位置 2016-10-13 将 SID 翻译为用户名 2016-10-14 Getting List of Current Group Memberships 2016-10-17 查找隐藏的自启动程序 2016-10-18 理解二次远程连接问题 2016-10-19 用 CredSSP 解决二次远程连接 2016-10-20 在单侧启用 CredSSP 2016-10-21 PowerShell Remoting and HTTP 403 Error 2016-10-24 检查电子邮件地址（或其它文本）中的非法字符 2016-10-25 查找多个非法字符 2016-10-26 查找文件路径中的非法字符（基于文件系统） 2016-10-27 检查文件名的非法字符 2016-10-28 Cmelet 错误报告的简单策略 2016-10-31 从网站上下载图片 2016 年 11 月 2016-11-01 在 PowerShell ISE 中获得 Cmdlet 的 IntelliSense 2016-11-02 用一行代码更新 PowerShell 帮助信息 2016-11-03 获取 Cmdlet 参数的帮助 2016-11-04 （分别）测试文件和文件夹 2016-11-07 获取PowerShell Gallery 模块的最新版本 2016-11-08 利用命令行历史 2016-11-09 创建新对象的快速方法 2016-11-10 PSCustomObject 到底如何工作 2016-11-11 使用 Add-Member 时请注意！ 2016-11-14 本地帐户的内置支持 2016-11-15 systeminfo.exe 的最新替代 2016-11-16 在同一台机器上运行 32 位代码 2016-11-17 探索函数源码 2016-11-18 PowerShell 5.1 中的时区管理 2016-11-21 隐藏启动 PowerShell 2016-11-22 在 PowerShell 函数中使用命名的函数 2016-11-23 禁止按位置的参数 2016-11-24 修复 PowerShell 5 帮助的 Bug 2016-11-25 轻轻跳进 PowerShell 版本的丛林 2016-11-28 用其他身份启动程序 2016-11-29 高级错误处理：重新抛出异常 2016-11-30 捕获 Native EXE 的错误 2016 年 12 月 2016-12-01 使用自定义域 2016-12-02 使用自定义作用域来屏蔽任何输出 2016-12-05 创建文件共享 2016-12-06 同时使用 -Force 和 -WhatIf 时请注意 2016-12-07 安全地对文本加解密 2016-12-08 最常用的动词 2016-12-09 查找不合规的命令动词 2016-12-12 分析结果出现次数（不浪费内存） 2016-12-13 按属性值分割结果 2016-12-14 对启用 PIN 的用户使用 PowerShell Remoting 2016-12-15 等待进程退出 2016-12-16 创建 Time Span 2016-12-19 系统内存、单位和四舍五入 2016-12-20 检测文件或文件夹 2016-12-21 捕获 Linux 输出 2016-12-22 使用“Exit”和 Linux 通信 2016-12-23 在 PowerShell 中创建 WinForms GUI 界面 2016-12-26 复制着色过的代码 2016-12-27 扩展 Robocopy 2016-12-28 创建简单的 UI 2016-12-29 调整简单界面 2016-12-30 解析纯文本（第一部分） 2017 年2017 年 01 月 2017-01-02 解析纯文本（第二部分） 2017-01-03 解析纯文本（第三部分） 2017-01-04 管理凭据（第一部分） 2017-01-05 管理凭据（第二部分） 2017-01-06 管理凭据（第三部分） 2017-01-09 管理凭据（第四部分） 2017-01-10 管理凭据（第五部分） 2017-01-11 小心 Get-Credential 和 SecureString 2017-01-12 获取 AD 用户属性 2017-01-13 管理本地用户 2017-01-16 探索本地账户管理 cmdlet 2017-01-17 定位锁定的 AD 账户 2017-01-18 批量重命名照片 2017-01-19 明智地使用进度条 2017-01-20 隐藏进度条 2017-01-23 在资源管理器中打开 PowerShell 2017-01-24 检查整数的位数 2017-01-25 增加和删除反斜杠 2017-01-26 语音之周：使用语音讲述人 2017-01-27 语音之周：更改讲述人的语音 2017-01-30 语音之周：记录语音到文件合成器 2017-01-31 语音之周：使用语音合成器高级选项 2017 年 02 月 2017-02-01 加速 New-Object Synthesizer 2017-02-02 确定个人年龄 2017-02-03 使用命名空间 2017-02-06 使用类（创建对象 - 第一部分） 2017-02-07 使用类（初始化属性 - 第二部分） 2017-02-08 使用类（增加方法 - 第三部分） 2017-02-09 使用类（重载 - 第四部分） 2017-02-10 使用类（构造函数 - 第五部分） 2017-02-13 使用类（静态成员 - 第六部分） 2017-02-14 检查 Execution Policy 2017-02-15 检测有问题的 Execution Policy 设置 2017-02-16 免费的 PowerShell 起步指南 2017-02-20 接触 PowerShell 6.0 2017-02-21 检测宿主 2017-02-22 设置环境变量 2017-02-23 Reading Environment Variables Freshly 2017-02-24 用 Pester Tests 做测试 2017-02-27 显示或隐藏窗口 2017-02-28 Power Shell 5 的类继承（第一部分） 2017 年 03 月 2017-03-01 Power Shell 5 的类继承（第二部分） 2017-03-02 使用泛型 2017-03-03 管理比特标志位（第一部分） 2017-03-06 管理比特标志位（第二部分） 2017-03-07 管理比特标志位（第三部分） 2017-03-08 管理比特标志位（第四部分） 2017-03-09 探索对象 2017-03-10 危险的临时文件！ 2017-03-13 Exploring Type Accelerators 2017-03-14 快速创建对象数组 2017-03-15 Where-Object 和 .Where() 2017-03-16 查找所有含桌面的配置文件 2017-03-17 限制文本的长度（第一部分）","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 多个返回值","slug":"returning-multiple-values","date":"2013-09-08T16:00:00.000Z","updated":"2017-03-17T15:26:21.970Z","comments":true,"path":"2013/09/09/returning-multiple-values/","link":"","permalink":"http://blog.vichamp.com/2013/09/09/returning-multiple-values/","excerpt":"一个PowerShell函数可以有多个返回值。要接收这些返回值，只需要将返回值赋给多个变量： function Get-DateTimeInfo { # Value 1 Get-Date -Format &apos;dddd&apos; # Value 2 Get-Date -Format &apos;MMMM&apos; # Value 3 Get-Date -Format &apos;HH:mm:ss&apos; } $day, $month, $time = Get-DateTimeInfo &quot;Today is $day, the month is $month, and it is $time&quot;","text":"一个PowerShell函数可以有多个返回值。要接收这些返回值，只需要将返回值赋给多个变量： function Get-DateTimeInfo { # Value 1 Get-Date -Format &apos;dddd&apos; # Value 2 Get-Date -Format &apos;MMMM&apos; # Value 3 Get-Date -Format &apos;HH:mm:ss&apos; } $day, $month, $time = Get-DateTimeInfo &quot;Today is $day, the month is $month, and it is $time&quot; 本文国际来源：Returning Multiple Values","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 处理文件系统路径(第3部分)","slug":"manipulating-file-system-paths-3","date":"2013-09-05T16:00:00.000Z","updated":"2017-03-17T15:26:21.953Z","comments":true,"path":"2013/09/06/manipulating-file-system-paths-3/","link":"","permalink":"http://blog.vichamp.com/2013/09/06/manipulating-file-system-paths-3/","excerpt":"在之前介绍的技巧中我们介绍了如何将文件系统路径转化为数组，并且通过改变或排除数组的一部分元素创建一个新的路径。您可以通过将数组转化为 ArrayList 类型来使其变得更简单。现在，您可以非常容易地删除现有的或增加新的路径元素。 这个例子将第一个层文件夹重命名，排除第二层子文件夹，并在第4层子文件夹之后增加一个子文件夹： $path = &apos;C:\\users\\Tobias\\Desktop\\functions.ps1&apos; [System.Collections.ArrayList]$array = $path -split &apos;\\\\&apos; $array[1] = &apos;MyUsers&apos; $array.RemoveAt(2) $array.Insert(3, &apos;NewSubFolder&apos;) $array.Insert(4, &apos;AnotherNewSubFolder&apos;) $array -join &apos;\\&apos; 结果路径是： C:\\MyUsers\\Desktop\\NewSubFolder\\AnotherNewSubFolder\\functions.ps1","text":"在之前介绍的技巧中我们介绍了如何将文件系统路径转化为数组，并且通过改变或排除数组的一部分元素创建一个新的路径。您可以通过将数组转化为 ArrayList 类型来使其变得更简单。现在，您可以非常容易地删除现有的或增加新的路径元素。 这个例子将第一个层文件夹重命名，排除第二层子文件夹，并在第4层子文件夹之后增加一个子文件夹： $path = &apos;C:\\users\\Tobias\\Desktop\\functions.ps1&apos; [System.Collections.ArrayList]$array = $path -split &apos;\\\\&apos; $array[1] = &apos;MyUsers&apos; $array.RemoveAt(2) $array.Insert(3, &apos;NewSubFolder&apos;) $array.Insert(4, &apos;AnotherNewSubFolder&apos;) $array -join &apos;\\&apos; 结果路径是： C:\\MyUsers\\Desktop\\NewSubFolder\\AnotherNewSubFolder\\functions.ps1 本文国际来源：Manipulating File System Paths (Part 3)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 处理文件系统路径(第2部分)","slug":"manipulating-file-system-paths-2","date":"2013-09-04T16:00:00.000Z","updated":"2017-03-17T15:26:21.953Z","comments":true,"path":"2013/09/05/manipulating-file-system-paths-2/","link":"","permalink":"http://blog.vichamp.com/2013/09/05/manipulating-file-system-paths-2/","excerpt":"当您将一个路径转换为数组来操作路径的各个部分时，如果您希望通过固定的数组下标来存取路径的部分，则该方法仅限于子文件夹的数量是固定的情况。 若要操作路径长度不固定的情况，试着利用变量。这个例子将会去除第1层和第2层子文件夹，无论路径有多长： $path = &apos;C:\\users\\Tobias\\Desktop\\functions.ps1&apos; $array = $path -split &apos;\\\\&apos; $length = $array.Count $newpath = $array[,0+3..$length] $newpath -join &apos;\\&apos; 请注意提取新路径的数组元素的方法： $newpath = $array[,0+3..$length] 这行代码取出第1个路径元素（下标为0）和第4个元素以及其之后的所有元素（下标从3开始）。 此处的奥秘是PowerShell支持多个数组下标。表达式 x..y 创建一个范围为x到y的数字型数组，其中x和/或y可以是变量。 当您需要增加单独的下标时，您必须将它们转化为数组，因为只有数组能被添加到数组中。这是为什么代码中下标0写成 ,0 的原因。这样写是为了创建一个只包含0的数组，并且这个数组可以被添加到数字范围的数组，并返回一个包含所有你需要的下标的数组。","text":"当您将一个路径转换为数组来操作路径的各个部分时，如果您希望通过固定的数组下标来存取路径的部分，则该方法仅限于子文件夹的数量是固定的情况。 若要操作路径长度不固定的情况，试着利用变量。这个例子将会去除第1层和第2层子文件夹，无论路径有多长： $path = &apos;C:\\users\\Tobias\\Desktop\\functions.ps1&apos; $array = $path -split &apos;\\\\&apos; $length = $array.Count $newpath = $array[,0+3..$length] $newpath -join &apos;\\&apos; 请注意提取新路径的数组元素的方法： $newpath = $array[,0+3..$length] 这行代码取出第1个路径元素（下标为0）和第4个元素以及其之后的所有元素（下标从3开始）。 此处的奥秘是PowerShell支持多个数组下标。表达式 x..y 创建一个范围为x到y的数字型数组，其中x和/或y可以是变量。 当您需要增加单独的下标时，您必须将它们转化为数组，因为只有数组能被添加到数组中。这是为什么代码中下标0写成 ,0 的原因。这样写是为了创建一个只包含0的数组，并且这个数组可以被添加到数字范围的数组，并返回一个包含所有你需要的下标的数组。 本文国际来源：Manipulating File System Paths (Part 2)","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"PowerShell 技能连载 - 处理文件系统路径(第1部分)","slug":"manipulating-file-system-paths-1","date":"2013-09-03T16:00:00.000Z","updated":"2017-03-17T15:26:21.937Z","comments":true,"path":"2013/09/04/manipulating-file-system-paths-1/","link":"","permalink":"http://blog.vichamp.com/2013/09/04/manipulating-file-system-paths-1/","excerpt":"PowerShell允许您存取多个数组元素。通过使用 -help 和 -join，您可以很方便地通过这种方式处理多个文件系统路径。 若要排除第二层和第三层文件夹，试试以下代码： $path = &apos;C:\\users\\Tobias\\Desktop\\functions.ps1&apos; $array = $path -split &apos;\\\\&apos; $newpath = $array[0,3,4] $newpath -join &apos;\\&apos; 若要重命名第二层子文件夹，试试以下代码： $path = &apos;C:\\users\\Tobias\\Desktop\\functions.ps1&apos; $array = $path -split &apos;\\\\&apos; $array[2] = &apos;OtherUser&apos; $array -join &apos;\\&apos;","text":"PowerShell允许您存取多个数组元素。通过使用 -help 和 -join，您可以很方便地通过这种方式处理多个文件系统路径。 若要排除第二层和第三层文件夹，试试以下代码： $path = &apos;C:\\users\\Tobias\\Desktop\\functions.ps1&apos; $array = $path -split &apos;\\\\&apos; $newpath = $array[0,3,4] $newpath -join &apos;\\&apos; 若要重命名第二层子文件夹，试试以下代码： $path = &apos;C:\\users\\Tobias\\Desktop\\functions.ps1&apos; $array = $path -split &apos;\\\\&apos; $array[2] = &apos;OtherUser&apos; $array -join &apos;\\&apos; 本文国际来源：Manipulating File System Paths","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"tip","slug":"tip","permalink":"http://blog.vichamp.com/tags/tip/"},{"name":"powertip","slug":"powertip","permalink":"http://blog.vichamp.com/tags/powertip/"},{"name":"series","slug":"series","permalink":"http://blog.vichamp.com/tags/series/"},{"name":"translation","slug":"translation","permalink":"http://blog.vichamp.com/tags/translation/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"},{"name":"tip","slug":"powershell/tip","permalink":"http://blog.vichamp.com/categories/powershell/tip/"}]},{"title":"定时休眠的命令","slug":"scheduling-hibernate","date":"2013-08-15T16:00:00.000Z","updated":"2017-03-17T15:26:21.937Z","comments":true,"path":"2013/08/16/scheduling-hibernate/","link":"","permalink":"http://blog.vichamp.com/2013/08/16/scheduling-hibernate/","excerpt":"例如2个小时以后休眠： timeout /t 7200 /nobreak &amp; shutdown /h","text":"例如2个小时以后休眠： timeout /t 7200 /nobreak &amp; shutdown /h 注意事项： shutdown /h /t xxx 这样的组合是没用的。 注意倒计时过程中不能按 CTRL+C 组合键来中止倒计时，否则会立即休眠。正确中止倒计时的方法是直接关闭命令行窗口。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"command","slug":"command","permalink":"http://blog.vichamp.com/tags/command/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"用PowerShell统计关键词","slug":"using-powershell-to-count-words","date":"2013-06-27T16:00:00.000Z","updated":"2017-03-17T15:26:21.937Z","comments":true,"path":"2013/06/28/using-powershell-to-count-words/","link":"","permalink":"http://blog.vichamp.com/2013/06/28/using-powershell-to-count-words/","excerpt":"本来开始打算大干一场的，结果发现区区4行代码搞定了。原来用PowerShell统计关键词这么欢乐啊。","text":"本来开始打算大干一场的，结果发现区区4行代码搞定了。原来用PowerShell统计关键词这么欢乐啊。 $wordBreakers = &quot;,. ()\\\\/&apos;;-&lt;&gt;_#&quot; $wordTemplate = &apos;^Pub\\w+&apos; cd D:\\Dropbox\\workdir\\LandiStore\\BOCISTDemo\\src\\Project $content = (dir *.c -Recurse | % { cat $_} ) -join &quot;`n&quot; $words = $content.Split($wordBreakers) $words = $words | ? {$_ -Match $wordTemplate} #$words | sort -Unique $words | group | sort count -Descending | select Name, Count","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"修正文件名/目录名的PowerShell脚本","slug":"fix-file-name","date":"2013-06-26T16:00:00.000Z","updated":"2017-03-17T15:26:21.921Z","comments":true,"path":"2013/06/27/fix-file-name/","link":"","permalink":"http://blog.vichamp.com/2013/06/27/fix-file-name/","excerpt":"计划写一系列整理文件用的脚本。例如根据id3来对mp3文件归档、根据exif信息来对照片归档、根据verycd上的资源名称对下载的文件归档……这时候会遇到一个问题：Windows的文件系统是不允许某些特殊字符，以及设备文件名的。详细的限制请参见：http://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88%E5%90%8D%E7%A8%B1。","text":"计划写一系列整理文件用的脚本。例如根据id3来对mp3文件归档、根据exif信息来对照片归档、根据verycd上的资源名称对下载的文件归档……这时候会遇到一个问题：Windows的文件系统是不允许某些特殊字符，以及设备文件名的。详细的限制请参见：http://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88%E5%90%8D%E7%A8%B1。 这个PowerShell脚本帮助你避开这些坑。具体的做法是将特殊字符替换成’.’，对于恰好是设备名称的主文件名或扩展名之前添加’_’。 function Get-ValidFileSystemName { [CmdletBinding()] param( [Parameter(Mandatory = $true, ValueFromPipeline = $true)] [string]$FileSystemName ) process{ $deviceFiles = &apos;CON&apos;, &apos;PRN&apos;, &apos;AUX&apos;, &apos;CLOCK$&apos;, &apos;NUL&apos;, &apos;COM1&apos;, &apos;COM2&apos;, &apos;COM3&apos;, &apos;COM4&apos;, &apos;COM5&apos;, &apos;COM6&apos;, &apos;COM7&apos;, &apos;COM8&apos;, &apos;COM9&apos;, &apos;LPT1&apos;, &apos;LPT2&apos;, &apos;LPT3&apos;, &apos;LPT4&apos;, &apos;LPT5&apos;, &apos;LPT6&apos;, &apos;LPT7&apos;, &apos;LPT8&apos;, &apos;LPT9&apos; $fileName = [System.IO.Path]::GetFileNameWithoutExtension($FileSystemName) $extension = [System.IO.Path]::GetExtension($FileSystemName) if ($extension.StartsWith(&apos;.&apos;)) { $extension = $extension.Substring(1) } if ($deviceFiles -contains $fileName) { $fileName = &quot;_$fileName&quot; } if ($deviceFiles -contains $extension) { $extension = &quot;_$extension&quot; } if ($extension -eq &apos;&apos;) { $FileSystemName = &quot;$fileName$extension&quot; } else { $FileSystemName = &quot;$fileName.$extension&quot; } $FileSystemName = $FileSystemName -creplace &apos;[\\\\/|?&quot;*:&lt;&gt;\\x00\\x1F\\t\\r\\n]&apos;, &apos;.&apos; return $FileSystemName } }","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"用脚本批量下载www.cheat-sheets.org中的所有pdf文件","slug":"batch-downloading-www-cheat-sheets-org","date":"2013-06-07T16:00:00.000Z","updated":"2017-03-17T15:26:21.921Z","comments":true,"path":"2013/06/08/batch-downloading-www-cheat-sheets-org/","link":"","permalink":"http://blog.vichamp.com/2013/06/08/batch-downloading-www-cheat-sheets-org/","excerpt":"流水不腐，户枢不蠹。虽然批量下载有很多工具能做到，但是为了提高，我们尽量动手编写脚本吧。http://www.cheat-sheets.org 里有很多好东西，我们把它批量下载下来。","text":"流水不腐，户枢不蠹。虽然批量下载有很多工具能做到，但是为了提高，我们尽量动手编写脚本吧。http://www.cheat-sheets.org 里有很多好东西，我们把它批量下载下来。 PowerShell代码： Add-Type -AssemblyName System.Web $baseUrl = &apos;http://www.cheat-sheets.org&apos; $result = Invoke-WebRequest $baseUrl $result.Links | ? {$_.href -Like &apos;*.pdf&apos;} | select -ExpandProperty href | sort | % { if ($_ -like &apos;/*&apos;) { $baseUrl + $_ } else { $_ } } | % { echo &quot;Downloading $_&quot; $fileName = $_.Substring($_.LastIndexOf(&quot;/&quot;) + 1) $localFileName = [System.Web.HttpUtility]::UrlDecode($fileName) if (Test-Path $localFileName) { return } Invoke-WebRequest -Uri $_ -OutFile $localFileName if (Test-Path $localFileName) { Unblock-File $localFileName } }","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"batch","slug":"batch","permalink":"http://blog.vichamp.com/tags/batch/"},{"name":"download","slug":"download","permalink":"http://blog.vichamp.com/tags/download/"},{"name":"cheatsheet","slug":"cheatsheet","permalink":"http://blog.vichamp.com/tags/cheatsheet/"},{"name":"resource","slug":"resource","permalink":"http://blog.vichamp.com/tags/resource/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"新手从 0 开始学习 PowerShell 的路线","slug":"guide-line-to-learn-powershell","date":"2013-05-08T16:00:00.000Z","updated":"2017-03-17T15:26:21.906Z","comments":true,"path":"2013/05/09/guide-line-to-learn-powershell/","link":"","permalink":"http://blog.vichamp.com/2013/05/09/guide-line-to-learn-powershell/","excerpt":"以下是我个人的PowerShell学习路线，也许可以节省您一些走弯路的时间，供参考。","text":"以下是我个人的PowerShell学习路线，也许可以节省您一些走弯路的时间，供参考。 入门材料 微软虚拟学院 快速入门: PowerShell 3.0 - 有讲座视频、中文字幕、pdf 讲义，轻松起步。我把它们都传到百度云上了，下载地址请参见 PowerShell 微软虚拟学院课程。 Windows Powershell入门指南（中文）-微软资料.pdf - 篇幅很短，仅 29 页，入门找感觉，一天即可读完。 pstips.chm - 中文电子书，篇幅适中，涵盖了语法要点，重点推荐！ 速查表推荐打印出来放案头备用。 Windows PowerShell 语言快速参考.rtf - 只有三页纸的速查表（中文） powershell_reference_Apr2010.doc - 只有两页纸的速查表（英文） 中文手册，用于查阅 WindowsPowerShellHelp_官方手册.chm - 微软官方，浏览一下有哪些内容，日后备用。 官方网站Microsoft PowerShell 英文电子书 [Windows.PowerShell.Pocket.Reference(2nd,2012.12)].Lee.Holmes.文字版.pdf - 系统学习用，可以一周读完，后几章可跳过，100 来页。 [Windows.Powershell.实战(第2版)].(Windows.Powershell.in.Action).Bruce.Payette.文字版.pdf - 经典，深入学习用，900 来页，可以用来当工具书查阅。 邮件列表 Power Tips - 右侧有个 Tips via Email，在这儿通过电子邮件订阅，每天会发给你一封短小的邮件。一点一滴学习，内容都很精致。 电子书合集所有 PowerShell 电子书的合集，自动更新：《PowerShell 电子书合集》 补充说明 文中提到的所有 pdf、chm 电子书，都可以在*PowerShell 技术交流（QQ 群号：271143343）的群共享中找到。 pstips.chm 实际上是 PowerShell 在线教程 的离线版。 PowerShell 在线教程 实际上又是 Master-PowerShell 的中文翻译，感谢荔非苔的劳动。","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"ebook","slug":"ebook","permalink":"http://blog.vichamp.com/tags/ebook/"},{"name":"learning","slug":"learning","permalink":"http://blog.vichamp.com/tags/learning/"},{"name":"guideline","slug":"guideline","permalink":"http://blog.vichamp.com/tags/guideline/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"批量更改csdn下载的文件名（UrlDecode) ","slug":"batch-changing-csdn-download-file-name","date":"2013-05-06T16:00:00.000Z","updated":"2017-03-17T15:26:21.890Z","comments":true,"path":"2013/05/07/batch-changing-csdn-download-file-name/","link":"","permalink":"http://blog.vichamp.com/2013/05/07/batch-changing-csdn-download-file-name/","excerpt":"例如csdn下载的一个文件名字为 %5B大家网%5DWindows.PowerShell应用手册%5Bwww.TopSage.com%5D.pdf，我们通过两行PowerShell脚本把它转化为正常的 [大家网]Windows.PowerShell应用手册[www.TopSage.com].pdf。量大的时候特别好用。","text":"例如csdn下载的一个文件名字为 %5B大家网%5DWindows.PowerShell应用手册%5Bwww.TopSage.com%5D.pdf，我们通过两行PowerShell脚本把它转化为正常的 [大家网]Windows.PowerShell应用手册[www.TopSage.com].pdf。量大的时候特别好用。 方法如下： Add-Type -AssemblyName System.Web dir | % { ren -LiteralPath $_ ([System.Web.HttpUtility]::UrlDecode($_)) }","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"batch","slug":"batch","permalink":"http://blog.vichamp.com/tags/batch/"},{"name":"download","slug":"download","permalink":"http://blog.vichamp.com/tags/download/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"以GTD的思想整理目录的PowerShell脚本","slug":"gtd-script","date":"2013-03-06T16:00:00.000Z","updated":"2017-03-17T15:26:21.890Z","comments":true,"path":"2013/03/07/gtd-script/","link":"","permalink":"http://blog.vichamp.com/2013/03/07/gtd-script/","excerpt":"这是花了一个晚上写的PowerShell脚本，可以把你的目录以GTD的思想整理得井井有条。但是GTD功能已经完整并通过测试。github地址：victorwoo/Get-ThingsDone。","text":"这是花了一个晚上写的PowerShell脚本，可以把你的目录以GTD的思想整理得井井有条。但是GTD功能已经完整并通过测试。github地址：victorwoo/Get-ThingsDone。 不了解GTD的同学请参考以下材料：《搞定》中文版、《Get Things Done》英文版 #======================================================================== # Created on: 2013-3-7 16:21 # Created by: Victor.Woo # Organization: www.vichamp.com # Filename: Get-ThingsDone.ps1 #======================================================================== function Check-Enviroment { $gtdPath = &quot;HKCU:\\Software\\Vichamp\\GTD&quot; if ((Get-ItemProperty $gtdPath -ErrorAction SilentlyContinue).AutoStart -eq &quot;False&quot;) { return } $runPath = &apos;HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run&apos; $run = Get-ItemProperty $runPath if ($run.GTD -eq $null) { $title = &apos;自动执行请求&apos; $message = &apos;在当前 Windows 用户登录时自动运行此脚本，可以自动帮助您整理、规划当日的工作内容。如果您选择了“是”，但将来不希望自动启动，请执行 uninstall.cmd。是否在当前用户登录时自动执行脚本？&apos; $yes = New-Object System.Management.Automation.Host.ChoiceDescription &quot;&amp;Yes&quot;,&quot;Windows 用户登录时自动运行此脚本。&quot; $no = New-Object System.Management.Automation.Host.ChoiceDescription &quot;&amp;No&quot;,&quot;Windows 用户登录时不运行此脚本，并且不再提示。&quot; $options = [System.Management.Automation.Host.ChoiceDescription[]]($yes,$no) $result = $Host.UI.PromptForChoice($title,$message,$options,0) switch ($result) { 0 { Set-ItemProperty -Path $runPath -Name GTD -Value $gtdCmd } 1 { md $gtdPath -Force Set-ItemProperty -Path $gtdPath -Name AutoStart -Value &quot;False&quot; } } } } function TryCreate-Directory ([Parameter(Mandatory = $True)] [string]$dirName) { $private:dir = Join-Path $baseDir $dirName if (-not (Test-Path $dir)) { Write-Output &quot;$dir 不存在，正在创建。&quot; mkdir $dir | Out-Null } } function TryCreate-Directories () { Write-Output &quot;正在检查目录完整性&quot; $dirNames | % { TryCreate-Directory $_ } } function Remove-Directories () { $dirNames | % { $private:dir = Join-Path $baseDir $_ if (Test-Path $dir) { Write-Warning &quot;正在移除$dir&quot; rm $dir -Recurse } } } function MoveTo-WithRenamming ( [Parameter(Mandatory = $True)] [System.IO.FileSystemInfo]$item, [Parameter(Mandatory = $True)] [string]$targetDir) { function Get-NextFilePath ([string]$dir,[System.IO.FileInfo]$fileInfo) { $Private:targetFilePath = Join-Path $dir $fileInfo.Name if (Test-Path $Private:targetFilePath) { $Private:index = 1 do { $Private:targetFilePath = Join-Path $dir &quot;$($fileInfo.BaseName) ($index)$($fileInfo.Extension)&quot; $Private:index++ } while (Test-Path $Private:targetFilePath) } return [System.IO.FileInfo]$Private:targetFilePath } function Get-NextDirectoryPath ([string]$dir,[System.IO.DirectoryInfo]$directoryInfo) { $Private:targetDirectoryPath = Join-Path $dir $directoryInfo.Name if (Test-Path $Private:targetDirectoryPath) { $Private:index = 1 do { $Private:targetDirectoryPath = Join-Path $dir &quot;$($directoryInfo.Name) ($index)&quot; $Private:index++ } while (Test-Path $Private:targetDirectoryPath) } return [System.IO.DirectoryInfo]$Private:targetDirectoryPath } Write-Output &quot;正在移动 $item 至 $targetDir 目录&quot; if ($item -is [System.IO.FileInfo]) { # 待移动的是文件 [System.IO.FileInfo]$item = [System.IO.FileInfo]$item $Private:targetFilePath = Join-Path $targetDir $item.Name if (Test-Path $Private:targetFilePath) { # 目标文件已存在 $targetFileInfo = [System.IO.FileInfo]$Private:targetFilePath $Private:targetFilePath = Get-NextFilePath $targetDir $item if ($item.LastWriteTime -eq $targetFileInfo.LastWriteTime -and $item.Length -eq $targetFileInfo.Length) { # 文件时间和大小相同 Write-Warning &quot;源文件 $item.FullName 与目标文件 $targetFileInfo.FullName 相同，删除源文件&quot; Remove-Item $item.FullName } else { Write-Warning &quot;目标文件已存在，自动改名为$($Private:targetFilePath.Name)&quot; Move-Item $item.FullName $Private:targetFilePath | Out-Null } } else { # 目标文件不存在 if (!(Test-Path $targetDir)) { # 目标目录不存在，创建目标目录 md $targetDir | Out-Null } Move-Item $item.FullName $Private:targetFilePath | Out-Null } } elseif ($item -is [System.IO.DirectoryInfo]) { # 待移动的是目录 [System.IO.DirectoryInfo]$item = [System.IO.DirectoryInfo]$item $Private:targetDirectoryPath = Join-Path $targetDir $item.Name if (Test-Path $Private:targetDirectoryPath) { $Private:targetDirectoryPath = Get-NextDirectoryPath $targetDir $item Write-Warning &quot;目标文件夹已存在，自动改名为$($Private:targetDirectoryPath.Name)&quot; } Move-Item $item.FullName $Private:targetDirectoryPath | Out-Null } } function Process-IsolatedItems { Write-Output &quot;正在将游离内容移至 [STUFF] 目录&quot; Get-ChildItem $baseDir -Exclude ($dirNames + $reservedDirs + $reservedFiles) | % { MoveTo-WithRenamming $_ $stuffDir } } function Process-TomorrowDir { Write-Output &quot;正在处理 [TOMORROW] 目录&quot; Get-ChildItem $tomorrowDir | % { MoveTo-WithRenamming $_ $todayDir } } function Process-CalendarDir { Write-Output &quot;正在处理 [CALENDAR] 目录&quot; Get-ChildItem $calendarDir -File | % { MoveTo-WithRenamming $_ $stuffDir } Get-ChildItem $calendarDir -Directory | % { $regex = [regex]&apos;(?m)^(?&lt;year&gt;19|20\\d{2})[-_.](?&lt;month&gt;\\d{1,2})[-_.](?&lt;day&gt;\\d{1,2})$&apos; $match = $regex.Match($_.Name) if ($match.Success) { $Private:year = $regex.Match($_.Name).Groups[&apos;year&apos;].Value; $Private:month = $regex.Match($_.Name).Groups[&apos;month&apos;].Value; $Private:day = $regex.Match($_.Name).Groups[&apos;day&apos;].Value; $Private:date = New-Object System.DateTime $Private:year,$Private:month,$Private:day $now = (Get-Date) $today = $now.Subtract($now.TimeOfDay) if ($date -lt $today) { Write-Output &quot;移动过期任务 $($_.Name) 到 [STUFF] 目录&quot; MoveTo-WithRenamming $_ $stuffDir } elseif ($date -eq $today) { Write-Output &quot;移动今日任务 $($_.Name) 到 [TODAY] 目录&quot; MoveTo-WithRenamming $_ $todayDir } elseif ($date -eq $today.AddDays(1)) { Write-Output &quot;移动明日任务 $($_.Name) 到 [TOMORROW] 目录&quot; MoveTo-WithRenamming $_ $tomorrowDir } } else { Write-Output &quot;[CALENDAR] 目录下，$($_.Name) 名字不符合规范，将移动至 [STUFF] 目录&quot; MoveTo-WithRenamming $_ $stuffDir } } } function Process-ArchiveDir { Write-Output &quot;正在检查 [ARCHIVE] 目录&quot; # 创建本月目录 $nowString = &quot;{0:yyyy.MM}&quot; -f (Get-Date) $thisMonthDir = Join-Path $archiveDir $nowString if (-not (Test-Path $thisMonthDir)) { Write-Output &quot;正在创建本月目录&quot; md $thisMonthDir } # 移除除本月之外的空目录 Get-ChildItem $archiveDir -Exclude $nowString -Recurse | Where { $_.PSIsContainer -and @( Get-ChildItem -LiteralPath $_.FullName -Recurse | Where { !$_.PSIsContainer }).Length -eq 0 } | % { Write-Output &quot;正在删除空目录$($_.FullName)&quot; Remove-Item -Recurse } # 移动所有文件到 本月存档 目录 Get-ChildItem $archiveDir -File | % { $lastWriteTime = &quot;{0:yyyy.MM}&quot; -f $_.LastWriteTime $lastWriteDir = Join-Path $archiveDir $lastWriteTime Write-Output &quot;移动 [ARCHIVE] 目录下，$($_.Name) 游离文件至 $lastWriteDir 存档目录&quot; MoveTo-WithRenamming $_ $lastWriteDir } # 检查目录命名是否符合规范。 Get-ChildItem $archiveDir -Directory | % { $regex = [regex]&apos;(?m)^(?&lt;year&gt;19|20\\d{2})[-_.](?&lt;month&gt;\\d{1,2})$&apos; $match = $regex.Match($_.Name) if ($match.Success) { # Archive目录下的名字符合格式 $year = $regex.Match($_.Name).Groups[&apos;year&apos;].Value; $month = $regex.Match($_.Name).Groups[&apos;month&apos;].Value; $date = New-Object System.DateTime $year,$month,1 if ($date -gt (Get-Date)) { Write-Output &quot;[ARCHIVE] 目录下，$($_.Name) 名字不符合规范（存档日期超出当前时间），将移动至 [STUFF] 目录&quot; MoveTo-WithRenamming $_ $stuffDir } else { $formattedDate = &quot;{0:yyyy.MM}&quot; -f $date if ($_.Name -ne $formattedDate) { $targetDirectory = [System.IO.DirectoryInfo](Join-Path $_.Parent.FullName $formattedDate) Write-Warning &quot;将 [ARCHIVE] 下的目录名 $($_.Name) 处理为规范格式 $($targetDirectory.Name)&quot; Move-Item $_.FullName $targetDirectory.FullName } } } else { # Archive目录下的名字符不合格式 $lastWriteTime = $nowString = &quot;{0:yyyy.MM}&quot; -f $_.LastWriteTime $lastWriteDir = Join-Path $archiveDir $lastWriteTime Write-Output &quot;移动 [ARCHIVE] 目录下，$($_.Name) 游离文件夹至 $lastWriteDir 存档目录&quot; MoveTo-WithRenamming $_ $lastWriteDir } } } function Explore-Dirs { if ((Get-ChildItem $stuffDir) -ne $null) { explorer $stuffDir } if ((Get-ChildItem $todayDir) -ne $null) { explorer $todayDir } } $STUFF = &quot;1.STUFF&quot; $TODAY = &quot;2.TODAY&quot; $TOMORROW = &quot;3.TOMORROW&quot; $UPCOMING = &quot;4.UPCOMING&quot; $CALENDAR = &quot;5.CALENDAR&quot; $SOMEDAY = &quot;6.SOMEDAY&quot; $ARCHIVE = &quot;7.ARCHIVE&quot; $dirNames = $STUFF,$TODAY,$TOMORROW,$UPCOMING,$CALENDAR,$SOMEDAY,$ARCHIVE $reservedDirs = &quot;.git&quot;,&quot;_gsdata_&quot; $reservedFiles = &quot;.gitignore&quot;,&quot;Get-ThingsDone.ps1&quot;,&quot;README*.md&quot;,&quot;gtd_logo.png&quot;,&quot;LICENSE.md&quot;,&quot;GTD.cmd&quot;,&quot;uninstall.cmd&quot; $baseDir = Split-Path $MyInvocation.MyCommand.Path $stuffDir = Join-Path $baseDir $STUFF $todayDir = Join-Path $baseDir $TODAY $tomorrowDir = Join-Path $baseDir $TOMORROW $calendarDir = Join-Path $baseDir $CALENDAR $archiveDir = Join-Path $baseDir $ARCHIVE $gtdCmd = Join-Path $baseDir &quot;GTD.cmd&quot; Get-Date | Write-Output Check-Enviroment TryCreate-Directories Process-IsolatedItems Process-TomorrowDir Process-CalendarDir Process-ArchiveDir Explore-Dirs ######################### 开发临时用（在 ISE 中选中并按 F8 执行） ######################### return { return # 创建游离内容。 $null | Set-Content (Join-Path $baseDir &quot;to.del.file.txt&quot;) md (Join-Path $baseDir &quot;to.del.dir&quot;) | Out-Null } { return # 对代码排版。 Import-Module D:\\Dropbox\\script\\DTW.PS.PrettyPrinterV1\\DTW.PS.PrettyPrinterV1.psd1 Edit-DTWCleanScript D:\\Dropbox\\vichamp\\GTD\\Get-ThingsDone.ps1 } { return # 移除所有目录 Remove-Directories }","categories":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}],"tags":[{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"},{"name":"gtd","slug":"gtd","permalink":"http://blog.vichamp.com/tags/gtd/"},{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/tags/powershell/"},{"name":"script","slug":"script","permalink":"http://blog.vichamp.com/tags/script/"},{"name":"regex","slug":"regex","permalink":"http://blog.vichamp.com/tags/regex/"}],"keywords":[{"name":"powershell","slug":"powershell","permalink":"http://blog.vichamp.com/categories/powershell/"}]},{"title":"在vim里转换HEX数据的显示","slug":"extract-hex-data-in-vim","date":"2012-04-05T16:00:00.000Z","updated":"2017-03-17T15:26:21.890Z","comments":true,"path":"2012/04/06/extract-hex-data-in-vim/","link":"","permalink":"http://blog.vichamp.com/2012/04/06/extract-hex-data-in-vim/","excerpt":"","text":"在做嵌入式设备开发和调试工作中，可能常常遇到以下场景，需要把： 0000:60 00 00 00 00 00 00 00 00 00 00 42 00 00 18 00 `....... ...B....:0015 0016:01 80 80 00 03 14 20 24 20 11 08 17 08 12 34 56 ...... $ .....4V:0031 0032:78 08 87 65 43 21 36 35 30 34 31 37 31 38 00 59 x..eC!65 041718.Y:0047 0048:30 30 30 30 30 30 30 30 30 30 30 31 30 30 30 30 00000000 00010000:0063 0064:30 30 30 30 49 43 41 52 44 30 30 30 30 30 30 30 0000ICAR D0000000:0079 0080:34 30 30 30 30 30 30 31 32 31 36 30 30 30 30 30 40000001 21600000:0095 0096:30 34 30 30 30 30 32 30 34 30 35 31 31 31 31 31 04000020 40511111:0111 0112:31 31 31 111 :0127 这样的文本，转换为单行，头尾部分不要，中间重复的空格也不要。如下： 60 00 00 00 00 00 00 00 00 00 00 42 00 00 18 00 01 80 80 00 03 14 20 24 20 11 08 17 08 12 34 56 78 08 87 65 43 21 36 35 30 34 31 37 31 38 00 59 30 30 30 30 30 30 30 30 30 30 30 31 30 30 30 30 30 30 30 30 49 43 41 52 44 30 30 30 30 30 30 30 34 30 30 30 30 30 30 31 32 31 36 30 30 30 30 30 30 34 30 30 30 30 32 30 34 30 35 31 31 31 31 31 31 31 31 这个可以用vim的替换来实现，命令是：:%s/\\d*:\\(\\(\\x\\|\\s\\)\\{24}\\) \\(\\(\\x\\|\\s\\)\\{24}\\).*\\n/\\1\\3/g 我们还可以为它在.vimrc中定义一个快捷键映射：map &lt;C-H&gt; :%s/\\d*:\\(\\(\\x\\\\|\\s\\)\\{24}\\) \\(\\(\\x\\\\|\\s\\)\\{24}\\).*\\n/\\1\\3/g&lt;CR&gt;这样以后按一下CTRL+H键就搞定了。","categories":[{"name":"vim","slug":"vim","permalink":"http://blog.vichamp.com/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://blog.vichamp.com/tags/vim/"},{"name":"geek","slug":"geek","permalink":"http://blog.vichamp.com/tags/geek/"}],"keywords":[{"name":"vim","slug":"vim","permalink":"http://blog.vichamp.com/categories/vim/"}]}]}